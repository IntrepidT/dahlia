use leptos::prelude::*;
pub mod app;

#[cfg(feature = "hydrate")]
#[wasm_bindgen::prelude::wasm_bindgen]
pub fn hydrate() {
    use app::*;
    use leptos::prelude::*;

    console_error_panic_hook::set_once();

    mount_to_body(App);
}
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_meta::*;
use leptos_router::components::*;
use leptos_router::hooks::*;

// Core modules - organized alphabetically
pub mod components;
pub mod db;
pub mod errors;
pub mod middleware;
pub mod models;
pub mod pages;
pub mod routes;
pub mod server_functions;
pub mod services;
pub mod utils;
pub mod websockets;

// Module for app routing
pub mod app_routes;

// Re-exports for convenience
pub use utils::{BenchmarkStats, BenchmarkUtils};

// Import what we need for the main app
use app_routes::AppRoutes;
use components::{
    auth::authorization_components::AuthProvider,
    enhanced_login_form::provide_student_mapping_service,
};
use middleware::global_settings::SettingsProvider;

#[component]
pub fn App() -> impl IntoView {
    provide_meta_context();

    let student_mapping_context = provide_student_mapping_service();
    provide_context(student_mapping_context);

    view! {
        <Stylesheet id="leptos" href="/pkg/dahlia.css"/>
        <link data-trunk rel="tailwind-css" href="/style/input.css" />
        <link rel="icon" href="/assets/favicon.ico" />
        <Title text="Teapot Testing"/>
        <Script>
            {r#"
            if (typeof window !== 'undefined' && !window.Chart) {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js';
                script.onload = function() {
                    console.log('Chart.js loaded successfully');
                    window.dispatchEvent(new Event('chartjs-loaded'));
                };
                script.onerror = function() {
                    console.error('Failed to load Chart.js');
                };
                document.head.appendChild(script);
            }
            "#}
        </Script>

        <AuthProvider>
            <SettingsProvider>
                <Router>
                    <main>
                        <Body />
                        <AppRoutes />
                    </main>
                </Router>
            </SettingsProvider>
        </AuthProvider>
    }
}
use leptos::prelude::*;
#[cfg(feature = "ssr")]
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    use actix::Actor;
    use actix_files::Files;
    use actix_web::middleware::DefaultHeaders;
    use actix_web::{web, App, HttpServer};
    use dahlia::app::db::database;
    use dahlia::app::middleware::authentication::Authentication;
    use dahlia::app::routes::saml_routes::configure_saml_routes; // Add this import
    use dahlia::app::websockets::lobby::Lobby;
    use dahlia::app::websockets::start_connection::start_connection;
    use dahlia::app::*;
    use leptos::prelude::*;
    use leptos_actix::{generate_route_list, LeptosRoutes};
    use std::env;

    let conf = get_configuration(None).await.unwrap();
    let addr = conf.leptos_options.site_addr.clone();

    println!("Site Root: {}", conf.leptos_options.site_root);
    println!("Site PKG Dir: {}", conf.leptos_options.site_pkg_dir);

    //Initialize the logger for reading log messages
    env::set_var("RUST_LOG", "info");
    env_logger::init();

    //Create and make a database connection pool setup
    let pool_one = database::create_pool().await;
    println!("Database connection pool created successfully");
    let pool = web::Data::new(pool_one.clone());

    //Initialize the Chat server
    let chat_server = web::Data::new(Lobby::new(pool_one.clone()).start());

    // Generate the list of routes in your Leptos App
    let routes = generate_route_list(App);
    println!("listening on http://{}", &addr);

    // Check for SAML configuration
    let base_url = env::var("BASE_URL").unwrap_or_else(|_| format!("http://{}", &addr));
    println!("Base URL for SAML: {}", base_url);

    HttpServer::new(move || {
        let leptos_options = &conf.leptos_options;
        let site_root = &leptos_options.site_root;

        // We make the pool available to Leptos server functions
        let leptos_options_clone = leptos_options.clone();
        let chat_server_clone = chat_server.clone();

        App::new()
            // Make DB pool available to the app
            .app_data(pool.clone())
            //make chat server available to app
            .app_data(chat_server_clone.clone())
            // Authentication middleware
            .wrap(Authentication::new())
            // Configure SAML routes BEFORE other routes
            .configure(configure_saml_routes)
            .wrap(
                DefaultHeaders::new()
                    .header("X-Frame-Options", "DENY")
                    .header("X-COntENT-TYPE-OPTIONS", "nosniff")
                    .header("X-XSS-Protection", "1; mode=block")
                    .header("Referrer-Policy", "strict-origin-when-cross-origin")
                    .header(
                        "Strict-Transport-Security",
                        "max-age=31536000; includeSubDomains; preload",
                    ),
            )
            // serve JS/WASM/CSS from `pkg`
            .service(Files::new("/pkg", format!("{site_root}/pkg")))
            // serve other assets from the `assets` directory
            .service(Files::new("/assets", "./assets"))
            // serve the favicon from /favicon.ico
            .service(favicon)
            .service(Files::new("/static", "./static").show_files_listing())
            .service(web::scope("/ws").service(start_connection))
            .service(web::scope("/api/ws").service(start_connection))
            // Leptos routes (this must be last)
            .route("/api/{tail:.*}", leptos_actix::handle_server_fns())
            .leptos_routes(leptos_options_clone.to_owned(), routes.to_owned(), App)
    })
    .bind(&addr)?
    .run()
    .await
}

#[cfg(feature = "ssr")]
#[actix_web::get("favicon")]
async fn favicon(
    leptos_options: actix_web::web::Data<leptos::LeptosOptions>,
) -> actix_web::Result<actix_files::NamedFile> {
    let leptos_options = leptos_options.into_inner();
    let site_root = &leptos_options.site_root;
    Ok(actix_files::NamedFile::open(format!(
        "{site_root}/assets/favicon.ico"
    ))?)
}

#[cfg(not(any(feature = "ssr", feature = "csr")))]
pub fn main() {
    // no client-side main function
    // unless we want this to work with e.g., Trunk for pure client-side testing
    // see lib.rs for hydration function instead
    // see optional feature `csr` instead
}

#[cfg(all(not(feature = "ssr"), feature = "csr"))]
pub fn main() {
    // a client-side main function is required for using `trunk serve`
    // prefer using `cargo leptos serve` instead
    // to run: `trunk serve --open --features csr`
    use dahlia::app::*;

    console_error_panic_hook::set_once();

    leptos::mount_to_body(App);
}
use leptos::prelude::*;
pub mod email_service;
pub use email_service::*;
use leptos::prelude::*;
// All email functionality is only available on the server side
#[cfg(feature = "ssr")]
use lettre::{
    transport::smtp::authentication::Credentials,
    transport::smtp::client::{Tls, TlsParameters},
    Message, SmtpTransport, Transport,
};
#[cfg(feature = "ssr")]
use log::{error, info, warn};
#[cfg(feature = "ssr")]
use std::env;
#[cfg(feature = "ssr")]
use std::time::Duration;

#[cfg(feature = "ssr")]
pub async fn send_reset_email(email: &str, reset_token: &str) -> Result<(), String> {
    // Teapot Testing email configuration
    let smtp_server = env::var("SMTP_SERVER").unwrap_or_else(|_| "smtp.gmail.com".to_string());
    let smtp_port = env::var("SMTP_PORT")
        .unwrap_or_else(|_| "587".to_string())
        .parse::<u16>()
        .unwrap_or(587);

    let smtp_username = env::var("SMTP_USERNAME")
        .map_err(|_| "SMTP_USERNAME (noreply@teapottesting.com) must be set".to_string())?;

    let smtp_password = env::var("SMTP_PASSWORD")
        .map_err(|_| "SMTP_PASSWORD (Google App Password) must be set".to_string())?;

    let app_url = env::var("APP_URL").unwrap_or_else(|_| "http://localhost:3000".to_string());
    let from_email =
        env::var("FROM_EMAIL").unwrap_or_else(|_| "noreply@teapottesting.com".to_string());

    // Validate configuration
    if !from_email.ends_with("@teapottesting.com") {
        warn!("FROM_EMAIL should use @teapottesting.com domain");
    }

    // Clean password (remove spaces if present) and validate
    let password_clean = smtp_password.replace(" ", "");
    if password_clean.len() != 16 {
        warn!("SMTP password should be 16 characters (Google App Password format). Current length: {}", password_clean.len());
    }

    // Create the reset link
    let reset_link = format!("{}/reset-password/{}", app_url, reset_token);

    info!(
        "Creating password reset email for {} from Teapot Testing",
        email
    );

    // Create branded email for Teapot Testing
    let email_message = Message::builder()
        .from(format!("Teapot Testing <{}>", from_email).parse()
            .map_err(|e| format!("Invalid from email: {}", e))?)
        .to(email.parse().map_err(|e| format!("Invalid recipient email: {}", e))?)
        .subject("Teapot Testing - Password Reset Request")
        .header(lettre::message::header::ContentType::TEXT_HTML)
        .body(format!(
            r#"
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Password Reset - Teapot Testing</title>
            </head>
            <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9f9f9;">
                
                <!-- Header with Teapot Testing branding -->
                <div style="text-align: center; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                        <h1 style="margin: 0; font-size: 28px; font-weight: 300;">ðŸ«– Teapot Testing</h1>
                        <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 14px;">Quality Assurance Platform</p>
                    </div>
                </div>

                <!-- Main content -->
                <div style="background-color: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <h2 style="color: #667eea; margin-top: 0; font-size: 24px; text-align: center;">Password Reset Request</h2>
                    
                    <p style="font-size: 16px; margin-bottom: 20px;">Hello,</p>
                    
                    <p style="font-size: 16px; margin-bottom: 25px;">We received a request to reset the password for your Teapot Testing account. Click the button below to set a new password:</p>
                    
                    <!-- Reset button -->
                    <div style="text-align: center; margin: 35px 0;">
                        <a href="{}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 35px; text-decoration: none; border-radius: 25px; display: inline-block; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);">
                            Reset Your Password
                        </a>
                    </div>
                    
                    <!-- Alternative link -->
                    <div style="margin: 30px 0; padding: 20px; background-color: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea;">
                        <p style="font-size: 14px; color: #666; margin: 0 0 10px 0; font-weight: 600;">Can't click the button? Copy and paste this link:</p>
                        <div style="word-break: break-all; font-family: monospace; font-size: 14px; background-color: white; padding: 10px; border-radius: 4px; border: 1px solid #e9ecef;">
                            <a href="{0}" style="color: #667eea; text-decoration: none;">{0}</a>
                        </div>
                    </div>
                    
                    <!-- Security notice -->
                    <div style="margin: 30px 0; padding: 20px; background-color: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
                        <p style="font-size: 14px; color: #856404; margin: 0; font-weight: 600;">ðŸ”’ Security Notice</p>
                        <ul style="font-size: 14px; color: #856404; margin: 10px 0 0 0; padding-left: 20px;">
                            <li>This link will expire in <strong>24 hours</strong></li>
                            <li>If you didn't request this reset, please ignore this email</li>
                            <li>For security concerns, contact our support team</li>
                        </ul>
                    </div>
                    
                    <!-- Footer -->
                    <div style="margin-top: 40px; padding-top: 25px; border-top: 2px solid #f1f3f4; text-align: center;">
                        <p style="font-size: 16px; margin: 0 0 15px 0; color: #333;">Happy Testing!</p>
                        <p style="font-size: 16px; margin: 0; font-weight: 600; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">The Teapot Testing Team</p>
                    </div>
                </div>
                
                <!-- Email footer -->
                <div style="text-align: center; font-size: 12px; color: #999; margin-top: 25px; padding: 20px;">
                    <p style="margin: 0 0 5px 0;">This is an automated email from Teapot Testing</p>
                    <p style="margin: 0 0 5px 0;">Please do not reply to this email address</p>
                    <p style="margin: 0;">Need help? Contact us at <a href="mailto:support@teapottesting.com" style="color: #667eea;">support@teapottesting.com</a></p>
                    <hr style="border: none; border-top: 1px solid #eee; margin: 15px 0;">
                    <p style="margin: 0; opacity: 0.7;">Â© 2025 Teapot Testing. All rights reserved.</p>
                </div>
            </body>
            </html>
            "#,
            reset_link
        ))
        .map_err(|e| format!("Failed to create email: {}", e))?;

    info!(
        "Sending Teapot Testing password reset email to {} via Google Workspace ({}:{})",
        email, smtp_server, smtp_port
    );

    let creds = Credentials::new(smtp_username.clone(), smtp_password);

    // Configure TLS for Google Workspace
    let tls_parameters = TlsParameters::new(smtp_server.clone())
        .map_err(|e| format!("TLS configuration error: {}", e))?;

    let mailer = SmtpTransport::builder_dangerous(&smtp_server)
        .port(smtp_port)
        .credentials(creds)
        .tls(Tls::Required(tls_parameters))
        .timeout(Some(Duration::from_secs(30)))
        .build();

    // Send the email
    match mailer.send(&email_message) {
        Ok(response) => {
            info!(
                "âœ… Teapot Testing password reset email sent successfully to {}",
                email
            );
            info!("SMTP Response: {:?}", response);
            Ok(())
        }
        Err(e) => {
            error!("âŒ Failed to send Teapot Testing email to {}: {}", email, e);

            // Provide helpful error messages based on error type
            let error_msg = if e.to_string().contains("authentication")
                || e.to_string().contains("Authentication")
            {
                format!("Authentication failed: {}. Check your Google Workspace app password for noreply@teapottesting.com", e)
            } else if e.to_string().contains("timeout") || e.to_string().contains("Timeout") {
                format!(
                    "Connection timeout: {}. Check internet connection and firewall settings.",
                    e
                )
            } else if e.to_string().contains("connection") || e.to_string().contains("Connection") {
                format!("Network error: {}. Check internet connection.", e)
            } else {
                format!("Email sending error: {}", e)
            };

            Err(error_msg)
        }
    }
}

// Provide a stub for client-side builds
#[cfg(not(feature = "ssr"))]
pub async fn send_reset_email(_email: &str, _reset_token: &str) -> Result<(), String> {
    Err("Email sending is only available on the server".to_string())
}
use leptos::prelude::*;
#[cfg(feature = "ssr")]
mod server {
    use actix_web::{
        dev::{forward_ready, Service, ServiceRequest, ServiceResponse, Transform},
        web, Error, HttpMessage, HttpResponse,
    };
    use futures::future::{ready, LocalBoxFuture, Ready};
    use log::{debug, error};
    use sqlx::PgPool;
    use std::rc::Rc;
    use std::task::{Context, Poll};

    use crate::app::db::user_database;
    use crate::app::models::user::{SessionUser, UserRole};

    pub struct Authentication;

    impl Authentication {
        pub fn new() -> Self {
            Authentication
        }
    }

    impl<S, B> Transform<S, ServiceRequest> for Authentication
    where
        S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + 'static,
        S::Future: 'static,
        B: 'static,
    {
        type Response = ServiceResponse<B>;
        type Error = Error;
        type Transform = AuthenticationMiddleware<S>;
        type InitError = ();
        type Future = Ready<Result<Self::Transform, Self::InitError>>;

        fn new_transform(&self, service: S) -> Self::Future {
            ready(Ok(AuthenticationMiddleware {
                service: Rc::new(service),
            }))
        }
    }

    pub struct AuthenticationMiddleware<S> {
        service: Rc<S>,
    }

    impl<S, B> Service<ServiceRequest> for AuthenticationMiddleware<S>
    where
        S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + 'static,
        S::Future: 'static,
        B: 'static,
    {
        type Response = ServiceResponse<B>;
        type Error = Error;
        type Future = LocalBoxFuture<'static, Result<Self::Response, Self::Error>>;

        forward_ready!(service);

        fn call(&self, req: ServiceRequest) -> Self::Future {
            let service = self.service.clone();

            Box::pin(async move {
                let mut authenticated_user: Option<SessionUser> = None;

                // Extract database pool
                if let Some(pool) = req.app_data::<web::Data<PgPool>>() {
                    // Check for session cookie
                    if let Ok(cookies) = req.cookies() {
                        if let Some(session_cookie) = cookies.iter().find(|c| c.name() == "session")
                        {
                            let session_token = session_cookie.value();

                            // Validate session - returns SessionUser (not User)
                            match user_database::validate_session(&pool, session_token).await {
                                Ok(Some(user)) => {
                                    debug!("Valid session found for user: {}", user.username);
                                    authenticated_user = Some(user); // Already SessionUser
                                }
                                Ok(None) => {
                                    debug!("Invalid or expired session token");
                                }
                                Err(e) => {
                                    error!("Error validating session: {:?}", e);
                                }
                            }
                        }
                    }
                } else {
                    error!("Database pool not found in middleware");
                }

                // Insert SessionUser into request extensions if authenticated
                if let Some(user) = authenticated_user {
                    req.extensions_mut().insert(user);
                    debug!("User successfully added to request extensions");
                }

                // Continue with request
                service.call(req).await
            })
        }
    }

    // Helper functions for extracting user data from requests
    pub fn get_current_user_from_request(req: &ServiceRequest) -> Option<SessionUser> {
        req.extensions().get::<SessionUser>().cloned()
    }

    // Helper function to check if user has required role
    pub fn user_has_role(user: &SessionUser, required_role: UserRole) -> bool {
        match required_role {
            UserRole::Guest => true, // All users can access guest-level content
            UserRole::User => user.is_user(),
            UserRole::Teacher => user.is_teacher(),
            UserRole::Admin => user.is_admin(),
            UserRole::SuperAdmin => user.is_super_admin(),
        }
    }

    // Helper to check if user has any of the required roles
    pub fn user_has_any_role(user: &SessionUser, required_roles: &[UserRole]) -> bool {
        required_roles.iter().any(|role| user_has_role(user, *role))
    }

    // Helper to get user ID from request
    pub fn get_user_id_from_request(req: &ServiceRequest) -> Option<i64> {
        get_current_user_from_request(req).map(|user| user.id)
    }

    // Helper to check if user is authenticated
    pub fn is_authenticated(req: &ServiceRequest) -> bool {
        get_current_user_from_request(req).is_some()
    }

    // Helper to check if user is admin
    pub fn is_admin(req: &ServiceRequest) -> bool {
        get_current_user_from_request(req)
            .map(|user| user.is_admin())
            .unwrap_or(false)
    }

    // Helper to check if user is teacher or admin
    pub fn is_teacher_or_admin(req: &ServiceRequest) -> bool {
        get_current_user_from_request(req)
            .map(|user| user.is_teacher())
            .unwrap_or(false)
    }
}

// Re-export the Authentication struct at the module root level
#[cfg(feature = "ssr")]
pub use server::Authentication;

// Provide a stub implementation for non-ssr builds
#[cfg(not(feature = "ssr"))]
pub struct Authentication;

#[cfg(not(feature = "ssr"))]
impl Authentication {
    pub fn new() -> Self {
        Authentication
    }
}
use crate::app::models::global::SettingsCache;
use crate::app::server_functions::globals::get_global_settings;
use leptos::prelude::*;
use leptos::task::spawn_local;

#[component]
pub fn SettingsProvider(children: Children) -> impl IntoView {
    let (settings, set_settings) = signal(SettingsCache::default());
    let (loading, set_loading) = signal(true);

    // Load settings on mount
    Effect::new(move |_| {
        set_loading.set(true);

        spawn_local(async move {
            match get_global_settings().await {
                Ok(settings_data) => {
                    log::info!("Settings loaded: {:?}", settings_data);
                    set_settings.set(settings_data);
                }
                Err(err) => {
                    log::info!("Error loading settings: {:?}", err);
                    // Keep default settings on error
                }
            }
            set_loading.set(false);
        });
    });

    // Provide settings context as tuple
    provide_context((settings, set_settings));
    provide_context(loading);

    children()
}

// Component to conditionally render based on settings
#[component]
pub fn ConditionalRender(
    #[prop(default = false)] student_protections_required: bool,
    children: Children,
    #[prop(optional)] fallback: Option<Children>,
) -> impl IntoView {
    let (settings, _) = use_settings();
    let loading = use_settings_loading();

    view! {
        {
            let children_view = children();
            move || {
                if loading.get() {
                    view! { <div>"Loading settings..."</div> }
                } else {
                    view! { <div>{children_view.clone()}</div> }
                }
            }
        }
    }
}

// Safe hook that returns Option instead of panicking
pub fn try_use_settings() -> Option<(ReadSignal<SettingsCache>, WriteSignal<SettingsCache>)> {
    use_context::<(ReadSignal<SettingsCache>, WriteSignal<SettingsCache>)>()
}

// Updated hook with better error handling
pub fn use_settings() -> (ReadSignal<SettingsCache>, WriteSignal<SettingsCache>) {
    use_context::<(ReadSignal<SettingsCache>, WriteSignal<SettingsCache>)>()
        .expect("Settings context not found - make sure SettingsProvider wraps your app and the component is mounted after settings load")
}

// Add the missing function - returns ReadSignal directly, panics if not found
pub fn use_settings_loading() -> ReadSignal<bool> {
    use_context::<ReadSignal<bool>>()
        .expect("Settings loading context not found - make sure SettingsProvider wraps your app")
}

// Safe version that returns Option
pub fn try_use_settings_loading() -> Option<ReadSignal<bool>> {
    use_context::<ReadSignal<bool>>()
}

// Hook that waits for settings to be loaded - FIXED
pub fn use_settings_when_ready() -> Option<(ReadSignal<SettingsCache>, WriteSignal<SettingsCache>)>
{
    let settings = try_use_settings()?;
    let loading = try_use_settings_loading()?; // Use the safe version

    if loading.get() {
        // Now we can call .get() on the ReadSignal<bool>
        None
    } else {
        Some(settings)
    }
}

// Safe version of use_student_protections
pub fn use_student_protections() -> bool {
    match try_use_settings() {
        Some((settings, _)) => settings.get().student_protections,
        None => {
            log::info!(
                "Settings context not available, defaulting student_protections to false"
            );
            false
        }
    }
}

// Component wrapper that ensures settings are loaded
#[component]
pub fn WithSettings<F>(children: F) -> impl IntoView
where
    F: Fn() -> View + 'static,
{
    let loading = use_context::<ReadSignal<bool>>();
    let settings_context = try_use_settings();

    view! {
        {move || {
            match (loading, settings_context) {
                (Some(loading), Some(_)) if !loading.get() => {
                    // Settings are loaded and ready
                    children()
                }
                (Some(_), Some(_)) => {
                    // Settings context exists but still loading
                    view! { <div class="text-gray-400">"Loading settings..."</div> }.into_any()
                }
                _ => {
                    // Settings context not available
                    view! { <div class="text-red-400">"Settings not available"</div> }.into_any()
                }
            }
        }}
    }
}
use crate::app::db::question_database;
use crate::app::errors::{question_errors, ErrorMessageQuestion, ResponseErrorTraitQuestion};
use crate::app::models::{
    question::{Question, QuestionType},
    CreateNewQuestionRequest, DeleteQuestionRequest, UpdateQuestionRequest,
};
use leptos::prelude::*;
#[cfg(feature = "ssr")]
use {
    crate::app::db::database, actix_web::web, rand::seq::SliceRandom, rand::thread_rng,
    sqlx::PgPool, std::error::Error, uuid::Uuid,
};

#[server]
pub async fn get_questions(test_id: String) -> Result<Vec<Question>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;
        log::info!("Attempting to retrieve all tests from database");

        match question_database::get_all_questions(test_id, &pool).await {
            Ok(questions) => {
                log::info!("Successfully retrieved all tests from database");
                Ok(questions)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn delete_questions(test_id: String) -> Result<Vec<Question>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;
        log::info!("Attempting to retrieve all tests from database");

        match question_database::delete_all_questions(test_id, &pool).await {
            Ok(questions) => {
                log::info!("Successfully deleted all questions related to test from database");
                Ok(questions)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn add_question(
    test_id: String,
    add_question_request: CreateNewQuestionRequest,
) -> Result<Question, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new question to the database");
        log::info!("Question type: {:?}", add_question_request.question_type);
        log::info!(
            "Weighted options: {:?}",
            add_question_request.weighted_options
        );

        let mut buffer_question = Question::new(
            add_question_request.word_problem,
            add_question_request.point_value,
            add_question_request.question_type,
            add_question_request.options,
            add_question_request.correct_answer,
            0, //this value is technically the qnumber but qnumber is determined by the backend
            test_id.clone(),
        );

        // IMPORTANT: Copy the weighted_options from the request!
        buffer_question.weighted_options = add_question_request.weighted_options.clone();

        log::info!(
            "Buffer question weighted_options: {:?}",
            buffer_question.weighted_options
        );

        match question_database::add_question(&buffer_question, &pool).await {
            Ok(created_question) => {
                log::info!(
                    "Successfully created question with ID: {}",
                    created_question.testlinker
                );
                log::info!(
                    "Created question weighted_options: {:?}",
                    created_question.weighted_options
                );
                Ok(created_question)
            }
            Err(e) => {
                log::error!("Failed to create question: {:?}", e);
                Err(ServerFnError::new(format!(
                    "Failed to create question: {}",
                    e
                )))
            }
        }
    }
}

#[server]
pub async fn delete_question(
    delete_question_request: DeleteQuestionRequest,
) -> Result<Question, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete question from the database");

        match question_database::delete_question(
            delete_question_request.qnumber,
            delete_question_request.testlinker,
            &pool,
        )
        .await
        {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(ServerFnError::new(
                "Failed to delete question from the database",
            )),
        }
    }
}

#[server]
pub async fn edit_question(
    test_id: String,
    edit_question_request: UpdateQuestionRequest,
) -> Result<Question, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update question from the database");

        let buffer_question = Question::new(
            edit_question_request.word_problem,
            edit_question_request.point_value,
            edit_question_request.question_type,
            edit_question_request.options,
            edit_question_request.correct_answer,
            edit_question_request.qnumber,
            edit_question_request.testlinker,
        );

        match question_database::update_question(&buffer_question, &pool).await {
            Ok(Some(updated_student)) => Ok(updated_student),
            Ok(None) => Err(ServerFnError::new(format!(
                "Failed to correctly existing student in the database"
            ))),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update student: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn duplicate_and_randomize_questions(
    source_test_id: String,
    target_test_id: String,
) -> Result<Vec<Question>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to duplicate and randomize questions from database");

        // First, get all questions from the source test
        match question_database::get_all_questions(source_test_id.clone(), &pool).await {
            Ok(source_questions) => {
                if source_questions.is_empty() {
                    return Err(ServerFnError::new("No questions found in source test"));
                }

                // Create randomized versions of the questions
                let mut randomized_questions = Vec::new();
                let mut rng = thread_rng();

                // Create a shuffled order for the questions
                let mut question_indices: Vec<usize> = (0..source_questions.len()).collect();
                question_indices.shuffle(&mut rng);

                for (new_index, &original_index) in question_indices.iter().enumerate() {
                    let source_question = &source_questions[original_index];
                    let mut new_question = source_question.clone();

                    // Update the question number to maintain sequential order in the new test
                    new_question.qnumber = (new_index + 1) as i32;
                    new_question.testlinker = target_test_id.clone();

                    // Randomize the answer options for multiple choice questions
                    if source_question.question_type == QuestionType::MultipleChoice
                        && !source_question.options.is_empty()
                    {
                        let mut shuffled_options = source_question.options.clone();
                        shuffled_options.shuffle(&mut rng);
                        new_question.options = shuffled_options;
                    }

                    randomized_questions.push(new_question);
                }

                // Insert the randomized questions into the database
                let mut created_questions = Vec::new();

                for question in randomized_questions {
                    match question_database::add_question(&question, &pool).await {
                        Ok(created_question) => {
                            created_questions.push(created_question);
                        }
                        Err(e) => {
                            log::error!("Failed to create randomized question: {:?}", e);
                            return Err(ServerFnError::new(format!(
                                "Failed to create randomized question: {}",
                                e
                            )));
                        }
                    }
                }

                log::info!(
                    "Successfully created {} randomized questions for test {}",
                    created_questions.len(),
                    target_test_id
                );

                Ok(created_questions)
            }
            Err(e) => {
                log::error!("Database error fetching source questions: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn generate_randomized_test(
    base_test_id: String,
    variation_name: String,
    shuffle_questions: bool,
    shuffle_options: bool,
) -> Result<String, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::models::test::{CreateNewTestRequest, Test};
        use crate::app::server_functions::tests::{add_test, get_test};

        log::info!("Attempting to generate randomized test");

        // Get the base test
        let base_test = match get_test(base_test_id.clone()).await {
            Ok(test) => test,
            Err(e) => {
                return Err(ServerFnError::new(format!("Base test not found: {}", e)));
            }
        };

        // Create the variation test
        let variation_test_request = CreateNewTestRequest::new(
            variation_name,
            base_test.score,
            base_test.instructions,
            format!("Randomized variation of {}", base_test.name),
            base_test.testarea,
            base_test.school_year,
            base_test.benchmark_categories,
            base_test.test_variant + 100, // Randomized variant offset
            base_test.grade_level,
            base_test.scope,
            base_test.course_id,
        );

        let new_test = match add_test(variation_test_request).await {
            Ok(test) => test,
            Err(e) => {
                return Err(ServerFnError::new(format!(
                    "Failed to create variation test: {}",
                    e
                )));
            }
        };

        // Generate randomized questions
        match duplicate_and_randomize_questions(base_test_id, new_test.test_id.clone()).await {
            Ok(_) => Ok(new_test.test_id),
            Err(e) => Err(e),
        }
    }
}

#[server]
pub async fn shuffle_question_options(
    qnumber: i32,
    test_id: String,
) -> Result<Question, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to shuffle question options");

        // Get the specific question first
        match question_database::get_single_question(qnumber, test_id.clone(), &pool).await {
            Ok(question) => {
                // Only shuffle if it's a multiple choice question with options
                if question.question_type == QuestionType::MultipleChoice
                    && !question.options.is_empty()
                {
                    let mut rng = thread_rng();
                    let mut shuffled_options = question.options.clone();
                    shuffled_options.shuffle(&mut rng);

                    // Update the question options in the database
                    match question_database::update_question_options(
                        qnumber,
                        test_id,
                        shuffled_options,
                        &pool,
                    )
                    .await
                    {
                        Ok(updated_question) => Ok(updated_question),
                        Err(e) => Err(ServerFnError::new(format!(
                            "Failed to update question options: {}",
                            e
                        ))),
                    }
                } else {
                    Ok(question)
                }
            }
            Err(e) => {
                log::error!("Database error fetching question: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn validate_test_for_randomization(
    test_id: String,
) -> Result<(bool, String), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to validate test for randomization");

        // Get question count
        let question_count =
            match question_database::count_questions_by_test(test_id.clone(), &pool).await {
                Ok(count) => count,
                Err(e) => {
                    log::error!("Database error counting questions: {}", e);
                    return Err(ServerFnError::new(format!("Database error: {}", e)));
                }
            };

        if question_count == 0 {
            return Ok((false, "Test has no questions to randomize".to_string()));
        }

        // Get multiple choice question count
        let mc_count = match question_database::count_multiple_choice_questions(
            test_id.clone(),
            &pool,
        )
        .await
        {
            Ok(count) => count,
            Err(e) => {
                log::error!("Database error counting MC questions: {}", e);
                return Err(ServerFnError::new(format!("Database error: {}", e)));
            }
        };

        if mc_count == 0 {
            return Ok((true, format!("Test has {} questions but no multiple choice questions. Only question order will be randomized.", question_count)));
        }

        Ok((true, format!("Test has {} questions ({} multiple choice). Both question order and answer choices will be randomized.", question_count, mc_count)))
    }
}

/*cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {

        use crate::app::db::database;
        use crate::app::errors::QuestionError;
        use sqlx::PgPool;

        pub async fn retrieve_all_questions(test_id: String, pool: &sqlx::PgPool) -> Vec<Question> {

            let get_all_question_results = database::get_all_questions(test_id.clone(), pool).await;

            get_all_question_results.expect("There was a problem gathering all the questions for this test.")
        }

        pub async fn add_new_question<T> (word_problem: T, point_value: i32, question_type: QuestionType, options: Vec<String>, correct_answer: T, qnumber: i64, test_id: T, pool: &sqlx::PgPool) -> Result<Question, ServerFnErro> where T: Into<String> {
            let new_question = Question::new(
                word_problem.into(),
                point_value,
                question_type,
                options,
                correct_answer.into(),
                qnumber,
                test_id.into(),
            );

            database::add_question(&new_question, pool).await
        }
        pub async fn delete_certain_question(qnumber: i64, test_id: String, pool: &sqlx::PgPool) -> Result<(), sqlx::Error> {
            database::delete_question(qnumber, test_id, pool).await
        }

        pub async fn edit_certain_question<T>(word_problem: T, point_value: i32, question_type: QuestionType, options:Vec<String>, correct_answer: T, qnumber: i64, test_id: T, pool: &sqlx::PgPool) -> Result<Option<Question>, sqlx::Error> where T: Into<String> {
            let updated_question = Question::new(
                word_problem.into(),
                point_value,
                question_type,
                options,
                correct_answer.into(),
                qnumber,
                test_id.into(),
            );
            database::update_question(&updated_question, pool).await
        }
    }
}*/
use leptos::prelude::*;
//this file contains all handler functions for employees
use crate::app::db::teacher_database;
use crate::app::models::employee::Employee;
use crate::app::models::employee::{AddNewEmployeeRequest, UpdateEmployeeRequest};
use crate::app::models::DeleteTeacherRequest;
use crate::app::models::EmployeeRole;
use log::{error, info};

#[cfg(feature = "ssr")]
use {
    crate::app::db::database, actix_web::web, chrono::Local, sqlx::PgPool, std::error::Error,
    uuid::Uuid,
};

#[server]
pub async fn get_employees() -> Result<Vec<Employee>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all teachers from database");
        use crate::app::db::database;

        match database::get_all_employees(&pool).await {
            Ok(employees) => {
                log::info!("Successfully retrieved all employees from database");
                Ok(employees)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn add_employee(
    add_employee_request: AddNewEmployeeRequest,
) -> Result<Employee, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new teacher to the database");

        let buffer_employee = match add_employee_request.role {
            EmployeeRole::Teacher { grade: _ } => Employee::new_teacher(
                0001,
                add_employee_request.firstname,
                add_employee_request.lastname,
                add_employee_request.status,
                add_employee_request.grade,
            ),
            EmployeeRole::AssistantPrincipal
            | EmployeeRole::Principal
            | EmployeeRole::Interventionist
            | EmployeeRole::IntegratedServices
            | EmployeeRole::Speech
            | EmployeeRole::OT
            | EmployeeRole::Psychologist
            | EmployeeRole::ParaProf
            | EmployeeRole::AssessmentCoordinator
            | EmployeeRole::Other => Employee::new(
                0001,
                add_employee_request.firstname,
                add_employee_request.lastname,
                add_employee_request.status,
                add_employee_request.role,
            ),
        };

        match database::add_employee(&buffer_employee, &pool).await {
            Ok(created_employee) => {
                log::info!(
                    "Successfully created employee: {} {}",
                    created_employee.firstname,
                    created_employee.lastname,
                );
                Ok(created_employee)
            }
            Err(e) => {
                log::info!("Failed to create employee: {:?}", e);
                Err(ServerFnError::new(format!(
                    "An error occured while creating the teacher"
                )))
            }
        }
    }
}

#[server]
pub async fn delete_employee(
    delete_teacher_request: DeleteTeacherRequest,
) -> Result<Employee, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete teacher from the database");

        match database::delete_employee(delete_teacher_request.id, &pool).await {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(ServerFnError::new(
                "Failed to delete teacher from the database",
            )),
        }
    }
}

#[server]
pub async fn edit_employee(
    update_employee_request: UpdateEmployeeRequest,
) -> Result<Employee, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update teacher in the database");

        let buffer_employee = match update_employee_request.role {
            EmployeeRole::Teacher { grade: _ } => Employee::new_teacher(
                update_employee_request.id,
                update_employee_request.firstname,
                update_employee_request.lastname,
                update_employee_request.status,
                update_employee_request.grade,
            ),
            EmployeeRole::AssistantPrincipal
            | EmployeeRole::Principal
            | EmployeeRole::Interventionist
            | EmployeeRole::IntegratedServices
            | EmployeeRole::Speech
            | EmployeeRole::OT
            | EmployeeRole::Psychologist
            | EmployeeRole::ParaProf
            | EmployeeRole::AssessmentCoordinator
            | EmployeeRole::Other => Employee::new(
                update_employee_request.id,
                update_employee_request.firstname,
                update_employee_request.lastname,
                update_employee_request.status,
                update_employee_request.role,
            ),
        };

        match database::update_employee(&buffer_employee, &pool).await {
            Ok(Some(updated_employee)) => Ok(updated_employee),
            Ok(None) => Err(ServerFnError::new(format!(
                "Failed to update and return employee"
            ))),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update employee: {}",
                e
            ))),
        }
    }
}
use crate::app::models::bulk_student::{StudentCsvRow, StudentCsvRowAlternative};
use crate::app::models::student::{
    AddStudentRequest, ESLEnum, GenderEnum, GradeEnum, InterventionEnum,
};
use chrono::NaiveDate;
use csv::ReaderBuilder;
use leptos::prelude::*;
use std::str::FromStr;
use validator::Validate;

#[cfg(feature = "ssr")]
use {crate::app::db::student_database, sqlx::PgPool};

#[server]
pub async fn upload_students_bulk(file_contents: String) -> Result<usize, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        // Parse and validate all students first
        let students = parse_and_validate_students(&file_contents)?;

        // Bulk insert using optimized method
        match student_database::bulk_insert_students_optimized(students, &pool).await {
            Ok(count) => Ok(count),
            Err(e) => {
                log::error!("Bulk student import failed: {:?}", e);
                Err(ServerFnError::ServerError(format!("Import failed: {}", e)))
            }
        }
    }
    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError(
            "Server-side functionality not available".to_string(),
        ))
    }
}

// Enhanced parsing logic with better error handling and flexibility
fn parse_and_validate_students(
    file_contents: &str,
) -> Result<Vec<AddStudentRequest>, ServerFnError> {
    let mut rdr = ReaderBuilder::new()
        .has_headers(true)
        .flexible(true) // Allow varying number of fields
        .trim(csv::Trim::All) // Trim whitespace from all fields
        .from_reader(file_contents.as_bytes());

    let mut students = Vec::new();
    let mut errors = Vec::new();

    // First, try to get headers to determine the format
    let headers = rdr
        .headers()
        .map_err(|e| ServerFnError::new(format!("Failed to read CSV headers: {}", e)))?;

    log::info!("CSV Headers: {:?}", headers);

    // Check if we have 'grade' or 'current_grade_level' in headers
    let has_grade_field = headers.iter().any(|h| h == "grade");
    let has_current_grade_level_field = headers.iter().any(|h| h == "current_grade_level");

    for (row_num, result) in rdr.records().enumerate() {
        match result {
            Ok(record) => {
                // Try to parse based on detected format
                let student_result = if has_grade_field && !has_current_grade_level_field {
                    // Use alternative format (matching CSV template with 'grade' header)
                    match record.deserialize::<StudentCsvRowAlternative>(None) {
                        Ok(alt_record) => {
                            let converted_record = StudentCsvRow::from(alt_record);
                            parse_student_record(converted_record, row_num + 2)
                        }
                        Err(e) => Err(format!(
                            "Row {}: Failed to parse CSV row: {}",
                            row_num + 2,
                            e
                        )),
                    }
                } else {
                    // Use standard format
                    match record.deserialize::<StudentCsvRow>(None) {
                        Ok(std_record) => parse_student_record(std_record, row_num + 2),
                        Err(e) => Err(format!(
                            "Row {}: Failed to parse CSV row: {}",
                            row_num + 2,
                            e
                        )),
                    }
                };

                match student_result {
                    Ok(student) => students.push(student),
                    Err(e) => errors.push(e),
                }
            }
            Err(e) => {
                errors.push(format!("Row {}: CSV parsing error: {}", row_num + 2, e));
            }
        }
    }

    if !errors.is_empty() {
        let error_msg = format!("Validation errors:\n{}", errors.join("\n"));
        log::error!("{}", error_msg);
        return Err(ServerFnError::new(error_msg));
    }

    // Validate all students
    for (index, student) in students.iter().enumerate() {
        if let Err(validation_errors) = student.validate() {
            let error_msg = format!(
                "Validation failed for student {} {} (row {}): {:?}",
                student.firstname,
                student.lastname,
                index + 2,
                validation_errors
            );
            log::error!("{}", error_msg);
            return Err(ServerFnError::new(error_msg));
        }
    }

    log::info!(
        "Successfully parsed and validated {} students",
        students.len()
    );
    Ok(students)
}

fn parse_student_record(
    record: StudentCsvRow,
    row_num: usize,
) -> Result<AddStudentRequest, String> {
    // Parse and validate gender
    let gender = GenderEnum::from_str(&record.gender.trim()).map_err(|e| {
        format!(
            "Row {}: Invalid gender '{}': {}. Valid values: Male, Female, Non-binary",
            row_num, record.gender, e
        )
    })?;

    // Parse and validate date of birth
    let date_of_birth = NaiveDate::parse_from_str(&record.date_of_birth.trim(), "%Y-%m-%d")
        .map_err(|e| {
            format!(
                "Row {}: Invalid date of birth '{}': {}. Expected format: YYYY-MM-DD",
                row_num, record.date_of_birth, e
            )
        })?;

    // Parse and validate current grade level
    let current_grade_level = GradeEnum::from_str(&record.current_grade_level.trim())
        .map_err(|e| {
            format!(
                "Row {}: Invalid grade '{}': {}. Valid values: Kindergarten, 1st Grade, 2nd Grade, etc.",
                row_num, record.current_grade_level, e
            )
        })?;

    // Parse and validate intervention (optional field)
    let intervention = if record.intervention.trim() == "None"
        || record.intervention.trim().is_empty()
    {
        None
    } else {
        Some(
            InterventionEnum::from_str(&record.intervention.trim()).map_err(|e| {
                format!(
                    "Row {}: Invalid intervention '{}': {}. Valid values: Literacy, Math, Literacy and Math, None",
                    row_num, record.intervention, e
                )
            })?,
        )
    };

    // Parse and validate ESL
    let esl = ESLEnum::from_str(&record.esl.trim())
        .map_err(|e| format!("Row {}: Invalid ESL value '{}': {}. Valid values: Not Applicable, Spanish, Arabic, etc.", 
                            row_num, record.esl, e))?;

    // Validate student ID range
    if record.student_id < 0 || record.student_id > 2000000000 {
        return Err(format!(
            "Row {}: Student ID {} is out of valid range (0-2000000000)",
            row_num, record.student_id
        ));
    }

    // Validate PIN range (assuming similar constraints)
    if record.pin < 0 || record.pin > 99999999 {
        return Err(format!(
            "Row {}: PIN {} is out of valid range",
            row_num, record.pin
        ));
    }

    // Validate required string fields are not empty
    if record.firstname.trim().is_empty() {
        return Err(format!("Row {}: First name cannot be empty", row_num));
    }
    if record.lastname.trim().is_empty() {
        return Err(format!("Row {}: Last name cannot be empty", row_num));
    }

    // IMPORTANT: Teacher field validation for decoupled model
    // Since teachers are decoupled, we now store teacher names as strings
    if record.teacher.trim().is_empty() {
        return Err(format!("Row {}: Teacher name cannot be empty", row_num));
    }

    // Validate teacher name is reasonable (basic validation)
    let teacher_name = record.teacher.trim();
    if teacher_name.len() < 2 {
        return Err(format!(
            "Row {}: Teacher name '{}' is too short",
            row_num, teacher_name
        ));
    }
    if teacher_name.len() > 100 {
        return Err(format!(
            "Row {}: Teacher name '{}' is too long (max 100 characters)",
            row_num, teacher_name
        ));
    }

    Ok(AddStudentRequest {
        firstname: record.firstname.trim().to_string(),
        lastname: record.lastname.trim().to_string(),
        preferred: record.preferred.trim().to_string(),
        gender,
        date_of_birth,
        student_id: record.student_id,
        esl,
        current_grade_level,
        teacher: teacher_name.to_string(), // Store as string, not ID
        iep: record.iep,
        bip: record.bip,
        student_504: record.student_504,
        readplan: record.readplan,
        gt: record.gt,
        intervention,
        eye_glasses: record.eye_glasses,
        notes: record.notes.trim().to_string(),
        pin: record.pin,
    })
}
use crate::app::models::assessment::RangeCategory;
use crate::app::models::assessment::SubjectEnum;
use crate::app::models::assessment::{
    Assessment, CreateNewAssessmentRequest, DeleteAssessmentRequest, UpdateAssessmentRequest,
};
use leptos::prelude::*;
#[cfg(feature = "ssr")]
use {
    crate::app::db::assessment_database, crate::app::db::database, actix_web::web, chrono::Local,
    sqlx::PgPool, std::error::Error, uuid::Uuid,
};

//this file contains a list of api functions that will be called on the server side
//lowercase functions denote functions that are server side while upper/camel case functions
//indicate Client side Objects/functions

#[server]
pub async fn get_assessments() -> Result<Vec<Assessment>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all assessments from database");

        match assessment_database::get_all_assessments(&pool).await {
            Ok(assessments) => {
                log::info!("Successfully retrieved all assessments from database");
                Ok(assessments)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn get_assessment(id: String) -> Result<Assessment, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve assessment");

        match assessment_database::get_assessment(id, &pool).await {
            Ok(assessment) => {
                log::info!("Successfully retrieved assessment from database");
                Ok(assessment)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn add_assessment(
    add_assessment_request: CreateNewAssessmentRequest,
) -> Result<Assessment, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new assessment to the database");

        let id = Uuid::new_v4();

        let buffer_assessment = if add_assessment_request.test_sequence.is_some() {
            Assessment::new_with_sequence(
                add_assessment_request.name,
                add_assessment_request.frequency,
                add_assessment_request.grade,
                add_assessment_request.version,
                id,
                add_assessment_request.composite_score,
                add_assessment_request.risk_benchmarks,
                add_assessment_request.national_benchmarks,
                add_assessment_request.subject,
                add_assessment_request.scope,
                add_assessment_request.course_id,
                add_assessment_request.test_sequence.unwrap(),
            )
        } else {
            Assessment::new(
                add_assessment_request.name,
                add_assessment_request.frequency,
                add_assessment_request.grade,
                add_assessment_request.version,
                id,
                add_assessment_request.tests,
                add_assessment_request.composite_score,
                add_assessment_request.risk_benchmarks,
                add_assessment_request.national_benchmarks,
                add_assessment_request.subject,
                add_assessment_request.scope,
                add_assessment_request.course_id,
            )
        };

        assessment_database::add_assessment(&buffer_assessment, &pool)
            .await
            .map_err(|e| {
                log::error!("Database error while adding assessment: {}", e);
                ServerFnError::new(format!("Database error: {}", e))
            })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn delete_assessment(
    delete_assessment_request: DeleteAssessmentRequest,
) -> Result<Assessment, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete assessment");

        match assessment_database::delete_assessment(
            delete_assessment_request.id.to_string(),
            &pool,
        )
        .await
        {
            Ok(deleted) => Ok(deleted),
            Err(e) => Err(ServerFnError::new(format!(
                "Error in deleting assessment: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn update_assessment_score(test_id: String) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match assessment_database::update_all_assessments_referencing_test(&test_id, &pool).await {
            Ok(()) => Ok(()),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update assessment scores: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn update_assessment(
    update_assessment_request: UpdateAssessmentRequest,
) -> Result<Assessment, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update assessment");

        let buffer_assessment = if update_assessment_request.test_sequence.is_some() {
            Assessment::new_with_sequence(
                update_assessment_request.name,
                update_assessment_request.frequency,
                update_assessment_request.grade,
                update_assessment_request.version,
                update_assessment_request.id,
                update_assessment_request.composite_score,
                update_assessment_request.risk_benchmarks,
                update_assessment_request.national_benchmarks,
                update_assessment_request.subject,
                update_assessment_request.scope,
                update_assessment_request.course_id,
                update_assessment_request.test_sequence.unwrap(),
            )
        } else {
            Assessment::new(
                update_assessment_request.name,
                update_assessment_request.frequency,
                update_assessment_request.grade,
                update_assessment_request.version,
                update_assessment_request.id,
                update_assessment_request.tests,
                update_assessment_request.composite_score,
                update_assessment_request.risk_benchmarks,
                update_assessment_request.national_benchmarks,
                update_assessment_request.subject,
                update_assessment_request.scope,
                update_assessment_request.course_id,
            )
        };

        match assessment_database::update_assessment(&buffer_assessment, &pool).await {
            Ok(updated_assessment) => Ok(updated_assessment),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update assessment: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}

#[server]
pub async fn get_test_sequence(
    assessment_id: String,
) -> Result<Vec<(String, String)>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve test sequence for assessment");

        match assessment_database::get_test_sequence(&assessment_id, &pool).await {
            Ok(test_sequence) => Ok(test_sequence),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to retrieve test sequence: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(
            "Server function called in client context",
        ))
    }
}
use crate::app::models::score::*;
use leptos::prelude::*;
use uuid::Uuid;

#[cfg(feature = "ssr")]
use {
    crate::app::db::database, crate::app::db::score_database, actix_web::web, sqlx::PgPool,
    std::error::Error,
};

#[server]
pub async fn get_scores() -> Result<Vec<Score>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all scores from database");
        use crate::app::db::score_database;

        match score_database::get_all_scores(&pool).await {
            Ok(scores) => {
                log::info!(
                    "Successfully retrieved {} scores from database",
                    scores.len()
                );
                Ok(scores)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_scores_by_test(test_ids: Vec<Uuid>) -> Result<Vec<Score>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to get scores based upon test IDs");

        match score_database::get_scores_by_test(test_ids, &pool).await {
            Ok(scores) => {
                log::info!("Successfully retrieved scores from database");
                Ok(scores)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_score(
    student_id: i32,
    test_id: String,
    test_variant: i32,
    attempt: i32,
) -> Result<Score, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all scores from database");

        match score_database::get_score(student_id, test_id, test_variant, attempt, &pool).await {
            Ok(score) => {
                log::info!("Successfully retrieved score from database");
                Ok(score)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_student_scores(student_id: i32) -> Result<Vec<Score>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!(
            "Attempting to retrieve all scores for student: {}",
            student_id
        );

        match score_database::get_all_student_scores(student_id, &pool).await {
            Ok(scores) => {
                log::info!(
                    "Successfully retrieved scores from database for student: {}",
                    student_id
                );
                Ok(scores)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn add_score(add_score_request: CreateScoreRequest) -> Result<Score, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new score to the database");

        match score_database::add_score(&add_score_request, &pool).await {
            Ok(created_score) => {
                log::info!(
                    "Successfully created score for student {}",
                    created_score.student_id
                );
                Ok(created_score)
            }
            Err(e) => {
                log::info!("Failed to create question: {:?}", e);
                Err(ServerFnError::new(format!(
                    "The score created was not saved correctly"
                )))
            }
        }
    }
}

#[server]
pub async fn delete_score(
    delete_score_request: DeleteScoreRequest,
) -> Result<Score, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete score from the database");

        match score_database::delete_score(
            delete_score_request.student_id,
            delete_score_request.test_id,
            delete_score_request.test_variant,
            delete_score_request.attempt,
            &pool,
        )
        .await
        {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(ServerFnError::new(
                "Failed to delete score from the database",
            )),
        }
    }
}
/*
#[server]
pub async fn edit_question(
    test_id: String,
    edit_question_request: UpdateQuestionRequest,
) -> Result<Question, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update question from the database");

        let buffer_question = Question::new(
            edit_question_request.word_problem,
            edit_question_request.point_value,
            edit_question_request.question_type,
            edit_question_request.options,
            edit_question_request.correct_answer,
            edit_question_request.qnumber,
            edit_question_request.testlinker,
        );

        match database::update_question(&buffer_question, &pool).await {
            Ok(Some(updated_student)) => Ok(updated_student),
            Ok(None) => Err(ServerFnError::new(format!(
                "Failed to correctly existing student in the database"
            ))),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update student: {}",
                e
            ))),
        }
    }
}
*/
use crate::app::db::user_database;
use crate::app::models::setting_data::{UserSettings, UserSettingsUpdate};
use leptos::prelude::*;

#[server]
pub async fn get_user_settings(user_id: i64) -> Result<UserSettings, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Fetching settings for user ID {}", user_id);

        match user_database::get_user_settings(&pool, user_id).await {
            Ok(settings) => {
                log::info!(
                    "Successfully retrieved user settings for user ID {}",
                    user_id
                );
                Ok(settings)
            }
            Err(e) => {
                log::error!("Database error getting user settings: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn update_user_settings(
    user_id: i64,
    settings_update: UserSettingsUpdate,
) -> Result<UserSettings, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Updating settings for user ID {}", user_id);

        match user_database::update_user_settings(&pool, user_id, settings_update).await {
            Ok(settings) => {
                log::info!("Successfully updated user settings for user ID {}", user_id);
                Ok(settings)
            }
            Err(e) => {
                log::error!("Database error updating user settings: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn reset_user_settings(user_id: i64) -> Result<UserSettings, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Resetting settings for user ID {}", user_id);

        match user_database::reset_user_settings(&pool, user_id).await {
            Ok(settings) => {
                log::info!("Successfully reset user settings for user ID {}", user_id);
                Ok(settings)
            }
            Err(e) => {
                log::error!("Database error resetting user settings: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

// Convenience functions for updating specific settings
#[server]
pub async fn update_dark_mode(
    user_id: i64,
    dark_mode: bool,
) -> Result<UserSettings, ServerFnError> {
    let settings_update = UserSettingsUpdate {
        ui: Some(crate::app::models::setting_data::UiSettingsUpdate {
            dark_mode: Some(dark_mode),
            pinned_sidebar: None,
        }),
    };

    update_user_settings(user_id, settings_update).await
}

#[server]
pub async fn update_pinned_sidebar(
    user_id: i64,
    pinned_sidebar: bool,
) -> Result<UserSettings, ServerFnError> {
    let settings_update = UserSettingsUpdate {
        ui: Some(crate::app::models::setting_data::UiSettingsUpdate {
            dark_mode: None,
            pinned_sidebar: Some(pinned_sidebar),
        }),
    };

    update_user_settings(user_id, settings_update).await
}
use crate::app::db::saml_database;
use crate::app::models::auth::{AuthProvider, SamlConfig, SamlResponse};
use crate::app::models::user::{SessionUser, UserRole};
use leptos::prelude::*;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[cfg(feature = "ssr")]
use {
    actix_web::{cookie::Cookie, http::header, HttpRequest, HttpResponse},
    leptos_actix::{extract, ResponseOptions},
    sqlx::{PgPool, Row}, // Added Row import
    url::Url,
};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlAuthResponse {
    pub success: bool,
    pub message: String,
    pub redirect_url: Option<String>,
    pub user: Option<SessionUser>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlInstitution {
    pub id: String,
    pub name: String,
    pub active: bool,
}
impl SamlInstitution {
    pub fn to_url_safe(&self) -> String {
        self.name
            .to_lowercase()
            .replace(" ", "-")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '-')
            .collect::<String>()
    }
}

// Get list of available SAML institutions
#[server]
pub async fn get_saml_institutions() -> Result<Vec<SamlInstitution>, leptos::ServerFnError>
{
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Check if user is admin for full list, otherwise return only active configs
        let current_user = crate::app::server_functions::auth::get_current_user().await?;
        let is_admin = current_user
            .map(|u| matches!(u.role, UserRole::Admin | UserRole::SuperAdmin))
            .unwrap_or(false);

        let configs = if is_admin {
            // Admins see all configurations
            saml_database::list_saml_configs(&pool).await?
        } else {
            // Regular users only see active configurations
            let all_configs = saml_database::list_saml_configs(&pool).await?;
            all_configs
                .into_iter()
                .filter(|config| config.active)
                .collect()
        };

        let institutions = configs
            .into_iter()
            .map(|config| SamlInstitution {
                id: config.id.to_string(), // Use UUID as string for management operations
                name: config.institution_name,
                active: config.active,
            })
            .collect();

        Ok(institutions)
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Initiate SAML login
#[server]
pub async fn initiate_saml_login(
    institution_id: String,
    relay_state: Option<String>,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Get SAML config for institution
        let config = saml_database::get_saml_config(&pool, &institution_id)
            .await?
            .ok_or_else(|| {
                leptos::ServerFnError::new(
                    "Institution not found or not configured for SAML",
                )
            })?;

        // Create SAML manager
        let base_url = std::env::var("BASE_URL").expect("BASE_URL environment variable not set");
        let saml_manager = saml_database::SamlManager::new(&base_url).map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to create SAML manager: {}", e))
        })?;

        // Generate auth request URL
        let auth_url = saml_manager
            .generate_auth_request(&institution_id, relay_state.as_deref())
            .map_err(|e| {
                leptos::ServerFnError::new(format!(
                    "Failed to generate auth request: {}",
                    e
                ))
            })?;

        // Store the institution ID in session for later use
        let response = expect_context::<ResponseOptions>();
        let cookie_value = format!(
            "saml_institution={}; Path=/; HttpOnly; SameSite=Strict; Max-Age=600{}",
            institution_id,
            if cfg!(debug_assertions) {
                ""
            } else {
                "; Secure"
            }
        );

        response.insert_header(
            header::SET_COOKIE,
            header::HeaderValue::from_str(&cookie_value).expect("Failed to create header value"),
        );

        Ok(SamlAuthResponse {
            success: true,
            message: "Redirecting to SAML provider".to_string(),
            redirect_url: Some(auth_url),
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Handle SAML response (ACS endpoint)
#[server]
pub async fn handle_saml_response(
    saml_response: String,
    relay_state: Option<String>,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use base64::{engine::general_purpose, Engine as _};
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        let req = extract::<HttpRequest>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract request: {}", e))
        })?;

        // Get institution ID from cookie
        let cookies = req.cookies().map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to get cookies: {}", e))
        })?;
        let institution_id = cookies
            .iter()
            .find(|c| c.name() == "saml_institution")
            .map(|c| c.value().to_string())
            .ok_or_else(|| {
                leptos::ServerFnError::new("No institution ID found in session")
            })?;

        // Get SAML config
        let config = saml_database::get_saml_config(&pool, &institution_id)
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Institution not found"))?;

        // Decode SAML response
        let decoded_response = general_purpose::STANDARD
            .decode(&saml_response)
            .map_err(|e| {
                leptos::ServerFnError::new(format!("Failed to decode SAML response: {}", e))
            })?;

        let saml_xml = String::from_utf8(decoded_response).map_err(|e| {
            leptos::ServerFnError::new(format!("Invalid UTF-8 in SAML response: {}", e))
        })?;

        // Create SAML manager and parse response
        let base_url = std::env::var("BASE_URL")
            .expect("BASE_URL environment variable must be set for SAML functionality");
        let saml_manager = saml_database::SamlManager::new(&base_url).map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to create SAML manager: {}", e))
        })?;

        let parsed_response = saml_manager
            .parse_saml_response(&saml_xml, &institution_id)
            .map_err(|e| {
                leptos::ServerFnError::new(format!("Failed to parse SAML response: {}", e))
            })?;

        // Provision or get existing user
        let user =
            saml_database::provision_saml_user(&pool, &parsed_response, &institution_id).await?;

        // Create session
        let session_token = crate::app::db::user_database::create_session(&pool, user.id)
            .await
            .map_err(|e| {
                leptos::ServerFnError::new(format!("Failed to create session: {}", e))
            })?;

        // Set session cookie
        let response = expect_context::<ResponseOptions>();
        let session_cookie = format!(
            "session={}; Path=/; HttpOnly; SameSite=Strict; Max-Age=604800{}",
            session_token,
            if cfg!(debug_assertions) {
                ""
            } else {
                "; Secure"
            }
        );

        response.insert_header(
            header::SET_COOKIE,
            header::HeaderValue::from_str(&session_cookie).expect("Failed to create header value"),
        );

        // Clear institution cookie
        let clear_institution_cookie = format!(
            "saml_institution=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0{}",
            if cfg!(debug_assertions) {
                ""
            } else {
                "; Secure"
            }
        );

        response.insert_header(
            header::SET_COOKIE,
            header::HeaderValue::from_str(&clear_institution_cookie)
                .expect("Failed to create header value"),
        );

        // Convert to SessionUser (only include fields that exist in SessionUser)
        let session_user = SessionUser {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role,
            display_name: user.display_name,
            first_name: user.first_name,
            last_name: user.last_name,
        };

        Ok(SamlAuthResponse {
            success: true,
            message: "SAML login successful".to_string(),
            redirect_url: relay_state.or_else(|| Some("/dashboard".to_string())),
            user: Some(session_user),
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Initiate SAML logout
#[server]
pub async fn initiate_saml_logout() -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        let req = extract::<HttpRequest>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract request: {}", e))
        })?;

        // Get current session
        let cookies = req.cookies().map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to get cookies: {}", e))
        })?;
        let session_token = cookies
            .iter()
            .find(|c| c.name() == "session")
            .map(|c| c.value())
            .ok_or_else(|| leptos::ServerFnError::new("No active session found"))?;

        // Validate session and get user
        let user = crate::app::db::user_database::validate_session(&pool, session_token)
            .await
            .map_err(|e| {
                leptos::ServerFnError::new(format!("Failed to validate session: {}", e))
            })?
            .ok_or_else(|| leptos::ServerFnError::new("Invalid session"))?;

        // Check if user has SAML mapping to determine logout URL
        let saml_mapping = sqlx::query(
            "SELECT institution_id, saml_name_id FROM saml_user_mappings WHERE user_id = $1 LIMIT 1"
        )
        .bind(user.id)
        .fetch_optional(&**pool)
        .await
        .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

        if let Some(mapping) = saml_mapping {
            let institution_id: String = mapping.get("institution_id");
            let saml_name_id: String = mapping.get("saml_name_id");

            // Get SAML config
            if let Some(config) = saml_database::get_saml_config(&pool, &institution_id).await? {
                if let Some(slo_url) = config.slo_url {
                    // Generate SAML logout request
                    let base_url = std::env::var("BASE_URL")
                        .expect("BASE_URL environment variable must be set for SAML functionality");
                    let saml_manager = saml_database::SamlManager::new(&base_url).map_err(|e| {
                        leptos::ServerFnError::new(format!(
                            "Failed to create SAML manager: {}",
                            e
                        ))
                    })?;

                    let logout_request = saml_manager
                        .generate_logout_request(&saml_name_id, None)
                        .map_err(|e| {
                            leptos::ServerFnError::new(format!(
                                "Failed to generate logout request: {}",
                                e
                            ))
                        })?;

                    // Create logout URL
                    let mut logout_url = Url::parse(&slo_url).map_err(|e| {
                        leptos::ServerFnError::new(format!("Invalid SLO URL: {}", e))
                    })?;
                    logout_url
                        .query_pairs_mut()
                        .append_pair("SAMLRequest", &logout_request);

                    // Delete local session
                    let _ =
                        crate::app::db::user_database::delete_session(&pool, session_token).await;

                    // Clear session cookie
                    let response = expect_context::<ResponseOptions>();
                    let clear_cookie = format!(
                        "session=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0{}",
                        if cfg!(debug_assertions) {
                            ""
                        } else {
                            "; Secure"
                        }
                    );

                    response.insert_header(
                        header::SET_COOKIE,
                        header::HeaderValue::from_str(&clear_cookie)
                            .expect("Failed to create header value"),
                    );

                    return Ok(SamlAuthResponse {
                        success: true,
                        message: "Redirecting to SAML logout".to_string(),
                        redirect_url: Some(logout_url.to_string()),
                        user: None,
                    });
                }
            }
        }

        // Fallback to local logout if no SAML SLO configured
        let _ = crate::app::db::user_database::delete_session(&pool, session_token).await;

        let response = expect_context::<ResponseOptions>();
        let clear_cookie = format!(
            "session=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0{}",
            if cfg!(debug_assertions) {
                ""
            } else {
                "; Secure"
            }
        );

        response.insert_header(
            header::SET_COOKIE,
            header::HeaderValue::from_str(&clear_cookie).expect("Failed to create header value"),
        );

        Ok(SamlAuthResponse {
            success: true,
            message: "Local logout successful".to_string(),
            redirect_url: Some("/login".to_string()),
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Admin function to create SAML config
#[server]
pub async fn create_saml_config(
    institution_name: String,
    entity_id: String,
    sso_url: String,
    slo_url: Option<String>,
    x509_cert: String,
    metadata_url: Option<String>,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use chrono::Utc;
        use leptos_actix::extract;
        use std::collections::HashMap;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config = SamlConfig {
            id: Uuid::new_v4(),
            institution_name: institution_name.clone(),
            entity_id,
            sso_url,
            slo_url,
            x509_cert,
            metadata_url,
            active: true,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            attribute_mapping: HashMap::new(),
            role_mapping: HashMap::new(),
            auto_provision: true,
            require_encrypted_assertions: false,
        };

        saml_database::create_saml_config(&pool, &config).await?;

        Ok(SamlAuthResponse {
            success: true,
            message: format!("SAML configuration created for {}", institution_name),
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Update existing SAML config
#[server]
pub async fn update_saml_config(
    config_id: String,
    institution_name: String,
    entity_id: String,
    sso_url: String,
    slo_url: Option<String>,
    x509_cert: String,
    metadata_url: Option<String>,
    active: bool,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config_uuid = Uuid::parse_str(&config_id)
            .map_err(|_| leptos::ServerFnError::new("Invalid config ID format"))?;

        saml_database::update_saml_config(
            &pool,
            config_uuid,
            &institution_name,
            &entity_id,
            &sso_url,
            slo_url.as_deref(),
            &x509_cert,
            metadata_url.as_deref(),
            active,
        )
        .await?;

        Ok(SamlAuthResponse {
            success: true,
            message: format!("SAML configuration updated for {}", institution_name),
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Delete SAML config
#[server]
pub async fn delete_saml_config(
    config_id: String,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config_uuid = Uuid::parse_str(&config_id)
            .map_err(|_| leptos::ServerFnError::new("Invalid config ID format"))?;

        let institution_name = saml_database::delete_saml_config(&pool, config_uuid).await?;

        Ok(SamlAuthResponse {
            success: true,
            message: format!("SAML configuration deleted for {}", institution_name),
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Toggle SAML config active status
#[server]
pub async fn toggle_saml_config(
    config_id: String,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config_uuid = Uuid::parse_str(&config_id)
            .map_err(|_| leptos::ServerFnError::new("Invalid config ID format"))?;

        let (institution_name, new_status) =
            saml_database::toggle_saml_config_status(&pool, config_uuid).await?;

        Ok(SamlAuthResponse {
            success: true,
            message: format!(
                "SAML configuration for {} is now {}",
                institution_name,
                if new_status { "active" } else { "inactive" }
            ),
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Get detailed SAML config (for editing)
#[server]
pub async fn get_saml_config_details(
    config_id: String,
) -> Result<SamlConfig, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config_uuid = Uuid::parse_str(&config_id)
            .map_err(|_| leptos::ServerFnError::new("Invalid config ID format"))?;

        let config = saml_database::get_saml_config_by_id(&pool, config_uuid)
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("SAML configuration not found"))?;

        Ok(config)
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Test SAML configuration
#[server]
pub async fn test_saml_config(
    config_id: String,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let config_uuid = Uuid::parse_str(&config_id)
            .map_err(|_| leptos::ServerFnError::new("Invalid config ID format"))?;

        let config = saml_database::get_saml_config_by_id(&pool, config_uuid)
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("SAML configuration not found"))?;

        // Test the configuration by trying to create a SAML manager and generate a test request
        let base_url = std::env::var("BASE_URL")
            .expect("BASE_URL environment variable must be set for SAML functionality");
        let saml_manager = saml_database::SamlManager::new(&base_url).map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to create SAML manager: {}", e))
        })?;

        // Try to validate the certificate format
        if config.x509_cert.trim().is_empty() {
            return Ok(SamlAuthResponse {
                success: false,
                message: "X.509 certificate is required".to_string(),
                redirect_url: None,
                user: None,
            });
        }

        // Test URL connectivity (basic validation)
        if !config.sso_url.starts_with("http") {
            return Ok(SamlAuthResponse {
                success: false,
                message: "SSO URL must be a valid HTTP/HTTPS URL".to_string(),
                redirect_url: None,
                user: None,
            });
        }

        Ok(SamlAuthResponse {
            success: true,
            message: format!(
                "SAML configuration for {} appears to be valid",
                config.institution_name
            ),
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Get SAML statistics
#[server]
pub async fn get_saml_stats() -> Result<SamlStats, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let stats = saml_database::get_saml_statistics(&pool).await?;
        Ok(stats)
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlStats {
    pub total_institutions: i64,
    pub active_institutions: i64,
    pub total_saml_users: i64,
    pub recent_logins: i64, // Last 30 days
}

// Import metadata from URL
#[server]
pub async fn import_saml_metadata(
    metadata_url: String,
    institution_name: String,
) -> Result<SamlMetadataResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        // Validate URL
        if !metadata_url.starts_with("http") {
            return Err(leptos::ServerFnError::new(
                "Metadata URL must be a valid HTTP/HTTPS URL",
            ));
        }

        let metadata = saml_database::fetch_and_parse_metadata(&metadata_url).await?;

        Ok(SamlMetadataResponse {
            success: true,
            message: "Metadata imported successfully".to_string(),
            entity_id: metadata.entity_id,
            sso_url: metadata.sso_url,
            slo_url: metadata.slo_url,
            x509_cert: metadata.x509_cert,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlMetadataResponse {
    pub success: bool,
    pub message: String,
    pub entity_id: String,
    pub sso_url: String,
    pub slo_url: Option<String>,
    pub x509_cert: String,
}

#[server]
pub async fn get_detailed_saml_institutions(
) -> Result<Vec<SamlInstitutionDetail>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let configs = saml_database::get_all_saml_configs_detailed(&pool).await?;

        let institutions = configs
            .into_iter()
            .map(|config| SamlInstitutionDetail {
                id: config.id.to_string(),
                name: config.institution_name,
                entity_id: config.entity_id,
                active: config.active,
                created_at: config.created_at,
                sso_url: config.sso_url,
                has_slo: config.slo_url.is_some(),
                has_metadata_url: config.metadata_url.is_some(),
            })
            .collect();

        Ok(institutions)
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlInstitutionDetail {
    pub id: String,
    pub name: String,
    pub entity_id: String,
    pub active: bool,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub sso_url: String,
    pub has_slo: bool,
    pub has_metadata_url: bool,
}

// Add a bulk operations function for admin convenience
#[server]
pub async fn bulk_toggle_saml_configs(
    config_ids: Vec<String>,
    enable: bool,
) -> Result<SamlAuthResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use uuid::Uuid;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let mut updated_count = 0;
        let mut errors = Vec::new();

        for config_id in config_ids {
            match Uuid::parse_str(&config_id) {
                Ok(uuid) => {
                    match saml_database::update_saml_config_status(&pool, uuid, enable).await {
                        Ok(_) => updated_count += 1,
                        Err(e) => errors.push(format!("Failed to update {}: {}", config_id, e)),
                    }
                }
                Err(_) => errors.push(format!("Invalid UUID format: {}", config_id)),
            }
        }

        let message = if errors.is_empty() {
            format!(
                "Successfully {} {} SAML configuration(s)",
                if enable { "enabled" } else { "disabled" },
                updated_count
            )
        } else {
            format!(
                "Updated {} configurations with {} errors: {}",
                updated_count,
                errors.len(),
                errors.join(", ")
            )
        };

        Ok(SamlAuthResponse {
            success: errors.is_empty(),
            message,
            redirect_url: None,
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

// Add validation function for SAML configurations
#[server]
pub async fn validate_saml_config(
    entity_id: String,
    sso_url: String,
    slo_url: Option<String>,
    x509_cert: String,
    metadata_url: Option<String>,
) -> Result<SamlValidationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        // Verify admin permissions
        let current_user = crate::app::server_functions::auth::get_current_user()
            .await?
            .ok_or_else(|| leptos::ServerFnError::new("Authentication required"))?;

        if !matches!(current_user.role, UserRole::Admin | UserRole::SuperAdmin) {
            return Err(leptos::ServerFnError::new(
                "Admin privileges required",
            ));
        }

        let mut validation_errors = Vec::new();
        let mut warnings = Vec::new();

        // Validate URLs
        if !sso_url.starts_with("https://") && !sso_url.starts_with("http://") {
            validation_errors.push("SSO URL must be a valid HTTP/HTTPS URL".to_string());
        }

        if sso_url.starts_with("http://") && !sso_url.contains("localhost") {
            warnings.push(
                "Using HTTP instead of HTTPS for SSO URL is not recommended for production"
                    .to_string(),
            );
        }

        if let Some(ref slo_url) = slo_url {
            if !slo_url.starts_with("https://") && !slo_url.starts_with("http://") {
                validation_errors.push("SLO URL must be a valid HTTP/HTTPS URL".to_string());
            }
        }

        if let Some(ref metadata_url) = metadata_url {
            if !metadata_url.starts_with("https://") && !metadata_url.starts_with("http://") {
                validation_errors.push("Metadata URL must be a valid HTTP/HTTPS URL".to_string());
            }
        }

        // Validate certificate format
        if !x509_cert.contains("-----BEGIN CERTIFICATE-----")
            || !x509_cert.contains("-----END CERTIFICATE-----")
        {
            validation_errors.push("X.509 certificate must be in PEM format".to_string());
        }

        // Validate entity ID format
        if entity_id.trim().is_empty() {
            validation_errors.push("Entity ID cannot be empty".to_string());
        }

        // Additional checks
        if entity_id.len() > 512 {
            validation_errors.push("Entity ID is too long (max 512 characters)".to_string());
        }

        if sso_url.len() > 2048 {
            validation_errors.push("SSO URL is too long (max 2048 characters)".to_string());
        }

        let is_valid = validation_errors.is_empty();

        Ok(SamlValidationResponse {
            valid: is_valid,
            errors: validation_errors,
            warnings,
            message: if is_valid {
                "Configuration is valid".to_string()
            } else {
                "Configuration has validation errors".to_string()
            },
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError(
            "Not implemented".to_string(),
        ))
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SamlValidationResponse {
    pub valid: bool,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
    pub message: String,
}
use crate::app::models::websocket_session::{
    CreateSessionRequest, Session, SessionStatus, SessionSummary, SessionType,
};
use chrono::{DateTime, Utc};
use leptos::prelude::*;
use uuid::Uuid;

#[cfg(feature = "ssr")]
use {
    crate::app::db::websocket_session_database, actix_web::web, leptos_actix::extract,
    sqlx::PgPool, std::error::Error,
};

#[server]
pub async fn list_active_sessions() -> Result<Vec<SessionSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Retrieving active sessions from database");

        // First, clean up any expired sessions
        if let Err(e) = websocket_session_database::cleanup_inactive_sessions(&pool).await {
            log::warn!("Failed to clean up inactive sessions: {}", e);
        }

        // Then get active sessions
        let sessions = websocket_session_database::get_active_sessions(&pool).await?;

        // Convert to summary objects that are safer to send to the client
        let summaries = sessions.into_iter().map(SessionSummary::from).collect();

        Ok(summaries)
    }
}

#[server]
pub async fn get_active_test_sessions() -> Result<Vec<SessionSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Retrieving active test sessions from database");

        let sessions = websocket_session_database::get_active_test_sessions(&pool).await?;

        let summaries = sessions.into_iter().map(SessionSummary::from).collect();

        Ok(summaries)
    }
}

#[server]
pub async fn get_session(session_id: String) -> Result<Option<SessionSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("Retrieving session with ID: {}", uuid);

        let session = websocket_session_database::get_session(uuid, &pool).await?;

        Ok(session.map(SessionSummary::from))
    }
}

#[server]
pub async fn get_test_sessions_by_test_id(
    test_id: String,
) -> Result<Vec<SessionSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Retrieving test sessions for test ID: {}", test_id);

        let sessions = websocket_session_database::get_sessions_by_test_id(&test_id, &pool).await?;

        let summaries = sessions.into_iter().map(SessionSummary::from).collect();

        Ok(summaries)
    }
}

#[server]
pub async fn create_session(
    request: CreateSessionRequest,
) -> Result<SessionSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Creating new session with name: {}", request.name);

        // If this is a test session, check if teacher already has an active session
        if let (Some(SessionType::Test), Some(teacher_id)) =
            (&request.session_type, request.teacher_id)
        {
            if let Some(existing_session) =
                websocket_session_database::get_teacher_active_session(teacher_id, &pool).await?
            {
                log::warn!(
                    "Teacher {} already has active session: {}",
                    teacher_id,
                    existing_session.id
                );
                return Err(ServerFnError::new(
                    "Teacher already has an active test session",
                ));
            }
        }

        let session_type = request.session_type.unwrap_or(SessionType::Chat);

        let mut session = Session::new(
            request.name,
            request.description,
            request.teacher_id, // Add teacher_id here
            session_type,
            request.test_id,
        );

        // Set optional fields
        if let Some(max_users) = request.max_users {
            session.max_users = max_users;
        }

        if let Some(is_private) = request.is_private {
            session.is_private = is_private;
        }

        if let Some(password) = &request.password {
            session.password_required = true;
            // In a real app, you would hash the password here
        }

        if let Some(metadata) = request.metadata {
            session.metadata = Some(metadata);
        }

        let created_session = websocket_session_database::create_session(&session, &pool).await?;

        Ok(SessionSummary::from(created_session))
    }
}

#[server]
pub async fn start_test_session(
    session_id: String,
    scheduled_end_time: Option<DateTime<Utc>>,
) -> Result<SessionSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("Starting test session: {}", uuid);

        let session_opt = websocket_session_database::get_session(uuid, &pool).await?;

        if let Some(mut session) = session_opt {
            if session.session_type != SessionType::Test {
                return Err(ServerFnError::new("Session is not a test session"));
            }

            let start_time = Utc::now();
            session.start_time = Some(start_time);
            session.end_time = scheduled_end_time;

            let updated_session = websocket_session_database::update_test_session_times(
                uuid,
                Some(start_time),
                scheduled_end_time,
                &pool,
            )
            .await?;

            Ok(SessionSummary::from(updated_session))
        } else {
            Err(ServerFnError::new("Session not found"))
        }
    }
}

#[server]
pub async fn join_session(
    session_id: String,
    password: Option<String>,
) -> Result<bool, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("User attempting to join session: {}", uuid);

        // Get the session to check if it exists and if it requires a password
        let session_opt = websocket_session_database::get_session(uuid, &pool).await?;

        match session_opt {
            Some(session) => {
                // Check if session is full
                if session.max_users > 0 && session.current_users >= session.max_users {
                    return Err(ServerFnError::new("Session is full"));
                }

                // Check if session requires password
                if session.password_required {
                    // In a real app, you would verify the password hash here
                    if password.is_none() {
                        return Err(ServerFnError::new("Password required for this session"));
                    }

                    // Simple example - in a real app you would compare hashed passwords
                    // if password.unwrap() != "correct_password" {
                    //     return Err(ServerFnError::new("Incorrect password"));
                    // }
                }

                // Increment user count
                websocket_session_database::update_session_user_count(uuid, true, &pool).await?;

                Ok(true)
            }
            None => Err(ServerFnError::new("Session not found")),
        }
    }
}

#[server]
pub async fn leave_session(session_id: String) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("User leaving session: {}", uuid);

        websocket_session_database::update_session_user_count(uuid, false, &pool).await?;

        Ok(())
    }
}

#[server]
pub async fn end_test_session(session_id: String) -> Result<SessionSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid Uuid {}", e)))?;

        log::info!("Ending test session: {}", uuid);

        let session_opt = websocket_session_database::get_session(uuid, &pool).await?;

        if let Some(session) = session_opt {
            if session.session_type != SessionType::Test {
                return Err(ServerFnError::new("Session is not a test session"));
            }

            let end_time = Utc::now();

            let updated_session = websocket_session_database::update_test_session_times(
                uuid,
                session.start_time,
                Some(end_time),
                &pool,
            )
            .await?;

            websocket_session_database::update_session_status(uuid, SessionStatus::Inactive, &pool)
                .await?;

            Ok(SessionSummary::from(updated_session))
        } else {
            Err(ServerFnError::new("Session not found"))
        }
    }
}

#[server]
pub async fn close_session(session_id: String) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("Closing session: {}", uuid);

        websocket_session_database::update_session_status(uuid, SessionStatus::Inactive, &pool)
            .await?;

        Ok(())
    }
}

#[server]
pub async fn check_teacher_access(test_id: String, teacher_id: i32) -> Result<bool, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!(
            "Checking teacher access for test_id: {}, teacher_id: {}",
            test_id,
            teacher_id
        );

        // FIRST: Run cleanup to remove any stale sessions
        if let Err(e) = websocket_session_database::cleanup_inactive_sessions(&pool).await {
            log::warn!(
                "Failed to clean up inactive sessions during access check: {}",
                e
            );
        }

        // SECOND: Use enhanced access check
        match websocket_session_database::check_teacher_test_access(&test_id, teacher_id, &pool)
            .await
        {
            Ok(can_access) => {
                if can_access {
                    log::info!("Teacher {} granted access to test {}", teacher_id, test_id);
                } else {
                    log::warn!(
                        "Teacher {} denied access to test {} - another teacher is active",
                        teacher_id,
                        test_id
                    );
                }
                Ok(can_access)
            }
            Err(e) => {
                log::error!("Error checking teacher access: {}", e);
                Err(e)
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Ok(true)
    }
}

#[server]
pub async fn assign_teacher_to_session(
    session_id: String,
    teacher_id: i32,
) -> Result<SessionSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("Assigning teacher {} to session {}", teacher_id, uuid);

        let updated_session =
            websocket_session_database::assign_teacher_to_session(uuid, teacher_id, &pool).await?;

        Ok(SessionSummary::from(updated_session))
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new("Server-side only function"))
    }
}

#[server]
pub async fn get_teacher_active_session(
    teacher_id: i32,
) -> Result<Option<SessionSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Getting active session for teacher: {}", teacher_id);

        let session_opt =
            websocket_session_database::get_teacher_active_session(teacher_id, &pool).await?;

        Ok(session_opt.map(SessionSummary::from))
    }

    #[cfg(not(feature = "ssr"))]
    {
        Ok(None)
    }
}

#[server]
pub async fn release_teacher_from_session(session_id: String) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let uuid = Uuid::parse_str(&session_id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        log::info!("Releasing teacher from session: {}", uuid);

        websocket_session_database::release_teacher_from_session(uuid, &pool).await?;

        Ok(())
    }

    #[cfg(not(feature = "ssr"))]
    {
        Ok(())
    }
}

#[server]
pub async fn cleanup_teacher_session_endpoint(teacher_id: i32) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!(
            "API endpoint: Cleaning up session for teacher: {}",
            teacher_id
        );

        // Use enhanced cleanup function
        websocket_session_database::cleanup_teacher_session(teacher_id, &pool).await?;

        Ok(())
    }

    #[cfg(not(feature = "ssr"))]
    {
        Ok(())
    }
}

#[server]
pub async fn create_or_join_session(
    request: CreateSessionRequest,
) -> Result<SessionSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        // Clean up stale sessions first
        if let Err(e) = websocket_session_database::cleanup_inactive_sessions(&pool).await {
            log::warn!("Failed to clean up inactive sessions: {}", e);
        }

        // If teacher_id is provided, check for existing active session
        if let Some(teacher_id) = request.teacher_id {
            if let Some(existing_session) =
                websocket_session_database::get_teacher_active_session(teacher_id, &pool).await?
            {
                // If session is for the same test, reuse it
                if existing_session.test_id == request.test_id {
                    log::info!(
                        "Reusing existing session {} for teacher {}",
                        existing_session.id,
                        teacher_id
                    );
                    return Ok(SessionSummary::from(existing_session));
                } else {
                    // Different test - cleanup old session and create new one
                    log::info!(
                        "Teacher {} switching tests, cleaning up old session",
                        teacher_id
                    );
                    websocket_session_database::cleanup_teacher_session(teacher_id, &pool).await?;
                }
            }
        }

        // Check for existing session for this test that can be reused
        if let Some(test_id) = &request.test_id {
            let existing_sessions =
                websocket_session_database::get_sessions_by_test_id(test_id, &pool).await?;

            // Look for a recent session that can be reused
            for session in existing_sessions {
                let now = chrono::Utc::now();
                let recent_threshold = now - chrono::Duration::minutes(5);

                if session.last_active > recent_threshold
                    && session.start_time.is_none()
                    && session.end_time.is_none()
                    && session.teacher_id.is_none()
                // No teacher assigned
                {
                    // Assign teacher to this session
                    if let Some(teacher_id) = request.teacher_id {
                        let updated_session =
                            websocket_session_database::assign_teacher_to_session(
                                session.id, teacher_id, &pool,
                            )
                            .await?;
                        log::info!(
                            "Assigned teacher {} to existing session {}",
                            teacher_id,
                            session.id
                        );
                        return Ok(SessionSummary::from(updated_session));
                    } else {
                        log::info!(
                            "Reusing existing session {} without teacher assignment",
                            session.id
                        );
                        return Ok(SessionSummary::from(session));
                    }
                }
            }
        }

        // Create new session
        let session_type = request.session_type.unwrap_or(SessionType::Chat);
        let mut session = Session::new(
            request.name,
            request.description,
            request.teacher_id,
            session_type,
            request.test_id,
        );

        // Set optional fields
        if let Some(max_users) = request.max_users {
            session.max_users = max_users;
        }
        if let Some(is_private) = request.is_private {
            session.is_private = is_private;
        }
        if let Some(password) = &request.password {
            session.password_required = true;
        }
        if let Some(metadata) = request.metadata {
            session.metadata = Some(metadata);
        }

        let created_session = websocket_session_database::create_session(&session, &pool).await?;
        log::info!(
            "Created new session {} for teacher {:?}",
            created_session.id,
            request.teacher_id
        );

        Ok(SessionSummary::from(created_session))
    }
}
use crate::app::models::bulk_enrollment::EnrollmentCsvRow;
use crate::app::models::enrollment::{AcademicYear, Enrollment, EnrollmentStatus};
use crate::app::models::student::GradeEnum;
use chrono::{NaiveDate, Utc};
use csv::ReaderBuilder;
use leptos::prelude::*;
use std::str::FromStr;
use validator::Validate;

#[cfg(feature = "ssr")]
use {crate::app::db::enrollment_database, sqlx::PgPool};

#[server]
pub async fn upload_bulk_enrollment(file_contents: String) -> Result<usize, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        // Parse and validate all rows in the CSV file
        let enrollments = parse_and_validate_enrollments(&file_contents)?;

        // Bulk insert using optimized method
        match enrollment_database::bulk_insert_enrollments(&pool, &enrollments).await {
            Ok(count) => {
                log::info!("Successfully imported {} enrollments", count);
                Ok(count)
            }
            Err(e) => {
                log::error!("Failed to insert enrollments: {}", e);
                Err(ServerFnError::ServerError(format!("Import failed: {}", e)))
            }
        }
    }
    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError(
            "Server-side rendering is not enabled".to_string(),
        ))
    }
}

// Separate parsing logic for reusability and better error handling
fn parse_and_validate_enrollments(file_contents: &str) -> Result<Vec<Enrollment>, ServerFnError> {
    let mut rdr = ReaderBuilder::new()
        .has_headers(true)
        .flexible(true) // Allow varying number of fields
        .trim(csv::Trim::All) // Trim whitespace from all fields
        .from_reader(file_contents.as_bytes());

    let mut enrollments = Vec::new();
    let mut errors = Vec::new();

    // Get current date for defaults
    let current_date = Utc::now().date_naive();

    // Log headers for debugging
    let headers = rdr
        .headers()
        .map_err(|e| ServerFnError::new(format!("Failed to read CSV headers: {}", e)))?;
    log::info!("Enrollment CSV Headers: {:?}", headers);

    for (row_num, result) in rdr.records().enumerate() {
        match result {
            Ok(record) => {
                match record.deserialize::<EnrollmentCsvRow>(None) {
                    Ok(csv_row) => {
                        match parse_enrollment_record(csv_row, row_num + 2, current_date) {
                            // +2 for header and 1-based indexing
                            Ok(enrollment) => enrollments.push(enrollment),
                            Err(e) => errors.push(e),
                        }
                    }
                    Err(e) => {
                        errors.push(format!(
                            "Row {}: Failed to deserialize CSV row: {}",
                            row_num + 2,
                            e
                        ));
                    }
                }
            }
            Err(e) => {
                errors.push(format!("Row {}: CSV parsing error: {}", row_num + 2, e));
            }
        }
    }

    if !errors.is_empty() {
        let error_msg = format!("Validation errors:\n{}", errors.join("\n"));
        log::error!("{}", error_msg);
        return Err(ServerFnError::new(error_msg));
    }

    // Validate all enrollments
    for (index, enrollment) in enrollments.iter().enumerate() {
        if let Err(validation_errors) = enrollment.validate() {
            let error_msg = format!(
                "Validation failed for enrollment student_id {} (row {}): {:?}",
                enrollment.student_id,
                index + 2,
                validation_errors
            );
            log::error!("{}", error_msg);
            return Err(ServerFnError::new(error_msg));
        }
    }

    log::info!(
        "Successfully parsed and validated {} enrollments",
        enrollments.len()
    );
    Ok(enrollments)
}

fn parse_enrollment_record(
    record: EnrollmentCsvRow,
    row_num: usize,
    current_date: NaiveDate,
) -> Result<Enrollment, String> {
    // Parse and validate academic year
    let academic_year = AcademicYear::from_str(&record.academic_year.trim()).map_err(|e| {
        format!(
            "Row {}: Invalid academic year '{}': {}. Expected format like '2024-2025'",
            row_num, record.academic_year, e
        )
    })?;

    // Parse and validate grade level
    let grade_level = GradeEnum::from_str(&record.grade_level.trim()).map_err(|e| {
        format!(
            "Row {}: Invalid grade level '{}': {}. Valid values: Kindergarten, 1st Grade, 2nd Grade, etc.",
            row_num, record.grade_level, e
        )
    })?;

    // Validate student_id
    if record.student_id < 0 || record.student_id > 2000000000 {
        return Err(format!(
            "Row {}: Student ID {} is out of valid range (0-2000000000)",
            row_num, record.student_id
        ));
    }

    // Validate teacher_id - IMPORTANT: This uses teacher_id (integer) not teacher name
    // This reflects the decoupled architecture where enrollments use formal teacher IDs
    if record.teacher_id < 1 {
        return Err(format!(
            "Row {}: Teacher ID {} is invalid (must be positive integer)",
            row_num, record.teacher_id
        ));
    }

    // For bulk uploads, status is always "Active" - ignore CSV status field
    let status = EnrollmentStatus::Active;

    // For bulk uploads, enrollment_date is always current date - ignore CSV field
    let enrollment_date = current_date;

    // For bulk uploads, status_change_date defaults to current date - ignore CSV field
    let status_change_date = Some(current_date);

    // Handle notes field
    let notes = if record.notes.trim().is_empty() {
        None
    } else {
        Some(record.notes.trim().to_string())
    };

    Ok(Enrollment {
        student_id: record.student_id,
        academic_year,
        grade_level,
        teacher_id: record.teacher_id, // Using teacher_id (integer) for formal enrollment
        status,
        enrollment_date,
        status_change_date,
        notes,
    })
}

// Helper function to validate that a teacher_id exists in the teachers table
#[cfg(feature = "ssr")]
pub async fn validate_teacher_exists(
    teacher_id: i32,
    pool: &sqlx::PgPool,
) -> Result<bool, ServerFnError> {
    use sqlx::Row;

    let row = sqlx::query(
        "SELECT EXISTS(SELECT 1 FROM employees WHERE id = $1 AND role LIKE '%Teacher%')",
    )
    .bind(teacher_id)
    .fetch_one(pool)
    .await
    .map_err(|e| ServerFnError::new(format!("Database error checking teacher: {}", e)))?;

    let exists: bool = row.get("exists");
    Ok(exists)
}

// Enhanced version with teacher validation
#[server]
pub async fn upload_bulk_enrollment_with_validation(
    file_contents: String,
) -> Result<usize, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        // Parse and validate all rows in the CSV file
        let enrollments = parse_and_validate_enrollments(&file_contents)?;

        // Additional validation: Check that all teacher_ids exist
        let mut validation_errors = Vec::new();
        for enrollment in &enrollments {
            match validate_teacher_exists(enrollment.teacher_id, &pool).await {
                Ok(exists) => {
                    if !exists {
                        validation_errors.push(format!(
                            "Teacher ID {} does not exist or is not a teacher",
                            enrollment.teacher_id
                        ));
                    }
                }
                Err(e) => {
                    validation_errors.push(format!(
                        "Failed to validate teacher ID {}: {}",
                        enrollment.teacher_id, e
                    ));
                }
            }
        }

        if !validation_errors.is_empty() {
            let error_msg = format!(
                "Teacher validation errors:\n{}",
                validation_errors.join("\n")
            );
            log::error!("{}", error_msg);
            return Err(ServerFnError::new(error_msg));
        }

        // Bulk insert using optimized method
        match enrollment_database::bulk_insert_enrollments(&pool, &enrollments).await {
            Ok(count) => {
                log::info!(
                    "Successfully imported {} enrollments with teacher validation",
                    count
                );
                Ok(count)
            }
            Err(e) => {
                log::error!("Failed to insert enrollments: {}", e);
                Err(ServerFnError::ServerError(format!("Import failed: {}", e)))
            }
        }
    }
    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError(
            "Server-side rendering is not enabled".to_string(),
        ))
    }
}
use crate::app::components::data_processing::student_results_summary::StudentResultsSummary;
use leptos::prelude::*;
use std::collections::HashMap;

#[server]
pub async fn get_student_results_server(
    student_id: i32,
) -> Result<StudentResultsSummary, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::components::data_processing::student_results_summary::get_student_results;

        get_student_results(student_id)
            .await
            .map_err(|e| ServerFnError::new(format!("There was an issue compiling and processing data for the designated student. Error: {}", e)))
    }
    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::new(String::from(
            "SSR function called on the client",
        )))
    }
}

#[server]
pub async fn get_student_results_batch(
    student_ids: Vec<i32>,
) -> Result<HashMap<i32, StudentResultsSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::components::data_processing::student_results_summary::get_student_results;

        let mut results_map: HashMap<i32, StudentResultsSummary> =
            HashMap::with_capacity(student_ids.len());

        // OPTIMIZATION 1: Process in smaller concurrent batches for better memory usage
        const CHUNK_SIZE: usize = 8; // Reduced from 30 to 8 for better concurrency

        for chunk in student_ids.chunks(CHUNK_SIZE) {
            // Create futures for concurrent processing
            let mut futures = Vec::with_capacity(chunk.len());

            for &student_id in chunk {
                futures.push(get_student_results(student_id));
            }

            // OPTIMIZATION 2: Process chunk concurrently
            let chunk_results = futures::future::join_all(futures).await;

            // OPTIMIZATION 3: Process results efficiently
            for (i, result) in chunk_results.into_iter().enumerate() {
                let student_id = chunk[i];
                match result {
                    Ok(student_result) => {
                        results_map.insert(student_id, student_result);
                    }
                    Err(e) => {
                        log::error!("Failed to fetch result for student {}: {}", student_id, e);
                        // Continue processing other students instead of failing the entire batch
                    }
                }
            }

            // OPTIMIZATION 4: Add a small delay between chunks to prevent overwhelming the database
            if student_ids.len() > CHUNK_SIZE {
                tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            }
        }

        Ok(results_map)
    }
}

// OPTIMIZATION 5: Add a new endpoint for streaming large datasets
#[server]
pub async fn get_student_results_stream(
    offset: usize,
    limit: usize,
) -> Result<(Vec<StudentResultsSummary>, bool), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::students::get_students;

        // Get all students first
        let all_students = get_students().await?;

        // Apply pagination
        let students_slice = if offset >= all_students.len() {
            Vec::new()
        } else {
            let end = std::cmp::min(offset + limit, all_students.len());
            all_students[offset..end].to_vec()
        };

        let has_more = offset + limit < all_students.len();

        if students_slice.is_empty() {
            return Ok((Vec::new(), false));
        }

        // Get student IDs for batch processing
        let student_ids: Vec<i32> = students_slice.iter().map(|s| s.student_id).collect();

        // Use the optimized batch function
        let results_map = get_student_results_batch(student_ids).await?;

        // Convert back to ordered list
        let results: Vec<StudentResultsSummary> = students_slice
            .into_iter()
            .filter_map(|student| results_map.get(&student.student_id).cloned())
            .collect();

        Ok((results, has_more))
    }
}

// OPTIMIZATION 6: Add caching for frequently accessed data
#[cfg(feature = "ssr")]
pub mod simple_cache {
    use chrono::{DateTime, Duration, Utc};
    use once_cell::sync::Lazy;
    use std::collections::HashMap;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    pub struct CacheEntry<T> {
        pub data: T,
        pub expires_at: DateTime<Utc>,
    }

    impl<T> CacheEntry<T> {
        pub fn new(data: T, ttl_minutes: i64) -> Self {
            Self {
                data,
                expires_at: Utc::now() + Duration::minutes(ttl_minutes),
            }
        }

        pub fn is_expired(&self) -> bool {
            Utc::now() > self.expires_at
        }
    }

    type CacheMap<T> = Arc<RwLock<HashMap<String, CacheEntry<T>>>>;

    // Simple cache instances
    static STUDENT_RESULTS_CACHE: Lazy<
        CacheMap<
            crate::app::components::data_processing::student_results_summary::StudentResultsSummary,
        >,
    > = Lazy::new(|| Arc::new(RwLock::new(HashMap::new())));

    pub async fn get_cached_student_result(
        student_id: i32,
    ) -> Option<
        crate::app::components::data_processing::student_results_summary::StudentResultsSummary,
    > {
        let cache = STUDENT_RESULTS_CACHE.read().await;
        let key = student_id.to_string();

        if let Some(entry) = cache.get(&key) {
            if !entry.is_expired() {
                return Some(entry.data.clone());
            }
        }
        None
    }

    pub async fn cache_student_result(
        student_id: i32,
        result: crate::app::components::data_processing::student_results_summary::StudentResultsSummary,
    ) {
        let mut cache = STUDENT_RESULTS_CACHE.write().await;
        let key = student_id.to_string();
        cache.insert(key, CacheEntry::new(result, 5)); // Cache for 5 minutes
    }

    pub async fn clear_cache() {
        let mut cache = STUDENT_RESULTS_CACHE.write().await;
        cache.clear();
    }
}

// OPTIMIZATION 7: Enhanced batch function with caching
#[server]
pub async fn get_student_results_batch_cached(
    student_ids: Vec<i32>,
) -> Result<HashMap<i32, StudentResultsSummary>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::components::data_processing::student_results_summary::get_student_results;
        use simple_cache::{cache_student_result, get_cached_student_result};

        let mut results_map: HashMap<i32, StudentResultsSummary> =
            HashMap::with_capacity(student_ids.len());
        let mut uncached_ids = Vec::new();

        // OPTIMIZATION: Check cache first
        for &student_id in &student_ids {
            if let Some(cached_result) = get_cached_student_result(student_id).await {
                results_map.insert(student_id, cached_result);
            } else {
                uncached_ids.push(student_id);
            }
        }

        // Process uncached students in batches
        if !uncached_ids.is_empty() {
            const CHUNK_SIZE: usize = 6; // Smaller chunks for cached version

            for chunk in uncached_ids.chunks(CHUNK_SIZE) {
                let mut futures = Vec::with_capacity(chunk.len());

                for &student_id in chunk {
                    futures.push(get_student_results(student_id));
                }

                let chunk_results = futures::future::join_all(futures).await;

                for (i, result) in chunk_results.into_iter().enumerate() {
                    let student_id = chunk[i];
                    match result {
                        Ok(student_result) => {
                            // Cache the result
                            cache_student_result(student_id, student_result.clone()).await;
                            results_map.insert(student_id, student_result);
                        }
                        Err(e) => {
                            log::error!("Failed to fetch result for student {}: {}", student_id, e);
                        }
                    }
                }

                // Small delay between chunks
                if uncached_ids.len() > CHUNK_SIZE {
                    tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
                }
            }
        }

        log::info!(
            "Batch processed {} students: {} from cache, {} fetched",
            student_ids.len(),
            student_ids.len() - uncached_ids.len(),
            uncached_ids.len()
        );

        Ok(results_map)
    }
}
use crate::app::models::course::{Course, CreateCourseRequest, UpdateCourseRequest};
use leptos::prelude::*;
use leptos::prelude::*;

#[cfg(feature = "ssr")]
use {crate::app::db::course_database, actix_web::web, sqlx::PgPool, std::error::Error};

#[server]
pub async fn get_courses() -> Result<Vec<Course>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!("Attempting to retrieve all courses");

        match course_database::get_all_courses(&pool).await {
            Ok(courses) => {
                log::info!("Successfully retrieved {} courses", courses.len());
                Ok(courses)
            }
            Err(e) => {
                log::error!("Error retrieving courses: {}", e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to retrieve courses".into(),
                ))
            }
        }
    }
}

#[server]
pub async fn get_course(course_id: i32) -> Result<Course, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!("Attempting to retrieve course with ID: {}", course_id);

        match course_database::get_course_by_id(&pool, course_id).await {
            Ok(course) => {
                log::info!("Successfully retrieved course with ID: {}", course_id);
                Ok(course)
            }
            Err(e) => {
                log::error!("Error retrieving course with ID {}: {}", course_id, e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to retrieve course".into(),
                ))
            }
        }
    }
}

#[server]
pub async fn get_course_by_code(
    course_code: String,
) -> Result<Course, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!("Attempting to retrieve course with code: {}", course_code);

        match course_database::get_course_by_code(&pool, &course_code).await {
            Ok(course) => {
                log::info!("Successfully retrieved course with code: {}", course_code);
                Ok(course)
            }
            Err(e) => {
                log::error!("Error retrieving course with code {}: {}", course_code, e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to retrieve course".into(),
                ))
            }
        }
    }
}

#[server]
pub async fn add_course(
    add_course_request: CreateCourseRequest,
) -> Result<Course, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!(
            "Attempting to add a new course with code: {}",
            add_course_request.course_code
        );

        match course_database::add_course(&pool, add_course_request).await {
            Ok(course) => {
                log::info!(
                    "Successfully added course with code: {}",
                    course.course_code
                );
                Ok(course)
            }
            Err(e) => {
                log::error!("Error adding course: {}", e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to add course".into(),
                ))
            }
        }
    }
}

#[server]
pub async fn update_course(
    course_id: i32,
    update_course_request: UpdateCourseRequest,
) -> Result<Course, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!("Attempting to update course with ID: {}", course_id);

        match course_database::update_course(&pool, course_id, update_course_request).await {
            Ok(course) => {
                log::info!("Successfully updated course with ID: {}", course_id);
                Ok(course)
            }
            Err(e) => {
                log::error!("Error updating course with ID {}: {}", course_id, e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to update course".into(),
                ))
            }
        }
    }
}

#[server]
pub async fn delete_course(course_id: i32) -> Result<(), leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract database pool: {}", e))
        })?;

        log::info!("Attempting to delete course with ID: {}", course_id);

        match course_database::delete_course(&pool, course_id).await {
            Ok(_) => {
                log::info!("Successfully deleted course with ID: {}", course_id);
                Ok(())
            }
            Err(e) => {
                log::error!("Error deleting course with ID {}: {}", course_id, e);
                Err(leptos::ServerFnError::ServerError(
                    "Failed to delete course".into(),
                ))
            }
        }
    }
}
use leptos::prelude::*;
use crate::app::db::global_database;
use crate::app::models::global::{GlobalSetting, SettingsCache};
use leptos::prelude::*;
#[cfg(feature = "ssr")]
use sqlx::PgPool;
use std::collections::HashMap;
use std::env;

#[server]
pub async fn get_global_setting() -> Result<Vec<GlobalSetting>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match global_database::get_global_settings(&pool).await {
            Ok(settings) => Ok(settings),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to get global settings: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn get_global_settings() -> Result<SettingsCache, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match global_database::get_all_global_settings(&pool).await {
            Ok(settings) => Ok(settings),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to get all global settings: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn get_single_global_setting(
    key: String,
) -> Result<Option<GlobalSetting>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match global_database::get_global_setting(&pool, &key).await {
            Ok(setting) => Ok(setting),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to get global setting: {}",
                e
            ))),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn update_global_setting_api(
    key: String,
    value: serde_json::Value,
) -> Result<bool, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;
        use actix_web::web;
        use leptos_actix::extract;

        // Check if user is authenticated and is admin
        let current_user = get_current_user().await?;
        if let Some(user) = current_user {
            if !user.is_admin() {
                return Err(leptos::ServerFnError::new(
                    "Unauthorized: Admin access required".to_string(),
                ));
            }

            let pool = extract::<web::Data<PgPool>>()
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

            global_database::update_global_setting(&pool, &key, value, user.id.try_into().unwrap())
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(true)
        } else {
            Err(leptos::ServerFnError::new(
                "Unauthorized: Login required".to_string(),
            ))
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn toggle_student_protection(
    enable: bool,
    mapping_key: Option<String>,
) -> Result<String, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;
        use actix_web::web;
        use leptos_actix::extract;
        use std::path::Path;
        use std::process::Command;

        let current_user = get_current_user().await?;
        if let Some(user) = current_user {
            if !user.is_super_admin() {
                return Err(leptos::ServerFnError::new(
                    "Unauthorized: Super admin access required".to_string(),
                ));
            }

            let pool = extract::<web::Data<PgPool>>()
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

            if enable {
                // Check if script file exists
                let script_paths = vec![
                    "./scripts/remove_pii_data.sql",
                    "/app/scripts/remove_pii_data.sql",
                    "scripts/remove_pii_data.sql",
                ];

                let script_path = script_paths
                    .iter()
                    .find(|&path| Path::new(path).exists())
                    .ok_or_else(|| {
                        leptos::ServerFnError::new(
                            "Cannot find remove_pii_data.sql script file".to_string(),
                        )
                    })?;

                // Update global setting first
                global_database::update_global_setting(
                    &pool,
                    "student_protections",
                    serde_json::Value::Bool(true),
                    user.id.try_into().map_err(|e| {
                        leptos::ServerFnError::new(format!("User ID conversion error: {}", e))
                    })?,
                )
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to update setting: {}", e)))?;

                // Check if psql is available
                let psql_check = Command::new("which").arg("psql").output().map_err(|e| {
                    leptos::ServerFnError::new(format!("Failed to check psql availability: {}", e))
                })?;

                if !psql_check.status.success() {
                    return Err(leptos::ServerFnError::new(
                        "psql command not found. PostgreSQL client tools not installed."
                            .to_string(),
                    ));
                }

                // Execute the remove PII script
                let output = Command::new("psql")
                    .arg(&env::var("DATABASE_URL").map_err(|_| {
                        leptos::ServerFnError::new("DATABASE_URL environment variable not set".to_string())
                    })?)
                    .arg("-f")
                    .arg(script_path)
                    .output()
                    .map_err(|e| {
                        leptos::ServerFnError::new(format!("Failed to execute PII removal: {}", e))
                    })?;

                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);

                if !output.status.success() {
                    return Err(leptos::ServerFnError::new(format!(
                        "PII removal failed. STDERR: {} STDOUT: {}",
                        stderr, stdout
                    )));
                }

                // Try to create CSV in multiple locations
                let csv_locations = vec![
                    "/tmp/student_id_mapping.csv",
                    "./student_id_mapping.csv",
                    "/app/student_id_mapping.csv",
                ];

                let mut csv_created = false;
                for csv_path in csv_locations {
                    if Path::new(csv_path).exists() {
                        csv_created = true;
                        // Try to copy to current directory if not already there
                        if csv_path != "./student_id_mapping.csv" {
                            let _ = Command::new("cp")
                                .arg(csv_path)
                                .arg("./student_id_mapping.csv")
                                .output();
                        }
                        break;
                    }
                }

                if !csv_created {
                    // Manually create CSV using psql
                    let csv_creation = Command::new("psql")
                        .arg(&env::var("DATABASE_URL").unwrap())
                        .arg("-c")
                        .arg("COPY (SELECT new_student_id as app_id, old_student_id as student_id, created_at FROM student_id_mapping ORDER BY new_student_id) TO '/tmp/student_id_mapping.csv' WITH CSV HEADER;")
                        .output()
                        .map_err(|e| leptos::ServerFnError::new(format!("Failed to create CSV: {}", e)))?;

                    if csv_creation.status.success() {
                        let _ = Command::new("cp")
                            .arg("/tmp/student_id_mapping.csv")
                            .arg("./student_id_mapping.csv")
                            .output();
                    }
                }

                Ok(
                    "Student protection enabled. Check for student_id_mapping.csv file."
                        .to_string(),
                )
            } else {
                // Disable protection logic (restore functionality)
                let _key = mapping_key.ok_or_else(|| {
                    leptos::ServerFnError::new(
                        "Mapping key required to disable student protection".to_string(),
                    )
                })?;

                // Check for restore script
                let restore_script_paths = vec![
                    "./scripts/restore_pii_data.sql",
                    "/app/scripts/restore_pii_data.sql",
                    "scripts/restore_pii_data.sql",
                ];

                let restore_script_path = restore_script_paths
                    .iter()
                    .find(|&path| Path::new(path).exists())
                    .ok_or_else(|| {
                        leptos::ServerFnError::new(
                            "Cannot find restore_pii_data.sql script file".to_string(),
                        )
                    })?;

                // Check for CSV file
                if !Path::new("./student_id_mapping.csv").exists() {
                    return Err(leptos::ServerFnError::new(
                        "Mapping CSV file not found. Cannot restore without mapping data."
                            .to_string(),
                    ));
                }

                // Copy CSV to /tmp for script access
                let _ = Command::new("cp")
                    .arg("./student_id_mapping.csv")
                    .arg("/tmp/student_id_mapping.csv")
                    .output();

                // Execute restore script
                let output = Command::new("psql")
                    .arg(&env::var("DATABASE_URL").unwrap())
                    .arg("-f")
                    .arg(restore_script_path)
                    .output()
                    .map_err(|e| {
                        leptos::ServerFnError::new(format!("Failed to execute PII restoration: {}", e))
                    })?;

                if !output.status.success() {
                    let stderr = String::from_utf8_lossy(&output.stderr);
                    let stdout = String::from_utf8_lossy(&output.stdout);
                    return Err(leptos::ServerFnError::new(format!(
                        "PII restoration failed. STDERR: {} STDOUT: {}",
                        stderr, stdout
                    )));
                }

                // Update global setting
                global_database::update_global_setting(
                    &pool,
                    "student_protections",
                    serde_json::Value::Bool(false),
                    user.id.try_into().map_err(|e| {
                        leptos::ServerFnError::new(format!("User ID conversion error: {}", e))
                    })?,
                )
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to update setting: {}", e)))?;

                // Clean up
                let _ = Command::new("rm")
                    .arg("/tmp/student_id_mapping.csv")
                    .output();

                Ok("Student protection disabled. Original student IDs restored.".to_string())
            }
        } else {
            Err(leptos::ServerFnError::new(
                "Unauthorized: Login required".to_string(),
            ))
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn restore_student_ids_from_file(file_content: String) -> Result<String, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;
        use actix_web::web;
        use leptos_actix::extract;
        use std::process::Command;

        // Check authentication and admin privileges
        let current_user = get_current_user().await?;
        if let Some(user) = current_user {
            if !user.is_super_admin() {
                return Err(leptos::ServerFnError::new(
                    "Unauthorized: Super admin access required".to_string(),
                ));
            }

            let pool = extract::<web::Data<PgPool>>()
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

            // Try multiple file paths that are more likely to work
            let possible_paths = vec![
                "./student_id_mapping.csv",    // Current working directory
                "/tmp/student_id_mapping.csv", // Temporary directory
                "student_id_mapping.csv",      // Relative path
            ];

            let mut temp_file_path = None;
            let mut write_error = None;

            // Try each path until one works
            for path in possible_paths {
                match std::fs::write(path, &file_content) {
                    Ok(_) => {
                        temp_file_path = Some(path);
                        break;
                    }
                    Err(e) => {
                        write_error = Some(format!("Failed to write to {}: {}", path, e));
                        continue;
                    }
                }
            }

            let final_path = temp_file_path.ok_or_else(|| {
                leptos::ServerFnError::new(format!(
                    "Failed to write temporary file to any location. Last error: {}",
                    write_error.unwrap_or_else(|| "Unknown error".to_string())
                ))
            })?;

            // Execute the restore PII script
            let output = Command::new("psql")
                .arg("postgresql://postgres:IntrepidTh13n32!@localhost/dahlia")
                .arg("-f")
                .arg("./scripts/restore_pii_data.sql")
                .output()
                .map_err(|e| {
                    leptos::ServerFnError::new(format!("Failed to execute PII restoration: {}", e))
                })?;

            // Capture output for debugging
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);

            if !output.status.success() {
                // Clean up temporary file on error
                let _ = std::fs::remove_file(final_path);

                return Err(leptos::ServerFnError::new(format!(
                    "PII restoration failed. STDERR: {} STDOUT: {}",
                    stderr, stdout
                )));
            }

            // Update global setting to reflect that protection is now disabled
            global_database::update_global_setting(
                &pool,
                "student_protections",
                serde_json::Value::Bool(false),
                user.id
                    .try_into()
                    .map_err(|e| leptos::ServerFnError::new(format!("User ID conversion error: {}", e)))?,
            )
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to update setting: {}", e)))?;

            // Clean up temporary file
            let _ = std::fs::remove_file(final_path);

            // Return success message with some output for debugging
            Ok(format!(
                "Student IDs successfully restored from uploaded mapping file!\n\nUsed file path: {}\n\nProcess output:\n{}",
                final_path, stdout
            ))
        } else {
            Err(leptos::ServerFnError::new(
                "Unauthorized: Login required".to_string(),
            ))
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}
use leptos::prelude::*;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
#[cfg(feature = "ssr")]
use sqlx::PgPool;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StudentValidationRequest {
    pub app_ids: Vec<i32>, // Changed from u32 to i32 for consistency
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StudentValidationResponse {
    pub valid_app_ids: Vec<i32>,
    pub invalid_app_ids: Vec<i32>,
    pub success: bool,
    pub message: String,
}

#[server]
pub async fn validate_student_ids(
    request: StudentValidationRequest,
) -> Result<StudentValidationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;
        use actix_web::web;
        use leptos_actix::extract;

        // Ensure user is authenticated
        let user = get_current_user().await?;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database connection error: {}", e)))?;

        // Check which app_ids exist in the database and belong to this user/session
        let mut valid_app_ids = Vec::new();
        let mut invalid_app_ids = Vec::new();

        for app_id in request.app_ids {
            // Adjust this query based on your actual database schema
            let exists = sqlx::query!(
                "SELECT COUNT(*) as count FROM students 
                 WHERE student_id = $1 AND (user_id = $2 OR session_user_id = $2)",
                app_id,
                user.id as i32
            )
            .fetch_one(&**pool)
            .await?;

            if exists.count.unwrap_or(0) > 0 {
                valid_app_ids.push(app_id);
            } else {
                invalid_app_ids.push(app_id);
            }
        }

        Ok(StudentValidationResponse {
            valid_app_ids,
            invalid_app_ids,
            success: true,
            message: format!(
                "Validated {} app_ids: {} valid, {} invalid",
                request.app_ids.len(),
                valid_app_ids.len(),
                invalid_app_ids.len()
            ),
        })
    }
    #[cfg(not(feature = "ssr"))]
    {
        // Client-side fallback
        Ok(StudentValidationResponse {
            valid_app_ids: vec![],
            invalid_app_ids: vec![],
            success: false,
            message: "This function can only be called server-side".to_string(),
        })
    }
}

// Helper function to get student data with de-anonymization
#[server]
pub async fn get_student_data(
    app_ids: Vec<i32>, // Changed from u32 to i32 for consistency
) -> Result<Vec<StudentRecord>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;
        use actix_web::web;
        use leptos_actix::extract;

        let user = get_current_user().await?;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database connection error: {}", e)))?;

        // Fetch anonymized student records
        let records = sqlx::query_as!(
            StudentRecord,
            "SELECT student_id as app_id  
             FROM students 
             WHERE student_id = ANY($1) AND (user_id = $2 OR session_user_id = $2)",
            &app_ids,
            user.id as i32
        )
        .fetch_all(&**pool)
        .await?;

        Ok(records)
    }
    #[cfg(not(feature = "ssr"))]
    {
        // Client-side fallback
        Ok(vec![])
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StudentRecord {
    pub app_id= i32, // Changed from u32 to i32 for consistency
}
use crate::app::db::user_database;
use crate::app::models::user::{User, UserRole};
use leptos::prelude::*;

#[server]
pub async fn get_users() -> Result<Vec<User>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Fetching users from the database");

        match user_database::get_all_users(&pool).await {
            Ok(users) => {
                log::info!("Successfully retrieved all users from the database");
                Ok(users)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_user(id: i64) -> Result<User, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Fetching user with ID {} from the database", id);

        match user_database::get_user(id, &pool).await {
            Ok(user) => {
                log::info!(
                    "Successfully retrieved user with ID {} from the database",
                    id
                );
                Ok(user)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn update_user_permissions(user_id: i64, role: UserRole) -> Result<(), ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Updating user permissions in the database");

        match user_database::update_permissions(user_id, role, &pool).await {
            Ok(_) => {
                log::info!("Successfully updated user permissions");
                Ok(())
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn update_user(new_user_data: User) -> Result<User, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        use sqlx::PgPool;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool")))?;

        /*log::info!(
            "Updating data for user: {} {}",
            new_user_data.first_name.unwrap_or("None".to_string()),
            new_user_data.last_name.unwrap_or("None".to_string())
        );*/

        match user_database::update_user_data(new_user_data, &pool).await {
            Ok(user) => {
                log::info!("Successfully updated user data");
                Ok(user)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}
use leptos::prelude::*;
use crate::app::db::invitation_database;
use crate::app::models::invitation::{
    normalize_phone_number, CreateInvitationRequest, Invitation, InvitationInfo, VerificationType,
};
use crate::app::models::user::SessionUser;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[cfg(feature = "ssr")]
use {actix_web::web, leptos_actix::extract, sqlx::PgPool};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvitationResponse {
    pub success: bool,
    pub message: String,
    pub invitation: Option<Invitation>,
}

#[server]
pub async fn create_invitation(
    request: CreateInvitationRequest,
) -> Result<InvitationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::middleware::authentication;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let req = extract::<actix_web::HttpRequest>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract request: {}", e)))?;

        // Check if user is admin
        let current_user = authentication::get_current_user_from_request(&req);
        let user_id = match current_user {
            Some(user) if user.is_admin() => Some(user.id),
            Some(_) => {
                return Ok(InvitationResponse {
                    success: false,
                    message: "Admin access required".to_string(),
                    invitation: None,
                });
            }
            None => {
                return Ok(InvitationResponse {
                    success: false,
                    message: "Authentication required".to_string(),
                    invitation: None,
                });
            }
        };

        // Validate request
        if request.school_name.trim().is_empty() {
            return Ok(InvitationResponse {
                success: false,
                message: "School name is required".to_string(),
                invitation: None,
            });
        }

        if request.max_uses < 1 || request.max_uses > 1000 {
            return Ok(InvitationResponse {
                success: false,
                message: "Max uses must be between 1 and 1000".to_string(),
                invitation: None,
            });
        }

        if request.expires_in_days < 1 || request.expires_in_days > 365 {
            return Ok(InvitationResponse {
                success: false,
                message: "Expiration must be between 1 and 365 days".to_string(),
                invitation: None,
            });
        }

        match invitation_database::create_invitation(&pool, request, user_id).await {
            Ok(invitation) => Ok(InvitationResponse {
                success: true,
                message: "Invitation created successfully".to_string(),
                invitation: Some(invitation),
            }),
            Err(e) => {
                log::error!("Failed to create invitation: {:?}", e);
                Ok(InvitationResponse {
                    success: false,
                    message: "Failed to create invitation".to_string(),
                    invitation: None,
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn validate_invitation(code: String) -> Result<Option<InvitationInfo>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match invitation_database::get_invitation_by_code(&pool, &code).await {
            Ok(Some(invitation)) => {
                if invitation.can_be_used() {
                    Ok(Some(InvitationInfo {
                        code: invitation.code,
                        school_name: invitation.school_name,
                        role: invitation.role,
                        expires_at: invitation.expires_at,
                        uses_remaining: invitation.uses_remaining(),
                    }))
                } else {
                    Ok(None) // Invalid or expired
                }
            }
            Ok(None) => Ok(None),
            Err(e) => {
                log::error!("Failed to validate invitation: {:?}", e);
                Err(leptos::ServerFnError::new("Database error".to_string()))
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationResponse {
    pub success: bool,
    pub message: String,
}

#[server]
pub async fn send_verification_code(
    user_id= i64,
    verification_type: String,
) -> Result<VerificationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let v_type =
            VerificationType::from_str(&verification_type).map_err(|e| leptos::ServerFnError::new(e))?;

        // Rate limiting - max 3 codes per 15 minutes
        match invitation_database::count_recent_verification_codes(
            &pool,
            user_id,
            v_type.clone(),
            15,
        )
        .await
        {
            Ok(count) if count >= 3 => {
                return Ok(VerificationResponse {
                    success: false,
                    message: "Too many verification attempts. Please wait 15 minutes.".to_string(),
                });
            }
            Err(e) => {
                log::error!("Failed to check rate limit: {:?}", e);
            }
            _ => {} // Continue
        }

        // Get user info for sending codes
        let user = match crate::app::db::user_database::get_user_by_id(&pool, user_id).await {
            Ok(Some(user)) => user,
            Ok(None) => {
                return Ok(VerificationResponse {
                    success: false,
                    message: "User not found".to_string(),
                });
            }
            Err(e) => {
                log::error!("Failed to get user: {:?}", e);
                return Ok(VerificationResponse {
                    success: false,
                    message: "Database error".to_string(),
                });
            }
        };

        // Create verification code
        match invitation_database::create_verification_code(&pool, user_id, v_type.clone()).await {
            Ok(verification_code) => {
                // Send the code
                match v_type {
                    VerificationType::Email => {
                        // Use your existing email service
                        match send_verification_email(&user.email, &verification_code.code).await {
                            Ok(_) => Ok(VerificationResponse {
                                success: true,
                                message: "Verification code sent to your email".to_string(),
                            }),
                            Err(e) => {
                                log::error!("Failed to send verification email: {}", e);
                                Ok(VerificationResponse {
                                    success: false,
                                    message: "Failed to send verification email".to_string(),
                                })
                            }
                        }
                    }
                    VerificationType::Phone => {
                        if let Some(phone) = user.phone_number {
                            match send_verification_sms(&phone, &verification_code.code).await {
                                Ok(_) => Ok(VerificationResponse {
                                    success: true,
                                    message: "Verification code sent to your phone".to_string(),
                                }),
                                Err(e) => {
                                    log::error!("Failed to send verification SMS: {}", e);
                                    Ok(VerificationResponse {
                                        success: false,
                                        message: "Failed to send verification SMS".to_string(),
                                    })
                                }
                            }
                        } else {
                            Ok(VerificationResponse {
                                success: false,
                                message: "No phone number on file".to_string(),
                            })
                        }
                    }
                }
            }
            Err(e) => {
                log::error!("Failed to create verification code: {:?}", e);
                Ok(VerificationResponse {
                    success: false,
                    message: "Failed to create verification code".to_string(),
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn verify_code(
    user_id= i64,
    code: String,
    verification_type: String,
) -> Result<VerificationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let v_type =
            VerificationType::from_str(&verification_type).map_err(|e| leptos::ServerFnError::new(e))?;

        match invitation_database::validate_verification_code(&pool, user_id, &code, v_type).await {
            Ok(true) => Ok(VerificationResponse {
                success: true,
                message: "Verification successful".to_string(),
            }),
            Ok(false) => Ok(VerificationResponse {
                success: false,
                message: "Invalid or expired verification code".to_string(),
            }),
            Err(e) => {
                log::error!("Failed to verify code: {:?}", e);
                Ok(VerificationResponse {
                    success: false,
                    message: "Verification failed".to_string(),
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[cfg(feature = "ssr")]
async fn send_verification_email(email: &str, code: &str) -> Result<(), String> {
    use crate::app::services::email_service;
    use std::env;

    let app_name = env::var("APP_NAME").unwrap_or_else(|_| "Teapot Testing".to_string());

    // Create verification email content
    let subject = format!("{} - Email Verification Code", app_name);
    let body = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Email Verification</title>
        </head>
        <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 style="color: #667eea;">ðŸ«– {}</h1>
            </div>
            
            <div style="background: #f8f9fa; padding: 30px; border-radius: 8px; text-align: center;">
                <h2 style="color: #333; margin-bottom: 20px;">Email Verification</h2>
                
                <p style="color: #666; font-size: 16px; margin-bottom: 30px;">
                    Please enter this verification code to confirm your email address:
                </p>
                
                <div style="background: white; border: 2px solid #667eea; border-radius: 8px; padding: 20px; margin: 20px 0; font-size: 32px; font-weight: bold; letter-spacing: 8px; color: #667eea;">
                    {}
                </div>
                
                <p style="color: #999; font-size: 14px;">
                    This code will expire in 10 minutes. If you didn't request this verification, please ignore this email.
                </p>
            </div>
        </body>
        </html>
        "#,
        app_name, code
    );

    // Use existing email service infrastructure
    email_service::send_email(email, &subject, &body).await
}

#[cfg(feature = "ssr")]
async fn send_verification_sms(phone: &str, code: &str) -> Result<(), String> {
    use std::env;

    let app_name = env::var("APP_NAME").unwrap_or_else(|_| "Teapot Testing".to_string());
    let message = format!(
        "Your {} verification code is: {}. This code expires in 10 minutes.",
        app_name, code
    );

    // Check if we're in development mode
    let is_development =
        env::var("APP_ENV").unwrap_or_else(|_| "development".to_string()) != "production";

    if is_development {
        // In development, log the SMS instead of sending it
        log::info!("SMS to {}: {}", phone, message);
        Ok(())
    } else {
        // In production, use actual SMS service
        send_sms_via_service(phone, &message).await
    }
}

#[cfg(feature = "ssr")]
async fn send_sms_via_service(phone: &str, message: &str) -> Result<(), String> {
    use std::env;

    // Get Twilio credentials from environment
    let account_sid = env::var("TWILIO_ACCOUNT_SID").map_err(|_| "TWILIO_ACCOUNT_SID not set")?;
    let auth_token = env::var("TWILIO_AUTH_TOKEN").map_err(|_| "TWILIO_AUTH_TOKEN not set")?;
    let from_phone = env::var("TWILIO_PHONE_NUMBER").map_err(|_| "TWILIO_PHONE_NUMBER not set")?;

    // Create Twilio API request
    let client = reqwest::Client::new();
    let url = format!(
        "https://api.twilio.com/2010-04-01/Accounts/{}/Messages.json",
        account_sid
    );

    let params = [
        ("From", from_phone.as_str()),
        ("To", phone),
        ("Body", message),
    ];

    let response = client
        .post(&url)
        .basic_auth(&account_sid, Some(&auth_token))
        .form(&params)
        .send()
        .await
        .map_err(|e| format!("Failed to send SMS request: {}", e))?;

    if response.status().is_success() {
        log::info!("SMS sent successfully to {}", phone);
        Ok(())
    } else {
        let error_body = response
            .text()
            .await
            .unwrap_or_else(|_| "Unknown error".to_string());
        log::error!("Failed to send SMS to {}: {}", phone, error_body);
        Err(format!("SMS sending failed: {}", error_body))
    }
}

#[server]
pub async fn get_invitations(
    limit: Option<i64>,
    offset: Option<i64>,
) -> Result<Vec<Invitation>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::middleware::authentication;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let req = extract::<actix_web::HttpRequest>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract request: {}", e)))?;

        // Check if user is admin
        match authentication::get_current_user_from_request(&req) {
            Some(user) if user.is_admin() => {
                let limit = limit.unwrap_or(50);
                let offset = offset.unwrap_or(0);

                match invitation_database::get_all_invitations_for_admin(&pool, limit, offset).await
                {
                    Ok(invitations) => Ok(invitations),
                    Err(e) => {
                        log::error!("Failed to get invitations: {:?}", e);
                        Err(leptos::ServerFnError::new(
                            "Failed to fetch invitations".to_string(),
                        ))
                    }
                }
            }
            Some(_) => Err(leptos::ServerFnError::new("Admin access required".to_string())),
            None => Err(leptos::ServerFnError::new("Authentication required".to_string())),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn delete_invitation(invitation_id= i64) -> Result<VerificationResponse, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::middleware::authentication;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let req = extract::<actix_web::HttpRequest>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract request: {}", e)))?;

        // Check if user is admin
        match authentication::get_current_user_from_request(&req) {
            Some(user) if user.is_admin() => {
                match invitation_database::delete_invitation(&pool, invitation_id).await {
                    Ok(true) => Ok(VerificationResponse {
                        success: true,
                        message: "Invitation deleted successfully".to_string(),
                    }),
                    Ok(false) => Ok(VerificationResponse {
                        success: false,
                        message: "Invitation not found".to_string(),
                    }),
                    Err(e) => {
                        log::error!("Failed to delete invitation: {:?}", e);
                        Ok(VerificationResponse {
                            success: false,
                            message: "Failed to delete invitation".to_string(),
                        })
                    }
                }
            }
            Some(_) => Ok(VerificationResponse {
                success: false,
                message: "Admin access required".to_string(),
            }),
            None => Ok(VerificationResponse {
                success: false,
                message: "Authentication required".to_string(),
            }),
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[cfg(not(feature = "ssr"))]
async fn send_verification_email(_email: &str, _code: &str) -> Result<(), String> {
    Err("Email sending only available on server".to_string())
}

#[cfg(not(feature = "ssr"))]
async fn send_verification_sms(_phone: &str, _code: &str) -> Result<(), String> {
    Err("SMS sending only available on server".to_string())
}
use crate::app::db::user_database;
use crate::app::models::user::{SessionUser, UserRole};
#[cfg(feature = "ssr")]
use actix_web::{cookie::Cookie, http::header, HttpRequest, HttpResponse};
use leptos::prelude::*;
#[cfg(feature = "ssr")]
use leptos_actix::{extract, ResponseOptions};
use log::{debug, error, info};
use serde::{Deserialize, Serialize};
#[cfg(feature = "ssr")]
use sqlx::PgPool;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AuthResponse {
    pub success: bool,
    pub message: String,
    pub user: Option<SessionUser>,
}

#[server]
pub async fn login(username: String, password: String) -> Result<AuthResponse, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        log::info!("Login attempt for user: {}", username);

        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Looking up user in database: {}", username);
        let user_result = user_database::get_user_by_username(&pool, &username).await;

        match user_result {
            Ok(Some(user)) => {
                log::info!("User found, verifying password");
                if user_database::verify_password(&password, &user.password_hash) {
                    log::info!("Password verified for user: {}", username);

                    match user_database::create_session(&pool, user.id).await {
                        Ok(session_token) => {
                            log::info!("Session created for user: {}", username);

                            // Set secure session cookie
                            let response = expect_context::<ResponseOptions>();
                            let cookie_value =
                                format!(
                                "session={}; Path=/; HttpOnly; SameSite=Strict; Max-Age=604800{}",
                                session_token,
                                if cfg!(debug_assertions) { "" } else { "; Secure" }
                            );

                            response.insert_header(
                                header::SET_COOKIE,
                                header::HeaderValue::from_str(&cookie_value)
                                    .expect("Failed to create header value"),
                            );

                            Ok(AuthResponse {
                                success: true,
                                message: "Login successful".to_string(),
                                user: Some(user.to_session_user()), // Convert to SessionUser
                            })
                        }
                        Err(e) => {
                            log::error!("Failed to create session: {:?}", e);
                            Ok(AuthResponse {
                                success: false,
                                message: "Failed to create session".to_string(),
                                user: None,
                            })
                        }
                    }
                } else {
                    log::info!("Invalid password for user: {}", username);
                    Ok(AuthResponse {
                        success: false,
                        message: "Invalid credentials".to_string(),
                        user: None,
                    })
                }
            }
            Ok(None) => {
                log::info!("User not found: {}", username);
                Ok(AuthResponse {
                    success: false,
                    message: "Invalid credentials".to_string(),
                    user: None,
                })
            }
            Err(e) => {
                log::error!("Database error when looking up user: {:?}", e);
                Ok(AuthResponse {
                    success: false,
                    message: "Database error".to_string(),
                    user: None,
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn logout() -> Result<AuthResponse, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let req = extract::<HttpRequest>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract request: {}", e)))?;

        let cookies = match req.cookies() {
            Ok(cookies) => cookies,
            Err(e) => {
                log::error!("Failed to extract cookies: {:?}", e);
                return Ok(AuthResponse {
                    success: false,
                    message: "Failed to parse cookies".to_string(),
                    user: None,
                });
            }
        };

        // Find and invalidate session
        if let Some(session_cookie) = cookies.iter().find(|c| c.name() == "session") {
            let session_token = session_cookie.value();
            if let Err(e) = user_database::delete_session(&pool, session_token).await {
                log::error!("Failed to delete session from database: {:?}", e);
            }
        }

        // Clear the session cookie
        let response = expect_context::<ResponseOptions>();
        let clear_cookie = format!(
            "session=; Path=/; HttpOnly; SameSite=Strict; Max-Age=0{}",
            if cfg!(debug_assertions) {
                ""
            } else {
                "; Secure"
            }
        );

        response.insert_header(
            header::SET_COOKIE,
            header::HeaderValue::from_str(&clear_cookie).expect("Failed to create header value"),
        );

        Ok(AuthResponse {
            success: true,
            message: "Logout successful".to_string(),
            user: None,
        })
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn get_current_user() -> Result<Option<SessionUser>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let req = extract::<HttpRequest>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract request: {}", e)))?;

        let cookies = match req.cookies() {
            Ok(cookies) => cookies,
            Err(e) => {
                log::error!("Failed to extract cookies: {:?}", e);
                return Ok(None);
            }
        };

        if let Some(session_cookie) = cookies.iter().find(|c| c.name() == "session") {
            let session_token = session_cookie.value();

            match user_database::validate_session(&pool, session_token).await {
                Ok(Some(user)) => {
                    log::debug!("Valid session found for user: {}", user.username);
                    return Ok(Some(user)); // Already returns SessionUser
                }
                Ok(None) => {
                    log::debug!("Invalid or expired session");
                }
                Err(e) => {
                    log::error!("Error validating session: {:?}", e);
                }
            }
        }

        Ok(None)
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn register(
    username: String,
    email: String,
    password: String,
) -> Result<AuthResponse, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        // Input validation
        if username.trim().is_empty() || email.trim().is_empty() || password.len() < 8 {
            return Ok(AuthResponse {
                success: false,
                message: "Invalid input: username and email cannot be empty, password must be at least 8 characters".to_string(),
                user: None,
            });
        }

        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Registration attempt for username: {}", username);

        // Check for existing username
        if let Ok(Some(_)) = user_database::get_user_by_username(&pool, &username).await {
            return Ok(AuthResponse {
                success: false,
                message: "Username already exists".to_string(),
                user: None,
            });
        }

        // Check for existing email
        if let Ok(Some(_)) = user_database::get_user_by_email(&pool, &email).await {
            return Ok(AuthResponse {
                success: false,
                message: "Email already exists".to_string(),
                user: None,
            });
        }

        // Create user
        match user_database::create_user(&pool, username.clone(), email, password, UserRole::Guest)
            .await
        {
            Ok(user) => {
                log::info!("User created successfully: {}", username);

                // Create session
                match user_database::create_session(&pool, user.id).await {
                    Ok(session_token) => {
                        // Set session cookie
                        let response = expect_context::<ResponseOptions>();
                        let cookie_value = format!(
                            "session={}; Path=/; HttpOnly; SameSite=Strict; Max-Age=604800{}",
                            session_token,
                            if cfg!(debug_assertions) {
                                ""
                            } else {
                                "; Secure"
                            }
                        );

                        response.insert_header(
                            header::SET_COOKIE,
                            header::HeaderValue::from_str(&cookie_value)
                                .expect("Failed to create header value"),
                        );

                        Ok(AuthResponse {
                            success: true,
                            message: "Registration successful".to_string(),
                            user: Some(user.to_session_user()), // Convert to SessionUser
                        })
                    }
                    Err(e) => {
                        log::error!("Failed to create session for new user: {:?}", e);
                        Ok(AuthResponse {
                            success: false,
                            message: "Failed to create session".to_string(),
                            user: None,
                        })
                    }
                }
            }
            Err(e) => {
                log::error!("Failed to create user: {:?}", e);
                Ok(AuthResponse {
                    success: false,
                    message: "Failed to create user".to_string(),
                    user: None,
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

// Keep password reset functions as they are - they're well implemented
#[server]
pub async fn request_password_reset(email: String) -> Result<AuthResponse, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::services::email_service;
        use actix_web::web;
        use chrono::{Duration, Utc};
        use leptos_actix::extract;
        use rand::{distributions::Alphanumeric, Rng};

        log::info!("Password reset requested for email: {}", email);

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        let user_result = user_database::get_user_by_email(&pool, &email).await;

        match user_result {
            Ok(Some(user)) => {
                let token: String = rand::thread_rng()
                    .sample_iter(&Alphanumeric)
                    .take(64)
                    .map(char::from)
                    .collect();

                let expires = Utc::now() + Duration::hours(24);

                match user_database::set_password_reset_token(&pool, user.id, &token, expires).await
                {
                    Ok(_) => {
                        if let Err(e) = email_service::send_reset_email(&email, &token).await {
                            log::error!("Failed to send password reset email: {}", e);
                        }

                        Ok(AuthResponse {
                            success: true,
                            message: "Password reset instructions sent to your email".to_string(),
                            user: None,
                        })
                    }
                    Err(e) => {
                        log::error!("Failed to set password reset token: {:?}", e);
                        Ok(AuthResponse {
                            success: false,
                            message: "Failed to initiate password reset".to_string(),
                            user: None,
                        })
                    }
                }
            }
            Ok(None) => {
                log::info!("Password reset requested for non-existent email: {}", email);
                Ok(AuthResponse {
                    success: true,
                    message:
                        "If this email is registered, password reset instructions have been sent"
                            .to_string(),
                    user: None,
                })
            }
            Err(e) => {
                log::error!("Database error looking up user by email: {:?}", e);
                Ok(AuthResponse {
                    success: false,
                    message: "An error occurred processing your request".to_string(),
                    user: None,
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn validate_reset_token(token: String) -> Result<bool, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        match user_database::validate_password_reset_token(&pool, &token).await {
            Ok(valid) => Ok(valid),
            Err(e) => {
                log::error!("Error validating reset token: {:?}", e);
                Err(ServerFnError::new("Database error".to_string()))
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn reset_password(
    token: String,
    new_password: String,
) -> Result<AuthResponse, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        if new_password.len() < 8 {
            return Ok(AuthResponse {
                success: false,
                message: "Password must be at least 8 characters long".to_string(),
                user: None,
            });
        }

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        if let Ok(true) = user_database::validate_password_reset_token(&pool, &token).await {
            match user_database::get_user_by_reset_token(&pool, &token).await {
                Ok(Some(user)) => {
                    let password_hash = user_database::hash_password(&new_password)?;

                    match user_database::update_password_and_clear_token(
                        &pool,
                        user.id,
                        &password_hash,
                    )
                    .await
                    {
                        Ok(_) => Ok(AuthResponse {
                            success: true,
                            message: "Password successfully reset".to_string(),
                            user: None,
                        }),
                        Err(e) => {
                            log::error!("Failed to update password: {:?}", e);
                            Ok(AuthResponse {
                                success: false,
                                message: "Failed to reset password".to_string(),
                                user: None,
                            })
                        }
                    }
                }
                Ok(None) => Ok(AuthResponse {
                    success: false,
                    message: "Invalid reset token".to_string(),
                    user: None,
                }),
                Err(e) => {
                    log::error!("Database error looking up user by reset token: {:?}", e);
                    Ok(AuthResponse {
                        success: false,
                        message: "An error occurred processing your request".to_string(),
                        user: None,
                    })
                }
            }
        } else {
            Ok(AuthResponse {
                success: false,
                message: "Invalid or expired reset token".to_string(),
                user: None,
            })
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(ServerFnError::ServerError("Not implemented".to_string()))
    }
}
use crate::app::models::enrollment::{
    AcademicYear, CreateEnrollmentRequest, Enrollment, EnrollmentStatus, UpdateEnrollmentRequest,
};
use leptos::prelude::*;
use leptos::prelude::*;
use uuid::Uuid;

#[cfg(feature = "ssr")]
use {crate::app::db::enrollment_database, actix_web::web, sqlx::PgPool, std::error::Error};

#[server]
pub async fn get_enrollments() -> Result<Vec<Enrollment>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to retrieve all enrollments from the database"); // Fixed log message

        match enrollment_database::get_all_enrollments(&pool).await {
            Ok(enrollments) => {
                log::info!("Successfully retrieved enrollments: {:?}", enrollments);
                Ok(enrollments)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to retrieve enrollments: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn get_enrollment(
    student_id: i32,
    academic_year: AcademicYear,
) -> Result<Enrollment, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to retrieve enrollment for student_id: {} and academic_year: {:?}",
            student_id,
            academic_year
        );

        match enrollment_database::get_enrollment_by_student_and_year(
            &pool,
            student_id,
            academic_year,
        )
        .await
        {
            Ok(enrollment) => {
                log::info!("Successfully retrieved enrollment: {:?}", enrollment);
                Ok(enrollment)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to retrieve enrollment: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn get_enrollments_by_student(
    student_id: i32,
) -> Result<Vec<Enrollment>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to retrieve enrollments for student_id: {}",
            student_id
        );

        match enrollment_database::get_enrollments_by_student(&student_id, &pool).await {
            Ok(enrollments) => {
                log::info!(
                    "Successfully retrieved enrollments for student: {:?}",
                    enrollments
                );
                Ok(enrollments)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to retrieve enrollments for student: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn get_enrollments_by_year(
    academic_year: AcademicYear,
) -> Result<Vec<Enrollment>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to retrieve enrollments for academic_year: {:?}",
            academic_year
        );

        match enrollment_database::get_enrollments_by_academic_year(&academic_year, &pool).await {
            Ok(enrollments) => {
                log::info!(
                    "Successfully retrieved enrollments for year: {:?}",
                    enrollments
                );
                Ok(enrollments)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to retrieve enrollments for year: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn get_enrollments_by_teacher(
    teacher_id: i32,
) -> Result<Vec<Enrollment>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to retrieve enrollments for teacher_id: {}",
            teacher_id
        );

        match enrollment_database::get_enrollments_by_teacher(teacher_id, &pool).await {
            Ok(enrollments) => {
                log::info!(
                    "Successfully retrieved enrollments for teacher: {:?}",
                    enrollments
                );
                Ok(enrollments)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to retrieve enrollments for teacher: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn create_enrollment(
    new_enrollment_request: CreateEnrollmentRequest,
) -> Result<Enrollment, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to create enrollment for student_id: {}, academic_year: {:?}",
            new_enrollment_request.student_id,
            new_enrollment_request.academic_year
        );

        // Convert CreateEnrollmentRequest to Enrollment
        let enrollment = Enrollment::new(
            new_enrollment_request.student_id,
            new_enrollment_request.academic_year,
            new_enrollment_request.grade_level,
            new_enrollment_request.teacher_id,
            new_enrollment_request.status,
            new_enrollment_request.enrollment_date,
            new_enrollment_request.status_change_date, // Now Option<NaiveDate>
            new_enrollment_request.notes,
        );

        match enrollment_database::add_enrollment(&enrollment, &pool).await {
            Ok(enrollment) => {
                log::info!("Successfully created enrollment: {:?}", enrollment);
                Ok(enrollment)
            }
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to create enrollment: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn modify_enrollment(
    update_enrollment_request: UpdateEnrollmentRequest,
) -> Result<Enrollment, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to modify enrollment for student_id: {}, academic_year: {:?}",
            update_enrollment_request.student_id,
            update_enrollment_request.academic_year
        );

        match enrollment_database::update_enrollment(
            &update_enrollment_request.student_id,
            &update_enrollment_request.academic_year,
            update_enrollment_request.grade_level,
            update_enrollment_request.teacher_id,
            update_enrollment_request.status,
            update_enrollment_request.enrollment_date,
            update_enrollment_request.status_change_date, // Now Option<NaiveDate>
            update_enrollment_request.notes,
            &pool,
        )
        .await
        {
            Ok(Some(enrollment)) => {
                log::info!("Successfully modified enrollment: {:?}", enrollment);
                Ok(enrollment)
            }
            Ok(None) => Err(leptos::ServerFnError::new(
                "Enrollment not found".to_string(),
            )),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to modify enrollment: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn update_enrollment_status(
    student_id: i32,
    academic_year: AcademicYear,
    status: EnrollmentStatus,
) -> Result<Enrollment, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use chrono::Utc;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to update enrollment status for student_id: {}, academic_year: {:?}, status: {:?}", 
            student_id, academic_year, status);

        let status_change_date = Utc::now().naive_utc().date();

        match enrollment_database::update_enrollment_status(
            &student_id,
            &academic_year,
            status,
            status_change_date,
            &pool,
        )
        .await
        {
            Ok(Some(enrollment)) => {
                log::info!("Successfully updated enrollment status: {:?}", enrollment);
                Ok(enrollment)
            }
            Ok(None) => Err(leptos::ServerFnError::new(
                "Enrollment not found".to_string(),
            )),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to update enrollment status: {}",
                e
            ))),
        }
    }
}

#[server]
pub async fn delete_enrollment(
    student_id: i32,
    academic_year: AcademicYear,
) -> Result<Enrollment, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!(
            "Attempting to delete enrollment for student_id: {}, academic_year: {:?}",
            student_id,
            academic_year
        );

        match enrollment_database::delete_enrollment(student_id, academic_year, &pool).await {
            Ok(Some(enrollment)) => {
                log::info!("Successfully deleted enrollment: {:?}", enrollment);
                Ok(enrollment)
            }
            Ok(None) => Err(leptos::ServerFnError::new(
                "Enrollment not found".to_string(),
            )),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to delete enrollment: {}",
                e
            ))),
        }
    }
}
use leptos::prelude::*;
use crate::app::db::saml_database;
use crate::app::db::user_database;
use crate::app::models::user::SessionUser;
use actix_web::{web, HttpRequest, HttpResponse, Result};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct SamlAcsRequest {
    #[serde(rename = "SAMLResponse")]
    saml_response: String,
    #[serde(rename = "RelayState")]
    relay_state: Option<String>,
}

#[derive(Deserialize)]
pub struct SamlSloRequest {
    #[serde(rename = "SAMLRequest")]
    saml_request: Option<String>,
    #[serde(rename = "SAMLResponse")]
    saml_response: Option<String>,
    #[serde(rename = "RelayState")]
    relay_state: Option<String>,
}

// Serve SAML metadata for service provider
pub async fn saml_metadata(pool: web::Data<sqlx::PgPool>) -> Result<HttpResponse> {
    let base_url =
        std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:8080".to_string());

    let metadata_xml = format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
                     entityID="{}/saml/metadata">
    <md:SPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
        <md:KeyDescriptor use="signing">
            <ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
                <ds:X509Data>
                    <ds:X509Certificate>
                        <!-- Your SP certificate here -->
                    </ds:X509Certificate>
                </ds:X509Data>
            </ds:KeyInfo>
        </md:KeyDescriptor>
        <md:KeyDescriptor use="encryption">
            <ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
                <ds:X509Data>
                    <ds:X509Certificate>
                        <!-- Your SP certificate here -->
                    </ds:X509Certificate>
                </ds:X509Data>
            </ds:KeyInfo>
        </md:KeyDescriptor>
        <md:SingleLogoutService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
                               Location="{}/saml/sls"/>
        <md:NameIDFormat>urn:oasis:names:tc:SAML:2.0:nameid-format:emailAddress</md:NameIDFormat>
        <md:AssertionConsumerService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                                    Location="{}/saml/acs"
                                    index="1"/>
    </md:SPSSODescriptor>
</md:EntityDescriptor>"#,
        base_url, base_url, base_url
    );

    Ok(HttpResponse::Ok()
        .content_type("application/xml")
        .body(metadata_xml))
}

// Handle SAML Assertion Consumer Service (ACS)
pub async fn saml_acs(
    pool: web::Data<sqlx::PgPool>,
    req: HttpRequest,
    form: web::Form<SamlAcsRequest>,
) -> Result<HttpResponse> {
    log::info!("Received SAML ACS request");

    // Get institution ID from cookie
    let institution_id = req
        .cookie("saml_institution")
        .map(|cookie| cookie.value().to_string())
        .ok_or_else(|| {
            log::error!("No institution ID found in cookie");
            actix_web::error::ErrorBadRequest("No institution ID found")
        })?;

    log::info!(
        "Processing SAML response for institution: {}",
        institution_id
    );

    // Get SAML config
    let config = match saml_database::get_saml_config(&pool, &institution_id).await {
        Ok(Some(config)) => config,
        Ok(None) => {
            log::error!("No SAML config found for institution: {}", institution_id);
            return Ok(HttpResponse::BadRequest().body("Institution not configured"));
        }
        Err(e) => {
            log::error!("Error getting SAML config: {:?}", e);
            return Ok(HttpResponse::InternalServerError().body("Configuration error"));
        }
    };

    // Decode and parse SAML response
    let base_url =
        std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string());
    let saml_manager = match saml_database::SamlManager::new(&base_url) {
        Ok(manager) => manager,
        Err(e) => {
            log::error!("Failed to create SAML manager: {:?}", e);
            return Ok(HttpResponse::InternalServerError().body("SAML configuration error"));
        }
    };

    // Decode base64 SAML response
    use base64::{engine::general_purpose, Engine as _};
    let decoded_response = match general_purpose::STANDARD.decode(&form.saml_response) {
        Ok(decoded) => decoded,
        Err(e) => {
            log::error!("Failed to decode SAML response: {:?}", e);
            return Ok(HttpResponse::BadRequest().body("Invalid SAML response format"));
        }
    };

    let saml_xml = match String::from_utf8(decoded_response) {
        Ok(xml) => xml,
        Err(e) => {
            log::error!("Invalid UTF-8 in SAML response: {:?}", e);
            return Ok(HttpResponse::BadRequest().body("Invalid SAML response encoding"));
        }
    };

    log::debug!("SAML Response XML: {}", saml_xml);

    // Parse SAML response
    let parsed_response = match saml_manager.parse_saml_response(&saml_xml, &institution_id) {
        Ok(response) => response,
        Err(e) => {
            log::error!("Failed to parse SAML response: {:?}", e);
            return Ok(HttpResponse::BadRequest().body("Invalid SAML response"));
        }
    };

    log::info!("Parsed SAML response for user: {}", parsed_response.name_id);

    // Provision or get existing user
    let user =
        match saml_database::provision_saml_user(&pool, &parsed_response, &institution_id).await {
            Ok(user) => user,
            Err(e) => {
                log::error!("Failed to provision SAML user: {:?}", e);
                return Ok(HttpResponse::InternalServerError().body("User provisioning failed"));
            }
        };

    // Create session
    let session_token = match user_database::create_session(&pool, user.id).await {
        Ok(token) => token,
        Err(e) => {
            log::error!("Failed to create session: {:?}", e);
            return Ok(HttpResponse::InternalServerError().body("Session creation failed"));
        }
    };

    log::info!(
        "SAML login successful for user: {} ({})",
        user.username,
        user.id
    );

    // Build redirect URL
    let redirect_url = form.relay_state.as_deref().unwrap_or("/dashboard");

    // Create HTML response with auto-redirect and session cookie
    let html_response = format!(
        r#"
<!DOCTYPE html>
<html>
<head>
    <title>Login Successful</title>
    <meta http-equiv="refresh" content="0;url={}">
</head>
<body>
    <p>Login successful! Redirecting...</p>
    <script>
        window.location.href = '{}';
    </script>
</body>
</html>"#,
        redirect_url, redirect_url
    );

    Ok(HttpResponse::Ok()
        .content_type("text/html")
        .cookie(
            actix_web::cookie::Cookie::build("session", session_token)
                .path("/")
                .http_only(true)
                .same_site(actix_web::cookie::SameSite::Strict)
                .max_age(actix_web::cookie::time::Duration::days(7))
                .secure(!cfg!(debug_assertions))
                .finish(),
        )
        .cookie(
            actix_web::cookie::Cookie::build("saml_institution", "")
                .path("/")
                .http_only(true)
                .max_age(actix_web::cookie::time::Duration::seconds(0))
                .finish(),
        )
        .body(html_response))
}

// Handle SAML Single Logout Service (SLS)
pub async fn saml_sls(
    pool: web::Data<sqlx::PgPool>,
    req: HttpRequest,
    query: web::Query<SamlSloRequest>,
) -> Result<HttpResponse> {
    log::info!("Received SAML SLS request");

    // Get current session
    let session_token = req
        .cookie("session")
        .map(|cookie| cookie.value().to_string());

    if let Some(token) = session_token {
        // Delete the session
        if let Err(e) = user_database::delete_session(&pool, &token).await {
            log::error!("Failed to delete session: {:?}", e);
        }
    }

    // If this is a logout response, just redirect
    if query.saml_response.is_some() {
        return Ok(HttpResponse::Found()
            .append_header(("Location", "/login"))
            .cookie(
                actix_web::cookie::Cookie::build("session", "")
                    .path("/")
                    .http_only(true)
                    .max_age(actix_web::cookie::time::Duration::seconds(0))
                    .finish(),
            )
            .finish());
    }

    // If this is a logout request, we should process it and send a response
    // For now, just redirect to login page
    let redirect_url = query.relay_state.as_deref().unwrap_or("/login");

    Ok(HttpResponse::Found()
        .append_header(("Location", redirect_url))
        .cookie(
            actix_web::cookie::Cookie::build("session", "")
                .path("/")
                .http_only(true)
                .max_age(actix_web::cookie::time::Duration::seconds(0))
                .finish(),
        )
        .finish())
}

// Health check endpoint for SAML functionality
pub async fn saml_health(pool: web::Data<sqlx::PgPool>) -> Result<HttpResponse> {
    // Check if we can connect to database and have SAML configs
    match saml_database::list_saml_configs(&pool).await {
        Ok(configs) => {
            let active_configs = configs.iter().filter(|c| c.active).count();
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "status": "ok",
                "saml_enabled": true,
                "active_institutions": active_configs,
                "total_institutions": configs.len()
            })))
        }
        Err(e) => {
            log::error!("SAML health check failed: {:?}", e);
            Ok(HttpResponse::ServiceUnavailable().json(serde_json::json!({
                "status": "error",
                "saml_enabled": false,
                "error": "Database connectivity issue"
            })))
        }
    }
}

// Configure SAML routes
pub fn configure_saml_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/saml")
            .route("/metadata", web::get().to(saml_metadata))
            .route("/acs", web::post().to(saml_acs))
            .route("/sls", web::get().to(saml_sls))
            .route("/sls", web::post().to(saml_sls))
            .route("/health", web::get().to(saml_health)),
    );
}
use crate::app::db::teacher_database;
use crate::app::models::employee::Employee;
use crate::app::models::teacher::{
    AddNewTeacherRequest, DeleteTeacherRequest, UpdateTeacherRequest,
};
use crate::app::models::StatusEnum;
use leptos::prelude::*;
use leptos::prelude::*;

#[cfg(feature = "ssr")]
use {
    crate::app::db::database, actix_web::web, chrono::Local, sqlx::PgPool, std::error::Error,
    uuid::Uuid,
};

#[server]
pub async fn get_employees() -> Result<Vec<Employee>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to retrieve all teachers from database");

        match database::get_all_employees(&pool).await {
            Ok(employees) => {
                log::info!("Successfully retrieved all employees from database");
                Ok(employees)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(leptos::ServerFnError::new(format!(
                    "Database error: {}",
                    e
                )))
            }
        }
    }
}

#[server]
pub async fn get_teachers() -> Result<Vec<Employee>, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to retrieve all teachers from database");

        match teacher_database::get_all_teachers(&pool).await {
            Ok(teachers) => {
                log::info!("Successfully retrieved all teachers from database");
                Ok(teachers)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(leptos::ServerFnError::new(format!(
                    "Database error: {}",
                    e
                )))
            }
        }
    }
}

#[server]
pub async fn add_teacher(
    add_teacher_request: AddNewTeacherRequest,
) -> Result<Employee, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to add new teacher to the database");
        let buffer_teacher = Employee::new_teacher(
            0001, //note that this value is simply a placeholder because the backend generates the
            //id automatically
            add_teacher_request.firstname,
            add_teacher_request.lastname,
            StatusEnum::NotApplicable,
            None,
        );

        match teacher_database::add_teacher(&buffer_teacher, &pool).await {
            Ok(created_teacher) => {
                log::info!(
                    "Successfully created teacher: {}{}",
                    created_teacher.firstname,
                    created_teacher.lastname,
                );
                Ok(created_teacher)
            }
            Err(e) => {
                log::info!("Failed to create teacher: {:?}", e);
                Err(leptos::ServerFnError::new(format!(
                    "An error occured while creating the teacher"
                )))
            }
        }
    }
}
/*
#[server]
pub async fn delete_teacher(
    delete_teacher_request: DeleteTeacherRequest,
) -> Result<Employee, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete teacher from the database");

        match teacher_database::delete_teacher(delete_teacher_request.id, &pool).await {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(leptos::ServerFnError::new(
                "Failed to delete teacher from the database",
            )),
        }
    }
}*/

#[server]
pub async fn edit_teacher(
    edit_teacher_request: UpdateTeacherRequest,
) -> Result<Employee, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>().await.map_err(|e| {
            leptos::ServerFnError::new(format!("Failed to extract pool: {}", e))
        })?;

        log::info!("Attempting to update teacher in the database");

        match teacher_database::update_teacher(
            edit_teacher_request.id,
            edit_teacher_request.firstname,
            edit_teacher_request.lastname,
            edit_teacher_request.status,
            edit_teacher_request.grade,
            &pool,
        )
        .await
        {
            Ok(Some(updated_student)) => Ok(updated_student),
            Ok(None) => Err(leptos::ServerFnError::new(format!(
                "Failed to update and return student"
            ))),
            Err(e) => Err(leptos::ServerFnError::new(format!(
                "Failed to update student: {}",
                e
            ))),
        }
    }
}
use crate::app::errors::ErrorMessage;
use crate::app::models::{
    student::Student, AddStudentRequest, DeleteStudentRequest, UpdateStudentRequest,
};
use leptos::prelude::*;

#[cfg(feature = "ssr")]
use {
    crate::app::db::database, crate::app::db::student_database, crate::app::errors::StudentError,
    actix_web::web, chrono::Local, sqlx::PgPool, std::error::Error, uuid::Uuid,
};

#[server]
pub async fn get_students() -> Result<Vec<Student>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all students from database");

        match student_database::get_all_students(&pool).await {
            Ok(students) => {
                log::info!("Successfully retrieve_all_students from database");
                Ok(students)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_student(student_id: i32) -> Result<Student, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve certain student");

        match student_database::get_certain_student(student_id, &pool).await {
            Ok(student) => {
                log::info!("Successfully got certain student");
                Ok(student)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_students_smart(fragment: String) -> Result<Vec<Student>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all students from database (smartly)");

        match student_database::get_all_students(&pool).await {
            Ok(students) => {
                log::info!("Successfully retrieve_all_students from database");
                Ok(students)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn add_student(add_student_request: AddStudentRequest) -> Result<Student, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new student to the database");
        let bufferStudent = Student::new(
            Some(add_student_request.firstname),
            Some(add_student_request.lastname),
            add_student_request.preferred,
            add_student_request.gender,
            add_student_request.date_of_birth,
            add_student_request.student_id,
            add_student_request.esl,
            add_student_request.current_grade_level,
            add_student_request.teacher,
            add_student_request.iep,
            add_student_request.bip,
            add_student_request.student_504,
            add_student_request.readplan,
            add_student_request.gt,
            add_student_request.intervention,
            add_student_request.eye_glasses,
            add_student_request.notes,
            Some(add_student_request.pin),
        );

        match student_database::add_student(&bufferStudent, &pool).await {
            Ok(created_student) => {
                log::info!(
                    "Successfully created student with ID: {}",
                    created_student.student_id
                );
                Ok(created_student)
            }
            Err(e) => {
                log::info!("Failed to create student: {:?}", e);
                Err(ServerFnError::new(format!(
                    "The object created was not a student...somehow?"
                )))
            }
        }
    }
}

#[server]
pub async fn delete_student(
    delete_student_request: DeleteStudentRequest,
) -> Result<Student, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete student to the database");

        match student_database::delete_student(
            delete_student_request.firstname,
            delete_student_request.lastname,
            delete_student_request.student_id,
            &pool,
        )
        .await
        {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(ServerFnError::new(
                "Failed to delete student from the database",
            )),
        }
    }
}

#[server]
pub async fn edit_student(
    edit_student_request: UpdateStudentRequest,
) -> Result<Student, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update student in the database");

        match student_database::update_student(
            edit_student_request.firstname,
            edit_student_request.lastname,
            edit_student_request.preferred,
            edit_student_request.gender,
            edit_student_request.date_of_birth,
            edit_student_request.student_id,
            edit_student_request.esl,
            edit_student_request.current_grade_level,
            edit_student_request.teacher,
            edit_student_request.iep,
            edit_student_request.bip,
            edit_student_request.student_504,
            edit_student_request.readplan,
            edit_student_request.gt,
            edit_student_request.intervention,
            edit_student_request.eye_glasses,
            edit_student_request.notes,
            edit_student_request.pin,
            &pool,
        )
        .await
        {
            Ok(Some(updated_student)) => Ok(updated_student),
            Ok(None) => Err(ServerFnError::new(format!(
                "An None Value was returned instead of an updated student"
            ))),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update student: {}",
                e
            ))),
        }
    }
}
use crate::app::models::test::BenchmarkCategory;
use crate::app::models::TestType;
use crate::app::models::{test::Test, CreateNewTestRequest, DeleteTestRequest, UpdateTestRequest};
use leptos::prelude::*;
use uuid::Uuid;
#[cfg(feature = "ssr")]
use {
    crate::app::db::database, crate::app::db::test_database, actix_web::web, chrono::Local,
    sqlx::PgPool, std::error::Error,
};
//this file contains a list of api functions that will be called on the server side
//lowercase functions denot functions that are server side while upper/camel case functions
//indicate Client side Objects/functions
//
#[server]
pub async fn get_tests() -> Result<Vec<Test>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve all tests from database");

        match test_database::get_all_tests(&pool).await {
            Ok(tests) => {
                log::info!("Successfully retrieved all tests from database");
                Ok(tests)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_tests_batch(test_ids: Vec<Uuid>) -> Result<Vec<Test>, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve a batch of tests from database");

        match test_database::get_tests_batch(test_ids, &pool).await {
            Ok(tests) => {
                log::info!("Successfully retrieved a batch of tests from database");
                Ok(tests)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn get_test(test_id: String) -> Result<Test, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to retrieve test");

        match test_database::get_test(test_id, &pool).await {
            Ok(test) => {
                log::info!("Successfully retrieved test from database");
                Ok(test)
            }
            Err(e) => {
                log::error!("Database error: {}", e);
                Err(ServerFnError::new(format!("Database error: {}", e)))
            }
        }
    }
}

#[server]
pub async fn add_test(add_test_request: CreateNewTestRequest) -> Result<Test, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to add new test to the database");

        let ID = Uuid::new_v4().to_string();
        let bufferTest = Test::new(
            add_test_request.name,
            add_test_request.score,
            add_test_request.instructions,
            add_test_request.comments,
            add_test_request.testarea,
            add_test_request.school_year,
            add_test_request.benchmark_categories,
            add_test_request.test_variant,
            add_test_request.grade_level,
            ID,
            add_test_request.scope,
            add_test_request.course_id,
        );
        test_database::add_test(&bufferTest, &pool)
            .await
            .map_err(|e| {
                log::error!("Database error while adding test: {}", e);
                ServerFnError::new(format!("Database error: {}", e))
            })
    }
}

#[server]
pub async fn delete_test(delete_test_request: DeleteTestRequest) -> Result<Test, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;
        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to delete test");

        match test_database::delete_test(delete_test_request.test_id, &pool).await {
            Ok(deleted) => Ok(deleted),
            Err(_) => Err(ServerFnError::new("Error in deleting test")),
        }
    }
}

#[server]
pub async fn update_test(update_test_request: UpdateTestRequest) -> Result<Test, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to update test");

        let buffer_test = Test::new(
            update_test_request.name,
            update_test_request.score,
            update_test_request.instructions,
            update_test_request.comments,
            update_test_request.testarea,
            update_test_request.school_year,
            update_test_request.benchmark_categories,
            update_test_request.test_variant,
            update_test_request.grade_level,
            update_test_request.test_id,
            update_test_request.scope,
            update_test_request.course_id,
        );

        match test_database::update_test(&buffer_test, &pool).await {
            Ok(Some(updated_test)) => Ok(updated_test),
            Ok(None) => Err(ServerFnError::new(format!(
                "A None value was returned instead of an updated test"
            ))),
            Err(e) => Err(ServerFnError::new(format!("Failed to update test: {}", e))),
        }
    }
}

#[server]
pub async fn score_overrider(test_id: String, score: i32) -> Result<Test, ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use actix_web::web;
        use leptos_actix::extract;

        let pool = extract::<web::Data<PgPool>>()
            .await
            .map_err(|e| ServerFnError::new(format!("Failed to extract pool: {}", e)))?;

        log::info!("Attempting to modify score for a test");

        match test_database::score_override(test_id, score, &pool).await {
            Ok(updated_test) => Ok(updated_test),
            Err(e) => Err(ServerFnError::new(format!(
                "Failed to update student: {}",
                e
            ))),
        }
    }
}
use leptos::prelude::*;
use crate::app::models::user::{SessionUser, UserRole};
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct AuthorizationCheck {
    pub authorized: bool,
    pub user: Option<SessionUser>,
    pub required_role: Option<String>,
    pub redirect_url: Option<String>,
}

#[server]
pub async fn check_authorization(
    required_role: Option<String>,
    required_roles: Option<Vec<String>>,
) -> Result<AuthorizationCheck, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;

        // Get current user from session
        let current_user = get_current_user().await?;

        match current_user {
            Some(user) => {
                let authorized = if let Some(role) = required_role.as_ref() {
                    // Check single role
                    match role.as_str() {
                        "admin" => user.is_admin(),
                        "teacher" => user.is_teacher(),
                        "user" => user.is_user(),
                        "guest" => user.is_guest(),
                        _ => false,
                    }
                } else if let Some(roles) = required_roles.as_ref() {
                    // Check multiple roles (any match)
                    roles.iter().any(|role| match role.as_str() {
                        "admin" => user.is_admin(),
                        "teacher" => user.is_teacher(),
                        "user" => user.is_user(),
                        "guest" => user.is_guest(),
                        _ => false,
                    })
                } else {
                    // No role required, just need to be authenticated
                    true
                };

                Ok(AuthorizationCheck {
                    authorized,
                    user: Some(user),
                    required_role,
                    redirect_url: if authorized {
                        None
                    } else {
                        Some("/".to_string())
                    },
                })
            }
            None => {
                // Not authenticated
                Ok(AuthorizationCheck {
                    authorized: false,
                    user: None,
                    required_role,
                    redirect_url: Some("/login".to_string()),
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}

#[server]
pub async fn check_page_authorization(
    page_path: String,
) -> Result<AuthorizationCheck, leptos::ServerFnError> {
    #[cfg(feature = "ssr")]
    {
        use crate::app::server_functions::auth::get_current_user;

        let current_user = get_current_user().await?;

        match current_user {
            Some(user) => {
                let authorized = match page_path.as_str() {
                    "/dashboard" => true,
                    "/admindashboard" => user.is_admin(),
                    "/admintest" => user.is_teacher(),
                    "/assessments" => user.is_teacher(),
                    "/teachers" => user.is_teacher(),
                    "/gradebook" => user.is_teacher(),
                    "/testbuilder" => user.is_teacher(),
                    "/studentview" => user.is_admin(),
                    "/mathtesting" | "/readingtesting" => user.is_teacher(),
                    _ => true, // Default: allow access
                };

                let redirect_url = if !authorized {
                    if user.is_guest() {
                        Some("/login".to_string())
                    } else {
                        Some("/".to_string()) // Redirect to home if insufficient permissions
                    }
                } else {
                    None
                };

                Ok(AuthorizationCheck {
                    authorized,
                    user: Some(user),
                    required_role: None,
                    redirect_url,
                })
            }
            None => {
                // Not authenticated - redirect to login
                Ok(AuthorizationCheck {
                    authorized: false,
                    user: None,
                    required_role: None,
                    redirect_url: Some("/login".to_string()),
                })
            }
        }
    }

    #[cfg(not(feature = "ssr"))]
    {
        Err(leptos::ServerFnError::ServerError("Not implemented".to_string()))
    }
}
use leptos::prelude::*;
fn parse_csv_to_add_requests(csv_content: &str) -> Result<Vec<AddStudentRequest>, String> {
    let mut lines = csv_content.lines();
    
    // Parse header row to identify column positions
    let header = match lines.next() {
        Some(header) => header,
        None => return Err("CSV file is empty".to_string()),
    };
    
    let headers: Vec<&str> = header.split(',').map(|s| s.trim()).collect();
    let mut column_map = std::collections::HashMap::new();
    
    for (i, col_name) in headers.iter().enumerate() {
        column_map.insert(col_name.to_lowercase(), i);
    }
    
    // Check required columns
    let required_columns = ["firstname", "lastname", "student_id", "grade", "teacher"];
    for &col in required_columns.iter() {
        if !column_map.contains_key(col) {
            return Err(format!("Required column '{}' not found in CSV", col));
        }
    }
    
    // Process data rows
    let mut requests = Vec::new();
    for (line_num, line) in lines.enumerate() {
        let line_num = line_num + 2; // Account for header and 1-indexing
        let fields: Vec<&str> = line.split(',').map(|s| s.trim()).collect();
        
        if fields.len() != headers.len() {
            return Err(format!("Line {} has incorrect number of columns", line_num));
        }
        
        // Helper function to get a field by column name
        let get_field = |name: &str| -> &str {
            if let Some(&index) = column_map.get(name) {
                if index < fields.len() {
                    return fields[index];
                }
            }
            ""
        };
        
        // Helper function to parse boolean fields
        let parse_bool = |name: &str| -> bool {
            let value = get_field(name).to_lowercase();
            match value.as_str() {
                "true" | "yes" | "1" => true,
                _ => false,
            }
        };
        
        // Parse required fields
        let firstname = get_field("firstname").to_string();
        let lastname = get_field("lastname").to_string();
        
        let student_id = match get_field("student_id").parse::<i32>() {
            Ok(id) => id,
            Err(_) => return Err(format!("Invalid student ID on line {}", line_num)),
        };
        
        let grade = match get_field("grade").parse::<i32>() {
            Ok(g) => g,
            Err(_) => return Err(format!("Invalid grade on line {}", line_num)),
        };
        
        let teacher = get_field("teacher").to_string();
        
        // Parse optional fields
        let preferred = if column_map.contains_key("preferred") {
            Some(get_field("preferred").to_string())
        } else {
            None
        };
        
        let gender = if column_map.contains_key("gender") {
            Some(get_field("gender").to_string())
        } else {
            None
        };
        
        let date_of_birth = if column_map.contains_key("date_of_birth") {
            let dob_str = get_field("date_of_birth");
            if !dob_str.is_empty() {
                match NaiveDate::parse_from_str(dob_str, "%Y-%m-%d") {
                    Ok(date) => Some(date),
                    Err(_) => return Err(format!("Invalid date of birth on line {}", line_num)),
                }
            } else {
                None
            }
        } else {
            None
        };
        
        // Create AddStudentRequest
        let request = AddStudentRequest {
            firstname,
            lastname,
            preferred,
            gender,
            date_of_birth,
            student_id,
            esl: parse_bool("esl"),
            grade,
            teacher,
            iep: parse_bool("iep"),
            bip: parse_bool("bip"),
            student_504: parse_bool("student_504"),
            readplan: parse_bool("readplan"),
            gt: parse_bool("gt"),
            intervention: parse_bool("intervention"),
            eye_glasses: parse_bool("eye_glasses"),
            notes: if column_map.contains_key("notes") {
                Some(get_field("notes").to_string())
            } else {
                None
            },
        };
        
        requests.push(request);
    }
    
    Ok(requests)
}
use leptos::prelude::*;
let handle_csv_upload = move |file: File| {
    let reader = FileReader::new().unwrap();
    let reader_clone = reader.clone();
    
    set_is_uploading(true);
    set_upload_status("Reading file...".to_string());
    set_show_status(true);
    set_status_type("info");
    
    // Handle file load completion
    let on_load = Closure::wrap(Box::new(move |_event: web_sys::Event| {
        if let Ok(result) = reader_clone.result() {
            if let Some(text) = result.as_string() {
                // Process CSV data
                match parse_csv_to_add_requests(&text) {
                    Ok(requests) => {
                        if requests.is_empty() {
                            set_upload_status("No valid student records found in CSV".to_string());
                            set_status_type("warning");
                            set_is_uploading(false);
                            return;
                        }
                        
                        set_upload_status(format!("Processing {} students...", requests.len()));
                        
                        // Call the bulk import API
                        spawn_local(async move {
                            match bulk_import_students(requests).await {
                                Ok(result) => {
                                    let message = format!(
                                        "Import completed: {} of {} students added successfully",
                                        result.success_count, result.total
                                    );
                                    set_upload_status(message);
                                    set_status_type(if result.error_count > 0 { "warning" } else { "success" });
                                    set_import_result(Some(result));
                                    
                                    // Refresh the student list if we have a refresh trigger
                                    if let Some(refresh) = refresh_trigger {
                                        refresh.update(|count| *count += 1);
                                    }
                                },
                                Err(err) => {
                                    set_upload_status(format!("Import failed: {}", err));
                                    set_status_type("error");
                                }
                            }
                            set_is_uploading(false);
                        });
                    },
                    Err(err) => {
                        set_upload_status(format!("Error parsing CSV: {}", err));
                        set_status_type("error");
                        set_is_uploading(false);
                    }
                }
            }
        }
    }) as Box<dyn FnMut(_)>);
    
    reader.set_onload(Some(on_load.as_ref().unchecked_ref()));
    reader.read_as_text(&file).unwrap();
    
    // Keep closure alive
    on_load.forget();
};

// Handle file selection from input
let handle_file_select = move |ev: web_sys::Event| {
    let input: HtmlInputElement = ev.target().unwrap().dyn_into().unwrap();
    if let Some(file_list) = input.files() {
        if let Some(file) = file_list.get(0) {
            handle_csv_upload(file);
        }
    }
};
use leptos::prelude::*;
pub mod add_student_form;
pub mod bulk_upload_modal;
pub mod delete_student_confirmation;
pub mod student_details;
pub mod student_search_filter;
pub mod student_table;
pub mod update_student_form;
use leptos::prelude::*;
use log::*;
use crate::app::components::{Toast, ToastMessage, ToastMessageType};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::rc::Rc;

const MODAL_STYLE: &str = 
    "flex flex-col bg-[#F9F9F8] px-6 py-5 w-96 rounded-lg shadow-lg border border-[#DADADA]";

const CARD_STYLE: &str = 
    "flex flex-col items-center justify-center p-4 rounded-lg hover:bg-[#DADADA] border border-[#DADADA] transition-all duration-200 hover:shadow-md cursor-pointer";

const ICON_STYLE: &str = 
    "h-10 w-10 mb-3 p-2 rounded-full bg-[#DADADA] flex items-center justify-center";

const BUTTON_TEXT_STYLE: &str = 
    "text-[#2E3A59] font-medium text-sm mt-1";

#[component]
pub fn ShowAdministerTestModal(set_if_show_modal: WriteSignal<bool>) -> impl IntoView {
    let close_modal = move |_| set_if_show_modal.update(|value| *value = false);

    // Prevent clicks inside the modal from closing the overlay
    let prevent_propagation = move |ev: leptos::ev::MouseEvent| {
        ev.stop_propagation();
    };

    view! {
        <div 
            class=format!("{} animate-slide-in-right", MODAL_STYLE)
            on:click=prevent_propagation
        >
            <div class="mb-4">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xl font-semibold text-[#2E3A59]">Select Assessment Type</h2>
                    /*<button 
                        class="text-gray-400 hover:text-gray-600 transition-colors"
                        on:click=close_modal
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>*/
                </div>
                <p class="text-sm text-gray-500">"Choose which assessment you'd like to administer"</p>
            </div>
            
            <div class="grid grid-cols-2 gap-4">
                <A href="/mathtesting" class=CARD_STYLE on:click=close_modal>
                    <div class=ICON_STYLE>
                        <img src="/assets/calculator.png" class="h-6 w-6" />
                    </div>
                    <span class=BUTTON_TEXT_STYLE>Math</span>
                </A>
                
                <A href="/readingtesting" class=CARD_STYLE on:click=close_modal>
                    <div class=ICON_STYLE>
                        <img src="/assets/reading.png" class="h-6 w-6" />
                    </div>
                    <span class=BUTTON_TEXT_STYLE>Reading</span>
                </A>

            </div>
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::header::Header;
use crate::app::models::assessment::ScopeEnum;
use crate::app::models::student::GradeEnum;
use crate::app::models::test::{CreateNewTestRequest, Test, TestType};
use crate::app::server_functions::questions::duplicate_and_randomize_questions;
use crate::app::server_functions::tests::{add_test, get_tests};
use leptos::ev;
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;
use std::str::FromStr;
use strum::IntoEnumIterator;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VariationType {
    Randomized,
    Distinct,
    Practice,
}

impl VariationType {
    pub fn display_name(&self) -> &'static str {
        match self {
            VariationType::Randomized => "Randomized",
            VariationType::Distinct => "Distinct",
            VariationType::Practice => "Practice",
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            VariationType::Randomized => {
                "Same questions with shuffled order and randomized answer choices"
            }
            VariationType::Distinct => "Entirely different questions covering the same topics",
            VariationType::Practice => {
                "Practice version for student preparation with new questions"
            }
        }
    }

    pub fn detailed_description(&self) -> &'static str {
        match self {
            VariationType::Randomized => "Creates a test variation with the same questions but in randomized order with shuffled answer choices. Questions are automatically generated from the base test.",
            VariationType::Distinct => "Creates a blank test variation where you can add entirely new questions for a different version covering the same material.",
            VariationType::Practice => "Creates a blank practice version where you can add new questions for student practice and preparation.",
        }
    }

    pub fn badge_class(&self) -> &'static str {
        match self {
            VariationType::Randomized => "bg-blue-100 text-blue-800 border-blue-300",
            VariationType::Distinct => "bg-green-100 text-green-800 border-green-300",
            VariationType::Practice => "bg-purple-100 text-purple-800 border-purple-300",
        }
    }

    pub fn card_class(&self) -> &'static str {
        match self {
            VariationType::Randomized => "border-blue-200 bg-blue-50",
            VariationType::Distinct => "border-green-200 bg-green-50",
            VariationType::Practice => "border-purple-200 bg-purple-50",
        }
    }

    pub fn requires_manual_questions(&self) -> bool {
        match self {
            VariationType::Randomized => false,
            VariationType::Distinct => true,
            VariationType::Practice => true,
        }
    }

    pub fn from_test_name(test_name: &str) -> Option<Self> {
        let name_lower = test_name.to_lowercase();
        if name_lower.contains("randomized") {
            Some(VariationType::Randomized)
        } else if name_lower.contains("distinct") {
            Some(VariationType::Distinct)
        } else if name_lower.contains("practice") {
            Some(VariationType::Practice)
        } else {
            None
        }
    }

    pub fn from_comments(comments: &str) -> Option<Self> {
        let comments_lower = comments.to_lowercase();
        if comments_lower.contains("variation: randomized") {
            Some(VariationType::Randomized)
        } else if comments_lower.contains("variation: distinct") {
            Some(VariationType::Distinct)
        } else if comments_lower.contains("variation: practice") {
            Some(VariationType::Practice)
        } else {
            None
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TestVariationInfo {
    pub base_test: Test,
    pub randomized_variations: Vec<Test>,
    pub distinct_variations: Vec<Test>,
    pub practice_variations: Vec<Test>,
}

impl TestVariationInfo {
    pub fn new(base_test: Test) -> Self {
        Self {
            base_test,
            randomized_variations: Vec::new(),
            distinct_variations: Vec::new(),
            practice_variations: Vec::new(),
        }
    }

    pub fn add_variation(&mut self, variation: Test) {
        if let Some(var_type) = VariationType::from_test_name(&variation.name) {
            match var_type {
                VariationType::Randomized => self.randomized_variations.push(variation),
                VariationType::Distinct => self.distinct_variations.push(variation),
                VariationType::Practice => self.practice_variations.push(variation),
            }
        } else if let Some(var_type) = VariationType::from_comments(&variation.comments) {
            match var_type {
                VariationType::Randomized => self.randomized_variations.push(variation),
                VariationType::Distinct => self.distinct_variations.push(variation),
                VariationType::Practice => self.practice_variations.push(variation),
            }
        }
    }

    pub fn total_variations(&self) -> usize {
        self.randomized_variations.len()
            + self.distinct_variations.len()
            + self.practice_variations.len()
    }

    pub fn get_variations_by_type(&self, var_type: &VariationType) -> &Vec<Test> {
        match var_type {
            VariationType::Randomized => &self.randomized_variations,
            VariationType::Distinct => &self.distinct_variations,
            VariationType::Practice => &self.practice_variations,
        }
    }

    pub fn has_variation_type(&self, var_type: &VariationType) -> bool {
        !self.get_variations_by_type(var_type).is_empty()
    }

    pub fn get_all_variations(&self) -> Vec<&Test> {
        let mut all = Vec::new();
        all.extend(self.randomized_variations.iter());
        all.extend(self.distinct_variations.iter());
        all.extend(self.practice_variations.iter());
        all
    }
}

// Utility functions
fn is_variation_test(test: &Test) -> bool {
    test.name.contains(" - ")
        && (VariationType::from_test_name(&test.name).is_some()
            || VariationType::from_comments(&test.comments).is_some())
}

fn get_base_test_name(test_name: &str) -> String {
    if test_name.contains(" - ") {
        test_name
            .split(" - ")
            .next()
            .unwrap_or(test_name)
            .to_string()
    } else {
        test_name.to_string()
    }
}

async fn get_next_variant_number(base_test_name: &str) -> Result<i32, ServerFnError> {
    let all_tests = get_tests().await?;

    // Find all tests with the same base name (including the base test itself)
    let related_tests: Vec<&Test> = all_tests
        .iter()
        .filter(|test| {
            let test_base_name = if test.name.contains(" - ") {
                test.name.split(" - ").next().unwrap_or(&test.name)
            } else {
                &test.name
            };
            test_base_name == base_test_name
        })
        .collect();

    // Find the highest variant number among related tests
    let max_variant = related_tests
        .iter()
        .map(|test| test.test_variant)
        .max()
        .unwrap_or(0);

    Ok(max_variant + 1)
}

fn group_tests_by_base(tests: Vec<Test>) -> Vec<TestVariationInfo> {
    let mut groups: std::collections::HashMap<String, TestVariationInfo> =
        std::collections::HashMap::new();

    for test in tests {
        let base_name = get_base_test_name(&test.name);

        if is_variation_test(&test) {
            groups
                .entry(base_name.clone())
                .and_modify(|group| group.add_variation(test.clone()))
                .or_insert_with(|| {
                    let mut group = TestVariationInfo::new(test.clone());
                    // Clear the base test since we're adding a variation first
                    group.base_test = Test::new(
                        base_name.clone(),
                        0,
                        Some(String::new()),
                        String::new(),
                        test.testarea.clone(),
                        test.school_year.clone(),
                        test.benchmark_categories.clone(),
                        0,
                        test.grade_level.clone(),
                        String::new(),
                        test.scope.clone(),
                        test.course_id.clone(),
                    );
                    group.add_variation(test.clone());
                    group
                });
        } else {
            groups
                .entry(base_name.clone())
                .and_modify(|group| {
                    // Replace placeholder base test if it exists
                    if group.base_test.test_id.is_empty() {
                        group.base_test = test.clone();
                    }
                })
                .or_insert_with(|| TestVariationInfo::new(test.clone()));
        }
    }

    // Filter out groups that only have placeholder base tests
    groups
        .into_values()
        .filter(|group| !group.base_test.test_id.is_empty())
        .collect()
}

#[component]
pub fn TestVariationManager() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/test-variations">
            <TestVariationManagerContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn TestVariationManagerContent() -> impl IntoView {
    let (search_term, set_search_term) = signal(String::new());
    let (selected_base_test, set_selected_base_test) = create_signal::<Option<Test>>(None);
    let (show_create_modal, set_show_create_modal) = signal(false);
    let (selected_variation_type, set_selected_variation_type) =
        create_signal::<Option<VariationType>>(None);
    let (is_creating, set_is_creating) = signal(false);
    let (show_info_panel, set_show_info_panel) = signal(false);

    // Load all tests
    let tests_resource = Resource::new(
        || (),
        |_| async move {
            match get_tests().await {
                Ok(tests) => tests,
                Err(e) => {
                    log::error!("Failed to load tests: {:?}", e);
                    Vec::new()
                }
            }
        },
    );

    // Group tests into variation families
    let test_groups = Memo::new(move |_| {
        let tests = tests_resource.get().unwrap_or_default();
        group_tests_by_base(tests)
    });

    // Filter groups based on search
    let filtered_groups = Memo::new(move |_| {
        let groups = test_groups.get();
        let search = search_term.get().to_lowercase();

        if search.is_empty() {
            groups
        } else {
            groups
                .into_iter()
                .filter(|group| {
                    group.base_test.name.to_lowercase().contains(&search)
                        || group
                            .get_all_variations()
                            .iter()
                            .any(|v| v.name.to_lowercase().contains(&search))
                })
                .collect()
        }
    });

    let create_variation = move |_| {
        if let Some(base_test) = selected_base_test.get() {
            if let Some(var_type) = selected_variation_type.get() {
                set_is_creating(true);

                let base_test_clone = base_test.clone();
                let var_type_clone = var_type.clone();

                spawn_local(async move {
                    let variation_name = format!(
                        "{} - {}",
                        base_test_clone.name,
                        var_type_clone.display_name()
                    );
                    let variation_comments = format!(
                        "Variation: {} of {}",
                        var_type_clone.display_name(),
                        base_test_clone.name
                    );

                    // Get the next sequential variant number
                    let variant_number = match get_next_variant_number(&base_test_clone.name).await
                    {
                        Ok(num) => num,
                        Err(e) => {
                            log::error!("Failed to get next variant number: {:?}", e);
                            // Handle error appropriately - you might want to set an error state
                            set_is_creating(false);
                            return;
                        }
                    };

                    let create_request = CreateNewTestRequest::new(
                        variation_name,
                        base_test_clone.score,
                        base_test_clone.instructions.clone(),
                        variation_comments,
                        base_test_clone.testarea.clone(),
                        base_test_clone.school_year.clone(),
                        base_test_clone.benchmark_categories.clone(),
                        variant_number, // Use the correctly named variable
                        base_test_clone.grade_level.clone(),
                        base_test_clone.scope.clone(),
                        base_test_clone.course_id.clone(),
                    );

                    match add_test(create_request).await {
                        Ok(new_test) => {
                            match var_type_clone {
                                VariationType::Randomized => {
                                    // Generate randomized questions automatically
                                    match duplicate_and_randomize_questions(
                                        base_test_clone.test_id.clone(),
                                        new_test.test_id.clone(),
                                    )
                                    .await
                                    {
                                        Ok(_) => {
                                            log::info!("Successfully created randomized variation");
                                            tests_resource.refetch();
                                            set_show_create_modal(false);
                                            set_selected_variation_type(None);
                                            set_selected_base_test(None);
                                        }
                                        Err(e) => {
                                            log::error!(
                                                "Failed to create randomized questions: {:?}",
                                                e
                                            );
                                        }
                                    }
                                }
                                VariationType::Distinct | VariationType::Practice => {
                                    // Navigate to test builder for manual question entry
                                    tests_resource.refetch();
                                    set_show_create_modal(false);
                                    set_selected_variation_type(None);
                                    set_selected_base_test(None);

                                    let navigate = use_navigate();
                                    navigate(
                                        &format!("/testbuilder/{}", new_test.test_id),
                                        Default::default(),
                                    );
                                }
                            }
                        }
                        Err(e) => {
                            log::error!("Failed to create variation: {:?}", e);
                        }
                    }

                    set_is_creating(false);
                });
            }
        }
    };

    view! {
        <Header />
        <main class="w-full max-w-7xl mx-auto px-6 py-12">
            // Header Section
            <div class="flex flex-col mb-8">
                <h1 class="text-3xl font-semibold text-gray-800">Test Variation Manager</h1>
                <p class="mt-2 text-gray-600">Create and manage different versions of your tests</p>
                <div class="h-0.5 w-full bg-gray-300 mt-3"></div>
            </div>

            // Information Panel
            {move || {
                if show_info_panel() {
                    view! {
                        <div class="mb-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-6 border border-blue-200">
                            <div class="flex items-start justify-between mb-4">
                                <h3 class="text-lg font-medium text-blue-900">Available Variation Types</h3>
                                <button
                                    class="text-blue-600 hover:text-blue-800 text-sm"
                                    on:click=move |_| set_show_info_panel(false)
                                >
                                    "Hide"
                                </button>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <VariationTypeInfo var_type=VariationType::Randomized />
                                <VariationTypeInfo var_type=VariationType::Distinct />
                                <VariationTypeInfo var_type=VariationType::Practice />
                            </div>
                        </div>
                    }.into_any()
                } else {
                    view! {
                        <div class="mb-6">
                            <button
                                class="text-blue-600 hover:text-blue-800 text-sm font-medium"
                                on:click=move |_| set_show_info_panel(true)
                            >
                                "Show Variation Types Info"
                            </button>
                        </div>
                    }.into_any()
                }
            }}

            // Search and Controls
            <div class="mb-6 flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <input
                        type="text"
                        placeholder="Search tests and variations..."
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        prop:value=search_term
                        on:input=move |ev| set_search_term(event_target_value(&ev))
                    />
                </div>
                <button
                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    on:click=move |_| {
                        let navigate = use_navigate();
                        navigate("/testbuilder", Default::default());
                    }
                >
                    "Create New Base Test"
                </button>
            </div>

            // Test Groups Display
            <Suspense fallback=move || view! {
                <div class="animate-pulse space-y-4">
                    {(0..3).map(|_| view! {
                        <div class="bg-gray-200 h-32 rounded-lg"></div>
                    }).collect::<Vec<_>>()}
                </div>
            }>
                <div class="space-y-6">
                    <For
                        each=move || filtered_groups.get()
                        key=|group| group.base_test.test_id.clone()
                        children=move |group: TestVariationInfo| {
                            view! {
                                <TestVariationCard
                                    group=group
                                    on_create_variation=move |test: Test| {
                                        set_selected_base_test(Some(test));
                                        set_show_create_modal(true);
                                    }
                                />
                            }
                        }
                    />
                </div>
            </Suspense>

            // Create Variation Modal
            {move || {
                if show_create_modal() {
                    view! {
                        <CreateVariationModal
                            base_test=selected_base_test
                            selected_type=selected_variation_type
                            set_selected_type=set_selected_variation_type
                            is_creating=is_creating
                            on_create=create_variation
                            on_cancel=move |_| {
                                set_show_create_modal(false);
                                set_selected_variation_type(None);
                                set_selected_base_test(None);
                            }
                        />
                    }.into_any()
                } else {
                    view! { <div></div> }.into_any()
                }
            }}
        </main>
    }
}

#[component]
fn VariationTypeInfo(var_type: VariationType) -> impl IntoView {
    let icon_class = match var_type {
        VariationType::Randomized => "text-blue-600",
        VariationType::Distinct => "text-green-600",
        VariationType::Practice => "text-purple-600",
    };

    view! {
        <div class="bg-white p-4 rounded-lg border border-gray-200">
            <div class="flex items-start space-x-3">
                <div class=format!("flex-shrink-0 w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center {}", icon_class)>
                    {match var_type {
                        VariationType::Randomized => "R",
                        VariationType::Distinct => "D",
                        VariationType::Practice => "P",
                    }}
                </div>
                <div class="flex-1">
                    <h4 class="font-medium text-gray-900">{var_type.display_name()}</h4>
                    <p class="text-sm text-gray-600 mt-1">{var_type.description()}</p>
                    <span class=format!("inline-block mt-2 px-2 py-1 text-xs rounded {}", var_type.badge_class())>
                        {if var_type.requires_manual_questions() { "Manual" } else { "Auto-generated" }}
                    </span>
                </div>
            </div>
        </div>
    }
}

#[component]
fn TestVariationCard(
    group: TestVariationInfo,
    on_create_variation: impl Fn(Test) + 'static + Clone,
) -> impl IntoView {
    let base_test = group.base_test.clone();
    let total_variations = group.total_variations();

    // Clone values we need for the closures
    let base_test_for_create = base_test.clone();
    let base_test_for_edit = base_test.clone();

    view! {
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
            // Base test header
            <div class="bg-gray-50 px-6 py-4 border-b border-gray-200">
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="text-lg font-medium text-gray-900">{base_test.name.clone()}</h3>
                        <p class="text-sm text-gray-600">
                            {format!("{:?} - {} points - Grade: {:?} - {} variation(s)",
                                base_test.testarea,
                                base_test.score,
                                base_test.grade_level.as_ref().map(|g| format!("{:?}", g)).unwrap_or("Not specified".to_string()),
                                total_variations
                            )}
                        </p>
                    </div>
                    <div class="flex space-x-2">
                        <button
                            class="px-3 py-2 bg-green-600 text-white text-sm rounded-md hover:bg-green-700"
                            on:click=move |_| {
                                let test_clone = base_test_for_create.clone();
                                on_create_variation(test_clone);
                            }
                        >
                            "Create Variation"
                        </button>
                        <button
                            class="px-3 py-2 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700"
                            on:click=move |_| {
                                let test_id = base_test_for_edit.test_id.clone();
                                let navigate = use_navigate();
                                navigate(&format!("/testbuilder/{}", test_id), Default::default());
                            }
                        >
                            "Edit Base"
                        </button>
                    </div>
                </div>
            </div>

            // Variations display
            <div class="px-6 py-4">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <VariationTypeSection
                        title="Randomized"
                        variations=group.randomized_variations
                        var_type=VariationType::Randomized
                    />
                    <VariationTypeSection
                        title="Distinct"
                        variations=group.distinct_variations
                        var_type=VariationType::Distinct
                    />
                    <VariationTypeSection
                        title="Practice"
                        variations=group.practice_variations
                        var_type=VariationType::Practice
                    />
                </div>
            </div>
        </div>
    }
}

#[component]
fn VariationTypeSection(
    title: &'static str,
    variations: Vec<Test>,
    var_type: VariationType,
) -> impl IntoView {
    view! {
        <div class=format!("border rounded-lg p-4 {}", var_type.card_class())>
            <h4 class="font-medium text-gray-900 mb-3">{title} " (" {variations.len()} ")"</h4>
            {if variations.is_empty() {
                view! {
                    <p class="text-sm text-gray-500 italic">No {title.to_lowercase()} variations yet</p>
                }.into_any()
            } else {
                view! {
                    <div class="space-y-3">
                        <For
                            each=move || variations.clone()
                            key=|variation| variation.test_id.clone()
                            children=move |variation: Test| {
                                view! {
                                    <VariationCard variation=variation var_type=var_type.clone() />
                                }
                            }
                        />
                    </div>
                }.into_any()
            }}
        </div>
    }
}

#[component]
fn VariationCard(variation: Test, var_type: VariationType) -> impl IntoView {
    let variation_clone = variation.clone();

    view! {
        <div class="bg-white rounded-md p-3 border border-gray-200">
            <div class="flex items-center justify-between mb-2">
                <h5 class="font-medium text-gray-900 text-sm">
                    {variation.name.split(" - ").nth(1).unwrap_or("Variation").to_string()}
                </h5>
                <span class=format!("text-xs px-2 py-1 rounded {}", var_type.badge_class())>
                    v{variation.test_variant}
                </span>
            </div>
            <p class="text-xs text-gray-600 mb-3">
                {format!("{} points", variation.score)}
            </p>
            <div class="flex space-x-2">
                <button
                    class="flex-1 px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
                    on:click=move |_| {
                        let test_id = variation_clone.test_id.clone();
                        let navigate = use_navigate();
                        navigate(&format!("/testbuilder/{}", test_id), Default::default());
                    }
                >
                    "Edit"
                </button>
                <button
                    class="flex-1 px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700"
                    on:click=move |_| {
                        let test_id = variation.test_id.clone();
                        let navigate = use_navigate();
                        navigate(&format!("/test-session/{}", test_id), Default::default());
                    }
                >
                    "Use"
                </button>
            </div>
        </div>
    }
}

#[component]
fn CreateVariationModal(
    base_test: ReadSignal<Option<Test>>,
    selected_type: ReadSignal<Option<VariationType>>,
    set_selected_type: WriteSignal<Option<VariationType>>,
    is_creating: ReadSignal<bool>,
    on_create: impl Fn(ev::MouseEvent) + 'static,
    on_cancel: impl Fn(ev::MouseEvent) + 'static,
) -> impl IntoView {
    view! {
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-lg w-full mx-4">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Create Test Variation</h3>

                {base_test.get().map(|test| view! {
                    <p class="text-sm text-gray-600 mb-6">
                        "Creating variation for: " <strong>{test.name.clone()}</strong>
                    </p>
                })}

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-3">
                        "Choose Variation Type"
                    </label>
                    <div class="space-y-3">
                        <VariationTypeSelector
                            var_type=VariationType::Randomized
                            selected=selected_type
                            set_selected=set_selected_type
                        />
                        <VariationTypeSelector
                            var_type=VariationType::Distinct
                            selected=selected_type
                            set_selected=set_selected_type
                        />
                        <VariationTypeSelector
                            var_type=VariationType::Practice
                            selected=selected_type
                            set_selected=set_selected_type
                        />
                    </div>
                </div>

                <div class="flex justify-end space-x-3">
                    <button
                        class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
                        on:click=on_cancel
                        prop:disabled=is_creating
                    >
                        "Cancel"
                    </button>
                    <button
                        class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
                        on:click=on_create
                        prop:disabled=move || is_creating() || selected_type().is_none()
                    >
                        {move || {
                            if is_creating() {
                                "Creating...".to_string()
                            } else {
                                match selected_type() {
                                    Some(VariationType::Randomized) => "Create & View".to_string(),
                                    Some(VariationType::Distinct) | Some(VariationType::Practice) => "Create & Edit".to_string(),
                                    None => "Select Type".to_string(),
                                }
                            }
                        }}
                    </button>
                </div>
            </div>
        </div>
    }
}

#[component]
fn VariationTypeSelector(
    var_type: VariationType,
    selected: ReadSignal<Option<VariationType>>,
    set_selected: WriteSignal<Option<VariationType>>,
) -> impl IntoView {
    let is_selected = Memo::new(move |_| selected.get() == Some(var_type));

    view! {
        <div
            class=move || {
                let base_class = "border rounded-lg p-4 cursor-pointer transition-all hover:border-gray-400";
                if is_selected() {
                    format!("{} border-blue-500 bg-blue-50 ring-2 ring-blue-500", base_class)
                } else {
                    format!("{} border-gray-300", base_class)
                }
            }
            on:click=move |_| set_selected(Some(var_type))
        >
            <div class="flex items-start space-x-3">
                <input
                    type="radio"
                    class="mt-1"
                    prop:checked=is_selected
                    on:change=move |_| set_selected(Some(var_type))
                />
                <div class="flex-1">
                    <div class="flex items-center space-x-2 mb-2">
                        <h4 class="font-medium text-gray-900">{var_type.display_name()}</h4>
                        <span class=format!("text-xs px-2 py-1 rounded {}", var_type.badge_class())>
                            {if var_type.requires_manual_questions() { "Manual" } else { "Auto" }}
                        </span>
                    </div>
                    <p class="text-sm text-gray-600">{var_type.detailed_description()}</p>
                </div>
            </div>
        </div>
    }
}
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;
use std::rc::Rc;

#[component]
pub fn SelectTestModal(
    test: Rc<Test>,
    show_modal: ReadSignal<bool>,
    set_show_modal: WriteSignal<bool>,
) -> impl IntoView {
    // Create separate variables for each navigation type to avoid borrow checker issues
    let realtime_test = test.clone();
    let individual_test = test.clone();
    let grid_test = test.clone();

    // Event handlers for each type of test navigation
    let on_realtime_click = move |_| {
        let test_id = realtime_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/test-session/{}", test_id), Default::default());
        set_show_modal.set(false);
    };

    let on_individual_click = move |_| {
        let test_id = individual_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/flashcardset/{}", test_id), Default::default());
        set_show_modal.set(false);
    };

    let on_grid_test_click = move |_| {
        let test_id = grid_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/gridtest/{}", test_id), Default::default());
        set_show_modal.set(false);
    };

    // Event handler for cancel button
    let on_cancel_click = move |_| {
        set_show_modal.set(false);
    };

    // Check if this is a variation test for display purposes
    let is_variation = test.name.contains(" - ")
        && (test.name.to_lowercase().contains("randomized")
            || test.name.to_lowercase().contains("distinct")
            || test.name.to_lowercase().contains("practice")
            || test.comments.to_lowercase().contains("variation:"));

    // Extract base name and variation type for display
    let (base_name, variation_type) = if is_variation {
        let parts: Vec<&str> = test.name.split(" - ").collect();
        (
            parts
                .get(0)
                .map(|s| s.to_string())
                .unwrap_or_else(|| test.name.clone()),
            parts.get(1).map_or("Variation", |v| v).to_string(),
        )
    } else {
        (test.name.clone(), String::new())
    };

    view! {
        <Show when=move || show_modal()>
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Choose Test Mode</h3>

                    // Show variation info in modal if applicable
                    {if is_variation {
                        view! {
                            <div class="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                <p class="text-sm text-blue-800">
                                    "Using " <strong>{variation_type.clone()}</strong> " version of " <strong>{base_name.clone()}</strong>
                                </p>
                            </div>
                        }
                    } else {
                        view! { <div></div> }
                    }}

                    <div class="space-y-4">
                        <button
                            class="w-full p-3 bg-blue-600 text-white rounded-lg flex items-center justify-between hover:bg-blue-700 transition-colors"
                            on:click=on_realtime_click.clone()
                        >
                            <span class="text-lg">Real-time Live Testing</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                            </svg>
                        </button>

                        <button
                            class="w-full p-3 bg-green-600 text-white rounded-lg flex items-center justify-between hover:bg-green-700 transition-colors"
                            on:click=on_individual_click.clone()
                        >
                            <span class="text-lg">Individual Flashcard Test</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                            </svg>
                        </button>

                        <button
                            class="w-full p-3 bg-purple-600 text-white rounded-lg flex items-center justify-between hover:bg-purple-700 transition-colors"
                            on:click=on_grid_test_click.clone()
                        >
                            <span class="text-lg">Grid Test</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>

                    <div class="mt-6 flex justify-end">
                        <button
                            class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 transition-colors"
                            on:click=on_cancel_click
                        >
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </Show>
    }
}
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;
use std::rc::Rc;

#[component]
pub fn GenericTestModal(test_id: String, test_name: String, children: Children) -> impl IntoView {
    let (show_options_modal, set_show_options_modal) = signal(false);
    let name_clone = test_name.clone();

    // Handle wrapper click to show the modal
    let on_wrapper_click = move |_| {
        set_show_options_modal.set(true);
    };

    // Navigation functions for different test modes
    let test_id_clone = test_id.clone();
    let on_realtime_click = move |_| {
        let navigate = use_navigate();
        navigate(
            &format!("/test-session/{}", test_id_clone),
            Default::default(),
        );
        set_show_options_modal.set(false);
    };

    let test_id_clone = test_id.clone();
    let on_individual_click = move |_| {
        let navigate = use_navigate();
        navigate(
            &format!("/flashcardset/{}", test_id_clone),
            Default::default(),
        );
        set_show_options_modal.set(false);
    };

    let test_id_clone = test_id.clone();
    let on_grid_test_click = move |_| {
        let navigate = use_navigate();
        navigate(&format!("/gridtest/{}", test_id_clone), Default::default());
        set_show_options_modal.set(false);
    };

    let on_cancel_click = move |_| {
        set_show_options_modal.set(false);
    };

    view! {
        <div class="relative cursor-pointer" on:click=on_wrapper_click>
            {children()}

            // Test Options Modal
            {move || {
                if show_options_modal() {
                    view! {
                        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                             on:click=move |e| {
                                 // Stop propagation to prevent modal closing when clicking inside it
                                 e.stop_propagation();
                             }
                        >
                            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                                <h3 class="text-xl font-semibold text-gray-800 mb-4">"Test Options: " {name_clone.clone()}</h3>
                                <div class="space-y-4">
                                    <button
                                        class="w-full p-3 bg-blue-600 text-white rounded-lg flex items-center justify-between hover:bg-blue-700 transition-colors"
                                        on:click=on_realtime_click.clone()
                                    >
                                        <span class="text-lg">"Real-time Live Testing"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-green-600 text-white rounded-lg flex items-center justify-between hover:bg-green-700 transition-colors"
                                        on:click=on_individual_click.clone()
                                    >
                                        <span class="text-lg">"Individual Flashcard Test"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-purple-600 text-white rounded-lg flex items-center justify-between hover:bg-purple-700 transition-colors"
                                        on:click=on_grid_test_click.clone()
                                    >
                                        <span class="text-lg">"Grid Test"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                                        </svg>
                                    </button>
                                </div>

                                <div class="mt-6 flex justify-end">
                                    <button
                                        class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 transition-colors"
                                        on:click=on_cancel_click
                                    >
                                        "Cancel"
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}
        </div>
    }
}

#[component]
pub fn TestItem(test: Test, test_id: String, test_name: String) -> impl IntoView {
    let (show_options_modal, set_show_options_modal) = signal(false);
    let name_clone = test_name.clone();

    // Handle test click to show the modal
    let on_test_click = move |_| {
        set_show_options_modal.set(true);
    };

    // Navigation functions for different test modes
    let test_id_clone = test_id.clone();
    let on_realtime_click = move |_| {
        let navigate = use_navigate();
        navigate(
            &format!("/test-session/{}", test_id_clone),
            Default::default(),
        );
        set_show_options_modal.set(false);
    };

    let test_id_clone = test_id.clone();
    let on_individual_click = move |_| {
        let navigate = use_navigate();
        navigate(
            &format!("/flashcardset/{}", test_id_clone),
            Default::default(),
        );
        set_show_options_modal.set(false);
    };

    let test_id_clone = test_id.clone();
    let on_grid_test_click = move |_| {
        let navigate = use_navigate();
        navigate(&format!("/gridtest/{}", test_id_clone), Default::default());
        set_show_options_modal.set(false);
    };

    let on_cancel_click = move |_| {
        set_show_options_modal.set(false);
    };

    view! {
        <div class="relative">
            <button
                class="flex items-center space-x-2 p-2 rounded bg-gray-50 hover:bg-gray-100 w-full text-left transition-colors"
                on:click=on_test_click
            >
                <span class="text-sm font-medium mr-2">{test_name}</span>
                <span class="text-xs text-gray-500 ml-auto">"Score: " {test.score}</span>
            </button>

            // Test Options Modal
            {move || {
                if show_options_modal() {
                    view! {
                        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                                <h3 class="text-xl font-semibold text-gray-800 mb-4">"Test Options: " {name_clone.clone()}</h3>
                                <div class="space-y-4">
                                    <button
                                        class="w-full p-3 bg-blue-600 text-white rounded-lg flex items-center justify-between hover:bg-blue-700 transition-colors"
                                        on:click=on_realtime_click.clone()
                                    >
                                        <span class="text-lg">"Real-time Live Testing"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-green-600 text-white rounded-lg flex items-center justify-between hover:bg-green-700 transition-colors"
                                        on:click=on_individual_click.clone()
                                    >
                                        <span class="text-lg">"Individual Flashcard Test"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-purple-600 text-white rounded-lg flex items-center justify-between hover:bg-purple-700 transition-colors"
                                        on:click=on_grid_test_click.clone()
                                    >
                                        <span class="text-lg">"Grid Test"</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                                        </svg>
                                    </button>
                                </div>

                                <div class="mt-6 flex justify-end">
                                    <button
                                        class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 transition-colors"
                                        on:click=on_cancel_click
                                    >
                                        "Cancel"
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}
        </div>
    }
}
use crate::app::components::{ShowTestModal, ToastMessage};
use crate::app::models::{Test, TestType};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::use_navigate;
use leptos_router::hooks::*;
use std::cell::RefCell;
use std::rc::Rc;

const DISPLAY_TEST_STYLE: &str = "group block w-full overflow-hidden border border-gray-200 rounded-lg bg-white shadow-sm hover:shadow-md transition-all duration-300";
const DISPLAY_TEST_EDIT_STYLE: &str = "group block w-full overflow-hidden rounded-lg bg-[#F44336] bg-opacity-40 hover:scale-105 hover:-translate-y-1 transition-all duration-300";

const IMG_SRC: &str = "/assets/math.png";

const CAPTION_STYLE: &str = "text-lg font-medium text-[#2E3A59]";
const INFO_STYLE: &str = "text-sm text-gray-600";
const SCORE_STYLE: &str = "text-md font-semibold text-[#2E3A59]";

#[component]
pub fn MathTestDisplay(
    test: Rc<Test>,
    test_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    set_if_show_toast: WriteSignal<bool>,
    set_toast_message: WriteSignal<ToastMessage>,
    editing_mode: ReadSignal<bool>,
    on_delete: Option<Callback<String>>,
    show_delete_mode: ReadSignal<bool>,
    show_variations: Option<bool>,
    all_tests: Option<ReadSignal<Vec<Test>>>,
) -> impl IntoView {
    let edit_test = test.clone();
    let (show_options_modal, set_show_options_modal) = signal(false);
    let (show_variations_panel, set_show_variations_panel) = signal(false);

    // Determine if this is a variation
    let is_variation = test.name.contains(" - ")
        && (test.name.to_lowercase().contains("remediation")
            || test.name.to_lowercase().contains("advanced")
            || test.name.to_lowercase().contains("easy")
            || test.name.to_lowercase().contains("hard")
            || test.comments.to_lowercase().contains("variation:"));

    // Extract base name and variation type
    let (base_name, variation_type) = if is_variation {
        let parts: Vec<&str> = test.name.split(" - ").collect();
        (
            parts
                .get(0)
                .map(|s| s.to_string())
                .unwrap_or_else(|| test.name.clone()),
            parts.get(1).map_or("Variation", |v| v).to_string(),
        )
    } else {
        (test.name.clone(), String::new())
    };

    // Find related variations if all_tests is provided
    let related_variations = Memo::new({
        let test_clone = test.clone();
        let base_name_clone = base_name.clone();
        let test_id_clone = test.test_id.clone();

        move |_| {
            if let Some(all_tests_signal) = all_tests {
                let all = all_tests_signal.get();
                let current_base = if is_variation {
                    base_name_clone.clone()
                } else {
                    test_clone.name.clone()
                };

                all.into_iter()
                    .filter(|t| {
                        let t_base = if t.name.contains(" - ") {
                            t.name.split(" - ").next().unwrap_or(&t.name).to_string()
                        } else {
                            t.name.clone()
                        };
                        t_base == current_base && t.test_id != test_id_clone
                    })
                    .collect::<Vec<_>>()
            } else {
                Vec::new()
            }
        }
    });

    // Handle showing selection modal instead of direct navigation
    let on_show_info = move |_| {
        if editing_mode() {
            // In editing mode, navigate directly to test builder
            let test_id = edit_test.test_id.clone();
            let navigate = use_navigate();
            navigate(&format!("/testbuilder/{}", test_id), Default::default());
        } else {
            // Show options modal in normal mode
            set_show_options_modal.set(true);
        }
    };

    let styling = move || {
        if editing_mode() {
            DISPLAY_TEST_EDIT_STYLE
        } else {
            DISPLAY_TEST_STYLE
        }
    };

    // Clone test for school_year_display closure
    let sy_test = test.clone();
    let school_year_display = move || match &sy_test.school_year {
        Some(year) if !year.is_empty() => year.clone(),
        _ => "Not specified".to_string(),
    };

    // Clone test for grade_level_display closure
    let gl_test = test.clone();
    let grade_level_display = move || match &gl_test.grade_level {
        Some(grade) => format!("{:?}", grade),
        None => "Not specified".to_string(),
    };

    // Clone test for benchmark_info closure
    let bm_test = test.clone();
    let benchmark_info = move || {
        match &bm_test.benchmark_categories {
            Some(categories) if !categories.is_empty() => {
                let category = &categories[0]; // Display first category info
                format!(
                    "Range: {} - {} ({})",
                    category.min, category.max, &category.label
                )
            }
            _ => "No benchmark data".to_string(),
        }
    };

    // Clone test for comments display
    let comments_test = test.clone();
    let content_test = test.clone();
    let has_comments = move || !comments_test.comments.is_empty();
    let comments_content = move || content_test.comments.clone();

    // Create score value for display
    let score_value = test.score.to_string();
    let test_name = test.name.clone();

    // Clone test for delete functionality
    let delete_test = test.clone();

    // Create separate variables for each navigation type
    let realtime_test = test.clone();
    let individual_test = test.clone();
    let grid_test = test.clone();
    let set_modal = set_show_options_modal.clone();

    let on_realtime_click = move |_| {
        let test_id = realtime_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/test-session/{}", test_id), Default::default());
        set_modal.set(false);
    };

    let on_individual_click = move |_| {
        let test_id = individual_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/flashcardset/{}", test_id), Default::default());
        set_modal.set(false);
    };

    let on_grid_test_click = move |_| {
        let test_id = grid_test.test_id.clone();
        let navigate = use_navigate();
        navigate(&format!("/gridtest/{}", test_id), Default::default());
        set_modal.set(false);
    };

    let on_cancel_click = move |_| {
        set_show_options_modal.set(false);
    };

    let on_show_variations = move |_| {
        set_show_variations_panel.set(!show_variations_panel());
    };

    view! {
        <div class="z-auto relative h-full">
            <button
                on:click=on_show_info
                class="w-full text-left"
            >
                <div class=styling>
                    <div class="flex items-center p-4">
                        <div class="w-12 h-12 flex-shrink-0">
                            <img src=IMG_SRC class="w-full h-full object-cover" />
                        </div>
                        <div class="ml-4 flex-grow">
                            <div class="flex items-center space-x-2">
                                <p class=CAPTION_STYLE>
                                    {if is_variation { base_name.clone() } else { test_name.clone() }}
                                </p>
                                {if is_variation {
                                    view! {
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                                            {variation_type.clone()}
                                        </span>
                                    }
                                } else {
                                    view! { <span></span> }
                                }}
                            </div>
                            <div class="mt-2 space-y-1">
                                <p class=SCORE_STYLE>
                                    "Total Score: " {score_value}
                                </p>
                                <p class=INFO_STYLE>
                                    "School Year: " {school_year_display}
                                </p>
                                <p class=INFO_STYLE>
                                    "Grade Level: " {grade_level_display}
                                </p>
                                {move || {
                                    if has_comments() {
                                        view! {
                                            <div>
                                                <p class=INFO_STYLE>
                                                    "Notes: " {comments_content()}
                                                </p>
                                            </div>
                                        }
                                    } else {
                                        view! { <div></div> }
                                    }
                                }}
                                <p class="text-xs text-gray-500 italic mt-1">
                                    {benchmark_info}
                                </p>

                                // Show variations count if applicable
                                {move || {
                                    let variations = related_variations.get();
                                    if !variations.is_empty() && show_variations.unwrap_or(false) {
                                        view! {
                                            <div class="flex items-center space-x-2 mt-2">
                                                <button
                                                    class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 px-2 py-1 rounded transition-colors"
                                                    on:click=move |e| {
                                                        e.stop_propagation();
                                                        on_show_variations(e);
                                                    }
                                                >
                                                    {format!("{} variation(s)", variations.len())}
                                                </button>
                                            </div>
                                        }
                                    } else {
                                        view! { <div></div> }
                                    }
                                }}
                            </div>
                        </div>
                        <div class="flex-shrink-0 ml-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                        </div>
                    </div>
                </div>
            </button>

            // Variations panel (expandable)
            {move || {
                if show_variations_panel() && show_variations.unwrap_or(false) {
                    let variations = related_variations.get();
                    view! {
                        <div class="bg-gray-50 border-t border-gray-200 px-4 py-3">
                            <h4 class="text-sm font-medium text-gray-700 mb-2">Related Tests:</h4>
                            <div class="space-y-2">
                                <For
                                    each=move || variations.clone()
                                    key=|variation| variation.test_id.clone()
                                    children=move |variation: Test| {
                                        let var_clone = variation.clone();
                                        let is_var = variation.name.contains(" - ");
                                        let display_name = if is_var {
                                            variation.name.split(" - ").nth(1).unwrap_or("Variation").to_string()
                                        } else {
                                            "Base Test".to_string()
                                        };

                                        view! {
                                            <div class="flex items-center justify-between bg-white rounded px-3 py-2 border border-gray-200">
                                                <div class="flex items-center space-x-2">
                                                    <span class="text-sm font-medium text-gray-900">
                                                        {display_name}
                                                    </span>
                                                    <span class="text-xs text-gray-500">
                                                        "({variation.score} pts)"
                                                    </span>
                                                </div>
                                                <div class="flex space-x-2">
                                                    <button
                                                        class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 px-2 py-1 rounded transition-colors"
                                                        on:click=move |e| {
                                                            e.stop_propagation();
                                                            let test_id = var_clone.test_id.clone();
                                                            let navigate = use_navigate();
                                                            navigate(&format!("/testbuilder/{}", test_id), Default::default());
                                                        }
                                                    >
                                                        "Edit"
                                                    </button>
                                                    <button
                                                        class="text-xs bg-green-100 hover:bg-green-200 text-green-800 px-2 py-1 rounded transition-colors"
                                                        on:click=move |e| {
                                                            e.stop_propagation();
                                                            // Navigate to test taking interface
                                                            let test_id = variation.test_id.clone();
                                                            let navigate = use_navigate();
                                                            navigate(&format!("/test-session/{}", test_id), Default::default());
                                                        }
                                                    >
                                                        "Use"
                                                    </button>
                                                </div>
                                            </div>
                                        }
                                    }
                                />
                            </div>
                            <div class="mt-3 pt-2 border-t border-gray-200">
                                <button
                                    class="text-xs bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded transition-colors"
                                    on:click=move |e| {
                                        e.stop_propagation();
                                        let navigate = use_navigate();
                                        navigate("/test-variations", Default::default());
                                    }
                                >
                                    "Manage All Variations"
                                </button>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}

            // Test Options Modal (existing code)
            {move || {
                if show_options_modal() {
                    view! {
                        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                                <h3 class="text-xl font-semibold text-gray-800 mb-4">Choose Test Mode</h3>

                                // Show variation info in modal if applicable
                                {if is_variation {
                                    view! {
                                        <div class="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                            <p class="text-sm text-blue-800">
                                                "Using " <strong>{variation_type.clone()}</strong> " version of " <strong>{base_name.clone()}</strong>
                                            </p>
                                        </div>
                                    }
                                } else {
                                    view! { <div></div> }
                                }}

                                <div class="space-y-4">
                                    <button
                                        class="w-full p-3 bg-blue-600 text-white rounded-lg flex items-center justify-between hover:bg-blue-700 transition-colors"
                                        on:click=on_realtime_click.clone()
                                    >
                                        <span class="text-lg">Real-time Live Testing</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-green-600 text-white rounded-lg flex items-center justify-between hover:bg-green-700 transition-colors"
                                        on:click=on_individual_click.clone()
                                    >
                                        <span class="text-lg">Individual Flashcard Test</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                                        </svg>
                                    </button>

                                    <button
                                        class="w-full p-3 bg-purple-600 text-white rounded-lg flex items-center justify-between hover:bg-purple-700 transition-colors"
                                        on:click=on_grid_test_click.clone()
                                    >
                                        <span class="text-lg">Grid Test</span>
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                                            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>

                                <div class="mt-6 flex justify-end">
                                    <button
                                        class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300 transition-colors"
                                        on:click=on_cancel_click
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}

            // Delete button (existing code)
            {move || {
                if show_delete_mode() && on_delete.is_some() {
                    let test_id = delete_test.test_id.clone();

                    let delete_action = move |_| {
                        if let Some(delete_fn) = on_delete.clone() {
                            delete_fn(test_id.clone());
                        }
                    };

                    view! {
                        <div class="absolute top-2 right-2 z-10">
                            <button
                                class="bg-red-600 text-white p-2 rounded-full shadow-md hover:bg-red-700 transition-colors"
                                on:click=delete_action
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}
        </div>
    }
}
use leptos::prelude::*;

#[component]
pub fn TestInstructions(instructions: Option<String>) -> impl IntoView {
    let (is_expanded, set_is_expanded) = signal(false);
    
    let has_instructions = instructions.as_ref().map(|i| !i.trim().is_empty()).unwrap_or(false);
    
    if !has_instructions {
        return view! { <div></div> }.into_any();
    }
    
    let instructions_text = instructions.unwrap_or_default();
    
    // Create a separate handler function
    let toggle_expanded = move |_| {
        set_is_expanded.update(|expanded| *expanded = !*expanded);
    };

    // Combined SVG class computation
    let svg_class = move || {
        let base = "w-4 h-4 text-blue-600 transition-transform duration-200";
        if is_expanded() {
            format!("{} rotate-180", base)
        } else {
            base.to_string()
        }
    };
    
    view! {
        <div class="mb-6 flex items-center justify-center">
            <div class="w-1/2 bg-blue-50 border-l-4 border-blue-400 overflow-hidden rounded-lg">
                <button
                    class="w-full px-4 py-3 text-left focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded-t-lg hover:bg-blue-100 transition-colors"
                    on:click=toggle_expanded
                >
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                            <h3 class="text-sm font-medium text-blue-800">
                                "Test Instructions"
                            </h3>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-xs text-blue-600 font-medium">
                                {move || if is_expanded() { "Hide" } else { "Show" }}
                            </span>
                            <svg 
                                class=svg_class
                                fill="none" 
                                stroke="currentColor" 
                                viewBox="0 0 24 24"
                            >
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                </button>
                
                <Show when=move || is_expanded()>
                    <div class="px-4 pb-4 pt-2">
                        <div class="bg-white rounded border border-blue-200 p-4">
                            <div class="text-sm text-gray-700 whitespace-pre-wrap leading-relaxed">
                                {instructions_text.clone()}
                            </div>
                        </div>
                    </div>
                </Show>
            </div>
        </div>
    }.into_any()
}
use crate::app::models::{Question, QuestionType, WeightedOption};
use leptos::html;
use leptos::prelude::*;
use std::rc::Rc;
use std::str::FromStr;

#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

const FIELD_TITLE: &str = "mt-5 font-base text-[#00356b] text-xl";
const INPUT: &str = "w-40 h-12 border-[#00356b] border pr-4 pl-6 py-4 text-[#00356b] rounded transition-all duration-1000 ease-in-out";
const INPUT_QUESTION: &str = "w-full h-12 border-[#00356b] border pr-4 pl-6 py-4 text-[#00356b] rounded transition-all duration-1000 ease-in-out";
const UNSELECTED_BUTTON: &str = "w-40 h-12 bg-gray-300 border-[#00356b] border pr-4 pl-6 py-4 text-[#00356b] rounded transition-all duration-1000 ease-in-out";
const SELECTED_BUTTON: &str = "w-40 h-12 bg-[#00356b] pr-4 pl-6 py-4 text-white rounded transition-all duration-1000 ease-in-out";
const INPUT_SELECTOR: &str ="w-45 h-12 border-[#00356b] border pr-4 pl-6 py-2 text-[#00356b] rounded transition-all duration-1000 ease-in-out";

#[component]
pub fn BuildingQuestion(
    initial_question: Question,
    on_update: Callback<Question>,
    on_remove: Callback<()>,
    on_duplicate: Option<Callback<Question>>,
    should_auto_focus: Memo<bool>,   // Changed from ReadSignal to Memo
    on_focus_complete: Callback<()>, // New callback to clear auto-focus
) -> impl IntoView {
    let (question_data, set_question_data) = signal(initial_question.clone());
    let question_input_ref = create_node_ref::<html::Textarea>();

    // Store initial_question for use in different closures
    let initial_question_clone = initial_question.clone();
    let initial_question_for_header = initial_question.clone();

    // Effect to update question_data when initial_question changes (for edit mode)
    Effect::new(move |_| {
        let current_initial = initial_question_clone.clone();
        set_question_data.update(|q| {
            // Only update if the question actually changed to avoid infinite loops
            if q.testlinker != current_initial.testlinker
                || q.qnumber != current_initial.qnumber
                || (q.word_problem.is_empty() && !current_initial.word_problem.is_empty())
            {
                *q = current_initial;
            }
        });
    });

    // Improved auto-focus mechanism with cleanup
    Effect::new(move |_| {
        if should_auto_focus() {
            if let Some(input) = question_input_ref.get() {
                #[cfg(feature = "hydrate")]
                {
                    request_animation_frame(move || {
                        let focus_result = input.focus();
                        if focus_result.is_ok() {
                            // Call the completion callback after successful focus
                            on_focus_complete(());
                        }
                    });
                }
                #[cfg(not(feature = "hydrate"))]
                {
                    // On server side, just call the completion callback immediately
                    on_focus_complete(());
                }
            }
        }
    });

    let update_field = move |field: &'static str, value: String| {
        set_question_data.update(|q| match field {
            "word_problem" => q.word_problem = value,
            "point_value" => q.point_value = value.parse().unwrap_or(1), // Default to 1 instead of 0
            "question_type" => {
                if !value.is_empty() {
                    let new_type = QuestionType::from_str(match value.as_str() {
                        "MultipleChoice" => "Multiple choice",
                        "Written" => "Written",
                        "Selection" => "Selection",
                        "TrueFalse" => "True False",
                        "WeightedMultipleChoice" => "Weighted Multiple Choice",
                        _ => "",
                    })
                    .unwrap_or(QuestionType::MultipleChoice);

                    // Only update if the type is actually different to avoid unnecessary resets
                    if q.question_type != new_type {
                        q.question_type = new_type.clone();

                        match new_type {
                            QuestionType::TrueFalse => {
                                q.options = vec!["true".to_string(), "false".to_string()];
                                q.correct_answer = "true".to_string();
                                q.weighted_options = None;
                            }
                            QuestionType::MultipleChoice => {
                                // Preserve existing options if they exist and are valid
                                if q.options.is_empty() || q.weighted_options.is_some() {
                                    q.options = vec!["".to_string(), "".to_string()];
                                }
                                // Set first option as correct if no correct answer or if coming from weighted
                                if q.correct_answer.is_empty() || q.weighted_options.is_some() {
                                    q.correct_answer =
                                        q.options.first().cloned().unwrap_or_default();
                                }
                                q.weighted_options = None;
                            }
                            QuestionType::WeightedMultipleChoice => {
                                // Clear regular options when switching to weighted
                                q.options = Vec::new();
                                q.correct_answer = String::new();
                                if q.weighted_options.is_none()
                                    || q.get_weighted_options().is_empty()
                                {
                                    let default_options = vec![
                                        WeightedOption::new("".to_string(), 1, true),
                                        WeightedOption::new("".to_string(), 1, true),
                                    ];
                                    q.set_weighted_options(default_options);
                                }
                            }
                            _ => {
                                q.options = Vec::new();
                                q.correct_answer = String::new();
                                q.weighted_options = None;
                            }
                        }
                    }
                }
            }
            _ => {}
        });
        on_update(question_data());
    };

    let handle_options_update = move |(options, correct_answer): (Vec<String>, String)| {
        set_question_data.update(|q| {
            q.options = options;
            q.correct_answer = correct_answer;
        });
        on_update(question_data());
    };

    let handle_weighted_options_update = move |weighted_options: Vec<WeightedOption>| {
        set_question_data.update(|q| {
            q.set_weighted_options(weighted_options.clone());
            q.options = weighted_options
                .iter()
                .map(|opt| opt.text.clone())
                .collect();
            let selectable_options: Vec<String> = weighted_options
                .iter()
                .filter(|opt| opt.is_selectable)
                .map(|opt| opt.text.clone())
                .collect();
            q.correct_answer = serde_json::to_string(&selectable_options).unwrap_or_default();
        });
        on_update(question_data());
    };

    let question_type_to_value = move |question_type: &QuestionType| -> String {
        match question_type {
            QuestionType::MultipleChoice => "MultipleChoice".to_string(),
            QuestionType::Written => "Written".to_string(),
            QuestionType::Selection => "Selection".to_string(),
            QuestionType::TrueFalse => "TrueFalse".to_string(),
            QuestionType::WeightedMultipleChoice => "WeightedMultipleChoice".to_string(),
        }
    };

    view! {
        <div class="question-builder p-6 border rounded-lg mb-6 bg-white shadow-sm hover:shadow-md transition-shadow">
            // Question header with actions
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-[#00356b]">
                    "Question " {initial_question.qnumber}
                </h3>
                <div class="flex space-x-2">
                    {move || {
                        if let Some(duplicate_callback) = on_duplicate {
                            view! {
                                <button
                                    type="button"
                                    class="px-3 py-1 text-sm bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors"
                                    on:click=move |_| duplicate_callback(question_data())
                                    title="Duplicate this question"
                                >
                                    "Duplicate"
                                </button>
                            }.into_any()
                        } else {
                            view! { <div></div> }.into_any()
                        }
                    }}
                    <button
                        type="button"
                        class="px-3 py-1 text-sm bg-red-100 text-red-700 rounded hover:bg-red-200 transition-colors"
                        on:click=move |_| on_remove(())
                        title="Remove this question"
                    >
                        "Remove"
                    </button>
                </div>
            </div>

            // Question text with enhanced input
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    "Question Text"
                    <span class="text-red-500">"*"</span>
                </label>
                <textarea
                    node_ref=question_input_ref
                    placeholder="Enter your question here..."
                    class="w-full h-20 px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all resize-none"
                    prop:value=move || question_data.with(|q| q.word_problem.clone())
                    on:input=move |event| update_field("word_problem", event_target_value(&event))
                ></textarea>
            </div>

            // Point value and question type in a row
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        "Point Value" <span class="text-red-500">"*"</span>
                    </label>
                    <input
                        type="number"
                        min="1"
                        placeholder="Points"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        prop:value=move || question_data.with(|q| q.point_value.to_string())
                        on:input=move |event| update_field("point_value", event_target_value(&event))
                        on:focus=move |event| {
                            // Select all text when focused - only on client side
                            #[cfg(feature = "hydrate")]
                            {
                                if let Some(target) = event.target() {
                                    if let Ok(input) = target.dyn_into::<web_sys::HtmlInputElement>() {
                                        let _ = input.select();
                                    }
                                }
                            }
                        }
                    />
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        "Question Type" <span class="text-red-500">"*"</span>
                    </label>
                    <select
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        prop:value=move || question_data.with(|q| question_type_to_value(&q.question_type))
                        on:change=move |event| update_field("question_type", event_target_value(&event))
                    >
                        // Most common types first
                        <option value="MultipleChoice">"Multiple Choice"</option>
                        <option value="TrueFalse">"True/False"</option>
                        <option value="WeightedMultipleChoice">"Weighted Multiple Choice"</option>
                    </select>
                </div>
            </div>

            // Question type specific content
            <div class="border-t pt-4">
                {move || match question_data.with(|q| q.question_type.clone()) {
                    QuestionType::MultipleChoice => {
                        let options = question_data.with(|q| q.options.clone());
                        let correct_answer = question_data.with(|q| q.correct_answer.clone());
                        view! {
                            <MultipleChoice
                                options=options
                                designated_answer=correct_answer
                                on_change=Callback::new(handle_options_update)
                            />
                        }.into_any()
                    },
                    QuestionType::TrueFalse => {
                        let designated_answer = question_data.with(|q| q.correct_answer.clone());
                        view! {
                            <TrueFalse
                                designated_answer=designated_answer
                                on_change=Callback::new(handle_options_update)
                            />
                        }.into_any()
                    },
                    QuestionType::WeightedMultipleChoice => {
                        let weighted_options = question_data.with(|q| q.get_weighted_options());
                        let max_points = question_data.with(|q| q.point_value);
                        view! {
                            <WeightedMultipleChoice
                                weighted_options=weighted_options
                                max_points=max_points
                                on_change=Callback::new(handle_weighted_options_update)
                            />
                        }.into_any()
                    },
                    _ => view! {
                        <div class="bg-gray-50 border border-gray-200 rounded p-4 text-center text-gray-500">
                            "Please select a question type to continue"
                        </div>
                    }.into_any(),
                }}
            </div>
        </div>
    }
}

#[component]
pub fn WeightedMultipleChoice(
    weighted_options: Vec<WeightedOption>,
    max_points: i32,
    on_change: Callback<Vec<WeightedOption>>,
) -> impl IntoView {
    // Generate initial IDs for tracking
    let next_id = std::cell::Cell::new(0);
    let get_next_id = move || {
        let id = next_id.get();
        next_id.set(id + 1);
        id
    };

    // Create initial options with IDs
    let initial_options = weighted_options
        .into_iter()
        .map(|opt| (get_next_id(), opt))
        .collect::<Vec<_>>();

    let (option_items, set_option_items) = signal(initial_options);

    // Calculate total assigned points
    let total_assigned_points = Memo::new(move |_| {
        option_items.with(|items| {
            items
                .iter()
                .filter(|(_, opt)| opt.is_selectable)
                .map(|(_, opt)| opt.points)
                .sum::<i32>()
        })
    });

    // Create a debounced update callback
    let debounced_update = store_value(move || {
        let options =
            option_items.with(|items| items.iter().map(|(_, opt)| opt.clone()).collect::<Vec<_>>());
        on_change(options);
    });

    // Add a new option
    let add_option = move |_| {
        let new_id = get_next_id();
        set_option_items.update(|items| {
            items.push((new_id, WeightedOption::new(String::new(), 0, false)));
        });
        debounced_update.with_value(|update| update());

        // Focus the newly added input with better timing
        #[cfg(feature = "hydrate")]
        {
            request_animation_frame(move || {
                request_animation_frame(move || {
                    if let Some(document) = web_sys::window().and_then(|w| w.document()) {
                        // Use data attribute for more reliable selection
                        let selector = &format!("input[data-weighted-option-id='{}']", new_id);
                        if let Ok(Some(element)) = document.query_selector(selector) {
                            if let Ok(input) = element.dyn_into::<web_sys::HtmlInputElement>() {
                                let _ = input.focus();
                            }
                        }
                    }
                });
            });
        }
    };

    // Update option text
    let update_option_text = move |id: usize, new_text: String| {
        set_option_items.update(|items| {
            if let Some((_, option)) = items.iter_mut().find(|(item_id, _)| *item_id == id) {
                option.text = new_text;
            }
        });
        // No immediate parent notification
    };

    // Update option points
    let update_option_points = move |id: usize, new_points: i32| {
        set_option_items.update(|items| {
            if let Some((_, option)) = items.iter_mut().find(|(item_id, _)| *item_id == id) {
                option.points = new_points;
            }
        });
        debounced_update.with_value(|update| update());
    };

    // Toggle option selectability
    let toggle_selectable = move |id: usize| {
        set_option_items.update(|items| {
            if let Some((_, option)) = items.iter_mut().find(|(item_id, _)| *item_id == id) {
                option.is_selectable = !option.is_selectable;
            }
        });
        debounced_update.with_value(|update| update());
    };

    // Remove option
    let remove_option = move |id: usize| {
        set_option_items.update(|items| {
            items.retain(|(item_id, _)| *item_id != id);
        });
        debounced_update.with_value(|update| update());
    };

    view! {
        <div class="mt-4 space-y-4">
            <div class="flex justify-between items-center">
                <h3 class="text-[#00356b] font-semibold">"Weighted Multiple Choice Options"</h3>
                <div class="text-sm text-gray-600">
                    "Total Points Assigned: "
                    <span class=move || {
                        if total_assigned_points() > max_points {
                            "font-bold text-red-600"
                        } else {
                            "font-bold text-green-600"
                        }
                    }>
                        {total_assigned_points}
                    </span>
                    " / " {max_points}
                </div>
            </div>

            <div class="bg-blue-50 border border-blue-200 rounded p-3 text-sm text-blue-800">
                <p><strong>"Instructions:"</strong></p>
                <ul class="list-disc list-inside mt-1 space-y-1">
                    <li>"Set point values for each option (can be positive or negative)"</li>
                    <li>"Check 'Selectable' for options students can choose"</li>
                    <li>"Students can select multiple options simultaneously"</li>
                    <li>"Final score = sum of selected option points (capped at question max)"</li>
                </ul>
            </div>

            <For
                each=move || {
                    option_items.get()
                        .into_iter()
                        .enumerate()
                        .collect::<Vec<_>>()
                }
                key=|(index, (id, _))| (*index, *id)
                children=move |(index, (id, option)): (usize, (usize, WeightedOption))| {
                    let option_id = id;
                    let option_index = index;
                    let option_text = option.text.clone();
                    let option_points = option.points;
                    let option_selectable = option.is_selectable;

                    view! {
                        <div class="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
                            // Text input for option - natural tab order
                            <input
                                type="text"
                                placeholder=format!("Option {}", option_index + 1)
                                class="flex-grow px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                prop:value=option_text
                                on:input=move |event| update_option_text(option_id, event_target_value(&event))
                                // No parent notifications, no blur handlers, no debouncing
                                // Use data attribute for more reliable selection
                                attr:data-weighted-option-id=option_id.to_string()
                                // NO tabindex - let browser use natural DOM order
                            />

                            // Points input - natural tab order
                            <div class="flex items-center space-x-2">
                                <label class="text-sm text-gray-600">"Points:"</label>
                                <input
                                    type="number"
                                    class="w-20 px-2 py-1 border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                    prop:value=option_points.to_string()
                                    on:input=move |event| {
                                        if let Ok(points) = event_target_value(&event).parse::<i32>() {
                                            update_option_points(option_id, points);
                                        }
                                    }
                                    // NO tabindex - let browser use natural DOM order
                                />
                            </div>

                            // Selectable checkbox - natural tab order
                            <div class="flex items-center space-x-2">
                                <label class="text-sm text-gray-600">"Selectable:"</label>
                                <input
                                    type="checkbox"
                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                    prop:checked=option_selectable
                                    on:change=move |_| toggle_selectable(option_id)
                                    // NO tabindex - let browser use natural DOM order
                                />
                            </div>

                            // Remove button - excluded from tab order
                            <button
                                type="button"
                                class="flex-shrink-0 p-2 text-red-600 hover:bg-red-100 rounded-full transition-colors"
                                on:click=move |_| {
                                    remove_option(option_id);
                                    debounced_update.with_value(|update| update()); // Only notify on remove
                                }
                                title="Remove option"
                                // Remove buttons from tab order
                                prop:tabindex=-1
                            >
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    }
                }
            />

            <button
                type="button"
                class="bg-[#00356b] text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors"
                on:click=add_option
                // Ensure add button doesn't interfere with tab order
                prop:tabindex=-1
            >
                "Add Option"
            </button>

            // Warning if points exceed maximum
            {move || {
                if total_assigned_points() > max_points {
                    view! {
                        <div class="bg-yellow-50 border border-yellow-200 rounded p-3 text-sm text-yellow-800">
                            <p><strong>"Warning:"</strong> " Total selectable points exceed the question's maximum value. Student scores will be capped at " {max_points} " points."</p>
                        </div>
                    }.into_any()
                } else {
                    view! { <div></div> }.into_any()
                }
            }}
        </div>
    }
}

#[component]
pub fn MultipleChoice(
    options: Vec<String>,
    designated_answer: String,
    on_change: Callback<(Vec<String>, String)>,
) -> impl IntoView {
    let next_id = std::cell::Cell::new(0);
    let get_next_id = move || {
        let id = next_id.get();
        next_id.set(id + 1);
        id
    };

    let initial_options = options
        .into_iter()
        .map(|value| (get_next_id(), value))
        .collect::<Vec<_>>();

    let (option_items, set_option_items) = signal(initial_options);
    let (correct_answer, set_correct_answer) = signal(if designated_answer.is_empty() {
        option_items.with(|items| items.first().map(|(_, v)| v.clone()).unwrap_or_default())
    } else {
        designated_answer
    });

    let notify_parent = move || {
        let values =
            option_items.with(|items| items.iter().map(|(_, v)| v.clone()).collect::<Vec<_>>());
        on_change((values, correct_answer()));
    };

    let add_option = move |_| {
        let new_id = get_next_id();
        set_option_items.update(|items| {
            items.push((new_id, String::new()));
        });
        notify_parent();

        // Focus the newly added input with better timing
        #[cfg(feature = "hydrate")]
        {
            request_animation_frame(move || {
                request_animation_frame(move || {
                    if let Some(document) = web_sys::window().and_then(|w| w.document()) {
                        // Use a more specific selector that targets the actual input
                        let selector = &format!("input[data-option-id='{}']", new_id);
                        if let Ok(Some(element)) = document.query_selector(selector) {
                            if let Ok(input) = element.dyn_into::<web_sys::HtmlInputElement>() {
                                let _ = input.focus();
                            }
                        }
                    }
                });
            });
        }
    };

    let update_option = move |id: usize, new_value: String| {
        set_option_items.update(|items| {
            if let Some(item) = items.iter_mut().find(|(item_id, _)| *item_id == id) {
                let old_value = item.1.clone();
                item.1 = new_value.clone();

                // If this was the correct answer, update it
                if correct_answer() == old_value {
                    set_correct_answer.set(new_value);
                }
            }
        });
        // No immediate parent notification - let the parent component handle this
    };

    let remove_option = move |id: usize| {
        set_option_items.update(|items| {
            let removing_correct = items
                .iter()
                .find(|(item_id, _)| *item_id == id)
                .map(|(_, value)| value == &correct_answer())
                .unwrap_or(false);

            items.retain(|(item_id, _)| *item_id != id);

            if removing_correct && !items.is_empty() {
                let new_correct = items[0].1.clone();
                set_correct_answer.set(new_correct);
            }
        });
        notify_parent();
    };

    let set_as_correct = move |id: usize| {
        if let Some(value) = option_items.with(|items| {
            items
                .iter()
                .find(|(item_id, _)| *item_id == id)
                .map(|(_, v)| v.clone())
        }) {
            set_correct_answer.set(value);
            notify_parent();
        }
    };

    view! {
        <div class="space-y-3">
            <div class="flex justify-between items-center">
                <h4 class="font-medium text-gray-700">"Answer Options"</h4>
                <span class="text-sm text-gray-500">"Select the correct answer"</span>
            </div>

            <For
                each=move || {
                    option_items.get()
                        .into_iter()
                        .enumerate()
                        .collect::<Vec<_>>()
                }
                key=|(index, (id, _))| (*index, *id)
                children=move |(index, (id, value)): (usize, (usize, String))| {
                    let option_id = id;
                    let option_index = index;
                    let option_value_for_memo = value.clone();
                    let option_value_for_input = value.clone();

                    let is_correct = Memo::new(move |_| correct_answer() == option_value_for_memo);

                    view! {
                        <div class=move || {
                            if is_correct() {
                                "flex items-center gap-3 p-3 bg-green-50 border border-green-200 rounded-lg"
                            } else {
                                "flex items-center gap-3 p-3 bg-gray-50 rounded-lg"
                            }
                        }>
                            <div class="flex-shrink-0">
                                <input
                                    type="radio"
                                    name="correct_answer"
                                    class="h-4 w-4 text-blue-600 focus:ring-blue-500"
                                    prop:checked=is_correct.get()
                                    on:change=move |_| {
                                        set_as_correct(option_id);
                                        notify_parent(); // Only notify on radio button changes
                                    }
                                    // Remove radio buttons from tab order completely
                                    prop:tabindex=-1
                                />
                            </div>
                            <input
                                type="text"
                                placeholder=format!("Option {}", option_index + 1)
                                class="flex-grow px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                prop:value=option_value_for_input
                                on:input=move |event| update_option(option_id, event_target_value(&event))
                                // No parent notifications, no blur handlers, no debouncing
                                // Use data attribute for more reliable selection
                                attr:data-option-id=option_id.to_string()
                                // NO tabindex - let browser use natural DOM order
                            />
                            <button
                                type="button"
                                class="flex-shrink-0 p-2 text-red-600 hover:bg-red-100 rounded-full transition-colors"
                                on:click=move |_| {
                                    remove_option(option_id);
                                    notify_parent(); // Only notify on remove
                                }
                                title="Remove option"
                                // Remove buttons from tab order
                                prop:tabindex=-1
                            >
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    }
                }
            />

            <button
                type="button"
                class="w-full py-2 px-4 border-2 border-dashed border-gray-300 rounded-lg text-gray-600 hover:border-blue-500 hover:text-blue-600 transition-colors"
                on:click=add_option
                // Ensure add button doesn't interfere with tab order
                prop:tabindex=-1
            >
                "+ Add Option"
            </button>
        </div>
    }
}

#[component]
pub fn SelectionQuestion() -> impl IntoView {
    let (options_number, set_options_number) = signal(2);
    let on_click_add = move |_| {
        set_options_number(options_number() + 1);
    };
    view! {
        <button on:click=on_click_add class=INPUT_SELECTOR>
            "Add Selection Option"
        </button>
        <p>"This is the Selction Question Builder"</p>
        <p>"This is the value of the option counter " {options_number}</p>
    }
}

#[component]
pub fn TrueFalse(
    designated_answer: String,
    on_change: Callback<(Vec<String>, String)>,
) -> impl IntoView {
    let options = store_value(vec!["true".to_string(), "false".to_string()]);
    let (selected_answer, set_selected_answer) = signal(if designated_answer.is_empty() {
        "true".to_string()
    } else {
        designated_answer
    });

    let update_answer = move |answer: String| {
        set_selected_answer.set(answer.clone());
        on_change((options.get_value(), answer));
    };

    view! {
        <div class="space-y-4">
            <h4 class="font-medium text-gray-700">"Select the correct answer:"</h4>
            <div class="flex gap-4">
                <button
                    type="button"
                    class=move || {
                        if selected_answer() == "true" {
                            "px-8 py-3 bg-green-500 text-white rounded-lg font-medium transition-all"
                        } else {
                            "px-8 py-3 bg-gray-200 text-gray-700 rounded-lg font-medium hover:bg-gray-300 transition-all"
                        }
                    }
                    on:click=move |_| update_answer("true".to_string())
                >
                    "True"
                </button>
                <button
                    type="button"
                    class=move || {
                        if selected_answer() == "false" {
                            "px-8 py-3 bg-green-500 text-white rounded-lg font-medium transition-all"
                        } else {
                            "px-8 py-3 bg-gray-200 text-gray-700 rounded-lg font-medium hover:bg-gray-300 transition-all"
                        }
                    }
                    on:click=move |_| update_answer("false".to_string())
                >
                    "False"
                </button>
            </div>
        </div>
    }
}
use leptos::prelude::*;
// src/app/components/test_components/font_controls.rs

use leptos::prelude::*;

// Font configuration constants
pub const DEFAULT_QUESTION_FONT_SIZE: &str = "text-4xl";
pub const DEFAULT_ANSWER_FONT_SIZE: &str = "text-lg";
pub const DEFAULT_QUESTION_FONT_FAMILY: &str = "font-sans";
pub const DEFAULT_ANSWER_FONT_FAMILY: &str = "font-sans";

// Font size options
pub const FONT_SIZES: &[(&str, &str)] = &[
    ("text-xs", "Extra Small"),
    ("text-sm", "Small"),
    ("text-base", "Normal"),
    ("text-lg", "Large"),
    ("text-xl", "Extra Large"),
    ("text-2xl", "2X Large"),
    ("text-3xl", "3X Large"),
    ("text-4xl", "4X Large"),
    ("text-5xl", "5X Large"),
    ("text-6xl", "6X Large"),
    ("text-7xl", "7X Large"),
    ("text-8xl", "8X Large"),
    ("text-9xl", "9X Large"),
];

// Font family options
pub const FONT_FAMILIES: &[(&str, &str)] = &[
    ("font-sans", "Sans Serif"),
    ("font-serif", "Serif"),
    ("font-mono", "Monospace"),
    ("font-custom", "Custom"),
];

// Font settings struct for easier management
#[derive(Debug, Clone)]
pub struct FontSettings {
    pub question_font_size: String,
    pub answer_font_size: String,
    pub question_font_family: String,
    pub answer_font_family: String,
    pub question_bold: bool,
}

impl Default for FontSettings {
    fn default() -> Self {
        Self {
            question_font_size: DEFAULT_QUESTION_FONT_SIZE.to_string(),
            answer_font_size: DEFAULT_ANSWER_FONT_SIZE.to_string(),
            question_font_family: DEFAULT_QUESTION_FONT_FAMILY.to_string(),
            answer_font_family: DEFAULT_ANSWER_FONT_FAMILY.to_string(),
            question_bold: true,
        }
    }
}

impl FontSettings {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn reset(&mut self) {
        *self = Self::default();
    }

    pub fn get_question_classes(&self) -> String {
        let bold_class = if self.question_bold {
            "font-bold"
        } else {
            "font-normal"
        };
        format!(
            "{} {} {} break-words",
            self.question_font_size, self.question_font_family, bold_class
        )
    }

    pub fn get_answer_classes(&self) -> String {
        format!("{} {}", self.answer_font_size, self.answer_font_family)
    }
}

// Hook for managing font settings
pub fn use_font_settings() -> (ReadSignal<FontSettings>, WriteSignal<FontSettings>) {
    signal(FontSettings::default())
}

// Main font controls component
#[component]
pub fn FontControls(
    font_settings: ReadSignal<FontSettings>,
    set_font_settings: WriteSignal<FontSettings>,
) -> impl IntoView {
    let (is_open, set_is_open) = signal(false);

    view! {
        <div class="relative">
            {/* Toggle Button */}
            <button
                class="flex items-center justify-center w-10 h-10 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 transition-colors"
                on:click=move |_| set_is_open.update(|open| *open = !*open)
                title="Font Settings"
            >
                <FontIcon />
            </button>

            {/* Font Controls Panel */}
            <Show when=move || is_open.get()>
                <div class="absolute top-12 right-0 z-50 bg-white border border-gray-200 rounded-lg shadow-lg p-4 min-w-[280px]">
                    <FontControlsPanel
                        font_settings=font_settings
                        set_font_settings=set_font_settings
                        set_is_open=set_is_open
                    />
                </div>
            </Show>
        </div>
    }
}

// Font controls panel component
#[component]
fn FontControlsPanel(
    font_settings: ReadSignal<FontSettings>,
    set_font_settings: WriteSignal<FontSettings>,
    set_is_open: WriteSignal<bool>,
) -> impl IntoView {
    let update_question_font_size = move |size: String| {
        set_font_settings.update(|settings| {
            settings.question_font_size = size;
        });
    };

    let update_answer_font_size = move |size: String| {
        set_font_settings.update(|settings| {
            settings.answer_font_size = size;
        });
    };

    let update_question_font_family = move |family: String| {
        set_font_settings.update(|settings| {
            settings.question_font_family = family;
        });
    };

    let update_answer_font_family = move |family: String| {
        set_font_settings.update(|settings| {
            settings.answer_font_family = family;
        });
    };

    let reset_settings = move |_| {
        set_font_settings.update(|settings| {
            settings.reset();
        });
    };

    view! {
        <div class="space-y-4">
            <div class="flex items-center justify-between mb-3">
                <h3 class="text-sm font-semibold text-gray-800">"Font Settings"</h3>
                <button
                    class="text-gray-400 hover:text-gray-600"
                    on:click=move |_| set_is_open.set(false)
                >
                    <CloseIcon />
                </button>
            </div>

            {/* Question Font Size */}
            <FontSizeSelector
                label="Question Size"
                current_value=move || font_settings.get().question_font_size
                on_change=update_question_font_size
            />

            {/* Answer Font Size */}
            <FontSizeSelector
                label="Answer Size"
                current_value=move || font_settings.get().answer_font_size
                on_change=update_answer_font_size
            />

            {/* Question Font Family */}
            <FontFamilySelector
                label="Question Font"
                current_value=move || font_settings.get().question_font_family
                on_change=update_question_font_family
            />

            {/* Answer Font Family */}
            <FontFamilySelector
                label="Answer Font"
                current_value=move || font_settings.get().answer_font_family
                on_change=update_answer_font_family
            />

            {/* Question Bold Toggle */}
            <BoldToggle
                label="Question Bold"
                current_value=move || font_settings.get().question_bold
                on_change=move |value| {
                    set_font_settings.update(|settings| {
                        settings.question_bold = value;
                    });
                }
            />

            {/* Reset Button */}
            <div class="pt-2 border-t border-gray-100">
                <button
                    class="w-full px-3 py-2 text-xs font-medium text-gray-600 border border-gray-200 rounded hover:bg-gray-50 transition-colors"
                    on:click=reset_settings
                >
                    "Reset to Defaults"
                </button>
            </div>
        </div>
    }
}

// Font size selector component
#[component]
fn FontSizeSelector<F>(
    label: &'static str,
    current_value: impl Fn() -> String + 'static,
    on_change: F,
) -> impl IntoView
where
    F: Fn(String) + 'static,
{
    view! {
        <div>
            <label class="block text-xs font-medium text-gray-700 mb-1">{label}</label>
            <select
                class="w-full p-2 text-sm border border-gray-200 rounded focus:ring-blue-500 focus:border-blue-500"
                prop:value=move || current_value()
                on:change=move |ev| {
                    let value = event_target_value(&ev);
                    on_change(value);
                }
            >
                {FONT_SIZES.iter().map(|(class, label)| {
                    view! {
                        <option value=*class>{*label}</option>
                    }
                }).collect_view()}
            </select>
        </div>
    }
}

// Font family selector component
#[component]
fn FontFamilySelector<F>(
    label: &'static str,
    current_value: impl Fn() -> String + 'static,
    on_change: F,
) -> impl IntoView
where
    F: Fn(String) + 'static,
{
    view! {
        <div>
            <label class="block text-xs font-medium text-gray-700 mb-1">{label}</label>
            <select
                class="w-full p-2 text-sm border border-gray-200 rounded focus:ring-blue-500 focus:border-blue-500"
                prop:value=move || current_value()
                on:change=move |ev| {
                    let value = event_target_value(&ev);
                    on_change(value);
                }
            >
                {FONT_FAMILIES.iter().map(|(class, label)| {
                    view! {
                        <option value=*class>{*label}</option>
                    }
                }).collect_view()}
            </select>
        </div>
    }
}

// Icon components
#[component]
fn FontIcon() -> impl IntoView {
    view! {
        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path>
        </svg>
    }
}

#[component]
fn CloseIcon() -> impl IntoView {
    view! {
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
    }
}

#[component]
fn BoldToggle<F>(
    label: &'static str,
    current_value: impl Fn() -> bool + 'static + Clone,
    on_change: F,
) -> impl IntoView
where
    F: Fn(bool) + 'static + Clone,
{
    let current_value_clone = current_value.clone();
    let on_change_clone = on_change.clone();

    view! {
        <div>
            <label class="block text-xs font-medium text-gray-700 mb-2">{label}</label>
            <div class="flex items-center space-x-0">
                <button
                    type="button"
                    class=move || {
                        if current_value() {
                            "flex-1 px-3 py-2 text-xs font-bold bg-blue-500 text-white rounded-l border border-blue-500 transition-colors"
                        } else {
                            "flex-1 px-3 py-2 text-xs font-normal bg-white text-gray-700 border border-gray-300 rounded-l hover:bg-gray-50 transition-colors"
                        }
                    }
                    on:click=move |_| on_change(true)
                >
                    "Bold"
                </button>
                <button
                    type="button"
                    class=move || {
                        if !current_value_clone() {
                            "flex-1 px-3 py-2 text-xs font-normal bg-blue-500 text-white rounded-r border border-blue-500 transition-colors"
                        } else {
                            "flex-1 px-3 py-2 text-xs font-normal bg-white text-gray-700 border border-gray-300 rounded-r hover:bg-gray-50 transition-colors"
                        }
                    }
                    on:click=move |_| on_change_clone(false)
                >
                    "Normal"
                </button>
            </div>
        </div>
    }
}

#[component]
fn BoldIcon() -> impl IntoView {
    view! {
        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h4.5a3.5 3.5 0 013.5 3.5v.5a3 3 0 01-3 3H6v2h4a3 3 0 110 6H4a1 1 0 01-1-1V4zm2 1v4h3.5a1.5 1.5 0 001.5-1.5v-.5A1.5 1.5 0 008.5 5H5zm0 6v4h4a1 1 0 100-2H6a1 1 0 01-1-1z" clip-rule="evenodd" />
        </svg>
    }
}

#[component]
fn NormalIcon() -> impl IntoView {
    view! {
        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    }
}
use leptos::prelude::*;
#[cfg(feature = "hydrate")]
use wasm_bindgen::prelude::*;

#[component]
pub fn BalloonCelebration(
    #[prop(into)] show: Signal<bool>,
    #[prop(default = "ðŸŽ‰ Test Complete! Great job! ðŸŽ‰")] message: &'static str,
    #[prop(default = 5000)] duration: u32, // Duration in milliseconds
) -> impl IntoView {
    let (is_visible, set_is_visible) = signal(false);
    let (animate_out, set_animate_out) = signal(false);

    // Handle show/hide animation
    Effect::new(move |_| {
        if show.get() {
            set_is_visible.set(true);
            set_animate_out.set(false);

            // Auto-hide after duration
            #[cfg(feature = "hydrate")]
            {
                use wasm_bindgen::closure::Closure;

                let timeout = web_sys::window()
                    .unwrap()
                    .set_timeout_with_callback_and_timeout_and_arguments_0(
                        &Closure::once_into_js(move || {
                            set_animate_out.set(true);
                            // Give time for exit animation
                            let hide_timeout = web_sys::window()
                                .unwrap()
                                .set_timeout_with_callback_and_timeout_and_arguments_0(
                                    &Closure::once_into_js(move || {
                                        set_is_visible.set(false);
                                    })
                                    .into(),
                                    500, // Exit animation duration
                                )
                                .unwrap();
                        })
                        .into(),
                        duration as i32,
                    )
                    .unwrap();
            }

            #[cfg(not(feature = "hydrate"))]
            {
                // For server-side rendering, just set a simple timeout using leptos
                set_timeout(
                    move || {
                        set_animate_out.set(true);
                        set_timeout(
                            move || {
                                set_is_visible.set(false);
                            },
                            std::time::Duration::from_millis(500),
                        );
                    },
                    std::time::Duration::from_millis(duration as u64),
                );
            }
        } else {
            set_is_visible.set(false);
            set_animate_out.set(false);
        }
    });

    view! {
        <Show when=move || is_visible.get()>
            <div class=move || {
                let base_classes = "fixed inset-0 z-50 flex items-center justify-center pointer-events-none";
                if animate_out.get() {
                    format!("{} animate-fade-out", base_classes)
                } else {
                    format!("{} animate-fade-in", base_classes)
                }
            }>
                {/* Background overlay */}
                <div class="absolute inset-0 bg-black bg-opacity-20 backdrop-blur-sm"></div>

                {/* Celebration content */}
                <div class="relative z-10 text-center px-8">
                    {/* Main message */}
                    <div class=move || {
                        if animate_out.get() {
                            "transform transition-all duration-500 ease-in-out scale-75 opacity-0"
                        } else {
                            "transform transition-all duration-700 ease-out scale-100 opacity-100 animate-bounce-gentle"
                        }
                    }>
                        <div class="bg-white rounded-2xl shadow-2xl p-8 mb-8 border-4 border-yellow-300">
                            <h1 class="text-4xl md:text-6xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-pink-600 mb-4">
                                {message}
                            </h1>
                            <p class="text-xl text-gray-600 font-medium">
                                "You can now close this page or wait for your teacher's next instructions."
                            </p>
                        </div>
                    </div>

                    {/* Floating balloons */}
                    <div class="absolute inset-0 pointer-events-none">
                        <Balloon color="bg-red-400" delay="0s" x_position="10%" />
                        <Balloon color="bg-blue-400" delay="0.5s" x_position="20%" />
                        <Balloon color="bg-yellow-400" delay="1s" x_position="30%" />
                        <Balloon color="bg-green-400" delay="0.3s" x_position="70%" />
                        <Balloon color="bg-purple-400" delay="0.8s" x_position="80%" />
                        <Balloon color="bg-pink-400" delay="1.2s" x_position="90%" />
                        <Balloon color="bg-indigo-400" delay="0.2s" x_position="50%" />
                        <Balloon color="bg-orange-400" delay="1.5s" x_position="60%" />
                    </div>

                    {/* Confetti particles */}
                    <div class="absolute inset-0 pointer-events-none overflow-hidden">
                        <ConfettiParticle color="bg-red-500" delay="0s" x="15%" />
                        <ConfettiParticle color="bg-blue-500" delay="0.3s" x="25%" />
                        <ConfettiParticle color="bg-yellow-500" delay="0.6s" x="35%" />
                        <ConfettiParticle color="bg-green-500" delay="0.9s" x="45%" />
                        <ConfettiParticle color="bg-purple-500" delay="1.2s" x="55%" />
                        <ConfettiParticle color="bg-pink-500" delay="1.5s" x="65%" />
                        <ConfettiParticle color="bg-indigo-500" delay="0.4s" x="75%" />
                        <ConfettiParticle color="bg-orange-500" delay="0.7s" x="85%" />
                    </div>
                </div>
            </div>
        </Show>

        {/* Custom CSS animations */}
        <style>
            r#"
            @keyframes float-up {
                0% {
                    transform: translateY(100vh) scale(0);
                    opacity: 0;
                }
                10% {
                    opacity: 1;
                }
                90% {
                    opacity: 1;
                }
                100% {
                    transform: translateY(-100vh) scale(1);
                    opacity: 0;
                }
            }
            
            @keyframes confetti-fall {
                0% {
                    transform: translateY(-100vh) rotate(0deg);
                    opacity: 1;
                }
                100% {
                    transform: translateY(100vh) rotate(360deg);
                    opacity: 0;
                }
            }
            
            @keyframes bounce-gentle {
                0%, 20%, 50%, 80%, 100% {
                    transform: translateY(0);
                }
                40% {
                    transform: translateY(-10px);
                }
                60% {
                    transform: translateY(-5px);
                }
            }
            
            @keyframes fade-in {
                from {
                    opacity: 0;
                    transform: scale(0.8);
                }
                to {
                    opacity: 1;
                    transform: scale(1);
                }
            }
            
            @keyframes fade-out {
                from {
                    opacity: 1;
                    transform: scale(1);
                }
                to {
                    opacity: 0;
                    transform: scale(0.8);
                }
            }
            
            .animate-float-up {
                animation: float-up 4s ease-out forwards;
            }
            
            .animate-confetti-fall {
                animation: confetti-fall 3s linear forwards;
            }
            
            .animate-bounce-gentle {
                animation: bounce-gentle 2s ease-in-out infinite;
            }
            
            .animate-fade-in {
                animation: fade-in 0.5s ease-out forwards;
            }
            
            .animate-fade-out {
                animation: fade-out 0.5s ease-in forwards;
            }
            "#
        </style>
    }
}

#[component]
fn Balloon(
    #[prop(into)] color: &'static str,
    #[prop(into)] delay: &'static str,
    #[prop(into)] x_position: &'static str,
) -> impl IntoView {
    view! {
        <div
            class=format!("absolute bottom-0 w-12 h-16 {} rounded-full animate-float-up", color)
            style=format!("left: {}; animation-delay: {}", x_position, delay)
        >
            {/* Balloon string */}
            <div class="absolute top-full left-1/2 w-0.5 h-20 bg-gray-400 transform -translate-x-1/2"></div>

            {/* Balloon highlight */}
            <div class="absolute top-2 left-2 w-3 h-4 bg-white bg-opacity-40 rounded-full"></div>
        </div>
    }
}

#[component]
fn ConfettiParticle(
    #[prop(into)] color: &'static str,
    #[prop(into)] delay: &'static str,
    #[prop(into)] x: &'static str,
) -> impl IntoView {
    view! {
        <div
            class=format!("absolute top-0 w-2 h-2 {} animate-confetti-fall", color)
            style=format!("left: {}; animation-delay: {}", x, delay)
        ></div>
    }
}

// Quick celebration trigger for instant feedback
#[component]
pub fn QuickCelebration(#[prop(into)] show: Signal<bool>) -> impl IntoView {
    view! {
        <Show when=move || show.get()>
            <div class="fixed top-4 right-4 z-50 animate-bounce">
                <div class="bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center gap-2">
                    <span class="text-2xl">"ðŸŽ‰"</span>
                    <span class="font-semibold">"Test Submitted!"</span>
                </div>
            </div>
        </Show>
    }
}
use leptos::prelude::*;
use leptos::prelude::*;

//this component is used to allow a user to select a benchmark category and display its color

const COLOR_PALETTE: &[&str] = &[
    "#10b981", // green
    "#06b6d4", // cyan
    "#f59e0b", // amber
    "#ef4444", // red
    "#8b5cf6", // purple
    "#f43f5e", // rose
    "#6b7280", // gray
];

#[component]
pub fn BenchmarkColorSelector(
    #[prop(into)] current_color: Signal<String>,
    on_color_change: Callback<String>,
) -> impl IntoView {
    let (show_palette, set_show_palette) = signal(false);

    view! {
        <button
            class="flex items-center justify-center w-8 h-8 rounded-full border-2 border-gray-300"
            style={move || format!("background-color: {}", current_color.get())}
            on:click=move |_| {
                set_show_palette.update(|show| *show = !*show);
            }
        >
        </button>

        <Show when=move || show_palette()>
            <div class="absolute z-10 p-2 bg-white border rounded shadow-lg">
                <div class="flex flex-wrap gap-2">
                    {COLOR_PALETTE.iter().map(|&color_value| {
                        view! {
                            <button
                                class="w-8 h-8 rounded-full border-2 border-gray-300 hover:border-gray-500"
                                style={format!("background-color: {}", color_value)}
                                on:click={
                                    let color_to_set = color_value.to_string();
                                    move |_| {
                                        set_show_palette.set(false);
                                        on_color_change.call(color_to_set.clone());
                                    }
                                }
                            ></button>
                        }
                    }).collect::<Vec<_>>()}
                </div>
            </div>
        </Show>
    }
}
use crate::app::components::{Toast, ToastMessage, ToastMessageType};
use crate::app::models::{DeleteTestRequest, Test};
use crate::app::server_functions::tests::delete_test;
use leptos::prelude::*;
use leptos::task::spawn_local;
use std::rc::Rc;

const INFO_STYLE: &str = "w-full h-12 pr-4 py-4 mt-6 flex flex-col outline-none focus:outline-none focus:pl-7 transition-all duration-1000 ease-in-out";

const INFO_TITLE_STYLE: &str = "text-stone-400 text-xs";
const INFO_VALUE_STYLE: &str = "text-white";

const CLOSE_BUTTON_STYLE: &str = "mt-10 bg-[#555555] px-8 py-2 rounded text-white mr-3 transition-all duration-1000 ease-in-out hover:bg-[#666666]";

const DELETE_BUTTON_STYLE: &str = "mt-10 bg-red-800 px-8 py-2 rounded text-white transition-all duration-1000 ease-in-out hover:bg-red-600";

const MODAL_STYLE: &str = "flex flex-col bg-[#222222] border-t-8 border-[#00356b] px-6 pt-5 h-[32rem] w-full max-w-[36rem] rounded-2xl z-50 -mt-2 fixed top-20 z-50";

#[component]
pub fn ShowTestModal(
    test: Rc<Test>,
    set_if_show_modal: WriteSignal<bool>,
    set_if_show_deleted: WriteSignal<bool>,
    test_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    set_toast_message: WriteSignal<ToastMessage>,
) -> impl IntoView {
    let mimic_test = test.clone();
    //to close the MODAL_STYLE
    let on_close = move |_| {
        set_if_show_modal(false);
    };

    //to perform deletion
    let on_click_delete = move |_| {
        let delete_test_request = DeleteTestRequest::new(mimic_test.test_id.clone());

        let _ = spawn_local(async move {
            let delete_result = delete_test(delete_test_request).await;

            match delete_result {
                Ok(_deleted_test) => {
                    test_resource.refetch();

                    set_toast_message(ToastMessage::create(ToastMessageType::TestDeleted));

                    set_if_show_deleted(true);

                    set_if_show_modal(false);
                }
                Err(e) => println!("Error deleting = {:?}", e),
            };
        });
    };

    view! {
        <div class="flex flex-col w-full h-full z-49 bg-[#222222/[.06]] rounded-2xl absolute">

            <div class="flex flex-col w-full h-full z-50 mx-auto items-center align-center">
                <div class=MODAL_STYLE>

                    <p class="text-white pt-2 text-4xl mt-2">
                        {&test.name}
                    </p>

                    <div class=INFO_STYLE>
                        <div class=INFO_TITLE_STYLE>"Maximum Score"</div>
                        <div class=INFO_VALUE_STYLE>{format!("{:?}", &test.score)}</div>
                    </div>

                    <div class=INFO_STYLE>
                        <div class=INFO_TITLE_STYLE>"Comments"</div>
                        <div class=INFO_VALUE_STYLE>{&test.comments}</div>
                    </div>

                    <div class=INFO_STYLE>
                        <div class=INFO_TITLE_STYLE>"Test Identifier"</div>
                        <div class=INFO_VALUE_STYLE>{format!("#{:?}", &test.test_id)}</div>
                    </div>

                    <div class=INFO_STYLE>
                        <div class=INFO_TITLE_STYLE>"Test Type"</div>
                        <div class=INFO_VALUE_STYLE>{format!("{:?}", &test.testarea)}</div>
                    </div>

                    <div class="flex flex-row w-full items-right justify-right mt-1">
                        <button on:click=on_close class=CLOSE_BUTTON_STYLE>
                            "Close"
                        </button>
                        <button on:click=on_click_delete class=DELETE_BUTTON_STYLE>
                            "Delete"
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod password_reset;

pub use password_reset::*;
use leptos::prelude::*;
pub mod chat;
pub mod color_utils;
pub mod dashboard_deanonymizer;
pub mod dashboard_sidebar;
pub mod scores_ledger;
use leptos::prelude::*;
pub mod administer_test_modal;
pub use administer_test_modal::ShowAdministerTestModal;

pub mod test_display;
pub use test_display::MathTestDisplay;

pub mod show_test_modal;
pub use show_test_modal::ShowTestModal;

pub mod question_builder;
pub use question_builder::BuildingQuestion;

pub mod test_item;
pub use test_item::*;

pub mod test_variation_manager;
pub use test_variation_manager::{
    TestVariationInfo, TestVariationManager, TestVariationManagerContent,
};

pub mod select_test_modal;
pub use select_test_modal::SelectTestModal;

pub mod test_instructions;
pub use test_instructions::TestInstructions;

pub mod font_controls;
pub use font_controls::*;

pub mod benchmark_color_selector;
pub use benchmark_color_selector::BenchmarkColorSelector;

pub mod balloon_celebration;
pub use balloon_celebration::{BalloonCelebration, QuickCelebration};
pub use font_controls::{use_font_settings, FontControls, FontSettings};
use leptos::prelude::*;
use leptos::prelude::*;
use std::time::Duration;

const TOAST_PARENT_STYLE: &str = "flex flex-row top-0 h-16 w-full max-w-[61rem] mx-auto items-center justify-center align-center fixed -mt-36 transition-all duration-1000 ease-in-out";     

const TOAST_PARENT_APPEAR_STYLE: &str = "flex flex-row top-0 h-16 w-full max-w-[61rem] mx-auto items-center justify-center align-center fixed mt-20 transition-all duration-1000 ease-in-out";     

const TOAST_STYLE: &str = "flex w-96 h-16 bg-[#333333] rounded px-10 py-4 text-white -mt-36 transition-all duration-1000 east-in-out items-center";

pub enum ToastMessageType {
    NewStudentAdded,
    StudentDeleted,
    StudentUpdated,
    NewTestAdded,
    TestDeleted,
    TestUpdated,
}

pub type ToastMessage = String;

pub trait Toast {
    fn create(toast_message_type: ToastMessageType) -> ToastMessage;
}

impl Toast for ToastMessage {
    fn create(toast_message_type: ToastMessageType) -> ToastMessage {
        match toast_message_type {
            ToastMessageType::NewStudentAdded => String::from("New Student Added"),
            ToastMessageType::StudentDeleted => String::from("Student deleted"),
            ToastMessageType::StudentUpdated => String::from("Student updated"),
            ToastMessageType::NewTestAdded => String::from("New Test Added"),
            ToastMessageType::TestDeleted => String::from("Test deleted"),
            ToastMessageType::TestUpdated => String::from("Test Updated")
        }
    }
}

#[component]
pub fn Toast(
    toast_message: ReadSignal<ToastMessage>,
    if_appear: ReadSignal<bool>,
    set_if_appear: WriteSignal<bool>,
) -> impl IntoView {
    let hide = move || {
        set_if_appear(false);
    };

    Effect::new(move |_| {
        if if_appear() {
                set_timeout(hide, Duration::from_secs(4));
        }
    });

    view! {
        <div class={move || {
            if if_appear() {TOAST_PARENT_APPEAR_STYLE}
            else {TOAST_PARENT_STYLE}
        }}>
            <div class=TOAST_STYLE>
                {toast_message}
            </div>
        </div>
    }
}
#[cfg(feature = "hydrate")]
use crate::app::components::data_processing::student_charts::wait_for_chartjs;
use crate::app::models::{
    score::Score,
    test::{BenchmarkCategory, Test},
};
use leptos::html;
use leptos::prelude::*;
use leptos::prelude::*;
use std::rc::Rc;

#[component]
pub fn PieChart(
    score: Score,
    test: Test,
    #[prop(default = "pie-chart".to_string())] chart_id: String,
    #[prop(default = "Test Score Breakdown".to_string())] title: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    // Wrap in Rc for shared ownership
    let score_rc = Rc::new(score);
    let test_rc = Rc::new(test);
    let title_rc = Rc::new(title);

    // Clone Rc references for use in different closures
    let score_for_effect = Rc::clone(&score_rc);
    let test_for_effect = Rc::clone(&test_rc);
    let title_for_effect = Rc::clone(&title_rc);

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let current_score = Rc::clone(&score_for_effect);
            let current_test = Rc::clone(&test_for_effect);
            let title_clone = Rc::clone(&title_for_effect);

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                let total_score: i32 = current_score.test_scores.iter().sum();

                // Get benchmark categories from the test
                let benchmark_categories = current_test
                    .benchmark_categories
                    .as_ref()
                    .cloned()
                    .unwrap_or_default();

                // Find which benchmark category this score falls into
                let current_benchmark =
                    Score::find_benchmark_category(total_score, &benchmark_categories);

                let max_possible = current_test.score;
                let remaining = (max_possible - total_score).max(0);

                // Get the color from the benchmark category the score falls into
                let earned_color = if let Some(ref current_cat) = current_benchmark {
                    current_cat.get_color()
                } else {
                    // Fallback color if no benchmark found
                    "#6b7280".to_string()
                };

                let (labels, data, colors) = if remaining > 0 {
                    (
                        vec!["Earned Points".to_string(), "Remaining Points".to_string()],
                        vec![total_score, remaining],
                        vec![
                            earned_color,
                            "rgba(229, 231, 235, 0.8)".to_string(), // Light gray for remaining
                        ],
                    )
                } else {
                    // Perfect score case
                    (
                        vec!["Perfect Score".to_string()],
                        vec![total_score],
                        vec![earned_color],
                    )
                };

                let config = json!({
                    "type": "pie",
                    "data": {
                        "labels": labels,
                        "datasets": [{
                            "data": data,
                            "backgroundColor": colors,
                            "borderWidth": 2,
                            "borderColor": "#ffffff",
                            "hoverOffset": 8
                        }]
                    },
                    "options": {
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": title_clone.as_ref(),
                                "font": {
                                    "size": 16,
                                    "weight": "bold"
                                },
                                "color": "#1f2937"
                            },
                            "legend": {
                                "position": "bottom",
                                "labels": {
                                    "padding": 20,
                                    "usePointStyle": true
                                }
                            },
                            "tooltip": {
                                "callbacks": {
                                    "label": "(context) => {
                                        const label = context.label || '';
                                        const value = context.raw;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${label}: ${value} (${percentage}%)`;
                                    }"
                                }
                            }
                        }
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    // Clone Rc references for use in the view
    let score_for_view = Rc::clone(&score_rc);
    let test_for_view = Rc::clone(&test_rc);

    view! {
        <div class="bg-white rounded-lg shadow-lg p-6">
            // Collapsible benchmark dropdown
            {
                let total_score: i32 = score_for_view.test_scores.iter().sum();

                if let Some(benchmark_categories) = &test_for_view.benchmark_categories {
                    if !benchmark_categories.is_empty() {
                        let current_benchmark = Score::find_benchmark_category(total_score, benchmark_categories);
                        let (is_open, set_is_open) = signal(false);

                        view! {
                            <div class="mb-4">
                                // Dropdown header (always visible)
                                <button
                                    class="w-full flex items-center justify-between p-3 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-lg transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    on:click=move |_| set_is_open.update(|open| *open = !*open)
                                >
                                    <div class="flex items-center space-x-3">
                                        {
                                            if let Some(current_benchmark) = &current_benchmark {
                                                view! {
                                                    <div
                                                        class="w-4 h-4 rounded-full border-2 border-white shadow-sm"
                                                        style=format!("background-color: {}", current_benchmark.get_color())
                                                    ></div>
                                                    <div class="text-left">
                                                        <div class="font-medium text-gray-900">
                                                            {current_benchmark.label.clone()}
                                                        </div>
                                                        <div class="text-sm text-gray-600">
                                                            "Score: " {total_score} " / " {test_for_view.score} " (" {current_benchmark.range_display()} " range)"
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            } else {
                                                view! {
                                                    <div class="text-left">
                                                        <div class="font-medium text-gray-900">No Benchmark Match</div>
                                                        <div class="text-sm text-gray-600">
                                                            "Score: " {total_score} " / " {test_for_view.score}
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            }
                                        }
                                    </div>

                                    // Dropdown arrow
                                    <svg
                                        class=move || format!("w-5 h-5 text-gray-500 transition-transform duration-200 {}",
                                            if is_open.get() { "rotate-180" } else { "" })
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </button>

                                // Expandable content
                                <div class=move || format!("overflow-hidden transition-all duration-300 ease-in-out {}",
                                    if is_open.get() { "max-h-96 opacity-100" } else { "max-h-0 opacity-0" })
                                >
                                    <div class="mt-2 border border-gray-200 rounded-lg bg-white shadow-sm">
                                        <div class="p-3 border-b border-gray-200 bg-gray-50">
                                            <h4 class="font-medium text-gray-900 text-sm">All Benchmark Categories</h4>
                                        </div>
                                        <div class="divide-y divide-gray-100">
                                            {benchmark_categories.iter().map(|category| {
                                                let is_current = current_benchmark
                                                    .as_ref()
                                                    .map_or(false, |current_cat| current_cat.label == category.label);

                                                view! {
                                                    <div class=format!("p-3 flex items-center justify-between hover:bg-gray-50 {}",
                                                        if is_current { "bg-blue-50 border-l-4 border-blue-500" } else { "" })
                                                    >
                                                        <div class="flex items-center space-x-3">
                                                            <div
                                                                class="w-4 h-4 rounded-full border-2 border-white shadow-sm"
                                                                style=format!("background-color: {}", category.get_color())
                                                            ></div>
                                                            <div>
                                                                <div class=format!("font-medium {}",
                                                                    if is_current { "text-blue-900" } else { "text-gray-900" })
                                                                >
                                                                    {category.label.clone()}
                                                                </div>
                                                                <div class=format!("text-sm {}",
                                                                    if is_current { "text-blue-700" } else { "text-gray-600" })
                                                                >
                                                                    {category.range_display()} " points"
                                                                </div>
                                                            </div>
                                                        </div>
                                                        {
                                                            if is_current {
                                                                view! {
                                                                    <span class="px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded-full">
                                                                        Current
                                                                    </span>
                                                                }.into_any()
                                                            } else {
                                                                view! { <div></div> }.into_any()
                                                            }
                                                        }
                                                    </div>
                                                }
                                            }).collect_view()}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }.into_any()
                    } else {
                        view! { <div></div> }.into_any()
                    }
                } else {
                    view! { <div></div> }.into_any()
                }
            }

            <div class="h-64 relative">
                <canvas node_ref=chart_ref id=chart_id></canvas>
            </div>
        </div>
    }
}
use crate::app::models::assessment::Assessment;
use crate::app::models::score::Score;
use crate::app::models::student::Student;
use crate::app::models::test::Test;
use crate::app::server_functions::teachers::get_teachers;
use crate::app::server_functions::{
    assessments::get_assessments, scores::get_student_scores, students::get_student,
    tests::get_tests,
};
use chrono::prelude::*;
use futures::join;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::{self, Debug};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub enum Progress {
    Completed,
    Ongoing,
    NotStarted,
}

impl fmt::Display for Progress {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Progress::Completed => "Completed".to_string(),
                Progress::Ongoing => "In Progress".to_string(),
                Progress::NotStarted => "Not Started".to_string(),
            }
        )
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct TestHistoryEntry {
    pub test_id: String,
    pub test_name: String,
    pub score: i32,
    pub total_possible: i32,
    pub date_administered: DateTime<Utc>,
    pub performance_class: String,
    pub evaluator: String,
    pub attempt: i32,
}

// New structures to represent pre-processed data for efficient rendering
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct StudentResultsSummary {
    pub student: Student,
    pub assessment_summaries: Vec<AssessmentSummary>,
    pub test_summaries: Vec<TestDetail>,
    pub test_history: Vec<TestHistoryEntry>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct AssessmentSummary {
    pub assessment_id: String,
    pub assessment_name: String,
    pub subject: String,
    pub total_possible: Option<i32>,
    pub current_score: i32,
    pub grade_level: Option<String>,
    pub test_details: Vec<TestDetail>, // Now contains ALL attempts, not just highest
    pub distribution_data: Vec<(String, i32)>,
    pub assessment_rating: String,
    pub progress: Progress,
}

#[derive(Debug, Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct TestDetail {
    pub test_id: String,
    pub test_name: String,
    pub score: i32,
    pub total_possible: i32,
    pub test_area: String,
    pub date_administered: DateTime<Utc>,
    pub performance_class: String,
    pub attempt: i32,
    pub test_variant: i32,
}

#[cfg(feature = "ssr")]
pub async fn get_student_results(student_id: i32) -> Result<StudentResultsSummary, String> {
    // Parallel data fetching instead of sequential - major performance improvement
    let (tests_result, assessments_result, scores_result, student_result, teachers_result) = join!(
        get_tests(),
        get_assessments(),
        get_student_scores(student_id),
        get_student(student_id),
        get_teachers(),
    );

    // Handle results with proper error propagation
    let tests = tests_result.map_err(|e| e.to_string())?;
    let assessments = assessments_result.map_err(|e| e.to_string())?;
    let scores = scores_result.map_err(|e| e.to_string())?;
    let student = student_result.map_err(|e| e.to_string())?;
    let teachers = teachers_result.map_err(|e| e.to_string())?;

    // Create efficient lookup maps - O(1) access instead of O(n) searches
    let test_lookup: HashMap<String, &Test> = tests
        .iter()
        .map(|test| (test.test_id.clone(), test))
        .collect();

    let assessment_lookup: HashMap<String, &Assessment> = assessments
        .iter()
        .map(|assessment| (assessment.id.to_string(), assessment))
        .collect();

    let teacher_lookup: HashMap<String, String> = teachers
        .iter()
        .map(|teacher| {
            let full_name = format!("{} {}", teacher.firstname, teacher.lastname);
            let teacher_id = teacher.id.to_string();
            log::info!("Teacher lookup entry: '{}' -> '{}'", teacher_id, full_name);
            (teacher_id, full_name)
        })
        .collect();

    log::info!(
        "Created teacher lookup with {} entries",
        teacher_lookup.len()
    );
    if teacher_lookup.is_empty() {
        log::warn!("Teacher lookup is empty! No teachers found.");
    }

    // Process test history efficiently without dataframes
    let test_history = build_test_history_fixed(&scores, &test_lookup, &teacher_lookup);

    // MODIFIED: Process ALL scores instead of just highest scores
    let all_test_details = build_all_test_details(&scores, &test_lookup, &teacher_lookup);

    // Find highest scores for the test_summaries field (backwards compatibility)
    let highest_scores = find_highest_scores(&scores);
    let highest_test_details =
        build_test_details_fixed(&highest_scores, &test_lookup, &teacher_lookup);

    // Group by assessment and create summaries with ALL attempts
    let assessment_summaries =
        build_assessment_summaries_with_all_attempts(&all_test_details, &assessment_lookup);

    Ok(StudentResultsSummary {
        student,
        assessment_summaries,
        test_summaries: highest_test_details, // Keep this as highest scores for backwards compatibility
        test_history,
    })
}

// NEW: Build test details for ALL scores, not just highest
#[cfg(feature = "ssr")]
fn build_all_test_details(
    scores: &[Score],
    test_lookup: &HashMap<String, &Test>,
    teacher_lookup: &HashMap<String, String>,
) -> Vec<TestDetail> {
    scores
        .iter()
        .filter_map(|score| {
            test_lookup.get(&score.test_id).map(|test| {
                let score_total = score.get_total();
                let evaluator_name = resolve_evaluator_name(&score.evaluator, teacher_lookup);

                TestDetail {
                    test_id: score.test_id.clone(),
                    test_name: test.name.clone(),
                    score: score_total,
                    total_possible: test.score,
                    test_area: test.testarea.to_string(),
                    date_administered: score.date_administered,
                    performance_class: determine_performance_class_fast(test, score_total),
                    attempt: score.attempt,
                    test_variant: score.test_variant,
                }
            })
        })
        .collect()
}

// MODIFIED: Assessment summary builder that includes ALL attempts
#[cfg(feature = "ssr")]
fn build_assessment_summaries_with_all_attempts(
    all_test_details: &[TestDetail],
    assessment_lookup: &HashMap<String, &Assessment>,
) -> Vec<AssessmentSummary> {
    // Group ALL test attempts by assessment efficiently
    let mut assessment_tests: HashMap<String, Vec<TestDetail>> = HashMap::new();

    for test_detail in all_test_details {
        for (assessment_id, assessment) in assessment_lookup {
            if assessment
                .tests
                .iter()
                .any(|uuid| uuid.to_string() == test_detail.test_id)
            {
                assessment_tests
                    .entry(assessment_id.clone())
                    .or_default()
                    .push(test_detail.clone());
            }
        }
    }

    // Create summaries using iterator patterns - very efficient
    assessment_tests
        .into_iter()
        .filter_map(|(assessment_id, mut test_details)| {
            assessment_lookup.get(&assessment_id).map(|assessment| {
                // Sort test details by date (most recent first) and then by attempt
                test_details.sort_unstable_by(|a, b| {
                    b.date_administered
                        .cmp(&a.date_administered)
                        .then_with(|| b.attempt.cmp(&a.attempt))
                });

                // For current_score calculation, use the highest score for each unique test
                let highest_scores_per_test = find_highest_scores_per_test(&test_details);
                let current_score: i32 = highest_scores_per_test.values().map(|td| td.score).sum();
                let total_possible = assessment.composite_score;

                AssessmentSummary {
                    assessment_id: assessment_id.clone(),
                    assessment_name: assessment.name.clone(),
                    subject: assessment
                        .subject
                        .map_or("Unknown".to_string(), |s| s.to_string()),
                    total_possible,
                    current_score,
                    grade_level: assessment.grade.as_ref().map(|g| g.to_string()),
                    test_details: test_details.clone(),
                    distribution_data: calculate_distribution_fast(&test_details),
                    assessment_rating: determine_assessment_rating_fast(
                        assessment,
                        current_score,
                        total_possible.unwrap_or(0),
                    ),
                    progress: calculate_progress_fast_all_attempts(assessment, &test_details),
                }
            })
        })
        .collect()
}

// NEW: Helper function to find highest scores per test from a list of test details
#[cfg(feature = "ssr")]
fn find_highest_scores_per_test(test_details: &[TestDetail]) -> HashMap<String, &TestDetail> {
    let mut highest_per_test: HashMap<String, &TestDetail> = HashMap::new();

    for test_detail in test_details {
        match highest_per_test.get(&test_detail.test_id) {
            Some(existing) if existing.score >= test_detail.score => {
                // Keep existing highest score
            }
            _ => {
                // Update with new highest score
                highest_per_test.insert(test_detail.test_id.clone(), test_detail);
            }
        }
    }

    highest_per_test
}

// MODIFIED: Progress calculation that works with all attempts
#[cfg(feature = "ssr")]
fn calculate_progress_fast_all_attempts(
    assessment: &Assessment,
    test_details: &[TestDetail],
) -> Progress {
    let assessment_test_ids: std::collections::HashSet<String> = assessment
        .tests
        .iter()
        .map(|uuid| uuid.to_string())
        .collect();

    // Get unique test IDs that have been attempted
    let attempted_test_ids: std::collections::HashSet<String> =
        test_details.iter().map(|td| td.test_id.clone()).collect();

    let attempted_count = attempted_test_ids.len();
    let total_count = assessment_test_ids.len();

    match attempted_count {
        0 => Progress::NotStarted,
        n if n == total_count => {
            // Verify all required tests have been attempted
            if assessment_test_ids == attempted_test_ids {
                Progress::Completed
            } else {
                Progress::Ongoing
            }
        }
        _ => Progress::Ongoing,
    }
}

// Optimized test history builder - no dataframes needed
#[cfg(feature = "ssr")]
fn build_test_history_fixed(
    scores: &[Score],
    test_lookup: &HashMap<String, &Test>,
    teacher_lookup: &HashMap<String, String>,
) -> Vec<TestHistoryEntry> {
    let mut history: Vec<TestHistoryEntry> = scores
        .iter()
        .filter_map(|score| {
            test_lookup.get(&score.test_id).map(|test| {
                let score_total = score.get_total();
                let evaluator_name = resolve_evaluator_name(&score.evaluator, teacher_lookup);

                TestHistoryEntry {
                    test_id: score.test_id.clone(),
                    test_name: test.name.clone(),
                    score: score_total,
                    total_possible: test.score,
                    date_administered: score.date_administered,
                    performance_class: determine_performance_class_fast(test, score_total),
                    evaluator: evaluator_name,
                    attempt: score.attempt,
                }
            })
        })
        .collect();

    // Sort by date (much faster than dataframe sorting)
    history.sort_unstable_by(|a, b| b.date_administered.cmp(&a.date_administered));
    history
}

// Optimized highest score finding - O(n) single pass
#[cfg(feature = "ssr")]
fn find_highest_scores(scores: &[Score]) -> HashMap<String, &Score> {
    let mut highest_scores: HashMap<String, &Score> = HashMap::new();

    for score in scores {
        let score_total = score.get_total();
        match highest_scores.get(&score.test_id) {
            Some(existing_score) if existing_score.get_total() >= score_total => {
                // Keep existing highest score
            }
            _ => {
                // Update with new highest score
                highest_scores.insert(score.test_id.clone(), score);
            }
        }
    }

    highest_scores
}

// Native test details processing - no dataframe overhead
#[cfg(feature = "ssr")]
fn build_test_details_fixed(
    highest_scores: &HashMap<String, &Score>,
    test_lookup: &HashMap<String, &Test>,
    teacher_lookup: &HashMap<String, String>,
) -> Vec<TestDetail> {
    highest_scores
        .iter()
        .filter_map(|(test_id, score)| {
            test_lookup.get(test_id).map(|test| {
                let score_total = score.get_total();
                let evaluator_name = resolve_evaluator_name(&score.evaluator, teacher_lookup);

                TestDetail {
                    test_id: score.test_id.clone(),
                    test_name: test.name.clone(),
                    score: score_total,
                    total_possible: test.score,
                    test_area: test.testarea.to_string(),
                    date_administered: score.date_administered,
                    performance_class: determine_performance_class_fast(test, score_total),
                    attempt: score.attempt,
                    test_variant: score.test_variant,
                }
            })
        })
        .collect()
}

// DEPRECATED: Keep for backwards compatibility but rename to indicate it's old
#[cfg(feature = "ssr")]
fn build_assessment_summaries(
    test_details: &[TestDetail],
    assessment_lookup: &HashMap<String, &Assessment>,
) -> Vec<AssessmentSummary> {
    // This now just calls the new function for backwards compatibility
    build_assessment_summaries_with_all_attempts(test_details, assessment_lookup)
}

// Optimized performance classification - avoid repeated benchmark iteration
#[cfg(feature = "ssr")]
fn determine_performance_class_fast(test: &Test, score: i32) -> String {
    if let Some(benchmark_categories) = &test.benchmark_categories {
        let percentage = (score as f32 / test.score as f32) * 100.0;

        // Use early return pattern for better performance
        for benchmark in benchmark_categories {
            if percentage >= benchmark.min as f32 && percentage <= benchmark.max as f32 {
                return benchmark.label.clone();
            }
        }
    }
    "Not Rated".to_string()
}

// Native distribution calculation - much faster than dataframe groupby
#[cfg(feature = "ssr")]
fn calculate_distribution_fast(test_details: &[TestDetail]) -> Vec<(String, i32)> {
    let mut counts: HashMap<String, i32> = HashMap::new();

    for test_detail in test_details {
        *counts
            .entry(test_detail.performance_class.clone())
            .or_insert(0) += 1;
    }

    counts.into_iter().collect()
}

// Fast assessment rating - avoid repeated benchmark checks
#[cfg(feature = "ssr")]
fn determine_assessment_rating_fast(
    assessment: &Assessment,
    score: i32,
    total_possible: i32,
) -> String {
    if total_possible == 0 {
        return "Not Rated".to_string();
    }

    let percentage = (score as f32 / total_possible as f32) * 100.0;

    // Check risk benchmarks first (early return pattern)
    if let Some(risk_benchmarks) = &assessment.risk_benchmarks {
        for benchmark in risk_benchmarks {
            if percentage >= benchmark.min as f32 && percentage <= benchmark.max as f32 {
                return benchmark.label.clone();
            }
        }
    }

    // Then national benchmarks
    if let Some(national_benchmarks) = &assessment.national_benchmarks {
        for benchmark in national_benchmarks {
            if percentage >= benchmark.min as f32 && percentage <= benchmark.max as f32 {
                return benchmark.label.clone();
            }
        }
    }

    "Not Rated".to_string()
}

// Keep these utility functions for backwards compatibility if needed elsewhere
#[cfg(feature = "ssr")]
fn group_tests_by_name(
    test_history: &[TestHistoryEntry],
) -> HashMap<String, Vec<&TestHistoryEntry>> {
    let mut grouped_tests: HashMap<String, Vec<&TestHistoryEntry>> = HashMap::new();

    for entry in test_history {
        grouped_tests
            .entry(entry.test_name.clone())
            .or_insert_with(Vec::new)
            .push(entry);
    }

    for entries in grouped_tests.values_mut() {
        entries.sort_by(|a, b| a.date_administered.cmp(&b.date_administered));
    }

    grouped_tests
}

#[cfg(feature = "ssr")]
fn group_tests_by_name_and_attempt(
    test_history: &[TestHistoryEntry],
) -> HashMap<(String, i32), Vec<&TestHistoryEntry>> {
    let mut grouped_tests: HashMap<(String, i32), Vec<&TestHistoryEntry>> = HashMap::new();

    for entry in test_history {
        grouped_tests
            .entry((entry.test_name.clone(), entry.attempt))
            .or_insert_with(Vec::new)
            .push(entry);
    }

    for entries in grouped_tests.values_mut() {
        entries.sort_by(|a, b| a.date_administered.cmp(&b.date_administered));
    }

    grouped_tests
}

#[cfg(feature = "ssr")]
fn resolve_evaluator_name(evaluator_id: &str, teacher_lookup: &HashMap<String, String>) -> String {
    if evaluator_id.is_empty() {
        log::debug!("Evaluator ID is empty, returning 'Unknown'");
        return "Unknown".to_string();
    }

    if let Some(teacher_name) = teacher_lookup.get(evaluator_id) {
        log::debug!("Found teacher: {} -> {}", evaluator_id, teacher_name);
        return teacher_name.clone();
    }

    // If direct lookup fails, try parsing as integer and converting back to string
    if let Ok(id_num) = evaluator_id.trim().parse::<i32>() {
        let normalized_id = id_num.to_string();
        if let Some(teacher_name) = teacher_lookup.get(&normalized_id) {
            log::debug!(
                "Found teacher after normalization: {} -> {} -> {}",
                evaluator_id,
                normalized_id,
                teacher_name
            );
            return teacher_name.clone();
        }
    }

    // Return a descriptive fallback
    if evaluator_id.chars().all(|c| c.is_ascii_digit()) {
        format!("Teacher #{}", evaluator_id)
    } else {
        evaluator_id.to_string()
    }
}
use crate::app::components::data_processing::{AssessmentSummary, TestDetail, TestHistoryEntry};
use leptos::html;
use leptos::prelude::*;
use leptos::prelude::*;

// Helper function to wait for Chart.js to be available
#[cfg(feature = "hydrate")]
pub fn wait_for_chartjs<F>(callback: F)
where
    F: Fn() + 'static,
{
    use wasm_bindgen::prelude::*;

    let window = web_sys::window().unwrap();

    // Check if Chart is already available
    if js_sys::Reflect::has(&window, &"Chart".into()).unwrap_or(false) {
        callback();
        return;
    }

    // Listen for the chartjs-loaded event
    let closure = Closure::wrap(Box::new(move |_: web_sys::Event| {
        callback();
    }) as Box<dyn Fn(_)>);

    window
        .add_event_listener_with_callback("chartjs-loaded", closure.as_ref().unchecked_ref())
        .unwrap();
    closure.forget();
}

// Assessment Progress Overview Chart
#[component]
pub fn AssessmentProgressChart(
    assessments: Vec<AssessmentSummary>,
    chart_id: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let assessments = assessments.clone();

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                let labels: Vec<String> = assessments
                    .iter()
                    .map(|a| a.assessment_name.clone())
                    .collect();

                let current_scores: Vec<i32> =
                    assessments.iter().map(|a| a.current_score).collect();

                let total_possibles: Vec<i32> = assessments
                    .iter()
                    .map(|a| a.total_possible.unwrap_or(0))
                    .collect();

                let config = json!({
                    "type": "bar",
                    "data": {
                        "labels": labels,
                        "datasets": [
                            {
                                "label": "Current Score",
                                "data": current_scores,
                                "backgroundColor": "rgba(59, 130, 246, 0.8)",
                                "borderColor": "rgba(59, 130, 246, 1)",
                                "borderWidth": 2,
                                "borderRadius": 6,
                            },
                            {
                                "label": "Total Possible",
                                "data": total_possibles,
                                "backgroundColor": "rgba(229, 231, 235, 0.8)",
                                "borderColor": "rgba(156, 163, 175, 1)",
                                "borderWidth": 1,
                                "borderRadius": 6,
                            }
                        ]
                    },
                    "options": {
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": "Assessment Progress Overview",
                                "font": {
                                    "size": 16,
                                    "weight": "bold"
                                },
                                "color": "#1f2937"
                            },
                            "legend": {
                                "position": "top"
                            }
                        },
                        "scales": {
                            "y": {
                                "beginAtZero": true
                            }
                        }
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    view! {
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="h-80 relative">
                <canvas node_ref=chart_ref id=chart_id></canvas>
            </div>
        </div>
    }
}

// Performance Distribution Pie Chart
#[component]
pub fn PerformanceDistributionChart(
    distribution_data: Vec<(String, i32)>,
    chart_id: String,
    title: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let distribution_data = distribution_data.clone();
            let title = title.clone();

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                let labels: Vec<String> = distribution_data
                    .iter()
                    .map(|(label, _)| label.clone())
                    .collect();

                let data: Vec<i32> = distribution_data.iter().map(|(_, count)| *count).collect();

                let colors: Vec<String> = labels
                    .iter()
                    .map(|label| {
                        if label.contains("Above")
                            || label.contains("High")
                            || label.contains("Excellent")
                        {
                            "rgba(34, 197, 94, 0.8)".to_string()
                        } else if label.contains("Average")
                            || label.contains("On Track")
                            || label.contains("Satisfactory")
                        {
                            "rgba(59, 130, 246, 0.8)".to_string()
                        } else if label.contains("Below")
                            || label.contains("Risk")
                            || label.contains("Needs")
                        {
                            "rgba(239, 68, 68, 0.8)".to_string()
                        } else {
                            "rgba(156, 163, 175, 0.8)".to_string()
                        }
                    })
                    .collect();

                let config = json!({
                    "type": "doughnut",
                    "data": {
                        "labels": labels,
                        "datasets": [{
                            "data": data,
                            "backgroundColor": colors,
                            "borderWidth": 2,
                            "hoverOffset": 8
                        }]
                    },
                    "options": {
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": title,
                                "font": {
                                    "size": 14,
                                    "weight": "bold"
                                }
                            },
                            "legend": {
                                "position": "bottom"
                            }
                        },
                        "cutout": "60%"
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    view! {
        <div class="bg-white rounded-lg shadow-lg p-4">
            <div class="h-64 relative">
                <canvas node_ref=chart_ref id=chart_id></canvas>
            </div>
        </div>
    }
}

// Test Scores Timeline Chart
#[component]
pub fn TestScoresTimelineChart(
    test_history: Vec<TestHistoryEntry>,
    chart_id: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let test_history = test_history.clone();

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                let mut sorted_history = test_history.clone();
                sorted_history.sort_by(|a, b| a.date_administered.cmp(&b.date_administered));

                let labels: Vec<String> = sorted_history
                    .iter()
                    .map(|entry| entry.date_administered.format("%Y-%m-%d").to_string())
                    .collect();

                let scores: Vec<f32> = sorted_history
                    .iter()
                    .map(|entry| (entry.score as f32 / entry.total_possible as f32) * 100.0)
                    .collect();

                let config = json!({
                    "type": "line",
                    "data": {
                        "labels": labels,
                        "datasets": [{
                            "label": "Score Percentage",
                            "data": scores,
                            "borderColor": "rgba(59, 130, 246, 1)",
                            "backgroundColor": "rgba(59, 130, 246, 0.1)",
                            "borderWidth": 3,
                            "pointRadius": 6,
                            "fill": true,
                            "tension": 0.4
                        }]
                    },
                    "options": {
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": "Test Performance Timeline",
                                "font": {
                                    "size": 16,
                                    "weight": "bold"
                                }
                            }
                        },
                        "scales": {
                            "y": {
                                "beginAtZero": true,
                                "max": 100,
                                "title": {
                                    "display": true,
                                    "text": "Score Percentage"
                                }
                            },
                            "x": {
                                "title": {
                                    "display": true,
                                    "text": "Date"
                                }
                            }
                        }
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    view! {
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="h-80 relative">
                <canvas node_ref=chart_ref id=chart_id></canvas>
            </div>
        </div>
    }
}

// Radar Chart for Assessment Comparison
#[component]
pub fn AssessmentRadarChart(
    assessment_data: Vec<AssessmentSummary>,
    radar_chart_id: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let assessment_data = assessment_data.clone();

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                let labels: Vec<String> = assessment_data
                    .iter()
                    .map(|a| a.assessment_name.clone())
                    .collect();

                let percentages: Vec<f32> = assessment_data
                    .iter()
                    .map(|a| {
                        if let Some(total) = a.total_possible {
                            if total > 0 {
                                (a.current_score as f32 / total as f32) * 100.0
                            } else {
                                0.0
                            }
                        } else {
                            0.0
                        }
                    })
                    .collect();

                let config = json!({
                    "type": "radar",
                    "data": {
                        "labels": labels,
                        "datasets": [{
                            "label": "Performance",
                            "data": percentages,
                            "borderColor": "rgba(59, 130, 246, 1)",
                            "backgroundColor": "rgba(59, 130, 246, 0.2)",
                            "borderWidth": 2,
                            "pointRadius": 5
                        }]
                    },
                    "options": {
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": "Assessment Performance Comparison",
                                "font": {
                                    "size": 16,
                                    "weight": "bold"
                                }
                            }
                        },
                        "scales": {
                            "r": {
                                "beginAtZero": true,
                                "max": 100
                            }
                        }
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    view! {
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="h-80 relative">
                <canvas node_ref=chart_ref id=radar_chart_id></canvas>
            </div>
        </div>
    }
}

// Test Area Performance Horizontal Bar Chart
#[component]
pub fn TestAreaPerformanceChart(
    test_area_data: Vec<TestDetail>,
    area_chart_id: String,
) -> impl IntoView {
    let chart_ref = create_node_ref::<html::Canvas>();

    #[cfg(feature = "hydrate")]
    Effect::new(move |_| {
        if let Some(canvas) = chart_ref.get() {
            let test_area_data = test_area_data.clone();

            wait_for_chartjs(move || {
                use gloo_utils::format::JsValueSerdeExt;
                use serde_json::json;
                use wasm_bindgen::prelude::*;

                let window = web_sys::window().unwrap();
                let chart_constructor = js_sys::Reflect::get(&window, &"Chart".into()).unwrap();

                // Group by test area and calculate averages
                let mut area_scores: std::collections::HashMap<String, Vec<f32>> =
                    std::collections::HashMap::new();

                for test in &test_area_data {
                    let percentage = (test.score as f32 / test.total_possible as f32) * 100.0;
                    area_scores
                        .entry(test.test_area.clone())
                        .or_insert_with(Vec::new)
                        .push(percentage);
                }

                let mut labels = Vec::new();
                let mut averages = Vec::new();
                let mut colors = Vec::new();

                for (area, scores) in area_scores {
                    let avg = scores.iter().sum::<f32>() / scores.len() as f32;
                    labels.push(area);
                    averages.push(avg);

                    if avg >= 80.0 {
                        colors.push("rgba(34, 197, 94, 0.8)".to_string());
                    } else if avg >= 60.0 {
                        colors.push("rgba(59, 130, 246, 0.8)".to_string());
                    } else {
                        colors.push("rgba(239, 68, 68, 0.8)".to_string());
                    }
                }

                let config = json!({
                    "type": "bar",
                    "data": {
                        "labels": labels,
                        "datasets": [{
                            "label": "Average Performance",
                            "data": averages,
                            "backgroundColor": colors,
                            "borderWidth": 2,
                            "borderRadius": 6
                        }]
                    },
                    "options": {
                        "indexAxis": "y",
                        "responsive": true,
                        "maintainAspectRatio": false,
                        "plugins": {
                            "title": {
                                "display": true,
                                "text": "Performance by Test Area",
                                "font": {
                                    "size": 16,
                                    "weight": "bold"
                                }
                            }
                        },
                        "scales": {
                            "x": {
                                "beginAtZero": true,
                                "max": 100
                            }
                        }
                    }
                });

                let config_js = JsValue::from_serde(&config).unwrap();
                let canvas_element = canvas.unchecked_ref::<web_sys::HtmlCanvasElement>();
                let args = js_sys::Array::new();
                args.push(&JsValue::from(canvas_element));
                args.push(&config_js);

                let _ = js_sys::Reflect::construct(&chart_constructor.into(), &args);
            });
        }
    });

    view! {
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="h-80 relative">
                <canvas node_ref=chart_ref id=area_chart_id></canvas>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::test::BenchmarkCategory;

pub struct ColorUtils;

impl ColorUtils {
    /// Converts hex colors from benchmark categories to Tailwind CSS classes
    pub fn hex_to_tailwind_classes(hex_color: &str) -> String {
        match hex_color.to_lowercase().as_str() {
            "#10b981" => "bg-green-100 text-green-800".to_string(), // green
            "#06b6d4" => "bg-cyan-100 text-cyan-800".to_string(),   // cyan
            "#f59e0b" => "bg-amber-100 text-amber-800".to_string(), // amber
            "#ef4444" => "bg-red-100 text-red-800".to_string(),     // red
            "#8b5cf6" => "bg-purple-100 text-purple-800".to_string(), // purple
            "#f43f5e" => "bg-rose-100 text-rose-800".to_string(),   // rose
            "#6b7280" => "bg-gray-100 text-gray-800".to_string(),   // gray
            _ => "bg-gray-100 text-gray-800".to_string(),           // default fallback
        }
    }

    /// Gets badge color classes based on score percentage and benchmark categories
    pub fn get_badge_classes_for_score(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        if max_score <= 0 {
            return "bg-gray-100 text-gray-800".to_string();
        }

        let percentage = (score as f64 / max_score as f64) * 100.0;

        // Check custom benchmark categories first
        if let Some(categories) = benchmark_categories {
            for category in categories {
                // Determine if benchmark category uses percentage or raw score
                let (min_check, max_check) = if Self::is_percentage_based(category, max_score) {
                    // Category uses percentages (0-100 range)
                    (category.min as f64, category.max as f64)
                } else {
                    // Category uses raw scores - convert to percentage for comparison
                    let min_percent = (category.min as f64 / max_score as f64) * 100.0;
                    let max_percent = (category.max as f64 / max_score as f64) * 100.0;
                    (min_percent, max_percent)
                };

                if percentage >= min_check && percentage <= max_check {
                    return Self::hex_to_tailwind_classes(&category.get_color());
                }
            }
        }

        // Fallback color scheme
        Self::get_default_color_for_percentage(percentage)
    }

    /// Determines if a benchmark category is using percentage (0-100) or raw score values
    fn is_percentage_based(category: &BenchmarkCategory, max_score: i32) -> bool {
        // If the category max is <= 100 and the test max_score is > 100,
        // assume category is percentage-based
        // This is a heuristic - you might want to add a field to BenchmarkCategory to be explicit
        category.max <= 100 && max_score > 100
    }

    /// Alternative method that uses raw score comparison (if you know categories use raw scores)
    pub fn get_badge_classes_for_raw_score(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        if max_score <= 0 {
            return "bg-gray-100 text-gray-800".to_string();
        }

        // Check custom benchmark categories using raw score values
        if let Some(categories) = benchmark_categories {
            for category in categories {
                if score >= category.min && score <= category.max {
                    return Self::hex_to_tailwind_classes(&category.get_color());
                }
            }
        }

        // Fallback to percentage-based colors
        let percentage = (score as f64 / max_score as f64) * 100.0;
        Self::get_default_color_for_percentage(percentage)
    }

    /// Alternative method that uses percentage comparison (if you know categories use percentages)
    pub fn get_badge_classes_for_percentage(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        if max_score <= 0 {
            return "bg-gray-100 text-gray-800".to_string();
        }

        let percentage = (score as f64 / max_score as f64) * 100.0;

        // Check custom benchmark categories using percentage values
        if let Some(categories) = benchmark_categories {
            for category in categories {
                let min_percent = category.min as f64;
                let max_percent = category.max as f64;
                if percentage >= min_percent && percentage <= max_percent {
                    return Self::hex_to_tailwind_classes(&category.get_color());
                }
            }
        }

        // Fallback color scheme
        Self::get_default_color_for_percentage(percentage)
    }

    /// Gets default color classes based on percentage (when no custom categories)
    fn get_default_color_for_percentage(percentage: f64) -> String {
        if percentage >= 90.0 {
            "bg-green-100 text-green-800".to_string() // Excellent
        } else if percentage >= 80.0 {
            "bg-cyan-100 text-cyan-800".to_string() // Good
        } else if percentage >= 70.0 {
            "bg-amber-100 text-amber-800".to_string() // Satisfactory
        } else if percentage >= 60.0 {
            "bg-rose-100 text-rose-800".to_string() // Needs Improvement
        } else {
            "bg-red-100 text-red-800".to_string() // Poor
        }
    }

    /// Converts hex colors to inline style string (alternative to Tailwind)
    pub fn hex_to_inline_style(hex_color: &str) -> String {
        let (bg_light, text_color) = Self::get_color_variants(hex_color);
        format!(
            "background-color: {}; color: {}; border: 1px solid {};",
            bg_light, text_color, hex_color
        )
    }

    /// Gets light background and contrasting text color for a given hex color
    fn get_color_variants(hex_color: &str) -> (&'static str, &'static str) {
        match hex_color.to_lowercase().as_str() {
            "#10b981" => ("#d1fae5", "#065f46"), // green light background, dark text
            "#06b6d4" => ("#cffafe", "#164e63"), // cyan light background, dark text
            "#f59e0b" => ("#fef3c7", "#92400e"), // amber light background, dark text
            "#ef4444" => ("#fee2e2", "#991b1b"), // red light background, dark text
            "#8b5cf6" => ("#ede9fe", "#581c87"), // purple light background, dark text
            "#f43f5e" => ("#ffe4e6", "#9f1239"), // rose light background, dark text
            "#6b7280" => ("#f3f4f6", "#374151"), // gray light background, dark text
            _ => ("#f3f4f6", "#374151"),         // default gray
        }
    }

    /// Gets inline style for score badges based on benchmark categories
    pub fn get_badge_style_for_score(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        if max_score <= 0 {
            return "background-color: #f3f4f6; color: #374151; border: 1px solid #d1d5db;"
                .to_string();
        }

        let percentage = (score as f64 / max_score as f64) * 100.0;

        // Check custom benchmark categories first
        if let Some(categories) = benchmark_categories {
            for category in categories {
                let (min_check, max_check) = if Self::is_percentage_based(category, max_score) {
                    (category.min as f64, category.max as f64)
                } else {
                    let min_percent = (category.min as f64 / max_score as f64) * 100.0;
                    let max_percent = (category.max as f64 / max_score as f64) * 100.0;
                    (min_percent, max_percent)
                };

                if percentage >= min_check && percentage <= max_check {
                    return Self::hex_to_inline_style(&category.get_color());
                }
            }
        }

        // Fallback using default colors
        let hex_color = if percentage >= 90.0 {
            "#10b981" // green
        } else if percentage >= 80.0 {
            "#06b6d4" // cyan
        } else if percentage >= 70.0 {
            "#f59e0b" // amber
        } else if percentage >= 60.0 {
            "#f43f5e" // rose
        } else {
            "#ef4444" // red
        };

        Self::hex_to_inline_style(hex_color)
    }

    /// Gets score text color classes based on benchmark categories
    pub fn get_score_text_color_for_score(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        let badge_classes =
            Self::get_badge_classes_for_score(score, max_score, benchmark_categories);

        if badge_classes.contains("text-green-800") {
            "text-lg font-semibold text-green-600".to_string()
        } else if badge_classes.contains("text-cyan-800") {
            "text-lg font-semibold text-cyan-600".to_string()
        } else if badge_classes.contains("text-amber-800") {
            "text-lg font-semibold text-amber-600".to_string()
        } else if badge_classes.contains("text-rose-800") {
            "text-lg font-semibold text-rose-600".to_string()
        } else if badge_classes.contains("text-red-800") {
            "text-lg font-semibold text-red-600".to_string()
        } else if badge_classes.contains("text-purple-800") {
            "text-lg font-semibold text-purple-600".to_string()
        } else {
            "text-lg font-semibold text-gray-600".to_string()
        }
    }

    /// Gets progress bar color classes based on benchmark categories
    pub fn get_progress_bar_color_for_score(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        let badge_classes =
            Self::get_badge_classes_for_score(score, max_score, benchmark_categories);

        if badge_classes.contains("text-green-800") {
            "bg-green-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else if badge_classes.contains("text-cyan-800") {
            "bg-cyan-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else if badge_classes.contains("text-amber-800") {
            "bg-amber-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else if badge_classes.contains("text-rose-800") {
            "bg-rose-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else if badge_classes.contains("text-red-800") {
            "bg-red-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else if badge_classes.contains("text-purple-800") {
            "bg-purple-500 h-1.5 rounded-full transition-all duration-300".to_string()
        } else {
            "bg-gray-500 h-1.5 rounded-full transition-all duration-300".to_string()
        }
    }
}
use crate::app::components::dashboard::color_utils::ColorUtils; // Import your new module
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent, StudentMappingService,
};
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::score::{DeleteScoreRequest, Score};
use crate::app::models::student::Student;
use crate::app::models::test::{BenchmarkCategory, Test};
use crate::app::server_functions::scores::{delete_score, get_scores};
use crate::app::server_functions::students::get_students;
use crate::app::server_functions::tests::get_tests;
use chrono::DateTime;
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;
use std::rc::Rc;

#[component]
pub fn ScoresLedger() -> impl IntoView {
    let navigate = use_navigate();

    // Get global settings for anonymization
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    // Get the student mapping service
    let (student_mapping_service, _) = use_student_mapping_service();

    // Create resource for fetching scores from the database
    let scores_resource = LocalResource::new(
        || (),
        |_| async {
            match get_scores().await {
                Ok(mut scores) => {
                    if scores.len() > 4 {
                        scores.truncate(4);
                        scores.reverse();
                    }
                    Ok(scores)
                }
                Err(e) => {
                    log::error!("Failed to load scores: {}", e);
                    Err(ServerFnError::new("Failed to load scores"))
                }
            }
        },
    );

    // Create students resource
    let students_resource = LocalResource::new(
        || (),
        |_| async {
            match get_students().await {
                Ok(students) => Some(students),
                Err(e) => {
                    log::error!("Failed to load students: {}", e);
                    None
                }
            }
        },
    );

    // Create enhanced student data with de-anonymization info
    let enhanced_students = Memo::new(move |_| {
        let students_data = students_resource.get().unwrap_or(None).unwrap_or_default();

        if anonymization_enabled() {
            students_data
                .into_iter()
                .map(|student| {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &student,
                        student_mapping_service.get().as_ref(),
                    );
                    (student, Some(de_anon))
                })
                .collect::<Vec<_>>()
        } else {
            students_data
                .into_iter()
                .map(|student| (student, None))
                .collect::<Vec<_>>()
        }
    });

    let tests_resource = LocalResource::new(
        || (),
        |_| async {
            match get_tests().await {
                Ok(mut tests) => Ok(tests),
                Err(e) => {
                    log::error!("Failed to load tests: {}", e);
                    Err(ServerFnError::new("Failed to load tests"))
                }
            }
        },
    );

    let (expanded_view, set_expanded_view) = signal(false);

    let toggle_expanded_view = move |_| {
        set_expanded_view.update(|val| *val = !*val);
    };

    view! {
        <div class={move || {
            if expanded_view() {
                "fixed inset-0 z-50 bg-[#F9F9F8] flex flex-col p-5"
            } else {
                "w-full"
            }
        }}>
            <div class="flex items-center justify-between mb-2 p-2">
                <h2 class="text-xl font-bold">Recent Scores</h2>
                <div>
                    <button
                        class="text-indigo-600 hover:text-indigo-800 text-sm font-medium"
                        on:click=toggle_expanded_view
                    >
                        {move || if expanded_view() {"Collapse"} else {"View all"}}
                    </button>
                </div>
            </div>

            <div class={move ||{
                let base_classes = "bg-[#F9F9F8] overflow-hidden shadow-lg sm:rounded-lg border border-gray-200";
                if expanded_view() {
                    format!("{} flex-grow overflow-hidden", base_classes)
                } else {
                    base_classes.to_string()
                }
            }}>
                <div class={move || {
                    let base_classes = "overflow-x-auto overflow-y-auto";
                    if expanded_view() {
                        format!("{} h-full", base_classes)
                    } else {
                        format!("{} max-h-80", base_classes)
                    }
                }}>
                    <table class="min-w-full divide-y divide-[#DADADA]">
                        <thead class="bg-[#DADADA]">
                            <tr>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Student ID
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Student Name
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Test
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Date
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Percentage
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Benchmark
                                </th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Evaluator
                                </th>
                                <th scope="col" class="px-6 py-3 text-right text-xs font-medium text-[#2E3A59] uppercase tracking-wider">
                                    Actions
                                </th>
                            </tr>
                        </thead>
                        <tbody class="bg-[#F9F9F8] divide-y divide-[#DADADA]">
                            {move || {
                                scores_resource.get().map(|result| {
                                    match result {
                                        Ok(scores) => {
                                            if scores.is_empty() {
                                                view! {
                                                    <tr>
                                                        <td colspan="7" class="px-6 py-4 text-center text-sm text-[#2E3A59]">
                                                            No scores found.
                                                        </td>
                                                    </tr>
                                                }
                                                .into_any()
                                            } else {
                                                scores.iter().rev().map(|score| {
                                                    let student_id = score.student_id;
                                                    let test_id = score.test_id.clone();
                                                    let test_variant = score.test_variant;
                                                    let attempt = score.attempt;

                                                    // Get test data for this score
                                                    let test_data = tests_resource.get()
                                                        .and_then(|result| result.ok())
                                                        .and_then(|tests| tests.iter().find(|t| t.test_id == test_id).cloned());

                                                    let max_score = test_data.as_ref().map(|t| t.score).unwrap_or(0);
                                                    let test_name = test_data.as_ref().map(|t| t.name.clone()).unwrap_or_else(|| "Unknown Test".to_string());
                                                    let benchmark_categories = test_data.as_ref().and_then(|t| t.benchmark_categories.as_ref());

                                                    // Calculate derived values
                                                    let total_score: i32 = score.test_scores.iter().sum();
                                                    let percentage = if max_score > 0 {
                                                        format!("{:.1}%", (total_score as f64 / max_score as f64 * 100.0))
                                                    } else {
                                                        "N/A".to_string()
                                                    };

                                                    let benchmark_label = ScoreUtils::get_benchmark_label(total_score, max_score, benchmark_categories);
                                                    let badge_classes = ColorUtils::get_badge_classes_for_score(total_score, max_score, benchmark_categories);

                                                    // Get student display info
                                                    let student_display = ScoreUtils::get_student_display_info(student_id, &enhanced_students());

                                                    view! {
                                                        <tr class="hover:bg-gray-50">
                                                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-[#2E3A59]">
                                                                {student_display.id}
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-[#2E3A59]">
                                                                {student_display.name}
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap text-sm text-[#2E3A59]">
                                                                <div class="flex flex-col">
                                                                    <span>{test_name}</span>
                                                                    <span class="text-xs text-[#2E3A59]">{"Variant: "}{score.test_variant}</span>
                                                                </div>
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap text-sm text-[#2E3A59]">
                                                                <div class="flex flex-col">
                                                                    <span>{score.date_administered.format("%b %d, %Y").to_string()}</span>
                                                                    <span class="text-xs text-[#2E3A59]">{score.date_administered.format("%H:%M").to_string()}</span>
                                                                </div>
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap">
                                                                <span class={format!("px-2 inline-flex text-xs leading-5 font-semibold rounded-full {}", badge_classes)}>
                                                                    {percentage}
                                                                </span>
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap">
                                                                <span class={format!("px-2 inline-flex text-xs leading-5 font-semibold rounded-full {}", badge_classes)}>
                                                                    {benchmark_label}
                                                                </span>
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap text-sm text-[#2E3A59]">
                                                                {&score.evaluator}
                                                            </td>
                                                            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                                {
                                                                    let nav = navigate.clone();
                                                                    let test_id = score.test_id.clone();
                                                                    let student_id = score.student_id;
                                                                    let test_variant = score.test_variant.clone();
                                                                    let attempt = score.attempt.clone();

                                                                    view! {
                                                                        <button
                                                                            class="text-indigo-600 hover:text-indigo-900 mr-3"
                                                                            on:click=move |_| {
                                                                                nav(&format!("/reviewtest/{}/{}/{}/{}", test_id, student_id, test_variant, attempt), Default::default());
                                                                            }
                                                                        >
                                                                            View
                                                                        </button>
                                                                    }
                                                                }
                                                            </td>
                                                        </tr>
                                                    }
                                                })
                                                .collect_view()
                                            }
                                        }
                                        Err(_) => {
                                            view! {
                                                <tr>
                                                    <td colspan="7" class="px-6 py-4 text-center text-sm text-[#2E3A59]">
                                                        Failed to load scores. Please try again later.
                                                    </td>
                                                </tr>
                                            }
                                            .into_any()
                                        }
                                    }
                                }).unwrap_or_else(|| view! {
                                    <tr>
                                        <td colspan="7" class="px-6 py-4 text-center text-sm text-[#2E3A59]">
                                            <div class="flex justify-center items-center">
                                                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                Loading scores...
                                            </div>
                                        </td>
                                    </tr>
                                }.into_any())
                            }}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    }
}

// Helper struct for student display info
#[derive(Clone)]
pub struct StudentDisplayInfo {
    pub id: String,
    pub name: String,
}

// Additional utility struct for score-related operations
pub struct ScoreUtils;

impl ScoreUtils {
    pub fn get_student_display_info(
        student_id: i32,
        enhanced_students: &[(Student, Option<DeAnonymizedStudent>)],
    ) -> StudentDisplayInfo {
        if let Some((student, de_anon_opt)) = enhanced_students
            .iter()
            .find(|(s, _)| s.student_id == student_id)
        {
            if let Some(de_anon) = de_anon_opt {
                StudentDisplayInfo {
                    id: de_anon.display_id.clone(),
                    name: de_anon.display_name.clone(),
                }
            } else {
                StudentDisplayInfo {
                    id: student.student_id.to_string(),
                    name: format!(
                        "{} {}",
                        student.firstname.as_ref().unwrap_or(&"Unknown".to_string()),
                        student.lastname.as_ref().unwrap_or(&"Student".to_string())
                    ),
                }
            }
        } else {
            StudentDisplayInfo {
                id: student_id.to_string(),
                name: "Unknown Student".to_string(),
            }
        }
    }

    pub fn get_benchmark_label(
        score: i32,
        max_score: i32,
        benchmark_categories: Option<&Vec<BenchmarkCategory>>,
    ) -> String {
        if max_score <= 0 {
            return "N/A".to_string();
        }

        let percentage = (score as f64 / max_score as f64) * 100.0;

        if let Some(categories) = benchmark_categories {
            for category in categories {
                let min_percent = category.min as f64;
                let max_percent = category.max as f64;
                if percentage >= min_percent && percentage <= max_percent {
                    return category.label.clone();
                }
            }
        }

        // Default labels if no custom categories
        if percentage >= 90.0 {
            "Excellent".to_string()
        } else if percentage >= 80.0 {
            "Good".to_string()
        } else if percentage >= 70.0 {
            "Satisfactory".to_string()
        } else {
            "Needs Improvement".to_string()
        }
    }
}
use crate::app::components::settings_modal::SettingsModal;
use icondata::IoChatbubbleEllipsesOutline;
use icondata::{
    AiApiOutlined, BsClipboardCheck, BsGraphUpArrow, ChNotesTick, FaChildrenSolid,
    LuLayoutDashboard, RiAdminUserFacesLine,
};
use leptos::prelude::*;
use leptos_router::path;
// Add new imports for additional icons, including pin/unpin icons
use crate::app::components::ShowAdministerTestModal;
use crate::app::models::{setting_data::UserSettings, user::SessionUser};
use crate::app::server_functions::user_settings::get_user_settings;
use icondata::{
    AiCoffeeOutlined,
    AiDashboardOutlined,
    BiClipboardRegular,
    IoPeopleOutline,
    // Add pin/unpin icons
    IoPinOutline,
    IoPinSharp,
    IoPricetagOutline,
    IoSettingsOutline,
};
use leptos::ev::MouseEvent;
use leptos::prelude::*;
use leptos_icons::Icon;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::time::Duration;

#[derive(Clone, PartialEq, Debug)]
pub enum SidebarSelected {
    Overview,
    Analytics,
    Settings,
    Chat,
    Dashboard,
    StudentView,
    TeacherView,
    AdministerTest,
    AdminDashboard,
    Gradebook,
    Assessments,
}
const GRAY_COLOR: &str = "text-[#DADADA]";
const BLUE_COLOR: &str = "text-[#2E3A59]";
const BLUE_HUE: &str = "bg-blue-100";
const BG_BLUE: &str = "bg-[#2E3A59]";
const WHITE_COLOR: &str = "text-[#F9F9F8]";

#[component]
pub fn DashboardSidebar(
    selected_item: ReadSignal<SidebarSelected>,
    set_selected_item: WriteSignal<SidebarSelected>,
) -> impl IntoView {
    // Get the current user ID from use_context
    let current_user =
        expect_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");
    let user_settings_resource = Resource::new(
        move || current_user.get().map(|user| user.id),
        move |id| async move {
            match id {
                Some(user_id) => match get_user_settings(user_id).await {
                    Ok(settings) => Some(settings),
                    Err(e) => {
                        log::error!("Failed to fetch user settings: {}", e);
                        // Return default settings if fetch fails
                        Some(UserSettings::default())
                    }
                },
                None => Some(UserSettings::default()), // Default settings for no user
            }
        },
    );
    let user_id = current_user.get().map(|user| user.id).unwrap_or_default();

    // Handle current route for active styling
    let (current_path, set_current_path) = signal(String::new());

    // Effect to track current route
    Effect::new(move |_| {
        if let Some(route_context) = expect_context::<Router>() {
            set_current_path(route_context.pathname().get());
        } else {
            set_current_path(String::from("/"));
        }
    });

    let (is_expanded, set_is_expanded) = signal(false);
    let (is_navigating, set_is_navigating) = signal(false);
    Effect::new(move |_| {
        let _current_path = current_path();
        set_is_navigating.set(true);
        set_timeout(
            move || {
                set_is_navigating.set(false);
            },
            Duration::from_millis(500),
        );
    });
    let (show_administer_modal, set_show_administer_modal) = signal(false);
    let (show_settings, set_show_settings) = signal(false);

    // New signal for pinned state
    let (is_pinned_closed, set_is_pinned_closed) = signal(false);
    Effect::new(move |_| {
        if let Some(Some(settings)) = user_settings_resource.get() {
            set_is_pinned_closed.set(settings.ui.pinned_sidebar);
        }
    });

    // Handle window size for responsive behavior
    let (is_small_screen, set_is_small_screen) = signal(false);

    // Computed position for dropdown modal based on screen size
    let modal_position = move || {
        let base_left = if is_pinned_closed() {
            if is_small_screen() {
                "5rem"
            } else {
                "5.5rem"
            }
        } else {
            if is_small_screen() {
                "12rem"
            } else {
                "16rem"
            }
        };

        format!("left: {}; top: 12rem;", base_left)
    };

    // Handle mouseenter event with consideration for pinned state
    let handle_mouseenter = move |_| {
        if !is_pinned_closed.get() && !is_navigating.get() && user_settings_resource.get().is_some()
        {
            set_is_expanded(true);
        }
    };

    // Handle mouseleave event with consideration for pinned state
    let handle_mouseleave = move |_| {
        // Only close the sidebar if we're not hovering the modal and not pinned
        if !show_administer_modal.get() && !is_pinned_closed.get() {
            set_is_expanded(false);
        }
    };

    // Toggle pinned state
    let toggle_pinned = move |_| {
        let new_value = !is_pinned_closed.get();
        set_is_pinned_closed.set(new_value);

        if new_value {
            set_is_expanded.set(false);
            set_show_administer_modal.set(false);
        }
    };

    view! {
        <div class="relative">
            <div
                class="fixed left-0 top-20 h-[calc(100vh-4rem)] bg-[#F9F9F8] shadow-lg transition-all duration-300 ease-in-out z-40"
                class=w-16={move || !is_expanded() && is_small_screen()}
                class=w-20={move || !is_expanded() && !is_small_screen()}
                class=w-48={move || is_expanded() && is_small_screen()}
                class=w-64={move || is_expanded() && !is_small_screen()}
                on:mouseenter=handle_mouseenter
                on:mouseleave=handle_mouseleave
            >
                <div class="flex flex-col h-full p-4 overflow-y-auto">
                    <div class="space-y-4 flex-1">
                        // Transferred navigation items from header
                        <SidebarNavLink
                            icon=AiDashboardOutlined
                            label="Dashboard (beta)"
                            path="/dashboard"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/dashboard"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=FaChildrenSolid
                            label="Student View"
                            path="/studentview"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/studentview"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=AiCoffeeOutlined
                            label="Teacher View"
                            path="/teachers"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/teachers"))
                            is_small_screen=is_small_screen.into()
                        />
                        <Show when=move || current_user.get().map(|user| user.is_admin()).unwrap_or(false)>
                            <SidebarNavLink
                                icon=RiAdminUserFacesLine
                                label="Admin Dashboard (beta)"
                                path="/admindashboard"
                                is_expanded=is_expanded.into()
                                is_active=Signal::derive(move || current_path().starts_with("/classrooms"))
                                is_small_screen=is_small_screen.into()
                            />
                        </Show>
                        <SidebarNavLink
                            icon=ChNotesTick
                            label="Assessments"
                            path="/assessments"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/assessments"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=BsGraphUpArrow
                            label="Gradebook (beta)"
                            path="/gradebook"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/gradebook"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=BsClipboardCheck
                            label="Tests"
                            path="/test-manager"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/test-manager"))
                            is_small_screen=is_small_screen.into()
                        />
                    </div>

                    <div class="space-y-4 mt-auto pb-4">

                        // Divider
                        <div class="border-t border-[#DADADA] my-2"></div>

                        // Pin/Unpin button
                        <div
                            class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
                            on:click=toggle_pinned
                            title=move || if is_pinned_closed() { "Unpin sidebar (allow expand on hover)" } else { "Pin sidebar closed" }
                        >
                            <Icon
                                icon={if is_pinned_closed() { IoPinSharp } else { IoPinOutline }}
                                class="w-5 h-5 text-[#2E3A59] flex-shrink-0"
                            />
                            <Show
                                when=move || is_expanded()
                                fallback=|| view! { <></> }
                            >
                                <span class="ml-2 font-semibold text-sm sm:text-base">
                                    {move || if is_pinned_closed() { "Unpin" } else { "Pin Sidebar" }}
                                </span>
                            </Show>
                        </div>

                        <button
                            class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
                            on:click=move |_| set_show_settings.set(true)
                        >
                            <Icon
                                icon=IoSettingsOutline
                                class="w-6 h-6 text[#2E3A59] flex-shrink-0"
                            />
                            <div class="overflow-hidden whitespace-nowrap">
                                <Show
                                    when=move || is_expanded()
                                    fallback=|| view! { <></> }
                                >
                                    <span class="ml-2 font-semibold text-sm sm:text-base">
                                        {"Settings (beta)"}
                                    </span>
                                </Show>
                            </div>
                        </button>

                    </div>
                </div>
            </div>

            // Modal Dropdown - Improved display logic for pinned state
            <Show when=move || show_administer_modal()>
                <div
                    class="fixed z-50 hover-area"
                    style=move || modal_position()
                    on:mouseenter=move |_| {
                        // Keep sidebar expanded when hovering modal
                        if !is_pinned_closed() {
                            set_show_administer_modal(true);
                        }
                    }
                    on:mouseleave=move |_| {
                        // If pinned closed, hide modal but keep sidebar collapsed
                        set_show_administer_modal(false);
                        if !is_pinned_closed() {
                            set_is_expanded(false);
                        }
                    }
                >
                    <ShowAdministerTestModal set_if_show_modal=set_show_administer_modal />
                </div>
            </Show>

            <Show when=move || show_settings()>
                <SettingsModal
                    show=show_settings
                    on_close=move |_| set_show_settings.set(false)
                    user_id=user_id
                />
            </Show>
        </div>
    }
}

#[component]
fn SidebarItem(
    icon: icondata::Icon,
    label: &'static str,
    description: &'static str,
    is_expanded: Signal<bool>,
    is_selected: Signal<bool>,
    is_small_screen: Signal<bool>,
    on_click: impl Fn(MouseEvent) + 'static,
) -> impl IntoView {
    view! {
        <div
            class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
            class=bg-blue-100=move || is_selected()
            on:click=on_click
        >
            <Icon
                icon=icon
                class="w-6 h-6 text-[#2E3A59] flex-shrink-0"
            />
            <div class="overflow-hidden whitespace-nowrap">
                <Show
                    when=move || is_expanded()
                    fallback=|| view! { <></> }
                >
                    <div class="flex flex-col ml-2">
                        <span
                            class="font-semibold text-sm sm:text-base"
                            class=GRAY_COLOR=move || !is_selected.get()
                            class=BLUE_COLOR=move || is_selected.get()
                        >
                            {label}
                        </span>
                        <Show
                            when=move || !is_small_screen()
                            fallback=|| view! { <></> }
                        >
                            <span class="text-xs text-[#2E3A59]">{description}</span>
                        </Show>
                    </div>
                </Show>
            </div>
        </div>
    }
}

#[component]
fn SidebarNavLink(
    icon: icondata::Icon,
    label: &'static str,
    path: &'static str,
    is_expanded: Signal<bool>,
    is_active: Signal<bool>,
    is_small_screen: Signal<bool>,
) -> impl IntoView {
    view! {
        <div
            class="rounded-lg"
            class=bg-blue-100=move || is_active()
        >
            <A
                href={path}
                class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
            >
                <Icon
                    icon=icon
                    class="w-6 h-6 text-[#2E3A59] flex-shrink-0"
                />
                <div class="overflow-hidden whitespace-nowrap">
                    <Show
                        when=move || is_expanded()
                        fallback=|| view! { <></> }
                    >
                        <span
                            class="ml-2 font-semibold text-sm sm:text-base"
                            class=GRAY_COLOR=move || !is_active.get()
                            class=BLUE_COLOR=move || is_active.get()
                        >
                            {label}
                        </span>
                    </Show>
                </div>
            </A>
        </div>
    }
}
use crate::app::components::settings_modal::SettingsModal;
use icondata::IoChatbubbleEllipsesOutline;
use icondata::{
    AiApiOutlined, BsClipboardCheck, BsGraphUpArrow, ChNotesTick, FaChildrenSolid,
    LuLayoutDashboard, RiAdminUserFacesLine,
};
use leptos_router::path;
// Add new imports for additional icons, including pin/unpin icons
use crate::app::components::ShowAdministerTestModal;
use crate::app::models::{setting_data::UserSettings, user::SessionUser};
use crate::app::server_functions::user_settings::get_user_settings;
use icondata::{
    AiCoffeeOutlined,
    AiDashboardOutlined,
    BiClipboardRegular,
    IoPeopleOutline,
    // Add pin/unpin icons
    IoPinOutline,
    IoPinSharp,
    IoPricetagOutline,
    IoSettingsOutline,
};
use leptos::ev::MouseEvent;
use leptos_icons::Icon;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::time::Duration;

#[derive(Clone, PartialEq, Debug)]
pub enum SidebarSelected {
    Overview,
    Analytics,
    Settings,
    Chat,
    Dashboard,
    StudentView,
    TeacherView,
    AdministerTest,
    AdminDashboard,
    Gradebook,
    Assessments,
}
const GRAY_COLOR: &str = "text-[#DADADA]";
const BLUE_COLOR: &str = "text-[#2E3A59]";
const BLUE_HUE: &str = "bg-blue-100";
const BG_BLUE: &str = "bg-[#2E3A59]";
const WHITE_COLOR: &str = "text-[#F9F9F8]";

#[component]
pub fn DashboardSidebar(
    selected_item: ReadSignal<SidebarSelected>,
    set_selected_item: WriteSignal<SidebarSelected>,
) -> impl IntoView {
    // Get the current user ID from expect_context
    let current_user = expect_context::<ReadSignal<Option<SessionUser>>>();
    let user_settings_resource = Resource::new(
        move || current_user.get().map(|user| user.id),
        move |id| async move {
            match id {
                Some(user_id) => match get_user_settings(user_id).await {
                    Ok(settings) => Some(settings),
                    Err(e) => {
                        log::error!("Failed to fetch user settings: {}", e);
                        // Return default settings if fetch fails
                        Some(UserSettings::default())
                    }
                },
                None => Some(UserSettings::default()), // Default settings for no user
            }
        },
    );
    let user_id = current_user.get().map(|user| user.id).unwrap_or_default();

    // Handle current route for active styling
    let (current_path, set_current_path) = signal(String::new());

    // Effect to track current route
    Effect::new(move |_| {
        if let Some(route_context) = expect_context::<Router>() {
            set_current_path(route_context.pathname().get());
        } else {
            set_current_path(String::from("/"));
        }
    });

    let (is_expanded, set_is_expanded) = signal(false);
    let (is_navigating, set_is_navigating) = signal(false);
    Effect::new(move |_| {
        let _current_path = current_path();
        set_is_navigating.set(true);
        set_timeout(
            move || {
                set_is_navigating.set(false);
            },
            Duration::from_millis(500),
        );
    });
    let (show_administer_modal, set_show_administer_modal) = signal(false);
    let (show_settings, set_show_settings) = signal(false);

    // New signal for pinned state
    let (is_pinned_closed, set_is_pinned_closed) = signal(false);
    Effect::new(move |_| {
        if let Some(Some(settings)) = user_settings_resource.get() {
            set_is_pinned_closed.set(settings.ui.pinned_sidebar);
        }
    });

    // Handle window size for responsive behavior
    let (is_small_screen, set_is_small_screen) = signal(false);

    // Computed position for dropdown modal based on screen size
    let modal_position = move || {
        let base_left = if is_pinned_closed() {
            if is_small_screen() {
                "5rem"
            } else {
                "5.5rem"
            }
        } else {
            if is_small_screen() {
                "12rem"
            } else {
                "16rem"
            }
        };

        format!("left: {}; top: 12rem;", base_left)
    };

    // Handle mouseenter event with consideration for pinned state
    let handle_mouseenter = move |_| {
        if !is_pinned_closed.get() && !is_navigating.get() && user_settings_resource.get().is_some()
        {
            set_is_expanded(true);
        }
    };

    // Handle mouseleave event with consideration for pinned state
    let handle_mouseleave = move |_| {
        // Only close the sidebar if we're not hovering the modal and not pinned
        if !show_administer_modal.get() && !is_pinned_closed.get() {
            set_is_expanded(false);
        }
    };

    // Toggle pinned state
    let toggle_pinned = move |_| {
        let new_value = !is_pinned_closed.get();
        set_is_pinned_closed.set(new_value);

        if new_value {
            set_is_expanded.set(false);
            set_show_administer_modal.set(false);
        }
    };

    // Combined class computation for the main sidebar div
    let sidebar_class = move || {
        let base_classes = "fixed left-0 top-20 h-[calc(100vh-4rem)] bg-[#F9F9F8] shadow-lg transition-all duration-300 ease-in-out z-40";

        let width_class = if is_expanded() {
            if is_small_screen() {
                "w-48"
            } else {
                "w-64"
            }
        } else {
            if is_small_screen() {
                "w-16"
            } else {
                "w-20"
            }
        };

        format!("{} {}", base_classes, width_class)
    };

    view! {
        <div class="relative">
            <div
                class=sidebar_class
                on:mouseenter=handle_mouseenter
                on:mouseleave=handle_mouseleave
            >
                <div class="flex flex-col h-full p-4 overflow-y-auto">
                    <div class="space-y-4 flex-1">
                        // Transferred navigation items from header
                        <SidebarNavLink
                            icon=AiDashboardOutlined
                            label="Dashboard (beta)"
                            path="/dashboard"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/dashboard"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=FaChildrenSolid
                            label="Student View"
                            path="/studentview"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/studentview"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=AiCoffeeOutlined
                            label="Teacher View"
                            path="/teachers"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/teachers"))
                            is_small_screen=is_small_screen.into()
                        />
                        <Show when=move || current_user.get().map(|user| user.is_admin()).unwrap_or(false)>
                            <SidebarNavLink
                                icon=RiAdminUserFacesLine
                                label="Admin Dashboard (beta)"
                                path="/admindashboard"
                                is_expanded=is_expanded.into()
                                is_active=Signal::derive(move || current_path().starts_with("/classrooms"))
                                is_small_screen=is_small_screen.into()
                            />
                        </Show>
                        <SidebarNavLink
                            icon=ChNotesTick
                            label="Assessments"
                            path="/assessments"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/assessments"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=BsGraphUpArrow
                            label="Gradebook (beta)"
                            path="/gradebook"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/gradebook"))
                            is_small_screen=is_small_screen.into()
                        />
                        <SidebarNavLink
                            icon=BsClipboardCheck
                            label="Tests"
                            path="/test-manager"
                            is_expanded=is_expanded.into()
                            is_active=Signal::derive(move || current_path().starts_with("/test-manager"))
                            is_small_screen=is_small_screen.into()
                        />
                    </div>

                    <div class="space-y-4 mt-auto pb-4">

                        // Divider
                        <div class="border-t border-[#DADADA] my-2"></div>

                        // Pin/Unpin button
                        <div
                            class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
                            on:click=toggle_pinned
                            title=move || if is_pinned_closed() { "Unpin sidebar (allow expand on hover)" } else { "Pin sidebar closed" }
                        >
                            <Icon
                                icon={if is_pinned_closed() { IoPinSharp } else { IoPinOutline }}
                                class="w-5 h-5 text-[#2E3A59] flex-shrink-0"
                            />
                            <Show
                                when=move || is_expanded()
                                fallback=|| view! { <></> }
                            >
                                <span class="ml-2 font-semibold text-sm sm:text-base">
                                    {move || if is_pinned_closed() { "Unpin" } else { "Pin Sidebar" }}
                                </span>
                            </Show>
                        </div>

                        <button
                            class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
                            on:click=move |_| set_show_settings.set(true)
                        >
                            <Icon
                                icon=IoSettingsOutline
                                class="w-6 h-6 text[#2E3A59] flex-shrink-0"
                            />
                            <div class="overflow-hidden whitespace-nowrap">
                                <Show
                                    when=move || is_expanded()
                                    fallback=|| view! { <></> }
                                >
                                    <span class="ml-2 font-semibold text-sm sm:text-base">
                                        {"Settings (beta)"}
                                    </span>
                                </Show>
                            </div>
                        </button>

                    </div>
                </div>
            </div>

            // Modal Dropdown - Improved display logic for pinned state
            <Show when=move || show_administer_modal()>
                <div
                    class="fixed z-50 hover-area"
                    style=move || modal_position()
                    on:mouseenter=move |_| {
                        // Keep sidebar expanded when hovering modal
                        if !is_pinned_closed() {
                            set_show_administer_modal(true);
                        }
                    }
                    on:mouseleave=move |_| {
                        // If pinned closed, hide modal but keep sidebar collapsed
                        set_show_administer_modal(false);
                        if !is_pinned_closed() {
                            set_is_expanded(false);
                        }
                    }
                >
                    <ShowAdministerTestModal set_if_show_modal=set_show_administer_modal />
                </div>
            </Show>

            <Show when=move || show_settings()>
                <SettingsModal
                    show=show_settings
                    on_close=move |_| set_show_settings.set(false)
                    user_id=user_id
                />
            </Show>
        </div>
    }
}

#[component]
fn SidebarItem(
    icon: icondata::Icon,
    label: &'static str,
    description: &'static str,
    is_expanded: Signal<bool>,
    is_selected: Signal<bool>,
    is_small_screen: Signal<bool>,
    on_click: impl Fn(MouseEvent) + 'static,
) -> impl IntoView {
    // Combined class computation for the item div
    let item_class = move || {
        let base_classes =
            "flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors";
        if is_selected() {
            format!("{} bg-blue-100", base_classes)
        } else {
            base_classes.to_string()
        }
    };

    // Combined class computation for the span
    let span_class = move || {
        let base_class = "font-semibold text-sm sm:text-base";
        if is_selected.get() {
            format!("{} {}", base_class, BLUE_COLOR)
        } else {
            format!("{} {}", base_class, GRAY_COLOR)
        }
    };

    view! {
        <div
            class=item_class
            on:click=on_click
        >
            <Icon
                icon=icon
                class="w-6 h-6 text-[#2E3A59] flex-shrink-0"
            />
            <div class="overflow-hidden whitespace-nowrap">
                <Show
                    when=move || is_expanded()
                    fallback=|| view! { <></> }
                >
                    <div class="flex flex-col ml-2">
                        <span class=span_class>
                            {label}
                        </span>
                        <Show
                            when=move || !is_small_screen()
                            fallback=|| view! { <></> }
                        >
                            <span class="text-xs text-[#2E3A59]">{description}</span>
                        </Show>
                    </div>
                </Show>
            </div>
        </div>
    }
}

#[component]
fn SidebarNavLink(
    icon: icondata::Icon,
    label: &'static str,
    path: &'static str,
    is_expanded: Signal<bool>,
    is_active: Signal<bool>,
    is_small_screen: Signal<bool>,
) -> impl IntoView {
    // Combined class computation for the nav div
    let nav_class = move || {
        let base_class = "rounded-lg";
        if is_active() {
            format!("{} bg-blue-100", base_class)
        } else {
            base_class.to_string()
        }
    };

    // Combined class computation for the span
    let span_class = move || {
        let base_class = "ml-2 font-semibold text-sm sm:text-base";
        if is_active.get() {
            format!("{} {}", base_class, BLUE_COLOR)
        } else {
            format!("{} {}", base_class, GRAY_COLOR)
        }
    };

    view! {
        <div class=nav_class>
            <A
                href={path}
                class="flex items-center cursor-pointer hover:bg-[#DADADA] p-2 rounded-md transition-colors"
            >
                <Icon
                    icon=icon
                    class="w-6 h-6 text-[#2E3A59] flex-shrink-0"
                />
                <div class="overflow-hidden whitespace-nowrap">
                    <Show
                        when=move || is_expanded()
                        fallback=|| view! { <></> }
                    >
                        <span class=span_class>
                            {label}
                        </span>
                    </Show>
                </div>
            </A>
        </div>
    }
}
use leptos::prelude::*;
/*
use leptos::prelude::*;
use log::{error, info, warn};
use serde::{Deserialize, Serialize};
use std::cell::RefCell;
use std::rc::Rc;
use uuid=:Uuid;

#[cfg(feature = "hydrate")]
use {
    js_sys::Date,
    wasm_bindgen::prelude::*,
    wasm_bindgen::JsCast,
    web_sys::{MessageEvent, WebSocket},
};

// Import the server functions
use crate::app::models::websocket_session::{CreateSessionRequest, SessionSummary, SessionType};
use crate::app::server_functions::websocket_sessions::{
    create_session, get_session, join_session, leave_session, list_active_sessions,
};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ChatMessage {
    sender_id= String,
    content: String,
    timestamp: String,
}

#[component]
pub fn Chat() -> impl IntoView {
    let (messages, set_messages) = signal(Vec::<ChatMessage>::new());
    let (current_message, set_current_message) = signal(String::new());
    let (connected, set_connected) = signal(false);
    let (user_id, set_user_id) = signal(String::new());

    // Room joining/creation states
    let (room_id, set_room_id) = signal(String::new());
    let (join_room_id, set_join_room_id) = signal(String::new());
    let (is_in_room, set_is_in_room) = signal(false);
    let (room_name, set_room_name) = signal(String::new());
    let (room_description, set_room_description) = signal(String::new());
    let (max_users, set_max_users) = signal(0);
    let (is_private, set_is_private) = signal(false);
    let (room_password, set_room_password) = signal(String::new());
    let (join_password, set_join_password) = signal(String::new());
    let (error_message, set_error_message) = signal(String::new());

    // Active sessions
    let (active_sessions, set_active_sessions) = signal(Vec::<SessionSummary>::new());
    let (loading_sessions, set_loading_sessions) = signal(false);

    // UI state
    let (active_tab, set_active_tab) = signal("join"); // "join" or "create"

    // Create a shared reference to store the WebSocket
    #[cfg(feature = "hydrate")]
    let socket_ref = Rc::new(RefCell::new(None::<WebSocket>));
    let socket_ref_for_cleanup = Rc::clone(&socket_ref);
    let socket_ref_for_send = Rc::clone(&socket_ref);
    let socket_ref_for_leave = Rc::clone(&socket_ref);

    // Define connect_to_websocket action before using it
    #[cfg(feature = "hydrate")]
    let connect_to_websocket = Action::new(move |room_id_str: &String| {
        let room_id_val = room_id_str.clone();
        let socket_ref_clone = Rc::clone(&socket_ref);
        let set_messages = set_messages.clone();
        let set_connected = set_connected.clone();
        let set_is_in_room = set_is_in_room.clone();
        let set_error_message = set_error_message.clone();
        let set_user_id = set_user_id.clone();
        let user_id = user_id.clone();

        async move {
            // Disconnect from any existing connection
            if let Some(socket) = socket_ref_clone.borrow_mut().take() {
                let _ = socket.close();
            }

            set_messages.update(|msgs| msgs.clear());
            set_connected.set(false);
            set_error_message.set(String::new());

            log::info!("Establishing WebSocket connection to room: {}", room_id_val);

            let ws_url = format!(
                "ws://{}/ws/{}",
                window().location().host().unwrap(),
                room_id_val
            );

            match WebSocket::new(&ws_url) {
                Ok(socket) => {
                    // Set up WebSocket event handlers
                    let set_connected_clone = set_connected.clone();
                    let set_is_in_room_clone = set_is_in_room.clone();
                    let on_open = Closure::wrap(Box::new(move |_| {
                        set_connected_clone.set(true);
                        set_is_in_room_clone.set(true);
                        log::info!("WebSocket connection established");
                    }) as Box<dyn FnMut(JsValue)>);
                    socket.set_onopen(Some(on_open.as_ref().unchecked_ref()));
                    on_open.forget();

                    let set_connected_clone = set_connected.clone();
                    let set_is_in_room_clone = set_is_in_room.clone();
                    let on_close = Closure::wrap(Box::new(move |_| {
                        set_connected_clone.set(false);
                        log::info!("WebSocket connection closed");
                    }) as Box<dyn FnMut(JsValue)>);
                    socket.set_onclose(Some(on_close.as_ref().unchecked_ref()));
                    on_close.forget();

                    let set_error_message_clone = set_error_message.clone();
                    let on_error = Closure::wrap(Box::new(move |e| {
                        set_error_message_clone.set(format!("WebSocket error: Connection failed"));
                        log::error!("WebSocket error: {:?}", e);
                    }) as Box<dyn FnMut(JsValue)>);
                    socket.set_onerror(Some(on_error.as_ref().unchecked_ref()));
                    on_error.forget();

                    let set_messages_clone = set_messages.clone();
                    let set_user_id_clone = set_user_id.clone();

                    let on_message = Closure::wrap(Box::new(move |e: MessageEvent| {
                        let data = e.data().as_string().unwrap();

                        // Check if this is the initial ID message
                        if data.starts_with("your id is ") {
                            let id = data.replace("your id is ", "");
                            set_user_id_clone.set(id);
                            return;
                        }

                        // Otherwise treat as a chat message
                        let parts: Vec<&str> = data.split(": ").collect();
                        let (sender_id, content) = if parts.len() > 1 {
                            (parts[0].to_string(), parts[1..].join(": "))
                        } else {
                            ("System".to_string(), data)
                        };

                        let now = js_sys::Date::new_0();
                        let timestamp = now.to_locale_time_string("en-US");

                        let new_msg = ChatMessage {
                            sender_id,
                            content,
                            timestamp: timestamp.into(),
                        };

                        set_messages_clone.update(|msgs| {
                            msgs.push(new_msg);
                        });
                    })
                        as Box<dyn FnMut(MessageEvent)>);

                    socket.set_onmessage(Some(on_message.as_ref().unchecked_ref()));
                    on_message.forget();

                    // Store the socket
                    *socket_ref_clone.borrow_mut() = Some(socket);

                    // Update room state
                    set_is_in_room.set(true);
                }
                Err(err) => {
                    set_error_message.set(format!("Failed to create WebSocket connection"));
                    log::error!("Failed to create WebSocket: {:?}", err);
                }
            }
        }
    });

    // Fetch active sessions
    let fetch_sessions = Action::new(move |_: &()| {
        let set_active_sessions = set_active_sessions.clone();
        let set_loading_sessions = set_loading_sessions.clone();
        let set_error_message = set_error_message.clone();

        async move {
            set_loading_sessions.set(true);
            set_error_message.set(String::new());

            match list_active_sessions().await {
                Ok(sessions) => {
                    set_active_sessions.set(sessions);
                }
                Err(err) => {
                    set_error_message.set(format!("Failed to load sessions: {}", err));
                }
            }

            set_loading_sessions.set(false);
        }
    });

    // Create a new room using the server API
    let create_new_room = Action::new(move |_: &()| {
        let room_name_val = room_name.get();
        let room_desc_val = room_description.get();
        let max_users_val = max_users.get();
        let is_private_val = is_private.get();
        let password_val = room_password.get();

        let set_error_message = set_error_message.clone();
        let set_room_id = set_room_id.clone();
        let connect_ws = connect_to_websocket.clone();

        async move {
            // Validate input
            if room_name_val.trim().is_empty() {
                set_error_message.set("Room name cannot be empty".into());
                return;
            }

            let request = CreateSessionRequest {
                name: room_name_val.clone(),
                description: if room_desc_val.trim().is_empty() {
                    None
                } else {
                    Some(room_desc_val)
                },
                max_users: if max_users_val <= 0 {
                    None
                } else {
                    Some(max_users_val)
                },
                is_private: Some(is_private_val),
                password: if password_val.trim().is_empty() {
                    None
                } else {
                    Some(password_val)
                },
                session_type: Some(SessionType::Chat),
                test_id= None,
                metadata: None,
            };

            match create_session(request).await {
                Ok(session) => {
                    log::info!("Created new room: {}", session.id);
                    // Connect to the websocket
                    set_room_id.set(session.id.to_string());
                    connect_ws.dispatch(session.id.to_string());
                }
                Err(err) => {
                    set_error_message.set(format!("Failed to create room: {}", err));
                }
            }
        }
    });

    // Join existing room by ID
    let join_room_by_id = Action::new(move |_: &()| {
        let room_id_val = join_room_id.get();
        let password_val = join_password.get();
        let set_error_message = set_error_message.clone();
        let set_room_id = set_room_id.clone();
        let connect_ws = connect_to_websocket.clone();

        async move {
            // Validate UUID
            if room_id_val.trim().is_empty() {
                set_error_message.set("Room ID is required".into());
                return;
            }

            if let Err(_) = Uuid=:parse_str(&room_id_val) {
                set_error_message.set("Invalid room ID format".into());
                return;
            }

            // Try to join the session
            match join_session(
                room_id_val.clone(),
                if password_val.is_empty() {
                    None
                } else {
                    Some(password_val)
                },
            )
            .await
            {
                Ok(_) => {
                    // Connect to websocket
                    set_room_id.set(room_id_val.clone());
                    connect_ws.dispatch(room_id_val);
                }
                Err(err) => {
                    set_error_message.set(format!("Failed to join room: {}", err));
                }
            }
        }
    });

    // Join from active sessions list
    let join_from_list = Action::new(move |session_id= &String| {
        let room_id_val = session_id.clone();
        let password_val = join_password.get();
        let set_error_message = set_error_message.clone();
        let set_room_id = set_room_id.clone();
        let connect_ws = connect_to_websocket.clone();

        async move {
            // Try to join the session
            match join_session(
                room_id_val.clone(),
                if password_val.is_empty() {
                    None
                } else {
                    Some(password_val)
                },
            )
            .await
            {
                Ok(_) => {
                    // Connect to websocket
                    set_room_id.set(room_id_val.clone());
                    connect_ws.dispatch(room_id_val);
                }
                Err(err) => {
                    set_error_message.set(format!("Failed to join room: {}", err));
                }
            }
        }
    });

    // Send message function
    let send_message = move |e: ev::SubmitEvent| {
        e.prevent_default();
        let msg = current_message.get();
        if !msg.trim().is_empty() && connected.get() {
            if let Some(socket) = socket_ref_for_send.borrow().as_ref() {
                if let Err(err) = socket.send_with_str(&msg) {
                    log::error!("Failed to send message: {:?}", err);
                } else {
                    set_current_message.set("".to_string());
                }
            }
        }
    };

    // Function to leave current room
    let leave_room = Action::new(move |_: &()| {
        let room_id_val = room_id.get();
        let socket_ref_for_leave = Rc::clone(&socket_ref_for_leave);
        let set_is_in_room = set_is_in_room.clone();
        let set_connected = set_connected.clone();
        let set_messages = set_messages.clone();

        async move {
            // Close WebSocket connection
            if let Some(socket) = socket_ref_for_leave.borrow_mut().take() {
                let _ = socket.close();
            }

            // Notify server we're leaving
            if !room_id_val.is_empty() {
                let _ = leave_session(room_id_val).await;
            }

            // Update UI state
            set_is_in_room.set(false);
            set_connected.set(false);
            set_messages.update(|msgs| msgs.clear());
        }
    });

    // Refresh active sessions periodically
    #[cfg(feature = "hydrate")]
    let refresh_timer = use_interval(
        move || {
            if !is_in_room.get() {
                fetch_sessions.dispatch(());
            }
        },
        10000, // Refresh every 10 seconds
    );

    // Load active sessions on component mount
    Effect::new(move |_| {
        fetch_sessions.dispatch(());
    });

    // Clean up when the component is unmounted
    on_cleanup(move || {
        log::info!("Cleaning up WebSocket connection");
        if let Some(socket) = socket_ref_for_cleanup.borrow_mut().take() {
            let _ = socket.close();
        }
    });

    view! {
        <div class="flex flex-col h-full border rounded-lg shadow">
            {move || {
                if !is_in_room.get() {
                    view! {
                        <div class="bg-white rounded-lg overflow-hidden">
                            <div class="p-6 border-b">
                                <h2 class="text-xl font-semibold text-gray-800">Chat Rooms</h2>
                            </div>

                            // Error message display
                            {move || {
                                let error = error_message.get();
                                if !error.is_empty() {
                                    view! {
                                        <div class="mx-6 mt-4 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded relative">
                                            <span class="block sm:inline">{error}</span>
                                            <button
                                                class="absolute top-0 right-0 px-4 py-3"
                                                on:click=move |_| set_error_message.set(String::new())
                                            >
                                                <span class="text-red-700">&times;</span>
                                            </button>
                                        </div>
                                    }
                                } else {
                                    view! { <div></div> }
                                }
                            }}

                            // Tab navigation
                            <div class="flex mx-6 mt-6 border-b">
                                <button
                                    class=move || format!("py-2 px-4 font-medium text-sm {} {}",
                                        if active_tab.get() == "join" { "text-blue-600 border-b-2 border-blue-600" }
                                        else { "text-gray-500 hover:text-gray-700" },
                                        if active_tab.get() == "join" { "font-medium" } else { "" }
                                    )
                                    on:click=move |_| set_active_tab.set("join")
                                >
                                    Join a Room
                                </button>
                                <button
                                    class=move || format!("py-2 px-4 font-medium text-sm {} {}",
                                        if active_tab.get() == "create" { "text-blue-600 border-b-2 border-blue-600" }
                                        else { "text-gray-500 hover:text-gray-700" },
                                        if active_tab.get() == "create" { "font-medium" } else { "" }
                                    )
                                    on:click=move |_| set_active_tab.set("create")
                                >
                                    Create a Room
                                </button>
                            </div>

                            <div class="p-6">
                                {move || {
                                    if active_tab.get() == "join" {
                                        view! {
                                            <div>
                                                // Active sessions section
                                                <div class="mb-8">
                                                    <div class="flex justify-between items-center mb-4">
                                                        <h3 class="text-lg font-medium text-gray-900">Available Rooms</h3>
                                                        <button
                                                            on:click=move |_| fetch_sessions.dispatch(())
                                                            class="text-blue-600 hover:text-blue-800 text-sm flex items-center"
                                                        >
                                                            Refresh
                                                        </button>
                                                    </div>

                                                    {move || {
                                                        if loading_sessions.get() {
                                                            view! {
                                                                <div class="text-center py-8">
                                                                    <p class="text-gray-500">Loading available rooms...</p>
                                                                </div>
                                                            }.into_any()
                                                        } else {
                                                            let sessions = active_sessions.get();
                                                            if sessions.is_empty() {
                                                                view! {
                                                                    <div class="text-center py-8 bg-gray-50 border border-gray-100 rounded">
                                                                        <p class="text-gray-500">No active rooms found</p>
                                                                        <p class="text-sm text-gray-400 mt-1">Create a new room to get started</p>
                                                                    </div>
                                                                }.into_any()
                                                            } else {
                                                                view! {
                                                                    <div class="grid gap-3">
                                                                        {sessions.into_iter().map(|session| {
                                                                            let id = session.id.to_string();
                                                                            let name = session.name.clone();
                                                                            let users = session.current_users;
                                                                            let has_password = session.password_required;
                                                                            let join_from_list_clone = join_from_list.clone();
                                                                            let set_join_password_clone = set_join_password.clone();

                                                                            view! {
                                                                                <div class="p-4 border rounded-md bg-white hover:bg-gray-50 transition-colors">
                                                                                    <div class="flex justify-between items-center">
                                                                                        <div>
                                                                                            <h4 class="font-medium text-gray-900">{name}</h4>
                                                                                            <div class="flex items-center mt-1 text-sm text-gray-600">
                                                                                                <span class="mr-3">{format!("{} users", users)}</span>
                                                                                                {if has_password {
                                                                                                    view! {
                                                                                                        <span class="flex items-center text-amber-600">
                                                                                                            <span class="mr-1">"ðŸ”’"</span> Password required
                                                                                                        </span>
                                                                                                    }.into_any()
                                                                                                } else {
                                                                                                    view! {}.into_any()
                                                                                                }}
                                                                                            </div>
                                                                                            {if let Some(desc) = session.description {
                                                                                                view! { <p class="text-sm mt-2 text-gray-600">{desc}</p> }.into_any()
                                                                                            } else {
                                                                                                view! {}.into_any()
                                                                                            }}
                                                                                            <div class="text-xs text-gray-500 mt-2">
                                                                                                {"ID: "}{id.clone()}
                                                                                            </div>
                                                                                        </div>
                                                                                        {if has_password {
                                                                                            let id_clone = id.clone();
                                                                                            view! {
                                                                                                <div class="flex flex-col items-end space-y-2">
                                                                                                    <input
                                                                                                        type="password"
                                                                                                        prop:value=move || join_password.get()
                                                                                                        on:input=move |ev| {
                                                                                                            set_join_password_clone.set(event_target_value(&ev));
                                                                                                        }
                                                                                                        class="p-2 text-sm border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                                                                        placeholder="Enter password"
                                                                                                    />
                                                                                                    <button
                                                                                                        on:click=move |_| join_from_list_clone.dispatch(id_clone.clone())
                                                                                                        class="bg-blue-600 text-white px-4 py-2 text-sm rounded hover:bg-blue-700 transition-colors"
                                                                                                    >
                                                                                                        Join Room
                                                                                                    </button>
                                                                                                </div>
                                                                                            }.into_any()
                                                                                        } else {
                                                                                            let id_clone = id.clone();
                                                                                            view! {
                                                                                                <button
                                                                                                    on:click=move |_| join_from_list_clone.dispatch(id_clone.clone())
                                                                                                    class="bg-blue-600 text-white px-4 py-2 text-sm rounded hover:bg-blue-700 transition-colors"
                                                                                                >
                                                                                                    Join Room
                                                                                                </button>
                                                                                            }.into_any()
                                                                                        }}
                                                                                    </div>
                                                                                </div>
                                                                            }
                                                                        }).collect_view()}
                                                                    </div>
                                                                }.into_any()
                                                            }
                                                        }
                                                    }}
                                                </div>

                                                // Direct join by ID section
                                                <div class="mt-8 pt-6 border-t">
                                                    <h3 class="text-base font-medium text-gray-900 mb-4">Join by Room ID</h3>
                                                    <div class="space-y-4">
                                                        <div>
                                                            <label class="block text-sm font-medium text-gray-700 mb-1">
                                                                Room ID
                                                            </label>
                                                            <input
                                                                type="text"
                                                                prop:value=move || join_room_id.get()
                                                                on:input=move |ev| {
                                                                    set_join_room_id.set(event_target_value(&ev));
                                                                }
                                                                class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                                placeholder="Enter room ID"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label class="block text-sm font-medium text-gray-700 mb-1">
                                                                Password (if required)
                                                            </label>
                                                            <input
                                                                type="password"
                                                                prop:value=move || join_password.get()
                                                                on:input=move |ev| {
                                                                    set_join_password.set(event_target_value(&ev));
                                                                }
                                                                class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                                placeholder="Password (if required)"
                                                            />
                                                        </div>
                                                        <button
                                                            on:click=move |_| join_room_by_id.dispatch(())
                                                            class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition-colors"
                                                        >
                                                            Join Room
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        }
                                    } else {
                                        view! {
                                            <div class="space-y-4">
                                                <div>
                                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                                        Room Name <span class="text-red-500">*</span>
                                                    </label>
                                                    <input
                                                        type="text"
                                                        prop:value=move || room_name.get()
                                                        on:input=move |ev| {
                                                            set_room_name.set(event_target_value(&ev));
                                                        }
                                                        class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                        placeholder="Enter a name for your room"
                                                    />
                                                </div>
                                                <div>
                                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                                        Description
                                                    </label>
                                                    <textarea
                                                        prop:value=move || room_description.get()
                                                        on:input=move |ev| {
                                                            set_room_description.set(event_target_value(&ev));
                                                        }
                                                        class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                        placeholder="Describe your room (optional)"
                                                        rows="3"
                                                    ></textarea>
                                                </div>
                                                <div class="flex gap-4">
                                                    <div class="w-1/2">
                                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                                            Max Users
                                                        </label>
                                                        <input
                                                            type="number"
                                                            prop:value=move || max_users.get()
                                                            on:input=move |ev| {
                                                                set_max_users.set(event_target_value(&ev).parse::<i32>().unwrap_or(0));
                                                            }
                                                            class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                            placeholder="0 = unlimited"
                                                        />
                                                    </div>
                                                    <div class="w-1/2">
                                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                                            Room Visibility
                                                        </label>
                                                        <div class="flex items-center mt-2">
                                                            <input
                                                                type="checkbox"
                                                                id="is-private"
                                                                prop:checked=move || is_private.get()
                                                                on:change=move |ev| {
                                                                    set_is_private.set(event_target_checked(&ev));
                                                                }
                                                                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                                                            />
                                                            <label for="is-private" class="ml-2 block text-sm text-gray-700">
                                                                Private Room
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                                        Password
                                                    </label>
                                                    <input
                                                        type="password"
                                                        prop:value=move || room_password.get()
                                                        on:input=move |ev| {
                                                            set_room_password.set(event_target_value(&ev));
                                                        }
                                                        class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                        placeholder="Set password (optional)"
                                                    />
                                                </div>
                                                <button
                                                    on:click=move |_| create_new_room.dispatch(())
                                                    class="w-full mt-4 bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition-colors"
                                                >
                                                    Create Room
                                                </button>
                                            </div>
                                        }
                                    }
                                }}
                            </div>
                        </div>
                    }
                } else {
                    // Chat room interface when user is in a room
                    view! {
                        <div class="flex flex-col h-full">
                            // Chat room header
                            <div class="bg-white p-4 border-b flex justify-between items-center">
                                <div>
                                    <h2 class="text-lg font-semibold text-gray-800">
                                        {move || {
                                            if !room_name.get().is_empty() {
                                                room_name.get()
                                            } else {
                                                format!("Chat Room: {}", room_id.get())
                                            }
                                        }}
                                    </h2>
                                    <div class="text-sm text-gray-500 flex items-center">
                                        <span class="mr-2">
                                            {move || {
                                                if connected.get() {
                                                    "Connected"
                                                } else {
                                                    "Disconnected"
                                                }
                                            }}
                                        </span>
                                        <div class={move || {
                                            format!("w-2 h-2 rounded-full mr-2 {}",
                                                if connected.get() { "bg-green-500" } else { "bg-red-500" }
                                            )
                                            }}>
                                        </div>
                                        <span>{"Your ID: "}{move || user_id.get()}</span>
                                    </div>
                                </div>
                                <button
                                    on:click=move |_| leave_room.dispatch(())
                                    class="bg-gray-100 text-gray-700 py-2 px-4 rounded hover:bg-gray-200 transition-colors"
                                >
                                    Leave Room
                                </button>
                            </div>

                            // Chat messages area
                            <div class="flex-grow overflow-y-auto p-4 bg-gray-50" id="messages">
                                <div class="space-y-3">
                                    {move || {
                                        messages.get().into_iter().map(|msg| {
                                            let is_self = msg.sender_id == user_id.get();
                                            let sender_name = if is_self { "You".to_string() } else { msg.sender_id.clone() };

                                            view! {
                                                <div class={move || {
                                                    format!("flex {}",
                                                        if is_self { "justify-end" } else { "justify-start" }
                                                    )
                                                }}>
                                                    <div class={move || {
                                                        format!("max-w-3/4 rounded-lg px-4 py-2 {}",
                                                            if is_self { "bg-blue-600 text-white" } else { "bg-white border" }
                                                        )
                                                    }}>
                                                        <div class="flex justify-between items-center mb-1">
                                                            <span class={move || {
                                                                format!("font-medium text-sm {}",
                                                                    if is_self { "text-blue-100" } else { "text-gray-700" }
                                                                )
                                                            }}>
                                                                {sender_name}
                                                            </span>
                                                            <span class={move || {
                                                                format!("text-xs ml-2 {}",
                                                                    if is_self { "text-blue-100" } else { "text-gray-500" }
                                                                )
                                                            }}>
                                                                {msg.timestamp.clone()}
                                                            </span>
                                                        </div>
                                                        <p class={move || {
                                                            if is_self { "text-white" } else { "text-gray-800" }
                                                        }}>
                                                            {msg.content.clone()}
                                                        </p>
                                                    </div>
                                                </div>
                                            }
                                        }).collect_view()
                                    }}
                                </div>
                            </div>

                            // Message input form
                            <div class="p-4 bg-white border-t">
                                <form on:submit=send_message.clone() class="flex gap-2">
                                    <input
                                        type="text"
                                        prop:value=move || current_message.get()
                                        on:input=move |ev| {
                                            set_current_message.set(event_target_value(&ev));
                                        }
                                        class="flex-grow p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                        placeholder="Type a message..."
                                        disabled=move || !connected.get()
                                    />
                                    <button
                                        type="submit"
                                        class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors disabled:bg-blue-300"
                                        disabled=move || !connected.get() || current_message.get().trim().is_empty()
                                    >
                                        Send
                                    </button>
                                </form>
                            </div>
                        </div>
                    }
                }
            }}
        </div>
    }
}

#[cfg(feature = "hydrate")]
fn use_interval<F>(f: F, ms: u32) -> impl Drop
where
    F: FnMut() + 'static,
{
    let window = web_sys::window().expect("no global `window` exists");
    let callback = Closure::wrap(Box::new(f) as Box<dyn FnMut()>);
    let interval_id = window
        .set_interval_with_callback_and_timeout_and_arguments_0(
            callback.as_ref().unchecked_ref(),
            ms as i32,
        )
        .expect("failed to set interval");

    // Keep the closure alive for the lifetime of the interval
    callback.forget();

    // Return a guard that will clear the interval when dropped
    IntervalGuard {
        window,
        interval_id,
    }
}

#[cfg(feature = "hydrate")]
struct IntervalGuard {
    window: web_sys::Window,
    interval_id= i32,
}

#[cfg(feature = "hydrate")]
impl Drop for IntervalGuard {
    fn drop(&mut self) {
        self.window.clear_interval_with_handle(self.interval_id);
    }
}*/
use leptos::prelude::*;
use crate::app::components::auth::enhanced_login_form::{
    use_student_mapping_service, StudentMapping, StudentMappingData, StudentMappingService,
};
use crate::app::middleware::global_settings::use_settings;
use icondata::BsKeyFill;
use leptos::prelude::*;
use leptos_icons::Icon;

#[cfg(feature = "hydrate")]
use wasm_bindgen::{closure::Closure, JsCast};

#[component]
pub fn DashboardDeanonymizer() -> impl IntoView {
    let (student_mapping_file, set_student_mapping_file) = create_signal::<Option<String>>(None);
    let (file_upload_status, set_file_upload_status) = create_signal::<Option<String>>(None);
    let (error, set_error) = create_signal::<Option<String>>(None);
    let (is_expanded, set_is_expanded) = signal(false);

    // Get settings and mapping service
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;
    let (mapping_service_signal, set_student_mapping_service) = use_student_mapping_service();

    // Check if mapping service is already active
    let has_active_mapping = move || mapping_service_signal.get().is_some();
    let mapping_count = move || {
        mapping_service_signal
            .get()
            .map(|service| service.get_mapping_count())
            .unwrap_or(0)
    };

    // CSV parsing (copy from enhanced_login_form.rs)
    let parse_csv_content = move |content: String| -> Result<StudentMappingData, String> {
        let lines: Vec<&str> = content.lines().collect();

        if lines.is_empty() {
            return Err("Empty file".to_string());
        }

        if lines.len() < 2 {
            return Err("File must contain header and at least one data row".to_string());
        }

        let header = lines[0];
        let expected_headers = [
            "app_id",
            "original_student_id",
            "firstname",
            "lastname",
            "pin",
            "created_at",
        ];
        let actual_headers: Vec<&str> = header.split(',').map(|h| h.trim()).collect();

        if actual_headers.len() != expected_headers.len() {
            return Err(format!(
                "Invalid header format: expected {} columns, found {}",
                expected_headers.len(),
                actual_headers.len()
            ));
        }

        // Parse data rows
        let data_lines = &lines[1..];
        let mut mappings = Vec::new();

        for (line_num, line) in data_lines.iter().enumerate() {
            if line.trim().is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split(',').collect();
            if parts.len() != 6 {
                return Err(format!(
                    "Invalid CSV format at line {}: expected 6 columns, found {}",
                    line_num + 2,
                    parts.len()
                ));
            }

            let app_id = parts[0]
                .trim()
                .parse::<i32>()
                .map_err(|_| format!("Invalid app_id at line {}: '{}'", line_num + 2, parts[0]))?;

            let original_student_id = parts[1].trim().parse::<i32>().map_err(|_| {
                format!(
                    "Invalid original_student_id at line {}: '{}'",
                    line_num + 2,
                    parts[1]
                )
            })?;

            if app_id <= 0 || original_student_id <= 0 {
                return Err(format!(
                    "Invalid ID values at line {}: IDs must be positive integers",
                    line_num + 2
                ));
            }

            mappings.push(StudentMapping {
                app_id,
                original_student_id,
                firstname: parts[2].trim().to_string(),
                lastname: parts[3].trim().to_string(),
                pin: parts[4].trim().to_string(),
                created_at: parts[5].trim().to_string(),
            });
        }

        if mappings.is_empty() {
            return Err("No valid data rows found in CSV file".to_string());
        }

        Ok(StudentMappingData { mappings })
    };

    // File upload handler
    #[cfg(feature = "hydrate")]
    let handle_file_upload = move |ev: web_sys::Event| {
        let input = ev
            .target()
            .unwrap()
            .dyn_into::<web_sys::HtmlInputElement>()
            .unwrap();

        if let Some(files) = input.files() {
            if files.length() > 0 {
                let file = files.get(0).unwrap();

                if !file.name().ends_with(".csv") {
                    set_error.set(Some("Please select a CSV file".to_string()));
                    return;
                }

                if file.size() > 10_000_000.0 {
                    set_error.set(Some("File too large. Maximum size is 10MB".to_string()));
                    return;
                }

                let file_reader = web_sys::FileReader::new().unwrap();
                set_file_upload_status.set(Some("Processing file...".to_string()));
                set_error.set(None);

                let onload = Closure::wrap(Box::new({
                    let set_error = set_error.clone();
                    let set_file_upload_status = set_file_upload_status.clone();
                    let set_student_mapping_service = set_student_mapping_service.clone();
                    let parse_csv_content = parse_csv_content.clone();

                    move |event: web_sys::Event| {
                        let file_reader = event
                            .target()
                            .unwrap()
                            .dyn_into::<web_sys::FileReader>()
                            .unwrap();

                        if let Ok(result) = file_reader.result() {
                            if let Some(content) = result.as_string() {
                                match parse_csv_content(content) {
                                    Ok(mapping_data) => {
                                        let mapping_service =
                                            StudentMappingService::new(mapping_data.mappings);
                                        let count = mapping_service.get_mapping_count();
                                        set_student_mapping_service.set(Some(mapping_service));
                                        set_error.set(None);
                                        set_file_upload_status.set(Some(format!(
                                            "âœ“ De-anonymization active ({} mappings loaded)",
                                            count
                                        )));
                                        log::info!(
                                            "Student mapping service activated with {} mappings",
                                            count
                                        );
                                    }
                                    Err(e) => {
                                        set_error.set(Some(format!("Invalid CSV: {}", e)));
                                        set_file_upload_status.set(None);
                                    }
                                }
                            }
                        }
                    }
                }) as Box<dyn Fn(web_sys::Event)>);

                file_reader.set_onload(Some(onload.as_ref().unchecked_ref()));
                onload.forget();
                let _ = file_reader.read_as_text(&file);
            }
        }
    };

    #[cfg(not(feature = "hydrate"))]
    let handle_file_upload = move |_| {
        set_error.set(Some(
            "File upload not supported in this environment".to_string(),
        ));
    };

    let clear_mapping = move |_| {
        set_student_mapping_service.set(None);
        set_file_upload_status.set(None);
        set_error.set(None);
        log::info!("Student mapping service cleared");
    };

    view! {
        {move || {
            if anonymization_enabled() {
                view! {
                    <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                        <div class="p-4 border-b border-gray-200">
                            <button
                                class="flex items-center justify-between w-full text-left"
                                on:click=move |_| set_is_expanded.set(!is_expanded.get())
                            >
                                <div class="flex items-center">
                                    <Icon
                                        icon=BsKeyFill
                                        class="w-6 h-6 text-blue-600 mr-2"
                                    />
                                    <h3 class="text-lg font-semibold text-gray-800">
                                        "Student De-anonymization"
                                    </h3>
                                </div>
                                <div class="flex items-center">
                                    {move || {
                                        if has_active_mapping() {
                                            view! {
                                                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 mr-2">
                                                    "Active (" {mapping_count()} " mappings)"
                                                </span>
                                            }.into_any()
                                        } else {
                                            view! {
                                                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 mr-2">
                                                    "Inactive"
                                                </span>
                                            }.into_any()
                                        }
                                    }}
                                    <svg
                                        class=move || if is_expanded.get() { "w-5 h-5 transform rotate-180 transition-transform" } else { "w-5 h-5 transition-transform" }
                                        fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                    >
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                    </svg>
                                </div>
                            </button>
                        </div>

                        {move || {
                            if is_expanded.get() {
                                view! {
                                    <div class="p-4">
                                        {move || {
                                            error.get().map(|err| {
                                                view! {
                                                    <div class="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
                                                        {err}
                                                    </div>
                                                }
                                            })
                                        }}

                                        {move || {
                                            if has_active_mapping() {
                                                view! {
                                                    <div class="bg-green-50 border border-green-200 rounded-md p-4 mb-4">
                                                        <div class="flex items-center justify-between">
                                                            <div>
                                                                <h4 class="text-sm font-medium text-green-800">
                                                                    "De-anonymization Active"
                                                                </h4>
                                                                <p class="text-sm text-green-700 mt-1">
                                                                    "Student data will show real names and IDs (" {mapping_count()} " mappings loaded)"
                                                                </p>
                                                            </div>
                                                            <button
                                                                class="text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700 transition-colors"
                                                                on:click=clear_mapping
                                                            >
                                                                "Disable"
                                                            </button>
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            } else {
                                                view! {
                                                    <div class="space-y-4">
                                                        <div class="bg-blue-50 border border-blue-200 rounded-md p-4">
                                                            <h4 class="text-sm font-medium text-blue-800 mb-2">
                                                                "Upload De-anonymization File"
                                                            </h4>
                                                            <p class="text-sm text-blue-700 mb-3">
                                                                "Upload a CSV file to convert anonymized student IDs back to real names and original IDs."
                                                            </p>

                                                            <input
                                                                type="file"
                                                                accept=".csv"
                                                                class="w-full p-2 border border-gray-300 rounded-md file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                                                on:change=handle_file_upload
                                                            />

                                                            {move || {
                                                                if let Some(status) = file_upload_status.get() {
                                                                    view! {
                                                                        <p class="text-sm text-blue-600 mt-2">{status}</p>
                                                                    }.into_any()
                                                                } else {
                                                                    view! { <span></span> }.into_any()
                                                                }
                                                            }}
                                                        </div>

                                                        <div class="bg-gray-50 rounded-md p-4">
                                                            <h4 class="text-sm font-semibold text-gray-700 mb-2">
                                                                "Required CSV Format:"
                                                            </h4>
                                                            <div class="bg-gray-800 text-gray-100 p-3 rounded text-xs font-mono overflow-x-auto">
                                                                <pre>{"app_id,original_student_id,firstname,lastname,pin,created_at\n100000,12345,John,Doe,1234,2025-06-09 19:52:19.862183\n100001,52884,Thien,Le,1234,2025-06-09 19:52:19.862183"}</pre>
                                                            </div>
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            }
                                        }}
                                    </div>
                                }.into_any()
                            } else {
                                view! { <span></span> }.into_any()
                            }
                        }}
                    </div>
                }.into_any()
            } else {
                view! { <span></span> }.into_any()
            }
        }}
    }
}
use leptos::prelude::*;
pub mod add_employee_form;
pub mod delete_confirmation;
pub mod employee_details;
pub mod employee_table;
pub mod role_selector;
pub mod search_filter;
pub mod teacher_table;
pub mod update_employee_form;
pub mod user_table;

pub use add_employee_form::*;
pub use delete_confirmation::*;
pub use employee_details::*;
pub use employee_table::*;
pub use role_selector::*;
pub use search_filter::*;
pub use teacher_table::*;
pub use update_employee_form::*;
pub use user_table::*;
use super::{
    connection_status::ConnectionStatusIndicator,
    navigation::NavigationControls,
    participants_list::ParticipantsList,
    question_card::QuestionCard,
    test_controls::TestControls,
    types::*,
    websocket_handler::{use_websocket_connection, WebSocketActions},
};
use crate::app::components::test_components::balloon_celebration::BalloonCelebration;
use crate::app::components::test_components::font_controls::{use_font_settings, FontControls};
use crate::app::components::test_components::test_instructions::TestInstructions;
use crate::app::models::question::{Question, QuestionType};
use crate::app::models::score::CreateScoreRequest;
use crate::app::models::test::Test;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::websocket_sessions::cleanup_teacher_session_endpoint;
use crate::app::server_functions::{
    questions::get_questions, scores::add_score, tests::get_tests, websocket_sessions,
};
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::components::*;
use leptos_router::hooks::*;
use log;
use serde_json::json;
use std::collections::HashMap;
use uuid::Uuid;
#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

// Helper function using your existing create_or_join_session - FIXED
async fn create_new_session_with_existing_function(
    tid: String,
    test_name: String,
    teacher_id: i32,
    set_room_id: WriteSignal<Option<Uuid>>,
    set_error_message: WriteSignal<Option<String>>,
) {
    let request = crate::app::models::websocket_session::CreateSessionRequest {
        name: format!("Test Session for {}", test_name),
        description: Some(format!("Test session for {}", tid)),
        session_type: Some(crate::app::models::websocket_session::SessionType::Test),
        test_id: Some(tid.clone()),
        max_users: Some(30),
        is_private: Some(false),
        password: None,
        metadata: None,
        teacher_id: Some(teacher_id),
    };

    match websocket_sessions::create_or_join_session(request).await {
        Ok(session) => {
            log::info!("Created/joined session: {}", session.id);
            #[cfg(feature = "hydrate")]
            {
                log::info!("Waiting for 1.5 seconds before setting room ID");
                gloo_timers::future::TimeoutFuture::new(1500).await; // Wait for 1.5 seconds
                log::info!("Waiting complete,setting up room");
            }
            set_room_id.set(Some(session.id));
        }
        Err(e) => {
            log::error!("Failed to create/join session: {}", e);
            set_error_message.set(Some(format!("Failed to create session: {}", e)));
        }
    }
}

#[component]
pub fn RealtimeTestSession() -> impl IntoView {
    // Get test_id from URL parameters
    let params = use_params_map();
    let test_id_memo = Memo::new(move |_| {
        params.with(|params| params.get("test_id").cloned().unwrap_or_default())
    });

    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");

    // Initialize state
    let (room_id, set_room_id) = create_signal::<Option<Uuid>>(None);
    let (role, set_role) = signal(Role::Student);
    let (connected_students, set_connected_students) =
        create_signal::<Vec<ConnectedStudent>>(Vec::new());
    let (connection_status, set_connection_status) = signal(ConnectionStatus::Disconnected);
    let (error_message, set_error_message) = signal(None::<String>);
    let (current_card_index, set_current_card_index) = signal(0);
    let (responses, set_responses) = signal(HashMap::<i32, QuestionResponse>::new());
    let (selected_student_id, set_selected_student_id) = signal(None::<i32>);
    let (is_test_active, set_is_test_active) = signal(false);
    let (is_submitted, set_is_submitted) = signal(false);
    let (remaining_time, set_remaining_time) = create_signal::<Option<i32>>(None);
    let (should_disable_inputs, set_should_disable_inputs) = signal(true);
    let (show_participants, set_show_participants) = signal(false);
    let (font_settings, set_font_settings) = use_font_settings();
    let (show_celebration, set_show_celebration) = signal(false);
    let (shortcuts_expanded, set_shortcuts_expanded) = signal(false);
    let (instructions_expanded, set_instructions_expanded) = signal(false);

    // Initialize role based on user
    Effect::new(move |_| {
        log::info!("=== Role Assignment Effect Triggered ===");

        if let Some(current_user) = user() {
            log::info!("User session data available:");
            log::info!("  - User ID: {}", current_user.id);
            log::info!("  - Username: {}", current_user.username);
            log::info!("  - Role: {:?}", current_user.role);
            log::info!("  - is_admin(): {}", current_user.is_admin());
            log::info!("  - is_teacher(): {}", current_user.is_teacher());

            if current_user.is_admin() {
                log::info!("ðŸ”‘ Setting role to Teacher (Admin privileges)");
                set_role(Role::Teacher);
            } else if current_user.is_teacher() {
                log::info!("ðŸŽ Setting role to Teacher (Teacher privileges)");
                set_role(Role::Teacher);
            } else {
                log::info!("ðŸ“š Setting role to Student (role: {:?})", current_user.role);
                set_role(Role::Student);
            }
        } else {
            log::warn!("âŒ No user session data available - setting role to Unknown");
            set_role(Role::Unknown);
        }

        log::info!("=== Role Assignment Effect Complete ===");
    });

    // Enhanced role effect with input disable logic
    Effect::new(move |_| {
        let current_role = role.get();
        let should_disable = matches!(current_role, Role::Student | Role::Unknown);

        log::info!("=== Input Disable Effect ===");
        log::info!("Current role: {:?}", current_role);
        log::info!("Should disable inputs: {}", should_disable);
        log::info!("========================");

        set_should_disable_inputs.set(should_disable);
    });

    // Fetch test details and questions
    let test_details = Resource::new(test_id_memo, move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in the URL");
            return None;
        }
        match get_tests().await {
            Ok(tests) => tests.into_iter().find(|test| test.test_id == tid),
            Err(e) => {
                log::error!("Failed to fetch test details: {}", e);
                None
            }
        }
    });

    let questions = Resource::new(test_id_memo, move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in the URL");
            return Vec::new();
        }
        match get_questions(tid).await {
            Ok(mut questions) => {
                // Sort questions by qnumber to ensure consistent ordering
                questions.sort_by_key(|q| q.qnumber);
                questions
            }
            Err(e) => {
                log::error!("Failed to fetch questions: {}", e);
                Vec::new()
            }
        }
    });

    // WebSocket connection and actions
    #[cfg(feature = "hydrate")]
    let ws_actions = use_websocket_connection(
        room_id.into(),
        user.into(),
        set_connection_status,
        set_error_message,
        set_role,
        set_connected_students,
        set_responses,
        set_current_card_index,
        set_remaining_time,
        set_is_test_active,
        set_is_submitted,
        test_id_memo.into(),
        room_id.into(),
        questions.into(),
    );

    // Heartbeat system
    #[cfg(feature = "hydrate")]
    {
        Effect::new(move |_| {
            if matches!(connection_status.get(), ConnectionStatus::Connected) {
                let send_heartbeat = ws_actions.send_heartbeat.clone();
                let interval_handle = super::utils::set_interval_with_handle(
                    move || {
                        send_heartbeat.call(());
                    },
                    std::time::Duration::from_secs(30),
                );

                on_cleanup(move || {
                    if let Ok(handle) = interval_handle {
                        handle.clear();
                    }
                });
            }
        });
    }

    // Detect tab close for user
    #[cfg(feature = "hydrate")]
    {
        use wasm_bindgen::prelude::*;

        Effect::new(move |_| {
            if matches!(role.get(), Role::Teacher) {
                let user_for_cleanup = user.clone();

                let beforeunload_closure =
                    Closure::wrap(Box::new(move |_: web_sys::BeforeUnloadEvent| {
                        if let Some(current_user) = user_for_cleanup.get_untracked() {
                            if let Some(window) = web_sys::window() {
                                let navigator = window.navigator();
                                let cleanup_data =
                                    format!(r#"{{"teacher_id": {}}}"#, current_user.id);

                                let _ = navigator.send_beacon_with_opt_str(
                                    "/api/CleanupTeacherSession",
                                    Some(&cleanup_data),
                                );
                            }
                        }
                    })
                        as Box<dyn FnMut(web_sys::BeforeUnloadEvent)>);

                if let Some(window) = web_sys::window() {
                    let _ = window.add_event_listener_with_callback(
                        "beforeunload",
                        beforeunload_closure.as_ref().unchecked_ref(),
                    );
                }

                beforeunload_closure.forget();
            }
        });
    }

    // Submit handler with weighted multiple choice support
    let handle_submit = Action::new(move |_: &()| async move {
        let current_responses = responses.get();
        let current_test_id = test_id_memo.get();
        let student_id = selected_student_id.get().unwrap_or(0);
        let evaluator = user().map(|u| u.id.to_string()).unwrap_or_default();
        let test_variant = 1;

        let mut test_scores = Vec::new();
        let mut comments = Vec::new();

        if let Some(questions) = questions.get() {
            let mut sorted_questions = questions.clone();
            sorted_questions.sort_by_key(|q| q.qnumber);

            for question in sorted_questions {
                if let Some(response) = current_responses.get(&question.qnumber) {
                    let score = match question.question_type {
                        QuestionType::WeightedMultipleChoice => {
                            // Calculate weighted score
                            if let Some(ref selected_opts) = response.selected_options {
                                question.calculate_weighted_score(selected_opts)
                            } else {
                                0
                            }
                        }
                        _ => {
                            // Regular scoring logic
                            if response.answer == question.correct_answer {
                                question.point_value
                            } else {
                                0
                            }
                        }
                    };

                    test_scores.push(score);
                    comments.push(response.comment.clone());
                } else {
                    test_scores.push(0);
                    comments.push(String::new());
                }
            }
        }

        let score_request = CreateScoreRequest {
            student_id,
            test_id: current_test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
        };

        match add_score(score_request).await {
            Ok(score) => {
                log::info!(
                    "Successfully submitted score for student {}",
                    score.student_id
                );

                set_show_celebration.set(true);
                set_is_submitted.set(true);

                #[cfg(feature = "hydrate")]
                ws_actions.end_test.call(());
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to submit score: {}", e);
                Err(e)
            }
        }
    });

    // Create or join session
    Effect::new(move |_| {
        let tid = test_id_memo.get();
        let test_name = match &test_details() {
            Some(Some(test)) => test.name.clone(),
            _ => "Unknown Test".to_string(),
        };

        if !tid.is_empty() {
            if let Some(current_user) = user() {
                let teacher_id = current_user.id as i32;

                spawn_local(async move {
                    log::info!("Checking for existing teacher sessions for test: {}", tid);

                    match websocket_sessions::get_teacher_active_session(teacher_id).await {
                        Ok(Some(existing_session)) => {
                            // Check if it's for the same test
                            if existing_session
                                .test_id
                                .as_ref()
                                .map_or(false, |test_id| test_id == &tid)
                            {
                                log::info!(
                                    "Found existing session for same test - taking over: {}",
                                    existing_session.id
                                );
                                set_room_id.set(Some(existing_session.id)); // FIXED: session.id is already Uuid
                            } else {
                                log::info!("Found session for different test - cleaning up and creating new");
                                // Clean up old session
                                let _ = websocket_sessions::cleanup_teacher_session_endpoint(
                                    teacher_id,
                                )
                                .await;

                                // Create new session using your existing create_or_join_session
                                create_new_session_with_existing_function(
                                    tid,
                                    test_name,
                                    teacher_id,
                                    set_room_id,
                                    set_error_message,
                                )
                                .await;
                            }
                        }
                        Ok(None) => {
                            log::info!("No existing session found - creating new");
                            create_new_session_with_existing_function(
                                tid,
                                test_name,
                                teacher_id,
                                set_room_id,
                                set_error_message,
                            )
                            .await;
                        }
                        Err(e) => {
                            log::error!("Error checking for teacher session: {}", e);
                            create_new_session_with_existing_function(
                                tid,
                                test_name,
                                teacher_id,
                                set_room_id,
                                set_error_message,
                            )
                            .await;
                        }
                    }
                });
            }
        }
    });

    //shortcuts effect ui
    #[cfg(feature = "hydrate")]
    {
        use leptos::ev::KeyboardEvent;

        let handle_keydown = move |ev: KeyboardEvent| {
            let target = ev.target().unwrap();
            let tag_name = target
                .unchecked_ref::<web_sys::Element>()
                .tag_name()
                .to_lowercase();

            // Handle Tab to blur from textarea/input
            if ev.key().as_str() == "Tab" && (tag_name == "textarea" || tag_name == "input") {
                if let Some(html_element) = target.dyn_ref::<web_sys::HtmlElement>() {
                    let _ = html_element.blur();
                    ev.prevent_default();
                }
                return;
            }

            // Only handle navigation shortcuts when not typing in input fields
            if tag_name == "input" || tag_name == "textarea" || tag_name == "select" {
                return;
            }

            match ev.key().as_str() {
                "ArrowRight" | "n" | "N" => {
                    ev.prevent_default();
                    #[cfg(feature = "hydrate")]
                    ws_actions.go_to_next_card.call(());
                }
                "ArrowLeft" | "p" | "P" => {
                    ev.prevent_default();
                    #[cfg(feature = "hydrate")]
                    ws_actions.go_to_previous_card.call(());
                }
                "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" => {
                    if !ev.ctrl_key() && !ev.alt_key() && !ev.meta_key() {
                        ev.prevent_default();
                        if let Ok(num) = ev.key().parse::<usize>() {
                            // Check if we're on a multiple choice question
                            if let Some(questions_vec) = questions.get() {
                                let current_question = &questions_vec[current_card_index.get()];
                                match current_question.question_type {
                                    QuestionType::MultipleChoice => {
                                        if num <= current_question.options.len() {
                                            let option = current_question.options[num - 1].clone();
                                            #[cfg(feature = "hydrate")]
                                            ws_actions
                                                .handle_answer_change
                                                .call((current_question.qnumber, option));
                                        }
                                    }
                                    QuestionType::WeightedMultipleChoice => {
                                        let weighted_options =
                                            current_question.get_weighted_options();
                                        if num <= weighted_options.len() {
                                            let option = &weighted_options[num - 1];
                                            if option.is_selectable {
                                                let current_selected = responses.with(|r| {
                                                    r.get(&current_question.qnumber)
                                                        .and_then(|resp| {
                                                            resp.selected_options.as_ref()
                                                        })
                                                        .cloned()
                                                        .unwrap_or_default()
                                                });

                                                let mut new_selected = current_selected;
                                                if new_selected.contains(&option.text) {
                                                    new_selected.retain(|x| x != &option.text);
                                                } else {
                                                    new_selected.push(option.text.clone());
                                                }

                                                #[cfg(feature = "hydrate")]
                                                ws_actions
                                                    .handle_weighted_selection
                                                    .call((current_question.qnumber, new_selected));
                                            }
                                        }
                                    }
                                    QuestionType::TrueFalse => {
                                        if num == 1 {
                                            #[cfg(feature = "hydrate")]
                                            ws_actions.handle_answer_change.call((
                                                current_question.qnumber,
                                                "true".to_string(),
                                            ));
                                        } else if num == 2 {
                                            #[cfg(feature = "hydrate")]
                                            ws_actions.handle_answer_change.call((
                                                current_question.qnumber,
                                                "false".to_string(),
                                            ));
                                        }
                                    }
                                    _ => {
                                        // For other question types, just navigate normally
                                    }
                                }
                            }
                        }
                    }
                }
                "c" | "C" => {
                    if !ev.ctrl_key() && !ev.alt_key() && !ev.meta_key() {
                        ev.prevent_default();
                        // Focus comments box
                        if let Some(window) = web_sys::window() {
                            if let Some(document) = window.document() {
                                if let Some(textarea) = document
                                    .query_selector("textarea[placeholder*='notes']")
                                    .ok()
                                    .flatten()
                                {
                                    let _ =
                                        textarea.unchecked_into::<web_sys::HtmlElement>().focus();
                                }
                            }
                        }
                    }
                }
                "Enter" => {
                    if ev.ctrl_key() || ev.meta_key() {
                        ev.prevent_default();
                        if let Some(questions_vec) = questions.get() {
                            if current_card_index.get() == questions_vec.len() - 1
                                && !is_submitted.get()
                            {
                                // Submit on last question
                                if selected_student_id.get().is_some()
                                    && matches!(role.get(), Role::Teacher)
                                {
                                    handle_submit.dispatch(());
                                    set_is_submitted.set(true);
                                }
                            } else {
                                #[cfg(feature = "hydrate")]
                                ws_actions.go_to_next_card.call(());
                            }
                        }
                    }
                }
                _ => {}
            }
        };

        Effect::new(move |_| {
            let window = web_sys::window().unwrap();
            let document = window.document().unwrap();

            let closure = wasm_bindgen::closure::Closure::wrap(
                Box::new(handle_keydown) as Box<dyn Fn(KeyboardEvent)>
            );

            document
                .add_event_listener_with_callback("keydown", closure.as_ref().unchecked_ref())
                .unwrap();

            closure.forget(); // Keep the closure alive
        });
    }

    // Format remaining time
    let formatted_time = move || {
        if let Some(seconds) = remaining_time.get() {
            let minutes = seconds / 60;
            let seconds = seconds % 60;
            format!("{}:{:02}", minutes, seconds)
        } else {
            "".to_string()
        }
    };

    // Calculate percentage of answered questions
    let calculate_answered_percentage = Memo::new(move |_| {
        let answered_count = responses.with(|r| {
            questions
                .get()
                .map(|q| {
                    q.iter()
                        .filter(|question| {
                            r.get(&question.qnumber)
                                .map(|resp| !resp.answer.trim().is_empty())
                                .unwrap_or(false)
                        })
                        .count() as f32
                })
                .unwrap_or(0.0)
        });

        let total = questions.get().map(|q| q.len() as f32).unwrap_or(1.0);
        if total > 0.0 {
            (answered_count / total) * 100.0
        } else {
            0.0
        }
    });

    // Cleanup on unmount
    #[cfg(feature = "hydrate")]
    on_cleanup(move || {
        log::info!("Component unmounting - cleaning up session");

        if let (Some(current_user), true) = (
            user.get_untracked(),
            matches!(role.get_untracked(), Role::Teacher),
        ) {
            spawn_local(async move {
                if let Err(e) =
                    cleanup_teacher_session_endpoint(current_user.id.try_into().unwrap()).await
                {
                    log::error!("Failed to cleanup teacher session on unmount: {}", e);
                }
            });
        }
    });

    view! {
        <div class="min-h-screen bg-gray-50" tabindex="-1">
            {/* Minimal Top Bar */}
            <div class="sticky top-0 z-10 bg-white/80 backdrop-blur-md border-b border-gray-100">
                <div class="max-w-5xl mx-auto px-6 py-3">
                    <div class="flex items-center justify-between">
                        {/* Left: Student Select (Teacher only) */}
                        <div class="flex-shrink-0">
                            <Show when=move || matches!(role.get(), Role::Teacher)>
                                <super::student_select::StudentSelect set_selected_student_id=set_selected_student_id />
                            </Show>
                        </div>

                        {/* Center: Test Title */}
                        <div class="flex-1 text-center px-8">
                            <h1 class="text-lg font-medium text-gray-900 truncate">
                                {move || match &test_details.get() {
                                    Some(Some(test)) => format!("Live Test: {}", test.name),
                                    _ => format!("Live Test: {}", test_id_memo.get())
                                }}
                            </h1>
                        </div>

                        {/* Right: Role and Status */}
                        <div class="flex items-center gap-3">
                            <FontControls
                                font_settings=font_settings
                                set_font_settings=set_font_settings
                            />
                            <div class="text-sm text-gray-500 font-medium hidden sm:block">
                                {move || match role.get() {
                                    Role::Teacher => {
                                        let user_clone = user.get().unwrap();
                                        format!("Teacher: {} {}", user_clone.first_name.unwrap_or("Unknown".to_string()), user_clone.last_name.unwrap_or("User".to_string()))
                                    },
                                    Role::Student => "Student".to_string(),
                                    Role::Unknown => "Connecting...".to_string(),
                                }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="max-w-5xl mx-auto px-6 py-4">
                {/* Connection Status */}
                <ConnectionStatusIndicator
                    connection_status=Signal::derive(move || connection_status.get())
                    error_message=Signal::derive(move || error_message.get())
                />

                {/* Instructions Toggle */}
                <Suspense fallback=move || view! { <div></div> }>
                    {move || match test_details.get() {
                        Some(Some(test)) => {
                            if test.instructions.as_ref().map_or(false, |inst| !inst.is_empty()) {
                                view! {
                                    <div class="mb-2">
                                        <button
                                            class="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 font-medium"
                                            on:click=move |_| set_instructions_expanded.update(|x| *x = !*x)
                                        >
                                            <svg class=move || format!("w-4 h-4 transition-transform {}",
                                                if instructions_expanded() { "rotate-90" } else { "" }
                                            ) fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                            </svg>
                                            "Test Instructions"
                                        </button>
                                        <Show when=move || instructions_expanded()>
                                            <div class="mt-2">
                                                <TestInstructions instructions=test.instructions.clone() />
                                            </div>
                                        </Show>
                                    </div>
                                }.into_any()
                            } else {
                                view! { <div></div> }.into_any()
                            }
                        },
                        _ => view! { <div></div> }.into_any()
                    }}
                </Suspense>

                {/* Shortcuts Toggle */}
                <div class="mb-4">
                    <button
                        class="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 font-medium"
                        on:click=move |_| set_shortcuts_expanded.update(|x| *x = !*x)
                    >
                        <svg class=move || format!("w-4 h-4 transition-transform {}",
                            if shortcuts_expanded() { "rotate-90" } else { "" }
                        ) fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                        "Keyboard Shortcuts"
                    </button>
                    <Show when=move || shortcuts_expanded()>
                        <div class="mt-2 bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                                <span>"â† â†’ or P/N: Navigate (works in textarea)"</span>
                                <span>"1-9: Select answers (Ctrl+1-9 in textarea)"</span>
                                <span>"Ctrl+Enter: Next/Submit (works everywhere)"</span>
                                <span>"C or Ctrl+C: Focus comments"</span>
                            </div>
                        </div>
                    </Show>
                </div>

                {/* Session Status */}
                /*<div class="flex justify-center items-center mb-3 space-x-8 text-sm">
                    <Show when=move || !formatted_time().is_empty()>
                        <div class="text-gray-600">
                            <span class="font-medium">"Time: "</span>
                            {move || formatted_time()}
                        </div>
                    </Show>
                </div>*/

                {/* Teacher Controls */}
                <div class="mb-4">
                    <TestControls
                        role=Signal::derive(move || role.get())
                        is_test_active=Signal::derive(move || is_test_active.get())
                        is_submitted=Signal::derive(move || is_submitted.get())
                        connection_status=Signal::derive(move || connection_status.get())
                        selected_student_id=Signal::derive(move || selected_student_id.get())
                        room_id=Signal::derive(move || room_id.get())
                        test_id=Signal::derive(move || test_id_memo.get())
                        start_test={
                            #[cfg(feature = "hydrate")]
                            {ws_actions.start_test}
                            #[cfg(not(feature = "hydrate"))]
                            {Callback::new(|_| {})}
                        }
                        end_test={
                            #[cfg(feature = "hydrate")]
                            {ws_actions.end_test}
                            #[cfg(not(feature = "hydrate"))]
                            {Callback::new(|_| {})}
                        }
                    />
                </div>

                {/* Compact Participants Dropdown */}
                <div class="mb-4">
                    <button
                        class="w-full flex items-center justify-between px-4 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
                        on:click=move |_| set_show_participants.update(|show| *show = !*show)
                    >
                        <div class="flex items-center gap-3">
                            <div class="w-2 h-2 bg-green-400 rounded-full"></div>
                            <span class="font-medium text-gray-700">
                                {move || format!("{} Connected", connected_students.get().len())}
                            </span>
                        </div>
                        <svg
                            class=move || format!("w-4 h-4 text-gray-400 transition-transform {}",
                                if show_participants.get() { "rotate-180" } else { "" })
                            fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        >
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>

                    <Show when=move || show_participants.get()>
                        <div class="mt-2 p-3 bg-white border border-gray-200 rounded-lg shadow-sm">
                            <ParticipantsList
                                connected_students=Signal::derive(move || connected_students.get())
                                role=Signal::derive(move || role.get())
                            />
                        </div>
                    </Show>
                </div>

                {/* Test Content */}
                <Show when=move || is_test_active.get() || matches!(role.get(), Role::Teacher)>
                    <Suspense fallback=move || view! {
                        <div class="flex items-center justify-center h-96">
                            <div class="flex flex-col items-center gap-4">
                                <div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                <p class="text-gray-500 text-sm">"Loading questions..."</p>
                            </div>
                        </div>
                    }>
                        {move || match questions.get() {
                            None => view! {
                                <div class="text-center py-8">"Loading..."</div>
                            }.into_any(),
                            Some(questions_vec) if questions_vec.is_empty() => {
                                view! {
                                    <div class="flex items-center justify-center h-96">
                                        <div class="text-center">
                                            <div class="w-16 h-16 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4">
                                                <svg class="w-8 h-8 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z"></path>
                                                </svg>
                                            </div>
                                            <p class="text-gray-500">"No questions found for this test."</p>
                                        </div>
                                    </div>
                                }.into_any()
                            },
                            Some(questions_vec) => {
                                let total_questions = questions_vec.len();
                                let current_question = Memo::new(move |_| {
                                    questions_vec.get(current_card_index.get()).cloned().unwrap_or_else(|| {
                                        questions_vec.first().cloned().unwrap()
                                    })
                                });

                                view! {
                                    <div class="space-y-6">
                                        {/* Progress Section */}
                                        <div class="text-center space-y-2">
                                            {/* Progress Bar */}
                                            <div class="w-full max-w-md mx-auto">
                                                <div class="bg-gray-100 rounded-full h-1">
                                                    <div
                                                        class="bg-gradient-to-r from-blue-500 to-indigo-600 h-1 rounded-full transition-all duration-700 ease-out"
                                                        style=move || format!("width: {}%", calculate_answered_percentage())
                                                    ></div>
                                                </div>
                                            </div>

                                            {/* Question Counter */}
                                            <div class="flex items-center justify-center gap-6 text-sm">
                                                <span class="text-gray-500">
                                                    "Question " {move || current_card_index.get() + 1} " of " {total_questions}
                                                </span>
                                                <span class="px-3 py-1 bg-indigo-50 text-indigo-700 rounded-full font-medium">
                                                    {move || current_question().point_value} " points"
                                                </span>
                                            </div>
                                        </div>

                                        {/* Question Card */}
                                        <div class="max-w-4xl mx-auto">
                                            <QuestionCard
                                                question=current_question()
                                                role=Signal::derive(move || role.get())
                                                responses=Signal::derive(move || responses.get())
                                                should_disable_inputs=Signal::derive(move || should_disable_inputs.get())
                                                font_settings=font_settings
                                                on_answer_change={
                                                    #[cfg(feature = "hydrate")]
                                                    {ws_actions.handle_answer_change}
                                                    #[cfg(not(feature = "hydrate"))]
                                                    {Callback::new(|_| {})}
                                                }
                                                on_comment_change={
                                                    #[cfg(feature = "hydrate")]
                                                    {ws_actions.handle_comment_change}
                                                    #[cfg(not(feature = "hydrate"))]
                                                    {Callback::new(|_| {})}
                                                }
                                                on_weighted_selection={
                                                    #[cfg(feature = "hydrate")]
                                                    {ws_actions.handle_weighted_selection}
                                                    #[cfg(not(feature = "hydrate"))]
                                                    {Callback::new(|_| {})}
                                                }
                                            />
                                        </div>

                                        {/* Navigation Controls */}
                                        <NavigationControls
                                            role=Signal::derive(move || role.get())
                                            is_test_active=Signal::derive(move || is_test_active.get())
                                            is_submitted=Signal::derive(move || is_submitted.get())
                                            should_disable_inputs=Signal::derive(move || should_disable_inputs.get())
                                            current_card_index=Signal::derive(move || current_card_index.get())
                                            total_questions=Signal::derive(move || total_questions)
                                            selected_student_id=Signal::derive(move || selected_student_id.get())
                                            on_previous={
                                                #[cfg(feature = "hydrate")]
                                                {ws_actions.go_to_previous_card}
                                                #[cfg(not(feature = "hydrate"))]
                                                {Callback::new(|_| {})}
                                            }
                                            on_next={
                                                #[cfg(feature = "hydrate")]
                                                {ws_actions.go_to_next_card}
                                                #[cfg(not(feature = "hydrate"))]
                                                {Callback::new(|_| {})}
                                            }
                                            on_submit=Callback::new(move |_| handle_submit.dispatch(()))
                                        />

                                        {/* Submission Status */}
                                        <Show when=move || is_submitted.get()>
                                            <div class="text-center pt-4">
                                                <div class="inline-flex items-center gap-3 px-6 py-3 bg-green-50 border border-green-200 rounded-lg text-green-800">
                                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                                    </svg>
                                                    "Assessment submitted successfully!"
                                                </div>
                                                <div class="mt-4">
                                                    <button
                                                        class="px-5 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 transition-colors"
                                                        on:click=move |_| {
                                                            let navigate = use_navigate();
                                                            navigate("/dashboard", Default::default());
                                                        }
                                                    >
                                                        "Return to Dashboard"
                                                    </button>
                                                </div>
                                            </div>
                                        </Show>
                                    </div>
                                }.into_any()
                            }
                        }}
                    </Suspense>
                </Show>

                {/* Waiting Message for Students */}
                <Show when=move || !is_test_active.get() && matches!(role.get(), Role::Student)>
                    <div class="flex flex-col items-center justify-center py-12 max-w-md mx-auto">
                        <div class="bg-white p-8 rounded-lg shadow-md w-full text-center">
                            <h3 class="text-xl font-medium mb-4">"Waiting for Test to Start"</h3>
                            <p class="text-gray-600 mb-6">"Your teacher will start the test soon. Please stay connected."</p>
                            <div class="animate-pulse flex justify-center">
                                <div class="h-4 w-4 bg-blue-400 rounded-full mr-1"></div>
                                <div class="h-4 w-4 bg-blue-500 rounded-full mr-1 animation-delay-200"></div>
                                <div class="h-4 w-4 bg-blue-600 rounded-full animation-delay-400"></div>
                            </div>
                        </div>
                    </div>
                </Show>
            </div>
        </div>

        {/* Balloon Celebration */}
        <BalloonCelebration
            show=Signal::derive(move || show_celebration.get())
            message="ðŸŽ‰ Assessment Complete! ðŸŽ‰"
            duration=5000
        />
    }
}
use crate::app::components::auth::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent,
};
use crate::app::middleware::global_settings::use_settings;
use crate::app::server_functions::students::get_students;
use leptos::prelude::*;
use leptos::prelude::*;
use log;

#[component]
pub fn StudentSelect(set_selected_student_id: WriteSignal<Option<i32>>) -> impl IntoView {
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;
    let (student_mapping_service, _) = use_student_mapping_service();

    let get_students_action = Action::new(|_: &()| async move {
        match get_students().await {
            Ok(fetched_students) => fetched_students,
            Err(e) => {
                log::error!("Failed to fetch students: {}", e);
                Vec::new()
            }
        }
    });

    let enhanced_students = Memo::new(move |_| {
        let students_data = get_students_action
            .value()
            .get()
            .as_ref()
            .cloned()
            .unwrap_or_default();

        if anonymization_enabled() {
            let mapping_service = student_mapping_service.get();
            students_data
                .into_iter()
                .map(|student| {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &student,
                        mapping_service.as_ref(),
                    );
                    (student, Some(de_anon))
                })
                .collect::<Vec<_>>()
        } else {
            students_data
                .into_iter()
                .map(|student| (student, None))
                .collect::<Vec<_>>()
        }
    });

    Effect::new(move |_| {
        get_students_action.dispatch(());
    });

    view! {
        <div class="mb-2 max-w-[20rem]">
            <label class="block text-sm font-medium mb-1">"Select Student:"</label>
            <select
                class="w-full p-2 border rounded-md"
                on:change=move |ev| {
                    let value = event_target_value(&ev).parse().ok();
                    set_selected_student_id.set(value);
                }
            >
                <option value="">"Select a student..."</option>
                <Suspense fallback=move || view! {
                    <option>"Loading students..."</option>
                }>
                    {move || {
                        enhanced_students().into_iter().map(|(student, de_anon_opt)| {
                            let display_text = if let Some(de_anon) = &de_anon_opt {
                                format!("{} - {}", de_anon.display_name, de_anon.display_id)
                            } else {
                                format!(
                                    "{} {} - {}",
                                    student.firstname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.lastname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.student_id
                                )
                            };

                            view! {
                                <option value={student.student_id.to_string()}>
                                    {display_text}
                                </option>
                            }
                        }).collect_view()
                    }}
                </Suspense>
            </select>
        </div>
    }
}
use leptos::prelude::*;
// QR Code component for easy mobile access
use leptos::prelude::*;
use uuid=:Uuid;

#[component]
pub fn TestShareModal(
    #[prop(into)] show: Signal<bool>,
    #[prop(into)] test_id= Signal<String>,
    #[prop(into)] room_id= Signal<Option<Uuid>>,
    #[prop(into)] on_close: Callback<()>,
) -> impl IntoView {
    let (copied_link, set_copied_link) = signal(false);
    let (show_qr, set_show_qr) = signal(false);

    let student_link = Memo::new(move |_| {
        if let (Some(room), tid) = (room_id.get(), test_id.get()) {
            if !tid.is_empty() {
                let origin = web_sys::window()
                    .and_then(|w| w.location().origin().ok())
                    .unwrap_or_else(|| "http://localhost:8080".to_string());
                return format!("{}/student-test/{}/{}", origin, tid, room);
            }
        }
        String::new()
    });

    // Generate QR code URL (using qr-server.com API)
    let qr_code_url = Memo::new(move |_| {
        let link = student_link.get();
        if !link.is_empty() {
            format!(
                "https://api.qrserver.com/v1/create-qr-code/?size=200x200&data={}",
                urlencoding::encode(&link)
            )
        } else {
            String::new()
        }
    });

    let copy_link = move |_| {
        let link = student_link.get();
        if !link.is_empty() {
            #[cfg(feature = "hydrate")]
            {
                if let Some(navigator) = web_sys::window().and_then(|w| w.navigator().clipboard()) {
                    let _ = navigator.write_text(&link);
                    set_copied_link.set(true);

                    set_timeout_with_handle(
                        move || set_copied_link.set(false),
                        std::time::Duration::from_secs(2),
                    )
                    .ok();
                }
            }
        }
    };

    view! {
        <Show when=move || show.get()>
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                 on:click=move |_| on_close.call(())>
                <div class="bg-white rounded-lg p-6 max-w-lg w-full mx-4"
                     on:click=move |e| e.stop_propagation()>

                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium">"Share Test with Student"</h3>
                        <button
                            class="text-gray-400 hover:text-gray-600"
                            on:click=move |_| on_close.call(())
                        >
                            "âœ•"
                        </button>
                    </div>

                    <div class="space-y-4">
                        // Tab navigation
                        <div class="flex border-b">
                            <button
                                class="px-4 py-2 font-medium"
                                class=border-b-2={move || !show_qr.get()}
                                class=border-blue-500={move || !show_qr.get()}
                                class=text-blue-600={move || !show_qr.get()}
                                on:click=move |_| set_show_qr.set(false)
                            >
                                "Share Link"
                            </button>
                            <button
                                class="px-4 py-2 font-medium"
                                class=border-b-2={move || show_qr.get()}
                                class=border-blue-500={move || show_qr.get()}
                                class=text-blue-600={move || show_qr.get()}
                                on:click=move |_| set_show_qr.set(true)
                            >
                                "QR Code"
                            </button>
                        </div>

                        // Link sharing tab
                        <Show when=move || !show_qr.get()>
                            <div class="space-y-4">
                                <p class="text-sm text-gray-600">
                                    "Send this link to your student. They can join directly without creating an account:"
                                </p>

                                <div class="bg-gray-50 p-3 rounded border break-all text-sm">
                                    {move || student_link.get()}
                                </div>

                                <div class="flex gap-2">
                                    <button
                                        class="flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                                        on:click=copy_link
                                    >
                                        {move || if copied_link.get() { "âœ“ Copied!" } else { "ðŸ“‹ Copy Link" }}
                                    </button>

                                    // Email sharing
                                    <a
                                        href=move || format!(
                                            "mailto:?subject=Join%20Test%20Session&body=Please%20join%20my%20test%20session%20by%20clicking%20this%20link:%20{}",
                                            urlencoding::encode(&student_link.get())
                                        )
                                        class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                                    >
                                        "ðŸ“§ Email"
                                    </a>
                                </div>
                            </div>
                        </Show>

                        // QR Code tab
                        <Show when=move || show_qr.get()>
                            <div class="space-y-4 text-center">
                                <p class="text-sm text-gray-600">
                                    "Have your student scan this QR code with their phone:"
                                </p>

                                <div class="flex justify-center">
                                    <img
                                        src=move || qr_code_url.get()
                                        alt="QR Code for test session"
                                        class="border rounded-lg shadow-sm"
                                        style="max-width: 200px; max-height: 200px;"
                                    />
                                </div>

                                <div class="text-xs text-gray-500">
                                    <p>"ðŸ“± Works with any QR code scanner or camera app"</p>
                                </div>
                            </div>
                        </Show>

                        // Instructions
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <h4 class="font-medium text-blue-900 mb-2">"How it works:"</h4>
                            <ol class="text-sm text-blue-800 space-y-1">
                                <li>"1. Share the link or QR code with your student"</li>
                                <li>"2. Student enters their name and ID"</li>
                                <li>"3. Student automatically joins your test session"</li>
                                <li>"4. Start the test when ready!"</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
        </Show>
    }
}
use leptos::prelude::*;
use super::types::{ConnectedStudent, Role};
use leptos::prelude::*;

#[component]
pub fn ParticipantsList(
    #[prop(into)] connected_students: Signal<Vec<ConnectedStudent>>,
    #[prop(into)] role: Signal<Role>,
) -> impl IntoView {
    view! {
        <div class="mb-8 max-w-4xl mx-auto">
            <h3 class="text-lg font-medium mb-2">
                {move || match role.get() {
                    Role::Teacher => "Connected Students",
                    Role::Student => "Connected Participants",
                    Role::Unknown => "Session Participants"
                }}
            </h3>
            <div class="bg-white shadow-sm rounded-lg p-4">
                <Show when=move || !connected_students.get().is_empty() fallback=|| view! {
                    <p class="text-gray-500 text-center py-2">"No participants connected"</p>
                }>
                    <ul class="divide-y divide-gray-200">
                        <For
                            each=move || connected_students.get()
                            key=|student| student.student_id.clone()
                            children=move |student| {
                                let status_class = if student.status == "Connected" {
                                    "bg-green-100 text-green-800"
                                } else {
                                    "bg-red-100 text-red-800"
                                };

                                view! {
                                    <li class="py-2 flex justify-between items-center">
                                        <span>{student.name.clone()}</span>
                                        <span class=format!("text-sm px-2 py-1 rounded-full {}", status_class)>
                                            {student.status.clone()}
                                        </span>
                                    </li>
                                }
                            }
                        />
                    </ul>
                </Show>
            </div>
        </div>
    }
}
use super::types::ConnectionStatus;
use leptos::prelude::*;

#[component]
pub fn ConnectionStatusIndicator(
    #[prop(into)] connection_status: Signal<ConnectionStatus>,
    #[prop(into)] error_message: Signal<Option<String>>,
) -> impl IntoView {
    // Combined class computation for the main status div
    let status_div_class = move || {
        let base_classes = "flex items-center space-x-2 px-3 py-1 rounded-full text-sm";
        match connection_status.get() {
            ConnectionStatus::Connected => format!("{} bg-green-100 text-green-800", base_classes),
            ConnectionStatus::Connecting => {
                format!("{} bg-yellow-100 text-yellow-800", base_classes)
            }
            ConnectionStatus::Error => format!("{} bg-red-100 text-red-800", base_classes),
            ConnectionStatus::Disconnected => format!("{} bg-gray-100 text-gray-800", base_classes),
        }
    };

    // Combined class computation for the status dot
    let status_dot_class = move || {
        let base_class = "w-2 h-2 rounded-full";
        match connection_status.get() {
            ConnectionStatus::Connected => format!("{} bg-green-500", base_class),
            ConnectionStatus::Connecting => format!("{} bg-yellow-500", base_class),
            ConnectionStatus::Error => format!("{} bg-red-500", base_class),
            ConnectionStatus::Disconnected => format!("{} bg-gray-500", base_class),
        }
    };

    view! {
        <div class="flex justify-center mb-4">
            <div class=status_div_class>
                <div class=status_dot_class></div>
                <span>{move || match connection_status.get() {
                    ConnectionStatus::Connected => "Connected",
                    ConnectionStatus::Connecting => "Connecting...",
                    ConnectionStatus::Error => "Connection Error",
                    ConnectionStatus::Disconnected => "Disconnected"
                }}</span>
            </div>
        </div>

        <Show when=move || error_message.get().is_some()>
            <div class="max-w-4xl mx-auto mb-6">
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    <strong>"Error: "</strong>
                    {move || error_message.get().unwrap_or_default()}
                </div>
            </div>
        </Show>
    }
}
use super::types::{ConnectionStatus, Role};
use leptos::prelude::*;
use uuid::Uuid;

#[cfg(feature = "hydrate")]
use wasm_bindgen::prelude::*;

#[component]
pub fn TestControls(
    #[prop(into)] role: Signal<Role>,
    #[prop(into)] is_test_active: Signal<bool>,
    #[prop(into)] is_submitted: Signal<bool>,
    #[prop(into)] connection_status: Signal<ConnectionStatus>,
    #[prop(into)] selected_student_id: Signal<Option<i32>>,
    #[prop(into)] room_id: Signal<Option<Uuid>>,
    #[prop(into)] test_id: Signal<String>,
    #[prop(into)] start_test: Callback<()>,
    #[prop(into)] end_test: Callback<()>,
) -> impl IntoView {
    let (show_link_modal, set_show_link_modal) = signal(false);
    let (copied_link, set_copied_link) = signal(false);
    let (show_qr, set_show_qr) = signal(false);

    // Generate student link
    let student_link = Memo::new(move |_| {
        if let (Some(room), tid) = (room_id.get(), test_id.get()) {
            if !tid.is_empty() {
                #[cfg(feature = "hydrate")]
                {
                    let origin = web_sys::window()
                        .and_then(|w| w.location().origin().ok())
                        .unwrap_or_else(|| "http://localhost:3000".to_string());
                    return format!("{}/student-test/{}/{}", origin, tid, room);
                }
                #[cfg(not(feature = "hydrate"))]
                {
                    return format!("http://localhost:3000/student-test/{}/{}", tid, room);
                }
            }
        }
        String::new()
    });

    // Generate QR code URL (using qr-server.com API)
    let qr_code_url = Memo::new(move |_| {
        let link = student_link.get();
        if !link.is_empty() {
            format!(
                "https://api.qrserver.com/v1/create-qr-code/?size=200x200&data={}",
                urlencoding::encode(&link)
            )
        } else {
            String::new()
        }
    });

    // Copy link to clipboard - FIXED navigator.clipboard() call
    let copy_link = move |_| {
        let link = student_link.get();
        if !link.is_empty() {
            #[cfg(feature = "hydrate")]
            {
                // Fixed: navigator().clipboard() returns Clipboard directly, not Option<Clipboard>
                if let Some(window) = web_sys::window() {
                    let clipboard = window.navigator().clipboard();
                    let _ = clipboard.write_text(&link);
                    set_copied_link.set(true);

                    // Reset copied state after 2 seconds
                    set_timeout_with_handle(
                        move || set_copied_link.set(false),
                        std::time::Duration::from_secs(2),
                    )
                    .ok();
                }
            }
        }
    };

    // Tab class computations
    let link_tab_class = move || {
        let base = "px-4 py-2 font-medium transition-colors";
        if !show_qr.get() {
            format!("{} border-b-2 border-blue-500 text-blue-600", base)
        } else {
            format!("{} text-gray-500", base)
        }
    };

    let qr_tab_class = move || {
        let base = "px-4 py-2 font-medium transition-colors";
        if show_qr.get() {
            format!("{} border-b-2 border-blue-500 text-blue-600", base)
        } else {
            format!("{} text-gray-500", base)
        }
    };

    view! {
        <Show when=move || matches!(role.get(), Role::Teacher)>
            <div class="mb-8 flex flex-wrap gap-4 justify-center">
                <Show when=move || !is_test_active.get() && !is_submitted.get()>
                    <div class="w-full mb-4 flex flex-col items-center space-y-4">
                        // Action buttons
                        <div class="flex flex-wrap gap-2 justify-center">
                            // Share Link Button
                            <button
                                class="px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                                on:click=move |_| set_show_link_modal.set(true)
                                disabled=move || !matches!(connection_status.get(), ConnectionStatus::Connected) || student_link.get().is_empty()
                            >
                                <span>"ðŸ”—"</span>
                                "Share Test Link"
                            </button>

                            // Traditional Start
                            <button
                                class="px-5 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                                on:click=move |_| start_test.call(())
                                disabled=move || selected_student_id.get().is_none() || !matches!(connection_status.get(), ConnectionStatus::Connected)
                            >
                                <span>"ðŸŽ¯"</span>
                                "Start with Selected Student"
                            </button>
                        </div>
                    </div>
                </Show>

                <Show when=move || is_test_active.get() && !is_submitted.get()>
                    <div class="flex flex-col items-center space-y-4">
                        <button
                            class="px-5 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors flex items-center gap-2"
                            on:click=move |_| end_test.call(())
                        >
                            <span>"ðŸ›‘"</span>
                            "End Test Session"
                        </button>

                        // Show link while test is active
                        <button
                            class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm flex items-center gap-2"
                            on:click=move |_| set_show_link_modal.set(true)
                        >
                            <span>"ðŸ”—"</span>
                            "Share Student Link"
                        </button>
                    </div>
                </Show>
            </div>

            // Student Link Sharing Modal
            <Show when=move || show_link_modal.get()>
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                     on:click=move |_| set_show_link_modal.set(false)>
                    <div class="bg-white rounded-lg p-6 max-w-lg w-full mx-4"
                         on:click=move |e| e.stop_propagation()>

                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-medium">"Share Test with Students"</h3>
                            <button
                                class="text-gray-400 hover:text-gray-600 text-xl"
                                on:click=move |_| set_show_link_modal.set(false)
                            >
                                "âœ•"
                            </button>
                        </div>

                        <div class="space-y-4">
                            // Tab navigation - FIXED: Combined classes
                            <div class="flex border-b">
                                <button
                                    class=link_tab_class
                                    on:click=move |_| set_show_qr.set(false)
                                >
                                    "ðŸ“‹ Share Link"
                                </button>
                                <button
                                    class=qr_tab_class
                                    on:click=move |_| set_show_qr.set(true)
                                >
                                    "ðŸ“± QR Code"
                                </button>
                            </div>

                            // Link sharing tab
                            <Show when=move || !show_qr.get()>
                                <div class="space-y-4">
                                    <p class="text-sm text-gray-600">
                                        "Students can join instantly by visiting this link. No login required - they just need to enter their name and student ID:"
                                    </p>

                                    <div class="bg-gray-50 p-3 rounded border break-all text-sm font-mono">
                                        {move || student_link.get()}
                                    </div>

                                    <div class="flex gap-2">
                                        <button
                                            class="flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"
                                            on:click=copy_link
                                        >
                                            {move || if copied_link.get() {
                                                view! { <><span>"âœ“"</span> "Copied!"</> }
                                            } else {
                                                view! { <><span>"ðŸ“‹"</span> "Copy Link"</> }
                                            }}
                                        </button>

                                        // Email sharing
                                        <a
                                            href=move || format!(
                                                "mailto:?subject=Join%20Test%20Session&body=Please%20join%20my%20test%20session%20by%20clicking%20this%20link:%0A%0A{}%0A%0ANo%20login%20required%20-%20just%20enter%20your%20name%20and%20student%20ID%20when%20prompted.",
                                                urlencoding::encode(&student_link.get())
                                            )
                                            class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors flex items-center gap-2"
                                        >
                                            <span>"ðŸ“§"</span>
                                            "Email"
                                        </a>
                                    </div>
                                </div>
                            </Show>

                            // QR Code tab
                            <Show when=move || show_qr.get()>
                                <div class="space-y-4 text-center">
                                    <p class="text-sm text-gray-600">
                                        "Students can scan this QR code with their phone camera or any QR code app:"
                                    </p>

                                    <div class="flex justify-center">
                                        <img
                                            src=move || qr_code_url.get()
                                            alt="QR Code for test session"
                                            class="border rounded-lg shadow-sm bg-white p-2"
                                            style="max-width: 200px; max-height: 200px;"
                                        />
                                    </div>

                                    <div class="text-xs text-gray-500 space-y-1">
                                        <p>"ðŸ“± Works with iPhone Camera, Android Camera, or any QR scanner"</p>
                                        <p>"ðŸ’¡ Students will be taken directly to the test join page"</p>
                                    </div>
                                </div>
                            </Show>

                            // Instructions
                            <div class="bg-blue-50 p-4 rounded-lg">
                                <h4 class="font-medium text-blue-900 mb-2">"ðŸ“ How it works:"</h4>
                                <ol class="text-sm text-blue-800 space-y-1 list-decimal list-inside">
                                    <li>"Share the link or QR code with your students"</li>
                                    <li>"Students enter their name and student ID (no login needed)"</li>
                                    <li>"They automatically join your test session"</li>
                                    <li>"Start the test when all students have joined!"</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </Show>
        </Show>
    }
}

// Utility function for timeouts
#[cfg(feature = "hydrate")]
fn set_timeout_with_handle<F>(f: F, delay: std::time::Duration) -> Result<TimeoutHandle, JsValue>
where
    F: FnOnce() + 'static,
{
    use wasm_bindgen::prelude::*;
    use wasm_bindgen::JsCast;

    let callback = Closure::once(Box::new(f) as Box<dyn FnOnce()>);
    let handle = web_sys::window()
        .unwrap()
        .set_timeout_with_callback_and_timeout_and_arguments_0(
            callback.as_ref().unchecked_ref(),
            delay.as_millis() as i32,
        )?;

    callback.forget();
    Ok(TimeoutHandle(handle))
}

#[cfg(feature = "hydrate")]
struct TimeoutHandle(i32);

#[cfg(feature = "hydrate")]
impl TimeoutHandle {
    fn clear(&self) {
        web_sys::window().unwrap().clear_timeout_with_handle(self.0);
    }
}

#[cfg(not(feature = "hydrate"))]
fn set_timeout_with_handle<F>(_f: F, _delay: std::time::Duration) -> Result<(), ()>
where
    F: FnOnce() + 'static,
{
    Ok(())
}
use super::types::*;
use crate::app::models::question::Question;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::websocket_sessions::cleanup_teacher_session_endpoint;
use crate::app::websockets::lobby::AnonymousStudent;
use leptos::prelude::*;
use leptos::prelude::*;
use log;
use serde_json::{json, Value};
use std::collections::HashMap;
use std::sync::Mutex;
use std::time::Duration as StdDuration;
use uuid::Uuid;

#[cfg(feature = "hydrate")]
use {
    wasm_bindgen::{closure::Closure, JsCast, JsValue},
    web_sys::{CloseEvent, MessageEvent, WebSocket},
};

pub struct WebSocketActions {
    pub start_test: Callback<()>,
    pub end_test: Callback<()>,
    pub go_to_next_card: Callback<()>,
    pub go_to_previous_card: Callback<()>,
    pub handle_answer_change: Callback<(i32, String)>,
    pub handle_comment_change: Callback<(i32, String)>,
    pub handle_weighted_selection: Callback<(i32, Vec<String>)>, // New for weighted multiple choice
    pub request_participants: Callback<()>,
    pub send_heartbeat: Callback<()>,
    pub join_as_anonymous_student: Callback<AnonymousStudent>,
}

#[cfg(feature = "hydrate")]
pub fn use_websocket_connection(
    room_id: Signal<Option<Uuid>>,
    user: Signal<Option<SessionUser>>,
    set_connection_status: WriteSignal<ConnectionStatus>,
    set_error_message: WriteSignal<Option<String>>,
    set_role: WriteSignal<Role>,
    set_connected_students: WriteSignal<Vec<ConnectedStudent>>,
    set_responses: WriteSignal<HashMap<i32, QuestionResponse>>,
    set_current_card_index: WriteSignal<usize>,
    set_remaining_time: WriteSignal<Option<i32>>,
    set_is_test_active: WriteSignal<bool>,
    set_is_submitted: WriteSignal<bool>,
    test_id: Signal<String>,
    session_room_id: Signal<Option<Uuid>>,
    questions: Signal<Option<Vec<Question>>>,
) -> WebSocketActions {
    use gloo_timers::future::TimeoutFuture;
    let (ws, set_ws) = create_signal::<Option<WebSocket>>(None);

    // Connect to WebSocket when room_id changes
    Effect::new(move |_| {
        if let Some(session_id) = room_id.get() {
            spawn_local(async move {
                //wait for any previous connection to close
                gloo_timers::future::TimeoutFuture::new(200).await;

                connect_to_session(
                    session_id,
                    set_ws,
                    user,
                    set_connection_status,
                    set_error_message,
                    set_role,
                    set_connected_students,
                    set_responses,
                    set_current_card_index,
                    set_remaining_time,
                    set_is_test_active,
                    set_is_submitted,
                    ws,
                );
            });
        }
    });

    // Send message through WebSocket
    let send_ws_message = move |message: String| {
        if let Some(socket) = ws.get() {
            match socket.send_with_str(&message) {
                Ok(_) => log::debug!("Sent WebSocket message: {}", message),
                Err(e) => log::error!("Failed to send WebSocket message: {:?}", e),
            }
        }
    };

    // Heartbeat sender to keep connection alive
    let send_heartbeat = Callback::new(move |_| {
        let heartbeat_message = json!({
            "type": "heartbeat",
            "timestamp": chrono::Utc::now().timestamp()
        })
        .to_string();

        send_ws_message(heartbeat_message);
    });

    // Start test handler
    let start_test = Callback::new(move |_| {
        if !test_id.get().is_empty() {
            let message = json!({
                "type": "test_message",
                "test_message_type": "start_test",
                "payload": {
                    "test_id": test_id.get()
                }
            })
            .to_string();

            send_ws_message(message);

            // Start timer
            let duration_minutes = 60;
            set_remaining_time.set(Some(duration_minutes * 60));

            // Start timer countdown
            let ws_clone = ws.clone();
            let _timer_handle = super::utils::set_interval_with_handle(
                move || {
                    set_remaining_time.update(|time| {
                        if let Some(t) = time {
                            if *t > 0 {
                                *t -= 1;

                                // Send time update every minute
                                if *t % 60 == 0 {
                                    let time_message = json!({
                                        "type": "test_message",
                                        "test_message_type": "time_update",
                                        "payload": {
                                            "remaining": *t
                                        }
                                    })
                                    .to_string();

                                    if let Some(socket) = ws_clone.get() {
                                        let _ = socket.send_with_str(&time_message);
                                    }
                                }
                            } else {
                                // Time's up, end the test
                                let end_message = json!({
                                    "type": "test_message",
                                    "test_message_type": "end_test",
                                    "payload": {}
                                })
                                .to_string();

                                if let Some(socket) = ws_clone.get() {
                                    let _ = socket.send_with_str(&end_message);
                                }
                            }
                        }
                    });
                },
                StdDuration::from_secs(1),
            )
            .expect("Could not create interval");
        }
    });

    // End test handler
    let end_test = Callback::new(move |_| {
        let test_id_value = test_id.get().clone();

        let end_message = json!({
            "type": "test_message",
            "test_message_type": "end_test",
            "payload": {}
        })
        .to_string();

        send_ws_message(end_message);
    });

    // Navigation handlers
    let go_to_next_card = Callback::new(move |_| {
        set_current_card_index.update(|index| {
            if let Some(questions_vec) = questions.get() {
                *index = (*index + 1).min(questions_vec.len() - 1);

                let focus_message = json!({
                    "type": "test_message",
                    "test_message_type": "question_focus",
                    "payload": {
                        "index": *index
                    }
                })
                .to_string();

                send_ws_message(focus_message);
            }
        });
    });

    let go_to_previous_card = Callback::new(move |_| {
        set_current_card_index.update(|index| {
            *index = index.saturating_sub(1);

            let focus_message = json!({
                "type": "test_message",
                "test_message_type": "question_focus",
                "payload": {
                    "index": *index
                }
            })
            .to_string();

            send_ws_message(focus_message);
        });
    });

    // Answer change handler (for regular questions)
    let handle_answer_change = Callback::new(move |(qnumber, value): (i32, String)| {
        // Update local state
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert(QuestionResponse::new());
            response.answer = value.clone();
        });

        // Send to server
        let answer_message = json!({
            "type": "test_message",
            "test_message_type": "submit_answer",
            "payload": {
                "question_id": qnumber,
                "answer": value,
                "answer_type": "regular"
            }
        })
        .to_string();

        send_ws_message(answer_message);
    });

    let handle_weighted_selection =
        Callback::new(move |(qnumber, selected_options): (i32, Vec<String>)| {
            // Update local state
            set_responses.update(|r| {
                let response = r.entry(qnumber).or_insert(QuestionResponse::new());
                response.selected_options = Some(selected_options.clone());
                // Also update answer field with JSON for compatibility
                response.answer = serde_json::to_string(&selected_options).unwrap_or_default();
            });

            // Send to server
            let weighted_message = json!({
                "type": "test_message",
                "test_message_type": "submit_answer",
                "payload": {
                    "question_id": qnumber,
                    "selected_options": selected_options,
                    "answer_type": "weighted_multiple_choice"
                }
            })
            .to_string();

            send_ws_message(weighted_message);
        });

    // Comment change handler
    let handle_comment_change = Callback::new(move |(qnumber, value): (i32, String)| {
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert(QuestionResponse::new());
            response.comment = value.clone();
        });

        let comment_message = json!({
            "type": "test_message",
            "test_message_type": "teacher_comment",
            "payload": {
                "question_id": qnumber,
                "comment": value
            }
        })
        .to_string();

        send_ws_message(comment_message);
    });

    let join_as_anonymous_student = Callback::new(move |student_data: AnonymousStudent| {
        let join_message = json!({
            "type": "anonymous_student_join",
            "name": student_data.name,
            "student_id": student_data.id,
            "timestamp": chrono::Utc::now().timestamp()
        })
        .to_string();

        send_ws_message(join_message);

        log::info!(
            "Sent anonymous student join message for: {}",
            student_data.name
        );
    });

    // Request participants
    let request_participants = Callback::new(move |_| {
        let request = json!({
            "type": "request_participants"
        })
        .to_string();

        send_ws_message(request);
    });

    // Cleanup on unmount
    on_cleanup(move || {
        if let Some(socket) = ws.get() {
            let _ = socket.close();
        }
    });

    WebSocketActions {
        start_test,
        end_test,
        go_to_next_card,
        go_to_previous_card,
        handle_answer_change,
        handle_comment_change,
        handle_weighted_selection,
        request_participants,
        send_heartbeat,
        join_as_anonymous_student,
    }
}

#[cfg(feature = "hydrate")]
fn connect_to_session(
    session_id: Uuid,
    set_ws: WriteSignal<Option<WebSocket>>,
    user: Signal<Option<SessionUser>>,
    set_connection_status: WriteSignal<ConnectionStatus>,
    set_error_message: WriteSignal<Option<String>>,
    set_role: WriteSignal<Role>,
    set_connected_students: WriteSignal<Vec<ConnectedStudent>>,
    set_responses: WriteSignal<HashMap<i32, QuestionResponse>>,
    set_current_card_index: WriteSignal<usize>,
    set_remaining_time: WriteSignal<Option<i32>>,
    set_is_test_active: WriteSignal<bool>,
    set_is_submitted: WriteSignal<bool>,
    ws: ReadSignal<Option<WebSocket>>,
) {
    spawn_local(async move {
        let protocol = if web_sys::window().unwrap().location().protocol().unwrap() == "https:" {
            "wss"
        } else {
            "ws"
        };
        let host = web_sys::window().unwrap().location().host().unwrap();
        let ws_url = format!("{protocol}://{host}/api/ws/{session_id}");

        log::info!("Connecting to WebSocket at: {}", ws_url);

        // Close any existing connection
        if let Some(existing_ws) = ws.get_untracked() {
            let _ = existing_ws.close();
        }

        set_connection_status.set(ConnectionStatus::Connecting);
        set_error_message.set(None);
        set_connected_students.set(Vec::new());

        match WebSocket::new(&ws_url) {
            Ok(websocket) => {
                setup_websocket_handlers(
                    websocket.clone(),
                    user,
                    set_connection_status,
                    set_error_message,
                    set_role,
                    set_connected_students,
                    set_responses,
                    set_current_card_index,
                    set_remaining_time,
                    set_is_test_active,
                    set_is_submitted,
                    ws,
                );

                set_ws.set(Some(websocket));
            }
            Err(err) => {
                let error_msg = format!("WebSocket connection failed: {:?}", err);
                log::error!("{}", error_msg);
                set_connection_status.set(ConnectionStatus::Error);
                set_error_message.set(Some(error_msg));
            }
        }
    });
}

#[cfg(feature = "hydrate")]
fn setup_websocket_handlers(
    websocket: WebSocket,
    user: Signal<Option<SessionUser>>,
    set_connection_status: WriteSignal<ConnectionStatus>,
    set_error_message: WriteSignal<Option<String>>,
    set_role: WriteSignal<Role>,
    set_connected_students: WriteSignal<Vec<ConnectedStudent>>,
    set_responses: WriteSignal<HashMap<i32, QuestionResponse>>,
    set_current_card_index: WriteSignal<usize>,
    set_remaining_time: WriteSignal<Option<i32>>,
    set_is_test_active: WriteSignal<bool>,
    set_is_submitted: WriteSignal<bool>,
    ws: ReadSignal<Option<WebSocket>>,
) {
    // Setup message handler
    let onmessage_callback = Closure::wrap(Box::new(move |e: MessageEvent| {
        if let Ok(text) = e.data().dyn_into::<js_sys::JsString>() {
            let message = text.as_string().unwrap();
            log::info!("WebSocket message received: {}", message);

            match serde_json::from_str::<Value>(&message) {
                Ok(json_value) => {
                    handle_websocket_message(
                        json_value,
                        set_role,
                        set_connected_students,
                        set_responses,
                        set_current_card_index,
                        set_remaining_time,
                        set_is_test_active,
                        set_is_submitted,
                    );
                }
                Err(err) => {
                    log::error!(
                        "Failed to parse WebSocket message: {:?}. Raw message: {}",
                        err,
                        message
                    );
                }
            }
        }
    }) as Box<dyn FnMut(MessageEvent)>);

    // Setup onopen handler
    let onopen_callback = Closure::wrap(Box::new(move |_| {
        log::info!("ðŸŽ‰ WebSocket connection established");
        set_connection_status.set(ConnectionStatus::Connected);
        set_error_message.set(None);

        // ROBUST: Try to send user_info with retries
        spawn_local(async move {
            let max_attempts = 5;

            for attempt in 1..=max_attempts {
                log::info!("ðŸ“¤ Attempting to send user_info (attempt {})", attempt);

                if let Some(current_user) = user.get_untracked() {
                    log::info!("âœ… User context available on attempt {}", attempt);

                    let user_info = json!({
                        "type": "user_info",
                        "user_id": current_user.id,
                        "role": current_user.role,
                        "is_teacher": current_user.is_teacher(),
                        "is_admin": current_user.is_admin(),
                        "is_reconnecting": true,
                    });

                    if let Some(socket) = ws.get() {
                        match socket.send_with_str(&user_info.to_string()) {
                            Ok(_) => {
                                log::info!("âœ… user_info sent successfully on attempt {}", attempt);

                                // Send participants request after successful user_info
                                gloo_timers::future::TimeoutFuture::new(500).await;

                                let participants_request = json!({
                                    "type": "request_participants"
                                })
                                .to_string();

                                let _ = socket.send_with_str(&participants_request);
                                log::info!("âœ… Participants request sent");
                                return; // Success!
                            }
                            Err(e) => {
                                log::error!(
                                    "âŒ Failed to send user_info on attempt {}: {:?}",
                                    attempt,
                                    e
                                );
                            }
                        }
                    } else {
                        log::error!("âŒ No WebSocket available on attempt {}", attempt);
                    }
                } else {
                    log::warn!("â³ User context not available on attempt {}", attempt);
                }

                // Wait before retry (increasing delay)
                gloo_timers::future::TimeoutFuture::new(300 * attempt as u32).await;
            }

            log::error!(
                "âŒ Failed to send user_info after {} attempts",
                max_attempts
            );
        });
    }) as Box<dyn FnMut(JsValue)>);

    // Setup onclose handler
    let onclose_callback = Closure::wrap(Box::new(move |e: CloseEvent| {
        log::info!("WebSocket closed: {} - {}", e.code(), e.reason());
        set_connection_status.set(ConnectionStatus::Disconnected);

        // Only cleanup if this was an established session (not initial connection failure)
        if e.code() != 1006 && e.code() != 1000 {
            // Avoid cleanup on normal close or connection never established
            if let Some(current_user) = user.get_untracked() {
                if current_user.is_teacher() || current_user.is_admin() {
                    spawn_local(async move {
                        if let Err(e) =
                            cleanup_teacher_session_endpoint(current_user.id.try_into().unwrap())
                                .await
                        {
                            log::error!(
                                "Failed to cleanup teacher session on WebSocket close: {}",
                                e
                            );
                        }
                    });
                }
            }
        }
    }) as Box<dyn FnMut(CloseEvent)>);

    // Setup onerror handler
    let onerror_callback = Closure::wrap(Box::new(move |_e| {
        let error_msg = "WebSocket connection failed".to_string();
        log::error!("WebSocket error occurred: {}", error_msg);
        set_connection_status.set(ConnectionStatus::Error);
        set_error_message.set(Some(error_msg));
    }) as Box<dyn FnMut(JsValue)>);

    // Set event handlers
    websocket.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
    websocket.set_onopen(Some(onopen_callback.as_ref().unchecked_ref()));
    websocket.set_onclose(Some(onclose_callback.as_ref().unchecked_ref()));
    websocket.set_onerror(Some(onerror_callback.as_ref().unchecked_ref()));

    // Store callbacks to prevent them from being dropped
    onmessage_callback.forget();
    onopen_callback.forget();
    onclose_callback.forget();
    onerror_callback.forget();
}

#[cfg(feature = "hydrate")]
fn handle_websocket_message(
    json_value: Value,
    set_role: WriteSignal<Role>,
    set_connected_students: WriteSignal<Vec<ConnectedStudent>>,
    set_responses: WriteSignal<HashMap<i32, QuestionResponse>>,
    set_current_card_index: WriteSignal<usize>,
    set_remaining_time: WriteSignal<Option<i32>>,
    set_is_test_active: WriteSignal<bool>,
    set_is_submitted: WriteSignal<bool>,
) {
    if let Some(msg_type) = json_value.get("type").and_then(|t| t.as_str()) {
        log::info!("Processing message type: {}", msg_type);

        match msg_type {
            "role_assigned" => {
                if let Some(role_str) = json_value.get("role").and_then(|r| r.as_str()) {
                    match role_str {
                        "teacher" => set_role.set(Role::Teacher),
                        "student" => set_role.set(Role::Student),
                        _ => set_role.set(Role::Unknown),
                    }
                }
            }
            "session_reset" => {
                log::info!("Session reset by teacher - clearing local state");
                set_responses.set(HashMap::new());
                set_current_card_index.set(0);
                set_is_test_active.set(false);
                set_is_submitted.set(false);
                set_remaining_time.set(None);
            }
            "participants_list" => {
                if let Some(participants) =
                    json_value.get("participants").and_then(|p| p.as_array())
                {
                    let connected_list: Vec<ConnectedStudent> = participants
                        .iter()
                        .filter_map(|p| {
                            let id = p.get("id")?.as_str()?;
                            let name = p.get("name")?.as_str().unwrap_or("Unknown");
                            let user_type = p.get("type")?.as_str().unwrap_or("User");
                            let status = p.get("status")?.as_str().unwrap_or("Connected");

                            Some(ConnectedStudent {
                                student_id: id.to_string(),
                                name: format!("{} ({})", name, user_type),
                                status: status.to_string(),
                            })
                        })
                        .collect();

                    set_connected_students.set(connected_list);
                }
            }
            "student_joined" | "user_joined" => {
                // Handle new participants joining
                let is_student = msg_type == "student_joined";
                let id_field = if is_student { "student_id" } else { "id" };
                let data_field = if is_student {
                    "student_data"
                } else {
                    "user_data"
                };
                let name_field = if is_student { "name" } else { "username" };

                if let Some(user_id) = json_value.get(id_field).and_then(|s| s.as_str()) {
                    if let Some(user_data) = json_value.get(data_field) {
                        let name = user_data
                            .get(name_field)
                            .and_then(|n| n.as_str())
                            .unwrap_or("Unknown");

                        let user_type = if is_student { "Student" } else { "Teacher" };
                        let display_name = format!("{} ({})", name, user_type);

                        set_connected_students.update(|students| {
                            if let Some(pos) = students.iter().position(|s| s.student_id == user_id)
                            {
                                students[pos].status = "Connected".to_string();
                                students[pos].name = display_name;
                            } else {
                                students.push(ConnectedStudent {
                                    student_id: user_id.to_string(),
                                    name: display_name,
                                    status: "Connected".to_string(),
                                });
                            }
                        });
                    }
                }
            }
            "anonymous_student_joined" => {
                // Handle confirmation that anonymous student has joined
                if let Some(student_id) = json_value.get("student_id").and_then(|s| s.as_str()) {
                    if let Some(name) = json_value.get("name").and_then(|n| n.as_str()) {
                        let display_name = format!("{} (Anonymous Student)", name);

                        set_connected_students.update(|students| {
                            if let Some(pos) =
                                students.iter().position(|s| s.student_id == student_id)
                            {
                                students[pos].status = "Connected".to_string();
                                students[pos].name = display_name;
                            } else {
                                students.push(ConnectedStudent {
                                    student_id: student_id.to_string(),
                                    name: display_name,
                                    status: "Connected".to_string(),
                                });
                            }
                        });

                        log::info!("Anonymous student joined: {} ({})", name, student_id);
                    }
                }
            }
            "student_left" | "user_left" => {
                let is_student = msg_type == "student_left";
                let id_field = if is_student { "student_id" } else { "id" };

                if let Some(user_id) = json_value.get(id_field).and_then(|s| s.as_str()) {
                    set_connected_students.update(|students| {
                        if let Some(pos) = students.iter().position(|s| s.student_id == user_id) {
                            students[pos].status = "Disconnected".to_string();
                        }
                    });
                }
            }
            "student_answer" => {
                if let Some(answer_data) = json_value.get("answer_data") {
                    if let Some(qnumber) = answer_data.get("question_id").and_then(|q| q.as_i64()) {
                        let qnumber = qnumber as i32;

                        set_responses.update(|r| {
                            let response = r.entry(qnumber).or_insert(QuestionResponse::new());

                            // Handle different answer types
                            if let Some(answer_type) =
                                answer_data.get("answer_type").and_then(|t| t.as_str())
                            {
                                match answer_type {
                                    "weighted_multiple_choice" => {
                                        if let Some(selected_options) = answer_data
                                            .get("selected_options")
                                            .and_then(|opts| opts.as_array())
                                        {
                                            let options: Vec<String> = selected_options
                                                .iter()
                                                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                                                .collect();
                                            response.selected_options = Some(options.clone());
                                            response.answer =
                                                serde_json::to_string(&options).unwrap_or_default();
                                        }
                                    }
                                    _ => {
                                        if let Some(answer) =
                                            answer_data.get("answer").and_then(|a| a.as_str())
                                        {
                                            response.answer = answer.to_string();
                                        }
                                    }
                                }
                            } else {
                                // Fallback for regular answers
                                if let Some(answer) =
                                    answer_data.get("answer").and_then(|a| a.as_str())
                                {
                                    response.answer = answer.to_string();
                                }
                            }
                        });
                    }
                }
            }
            "focus_question" => {
                if let Some(question_data) = json_value.get("question_data") {
                    if let Some(index) = question_data.get("index").and_then(|i| i.as_i64()) {
                        set_current_card_index.set(index as usize);
                    }
                }
            }
            "time_update" => {
                if let Some(time_data) = json_value.get("time_data") {
                    if let Some(remaining) = time_data.get("remaining").and_then(|r| r.as_i64()) {
                        set_remaining_time.set(Some(remaining as i32));
                    }
                }
            }
            "test_started" => {
                set_is_test_active.set(true);
            }
            "test_ended" => {
                set_is_test_active.set(false);
                set_is_submitted.set(true);
            }
            "heartbeat" => {
                log::debug!("Received heartbeat from client");
            }
            _ => {
                log::debug!("Unhandled message type: {}", msg_type);
            }
        }
    }
}

// Non-hydrate version (no-op)
#[cfg(not(feature = "hydrate"))]
pub fn use_websocket_connection(
    _room_id: Signal<Option<Uuid>>,
    _user: Signal<Option<SessionUser>>,
    _set_connection_status: WriteSignal<ConnectionStatus>,
    _set_error_message: WriteSignal<Option<String>>,
    _set_role: WriteSignal<Role>,
    _set_connected_students: WriteSignal<Vec<ConnectedStudent>>,
    _set_responses: WriteSignal<HashMap<i32, QuestionResponse>>,
    _set_current_card_index: WriteSignal<usize>,
    _set_remaining_time: WriteSignal<Option<i32>>,
    _set_is_test_active: WriteSignal<bool>,
    _set_is_submitted: WriteSignal<bool>,
    _test_id: Signal<String>,
    _session_room_id: Signal<Option<Uuid>>,
    _questions: Signal<Option<Vec<Question>>>,
) -> WebSocketActions {
    WebSocketActions {
        start_test: Callback::new(|_| {}),
        end_test: Callback::new(|_| {}),
        go_to_next_card: Callback::new(|_| {}),
        go_to_previous_card: Callback::new(|_| {}),
        handle_answer_change: Callback::new(|_| {}),
        handle_comment_change: Callback::new(|_| {}),
        handle_weighted_selection: Callback::new(|_| {}), // NEW
        request_participants: Callback::new(|_| {}),
        send_heartbeat: Callback::new(|_| {}),
        join_as_anonymous_student: Callback::new(|_| {}),
    }
}
use super::types::{ConnectionStatus, QuestionResponse, Role};
use crate::app::components::test_components::balloon_celebration::BalloonCelebration;
use crate::app::components::test_components::font_controls::{use_font_settings, FontControls};
use crate::app::models::question::{Question, QuestionType};
use crate::app::server_functions::{questions::get_questions, tests::get_tests};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use log;
use std::collections::HashMap;
use uuid::Uuid;

#[cfg(feature = "hydrate")]
use {
    serde_json::{json, Value},
    wasm_bindgen::{closure::Closure, JsCast, JsValue},
    web_sys::{CloseEvent, MessageEvent, WebSocket},
};

#[component]
pub fn AnonymousStudentTest() -> impl IntoView {
    let params = use_params_map();
    let test_id = move || params.with(|params| params.get("test_id").cloned().unwrap_or_default());
    let session_id_str =
        move || params.with(|params| params.get("session_id").cloned().unwrap_or_default());

    let (student_name, set_student_name) = signal(String::new());
    let (student_id_input, set_student_id_input) = signal(String::new());
    let (has_joined, set_has_joined) = signal(false);
    let (error_message, set_error_message) = signal(None::<String>);
    let (connection_status, set_connection_status) = signal(ConnectionStatus::Disconnected);
    let (is_test_active, set_is_test_active) = signal(false);
    let (current_card_index, set_current_card_index) = signal(0);
    let (responses, set_responses) = signal(HashMap::<i32, QuestionResponse>::new());
    let (remaining_time, set_remaining_time) = signal::<Option<i32>>(None);
    let (user_role, set_user_role) = signal(Role::Student);

    let (font_settings, set_font_settings) = use_font_settings();
    let (show_celebration, set_show_celebration) = signal(false);

    //Read-only mode control signal
    let (is_read_only, set_is_read_only) = signal(true);

    let should_disable_inputs =
        Memo::new(move |_| matches!(user_role.get(), Role::Student | Role::Unknown));

    #[cfg(feature = "hydrate")]
    let (ws, set_ws) = signal::<Option<WebSocket>>(None);

    // Get session ID as UUID
    let session_id = Memo::new(move |_| Uuid::parse_str(&session_id_str()).ok());

    // Fetch test details and questions
    let test_details = Resource::new(test_id.clone(), move |tid| async move {
        if tid.is_empty() {
            return None;
        }
        match get_tests().await {
            Ok(tests) => tests.into_iter().find(|test| test.test_id == tid),
            Err(e) => {
                log::error!("Failed to fetch test details: {}", e);
                None
            }
        }
    });

    let questions = Resource::new(test_id, move |tid| async move {
        if tid.is_empty() {
            return Vec::new();
        }
        match get_questions(tid).await {
            Ok(mut questions) => {
                // Sort questions by qnumber to ensure consistent ordering
                questions.sort_by_key(|q| q.qnumber);
                questions
            }
            Err(e) => {
                log::error!("Failed to fetch questions: {}", e);
                Vec::new()
            }
        }
    });

    // Join test function
    let join_test = move |_| {
        let name = student_name.get().trim().to_string();
        let id = student_id_input.get().trim().to_string();

        if name.is_empty() {
            set_error_message.set(Some("Please enter your name".to_string()));
            return;
        }

        if id.is_empty() {
            set_error_message.set(Some("Please enter your student ID".to_string()));
            return;
        }

        set_error_message.set(None);
        set_has_joined.set(true);
    };

    // WebSocket connection for anonymous students
    #[cfg(feature = "hydrate")]
    let connect_to_session = Action::new(move |session_uuid: &Uuid| {
        let session_uuid = *session_uuid;
        let student_name_val = student_name.get();
        let student_id_val = student_id_input.get();
        let test_id_val = test_id();

        async move {
            let protocol = if web_sys::window().unwrap().location().protocol().unwrap() == "https:"
            {
                "wss"
            } else {
                "ws"
            };
            let host = web_sys::window().unwrap().location().host().unwrap();
            let ws_url = format!("{protocol}://{host}/api/ws/{session_uuid}");

            log::info!("Anonymous student connecting to WebSocket at: {}", ws_url);

            set_connection_status.set(ConnectionStatus::Connecting);
            set_error_message.set(None);

            match WebSocket::new(&ws_url) {
                Ok(websocket) => {
                    // Setup message handler
                    let onmessage_callback = Closure::wrap(Box::new(move |e: MessageEvent| {
                        if let Ok(text) = e.data().dyn_into::<js_sys::JsString>() {
                            let message = text.as_string().unwrap();
                            log::info!("Anonymous student received message: {}", message);

                            match serde_json::from_str::<Value>(&message) {
                                Ok(json_value) => {
                                    if let Some(msg_type) =
                                        json_value.get("type").and_then(|t| t.as_str())
                                    {
                                        match msg_type {
                                            "role_assigned" => {
                                                if let Some(role_str) =
                                                    json_value.get("role").and_then(|r| r.as_str())
                                                {
                                                    match role_str {
                                                        "teacher" => {
                                                            log::warn!("anonymous student incorrectly assigned teacher role, forcing to student");
                                                            set_user_role.set(Role::Student);
                                                        }
                                                        "student" => {
                                                            log::info!("Anonymous student correctly assigned student role");
                                                            set_user_role.set(Role::Student);
                                                        }
                                                        _ => {
                                                            log::warn!("Anonymous student assigned unknown role, defaulting to student");
                                                            set_user_role.set(Role::Student);
                                                        }
                                                    }
                                                }
                                            }
                                            "test_started" => {
                                                log::info!("Test started for anonymous student");
                                                set_is_test_active.set(true);
                                            }
                                            "test_ended" => {
                                                log::info!("Test ended for anonymous student");
                                                set_show_celebration.set(true);
                                                set_is_test_active.set(false);
                                            }
                                            "focus_question" => {
                                                if let Some(question_data) =
                                                    json_value.get("question_data")
                                                {
                                                    if let Some(index) = question_data
                                                        .get("index")
                                                        .and_then(|i| i.as_i64())
                                                    {
                                                        set_current_card_index.set(index as usize);
                                                    }
                                                }
                                            }
                                            "time_update" => {
                                                if let Some(time_data) = json_value.get("time_data")
                                                {
                                                    if let Some(remaining) = time_data
                                                        .get("remaining")
                                                        .and_then(|r| r.as_i64())
                                                    {
                                                        set_remaining_time
                                                            .set(Some(remaining as i32));
                                                    }
                                                }
                                            }
                                            "teacher_comment" => {
                                                log::info!(
                                                    "Received teacher comment: {:?}",
                                                    json_value
                                                );
                                            }
                                            _ => {
                                                log::debug!("Unhandled message type: {}", msg_type);
                                            }
                                        }
                                    }
                                }
                                Err(err) => {
                                    log::error!("Failed to parse WebSocket message: {:?}", err);
                                }
                            }
                        }
                    })
                        as Box<dyn FnMut(MessageEvent)>);

                    // Setup onopen handler
                    let onopen_callback = Closure::wrap(Box::new(move |_| {
                        log::info!("Anonymous student WebSocket connection established");
                        set_connection_status.set(ConnectionStatus::Connected);
                        set_error_message.set(None);

                        // Send anonymous student join message
                        let student_join_msg = json!({
                            "type": "anonymous_student_join",
                            "student_name": student_name_val,
                            "student_id": student_id_val,
                            "test_id": test_id_val
                        })
                        .to_string();

                        if let Some(socket) = ws.get() {
                            let _ = socket.send_with_str(&student_join_msg);
                            log::info!("Sent anonymous student join message");
                        }
                    })
                        as Box<dyn FnMut(JsValue)>);

                    // Setup onclose handler
                    let onclose_callback = Closure::wrap(Box::new(move |e: CloseEvent| {
                        log::info!(
                            "Anonymous student WebSocket closed: {} - {}",
                            e.code(),
                            e.reason()
                        );
                        set_connection_status.set(ConnectionStatus::Disconnected);
                    })
                        as Box<dyn FnMut(CloseEvent)>);

                    // Setup onerror handler
                    let onerror_callback = Closure::wrap(Box::new(move |_e| {
                        let error_msg = "WebSocket connection failed".to_string();
                        log::error!("Anonymous student WebSocket error: {}", error_msg);
                        set_connection_status.set(ConnectionStatus::Error);
                        set_error_message.set(Some(error_msg));
                    })
                        as Box<dyn FnMut(JsValue)>);

                    // Set event handlers
                    websocket.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
                    websocket.set_onopen(Some(onopen_callback.as_ref().unchecked_ref()));
                    websocket.set_onclose(Some(onclose_callback.as_ref().unchecked_ref()));
                    websocket.set_onerror(Some(onerror_callback.as_ref().unchecked_ref()));

                    // Store callbacks to prevent them from being dropped
                    onmessage_callback.forget();
                    onopen_callback.forget();
                    onclose_callback.forget();
                    onerror_callback.forget();

                    // Store the websocket
                    set_ws.set(Some(websocket));
                    Ok(())
                }
                Err(err) => {
                    let error_msg = format!("WebSocket connection failed: {:?}", err);
                    log::error!("{}", error_msg);
                    set_connection_status.set(ConnectionStatus::Error);
                    set_error_message.set(Some(error_msg));
                    Err(())
                }
            }
        }
    });

    // Connect when student joins
    Effect::new(move |_| {
        if has_joined.get() {
            if let Some(session_uuid) = session_id.get() {
                #[cfg(feature = "hydrate")]
                connect_to_session.dispatch(session_uuid);
            } else {
                set_error_message.set(Some("Invalid session ID".to_string()));
            }
        }
    });

    // Handle answer submission (regular questions)
    #[cfg(feature = "hydrate")]
    let handle_answer_change = move |qnumber: i32, value: String| {
        // Update local state
        //
        //return early if read-only
        if is_read_only.get() {
            log::warn!("Attempted to change answer in read-only mode");
            return;
        }

        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert(QuestionResponse::new());
            response.answer = value.clone();
        });

        // Send answer to teacher
        let answer_message = json!({
            "type": "test_message",
            "test_message_type": "submit_answer",
            "payload": {
                "question_id": qnumber,
                "answer": value,
                "answer_type": "regular"
            }
        })
        .to_string();

        if let Some(socket) = ws.get() {
            let _ = socket.send_with_str(&answer_message);
        }
    };

    // Handle weighted selection (WeightedMultipleChoice questions)
    #[cfg(feature = "hydrate")]
    let handle_weighted_selection = move |qnumber: i32, selected_options: Vec<String>| {
        // Update local state

        // Return early if read-only
        if is_read_only.get() {
            log::warn!("Attempted to change weighted selection in read-only mode");
            return;
        }

        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert(QuestionResponse::new());
            response.selected_options = Some(selected_options.clone());
            response.answer = serde_json::to_string(&selected_options).unwrap_or_default();
        });

        // Send to teacher
        let weighted_message = json!({
            "type": "test_message",
            "test_message_type": "submit_answer",
            "payload": {
                "question_id": qnumber,
                "selected_options": selected_options,
                "answer_type": "weighted_multiple_choice"
            }
        })
        .to_string();

        if let Some(socket) = ws.get() {
            let _ = socket.send_with_str(&weighted_message);
        }
    };

    // Format remaining time
    let formatted_time = move || {
        if let Some(seconds) = remaining_time.get() {
            let minutes = seconds / 60;
            let seconds = seconds % 60;
            format!("{}:{:02}", minutes, seconds)
        } else {
            "".to_string()
        }
    };

    view! {
        <div class="min-h-screen bg-gray-50">
            <Show when=move || !has_joined.get()>
                // Student join form
                <div class="flex items-center justify-center min-h-screen">
                    <div class="bg-white p-8 rounded-lg shadow-md max-w-md w-full mx-4">
                        <div class="text-center mb-6">
                            <h2 class="text-2xl font-bold text-gray-800">"Join Test Session"</h2>
                            <p class="text-gray-600 mt-2">
                                {move || match &test_details.get() {
                                    Some(Some(test)) => format!("Test: {}", test.name),
                                    _ => format!("Test ID: {}", test_id())
                                }}
                            </p>
                        </div>

                        <Show when=move || error_message.get().is_some()>
                            <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                                {move || error_message.get().unwrap_or_default()}
                            </div>
                        </Show>

                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Your Name"
                                </label>
                                <input
                                    type="text"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                    placeholder="Enter your full name"
                                    prop:value=move || student_name.get()
                                    on:input=move |ev| set_student_name.set(event_target_value(&ev))
                                />
                            </div>

                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Student ID"
                                </label>
                                <input
                                    type="text"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                    placeholder="Enter your student ID"
                                    prop:value=move || student_id_input.get()
                                    on:input=move |ev| set_student_id_input.set(event_target_value(&ev))
                                />
                            </div>

                            <button
                                class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors font-medium"
                                on:click=join_test
                            >
                                "Join Test"
                            </button>
                        </div>

                        <div class="mt-6 text-center">
                            <div class="text-xs text-gray-500 space-y-1">
                                <p>"ðŸ’¡ No account needed - just enter your info above"</p>
                                <p>"ðŸ”’ Your teacher will see your responses in real-time"</p>
                            </div>
                        </div>
                    </div>
                </div>
            </Show>

            <Show when=move || has_joined.get()>
                // Test interface for anonymous student
                <div class="p-4 max-w-screen h-screen overflow-y-auto bg-gray-50 mx-auto">
                    {/* Header */}
                    <div class="text-center mb-8">
                        <div class="flex justify-between items-center mb-4">
                            <div></div> {/* Spacer */}
                            <div>
                                <h2 class="text-2xl font-bold text-gray-800">
                                    {move || match &test_details.get() {
                                        Some(Some(test)) => format!("Test: {}", test.name),
                                        _ => "Test Session".to_string()
                                    }}
                                </h2>
                                <div class="mt-2 text-sm text-gray-600">
                                    "Welcome, " {move || student_name.get()} " (ID: " {move || student_id_input.get()} ")"
                                </div>
                                <div class="mt-1 text-xs text-gray-400">
                                    "Role: " {move || format!("{:?}", user_role.get())}
                                </div>
                            </div>
                            <div class="flex items-center">
                                <FontControls
                                    font_settings=font_settings
                                    set_font_settings=set_font_settings
                                />
                            </div>
                        </div>
                    </div>

                    {/* Connection Status */}
                    <div class="flex justify-center mb-4">
                        {
                            let connection_status_class = move || {
                                let base_classes = "flex items-center space-x-2 px-3 py-1 rounded-full text-sm";
                                match connection_status.get() {
                                    ConnectionStatus::Connected => format!("{} bg-green-100 text-green-800", base_classes),
                                    ConnectionStatus::Connecting => format!("{} bg-yellow-100 text-yellow-800", base_classes),
                                    ConnectionStatus::Error => format!("{} bg-red-100 text-red-800", base_classes),
                                    ConnectionStatus::Disconnected => format!("{} bg-gray-100 text-gray-800", base_classes),
                                }
                            };

                            view! {
                                <div class=connection_status_class>
                                    <div class={move || {
                                        let base = "w-2 h-2 rounded-full";
                                        match connection_status.get() {
                                            ConnectionStatus::Connected => format!("{} bg-green-500", base),
                                            ConnectionStatus::Connecting => format!("{} bg-yellow-500", base),
                                            ConnectionStatus::Error => format!("{} bg-red-500", base),
                                            ConnectionStatus::Disconnected => format!("{} bg-gray-500", base),
                                        }
                                    }}></div>
                                    <span>{move || match connection_status.get() {
                                        ConnectionStatus::Connected => "Connected",
                                        ConnectionStatus::Connecting => "Connecting...",
                                        ConnectionStatus::Error => "Connection Error",
                                        ConnectionStatus::Disconnected => "Disconnected"
                                    }}</span>
                                </div>
                            }
                        }
                    </div>

                    {/* Status and Timer */}
                    <div class="flex justify-center items-center mb-6 space-x-8">
                        <div class="text-sm text-gray-600">
                            <span class="font-medium">"Status: "</span>
                            {move || if is_test_active.get() { "Test Active" } else { "Waiting for Teacher" }}
                        </div>
                        <Show when=move || !formatted_time().is_empty()>
                            <div class="text-sm text-gray-600">
                                <span class="font-medium">"Time Remaining: "</span>
                                {move || formatted_time()}
                            </div>
                        </Show>
                    </div>

                    {/* Test Content */}
                    <Show when=move || is_test_active.get()>
                        <Suspense fallback=move || view! {
                            <div class="flex justify-center items-center h-64">
                                <div class="animate-pulse bg-white rounded-lg shadow-md w-full max-w-2xl h-64 flex items-center justify-center">
                                    <p class="text-gray-400">"Loading questions..."</p>
                                </div>
                            </div>
                        }>
                            {move || match questions.get() {
                                None => view! {<div class="text-center py-8">"Loading..."</div>}.into_any(),
                                Some(questions_vec) if questions_vec.is_empty() => {
                                    view! {<div class="text-center py-8 text-red-500">"No questions found."</div>}.into_any()
                                },
                                Some(questions_vec) => {
                                    let questions_len = questions_vec.len();
                                    let questions_clone = questions_vec.clone();

                                    let current_question = Memo::new(move |_| {
                                        questions_clone.get(current_card_index.get()).cloned().unwrap_or_else(|| {
                                            questions_clone.first().cloned().unwrap()
                                        })
                                    });

                                    view! {
                                        <div class="flex flex-col items-center justify-center">
                                            {/* Card Counter */}
                                            <div class="text-center mb-4">
                                                <span class="inline-flex items-center justify-center bg-white text-sm font-medium text-gray-700 px-3 py-1 rounded-full shadow-sm border border-gray-200">
                                                    {move || current_card_index.get() + 1}
                                                    " / "
                                                    {questions_len}
                                                    <span class="ml-2 text-purple-600 font-semibold">
                                                        {move || current_question().point_value}
                                                        " pts"
                                                    </span>
                                                </span>
                                            </div>

                                            {/* Question Card */}
                                            <div class="bg-white rounded-xl shadow-lg overflow-hidden w-full max-w-2xl" style="min-height: 400px;">
                                                <div class="p-8 flex flex-col justify-start items-center w-full h-full">
                                                    {/* Question */}
                                                    <div class="text-center w-full mb-6">
                                                        <p class=move || format!("text-3xl font-bold text-gray-800 break-words {}",font_settings.get().get_question_classes())>
                                                            {move || current_question().word_problem.clone()}
                                                        </p>
                                                    </div>

                                                    {/* Answer Input */}
                                                    <div class="w-full mt-4">
                                                        {move || {
                                                            let q = current_question();
                                                            match q.question_type {
                                                                QuestionType::MultipleChoice => view! {
                                                                    <div class="space-y-2">
                                                                        <For
                                                                            each=move || q.options.clone()
                                                                            key=|option| option.clone()
                                                                            children=move |option| {
                                                                                let option_value = option.clone();
                                                                                let option_value_clone = option_value.clone();
                                                                                let qnumber = q.qnumber;
                                                                                let is_checked = Memo::new(move |_| {
                                                                                    responses.with(|r| {
                                                                                        r.get(&qnumber)
                                                                                         .map(|resp| resp.answer == option_value_clone.clone())
                                                                                         .unwrap_or(false)
                                                                                    })
                                                                                });

                                                                                view! {
                                                                                    <label class="flex items-center p-3 rounded-lg border border-gray-200 hover:border-blue-400 hover:bg-blue-50 transition-colors cursor-pointer">
                                                                                        <input
                                                                                            type="radio"
                                                                                            name=format!("q_{}", qnumber)
                                                                                            value=option_value.clone()
                                                                                            class="h-4 w-4 text-blue-600 focus:ring-blue-500"
                                                                                            prop:checked=move || is_checked()
                                                                                            on:change=move |ev| {
                                                                                                #[cfg(feature = "hydrate")]
                                                                                                {
                                                                                                    if !is_read_only.get() {
                                                                                                        let value = event_target_value(&ev);
                                                                                                        handle_answer_change(qnumber, value);
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        />
                                                                                        <span class=move || format!("ml-2 break-words {}", font_settings.get().get_answer_classes())>{option_value}</span>
                                                                                    </label>
                                                                                }
                                                                            }
                                                                        />
                                                                    </div>
                                                                }.into_any(),
                                                                QuestionType::WeightedMultipleChoice => {
                                                                    let qnumber = q.qnumber;
                                                                    let weighted_options = q.get_weighted_options();
                                                                    let q_clone_for_calc = q.clone();

                                                                    view! {
                                                                        <div class="space-y-3">
                                                                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                                                                                <p><strong>"Multiple selections allowed."</strong> " Each answer has different point values."</p>
                                                                            </div>

                                                                            <div class="space-y-2">
                                                                                {weighted_options.clone().into_iter().enumerate().map(|(index, option)| {
                                                                                    let option_clone = option.clone();
                                                                                    let option_text = option.text.clone();
                                                                                    let option_text_for_memo = option_text.clone();
                                                                                    let option_text_for_change = option_text.clone();
                                                                                    let choice_number = index + 1;

                                                                                    let is_selected = Memo::new(move |_| {
                                                                                        responses.with(|r| {
                                                                                            r.get(&qnumber)
                                                                                                .and_then(|resp| resp.selected_options.as_ref())
                                                                                                .map(|opts| opts.contains(&option_text_for_memo))
                                                                                                .unwrap_or(false)
                                                                                        })
                                                                                    });

                                                                                    view! {
                                                                                        <div class=move || {
                                                                                            let base_classes = "group flex items-center justify-between p-3 rounded-lg border transition-all duration-200";
                                                                                            if option_clone.is_selectable {
                                                                                                format!("{} border-gray-200 hover:border-blue-300 hover:bg-blue-50/50 cursor-pointer", base_classes)
                                                                                            } else {
                                                                                                format!("{} border-gray-200 bg-gray-50 cursor-not-allowed opacity-60", base_classes)
                                                                                            }
                                                                                        }
                                                                                        on:click=move |_| {
                                                                                            #[cfg(feature = "hydrate")]
                                                                                            {
                                                                                                if !is_read_only.get() && option_clone.is_selectable {
                                                                                                    let current_selected = responses.with(|r| {
                                                                                                        r.get(&qnumber)
                                                                                                            .and_then(|resp| resp.selected_options.as_ref())
                                                                                                            .cloned()
                                                                                                            .unwrap_or_default()
                                                                                                    });

                                                                                                    let mut new_selected = current_selected;
                                                                                                    if new_selected.contains(&option_text_for_change) {
                                                                                                        new_selected.retain(|x| x != &option_text_for_change);
                                                                                                    } else {
                                                                                                        new_selected.push(option_text_for_change.clone());
                                                                                                    }

                                                                                                    handle_weighted_selection(qnumber, new_selected);
                                                                                                }
                                                                                            }
                                                                                        }>
                                                                                            <div class="flex items-center gap-3">
                                                                                                <div class="relative flex-shrink-0">
                                                                                                    {if option_clone.is_selectable {
                                                                                                        view! {
                                                                                                            <div class=move || {
                                                                                                                if is_selected() {
                                                                                                                    "w-5 h-5 rounded border-2 border-blue-500 bg-blue-500 flex items-center justify-center"
                                                                                                                } else {
                                                                                                                    "w-5 h-5 rounded border-2 border-gray-300 group-hover:border-blue-400 transition-colors"
                                                                                                                }
                                                                                                            }>
                                                                                                                <Show when=move || is_selected()>
                                                                                                                    <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                                                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                                                                                    </svg>
                                                                                                                </Show>
                                                                                                            </div>
                                                                                                        }.into_any()
                                                                                                    } else {
                                                                                                        view! {
                                                                                                            <div class="w-5 h-5 rounded border-2 border-gray-300 bg-gray-100"></div>
                                                                                                        }.into_any()
                                                                                                    }}
                                                                                                </div>
                                                                                                <div class="flex items-start gap-3">
                                                                                                    <span class="text-xs text-gray-500 font-medium mt-1 min-w-[1rem]">
                                                                                                        {choice_number}
                                                                                                    </span>
                                                                                                    <span class=move ||format!("leading-relaxed break-words {}", font_settings.get().get_answer_classes())>
                                                                                                        {option_clone.text.clone()}
                                                                                                    </span>
                                                                                                </div>
                                                                                            </div>
                                                                                            <div class="flex items-center gap-2">
                                                                                                // Dont display bc this is the student screen
                                                                                                /*<span class=move || {
                                                                                                    if option_clone.points >= 0 {
                                                                                                        "text-green-600 font-semibold text-sm"
                                                                                                    } else {
                                                                                                        "text-red-600 font-semibold text-sm"
                                                                                                    }
                                                                                                }>
                                                                                                    {if option_clone.points >= 0 { "+" } else { "" }}
                                                                                                    {option_clone.points}
                                                                                                    " pts"
                                                                                                </span>*/
                                                                                                {if !option_clone.is_selectable {
                                                                                                    view! {
                                                                                                        <span class="text-xs text-gray-400 italic">"(info only)"</span>
                                                                                                    }.into_any()
                                                                                                } else {
                                                                                                    view! { <span></span> }.into_any()
                                                                                                }}
                                                                                            </div>
                                                                                        </div>
                                                                                    }
                                                                                }).collect_view()}
                                                                            </div>

                                                                            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                                                                                <div class="text-sm text-gray-700">
                                                                                    "Current score: "
                                                                                    <span class="font-semibold text-indigo-600">
                                                                                        {move || {
                                                                                            let selected = responses.with(|r| {
                                                                                                r.get(&qnumber)
                                                                                                    .and_then(|resp| resp.selected_options.as_ref())
                                                                                                    .cloned()
                                                                                                    .unwrap_or_default()
                                                                                            });
                                                                                            q_clone_for_calc.calculate_weighted_score(&selected)
                                                                                        }}
                                                                                        " / " {q.point_value} " points"
                                                                                    </span>
                                                                                </div>
                                                                            </div>
                                                                        </div>
                                                                    }.into_any()
                                                                },
                                                                QuestionType::TrueFalse => {
                                                                    let qnumber = q.qnumber;
                                                                    let is_true = Memo::new(move |_| {
                                                                        responses.with(|r| {
                                                                            r.get(&qnumber)
                                                                             .map(|resp| resp.answer == "true")
                                                                             .unwrap_or(false)
                                                                        })
                                                                    });
                                                                    let is_false = Memo::new(move |_| {
                                                                        responses.with(|r| {
                                                                            r.get(&qnumber)
                                                                             .map(|resp| resp.answer == "false")
                                                                             .unwrap_or(false)
                                                                        })
                                                                    });

                                                                    view! {
                                                                        {
                                                                            let true_button_class = move || {
                                                                                let base = "px-6 py-3 w-full rounded-lg font-medium text-center transition-colors";
                                                                                if is_true() {
                                                                                    format!("{} bg-green-500 text-white border-transparent", base)
                                                                                } else {
                                                                                    format!("{} bg-white text-gray-800 border-gray-200 border", base)
                                                                                }
                                                                            };

                                                                            let false_button_class = move || {
                                                                                let base = "px-6 py-3 w-full rounded-lg font-medium text-center transition-colors";
                                                                                if is_false() {
                                                                                    format!("{} bg-red-500 text-white border-transparent", base)
                                                                                } else {
                                                                                    format!("{} bg-white text-gray-800 border-gray-200 border", base)
                                                                                }
                                                                            };

                                                                            view! {
                                                                                <div class="w-full flex flex-col sm:flex-row gap-4 items-center justify-center">
                                                                                    <button
                                                                                        type="button"
                                                                                        class=true_button_class
                                                                                        on:click=move |_| {
                                                                                            #[cfg(feature = "hydrate")]{
                                                                                                if !is_read_only.get() {
                                                                                                    handle_answer_change(qnumber, "true".to_string());
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    >
                                                                                        <span class=move || font_settings.get().get_answer_classes()>
                                                                                            "Yes" //manually
                                                                                        </span>
                                                                                        //equivalent to
                                                                                        //"True"
                                                                                    </button>
                                                                                    <button
                                                                                        type="button"
                                                                                        class=false_button_class
                                                                                        on:click=move |_| {
                                                                                            #[cfg(feature = "hydrate")]
                                                                                            if !is_read_only.get() {
                                                                                                handle_answer_change(qnumber, "false".to_string());
                                                                                            }
                                                                                        }
                                                                                    >
                                                                                        <span class=move || font_settings.get().get_answer_classes()>
                                                                                            "No" //manually
                                                                                        </span>
                                                                                    </button>
                                                                                </div>
                                                                            }
                                                                        }
                                                                    }.into_any()
                                                                },
                                                                _ => {
                                                                    let qnumber = q.qnumber;
                                                                    let answer_value = Memo::new(move |_| {
                                                                        responses.with(|r| {
                                                                            r.get(&qnumber)
                                                                             .map(|resp| resp.answer.clone())
                                                                             .unwrap_or_default()
                                                                        })
                                                                    });

                                                                    view! {
                                                                        <div>
                                                                            <textarea
                                                                                class="w-full p-3 border border-gray-200 rounded-lg focus:ring-blue-500 focus:border-blue-500"
                                                                                prop:value=move || answer_value()
                                                                                on:input=move |ev| {
                                                                                    #[cfg(feature = "hydrate")]
                                                                                    {
                                                                                        if !is_read_only.get() {
                                                                                            let value = event_target_value(&ev);
                                                                                            handle_answer_change(qnumber, value);
                                                                                        }
                                                                                    }
                                                                                }
                                                                                placeholder="Enter your answer here..."
                                                                                rows="4"
                                                                            ></textarea>
                                                                        </div>
                                                                    }.into_any()
                                                                }
                                                            }
                                                        }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    }.into_any()
                                }
                            }}
                        </Suspense>
                    </Show>

                    {/* Waiting Message */}
                    <Show when=move || !is_test_active.get()>
                        <div class="flex flex-col items-center justify-center py-12 max-w-md mx-auto">
                            <div class="bg-white p-8 rounded-lg shadow-md w-full text-center">
                                <h3 class="text-xl font-medium mb-4">"Waiting for Test to Start"</h3>
                                <p class="text-gray-600 mb-6">"Your teacher will start the test soon. Please stay on this page."</p>
                                <div class="animate-pulse flex justify-center">
                                    <div class="h-4 w-4 bg-blue-400 rounded-full mr-1"></div>
                                    <div class="h-4 w-4 bg-blue-500 rounded-full mr-1 animation-delay-200"></div>
                                    <div class="h-4 w-4 bg-blue-600 rounded-full animation-delay-400"></div>
                                </div>
                            </div>
                        </div>
                    </Show>

                    {/* Error Message */}
                    <Show when=move || error_message.get().is_some()>
                        <div class="max-w-4xl mx-auto mb-6">
                            <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                                <strong>"Error: "</strong>
                                {move || error_message.get().unwrap_or_default()}
                            </div>
                        </div>
                    </Show>
                </div>
            </Show>
        </div>

        {/* Balloon Celebration */}
        <BalloonCelebration
            show=Signal::derive(move || show_celebration.get())
            message="ðŸŽ‰ Test Complete! Great job! ðŸŽ‰"
            duration=5000
        />
    }
}
use leptos::prelude::*;
use leptos::prelude::*;
use uuid=:Uuid;
use chrono::{DateTime, Utc};
use crate::app::models::websocket_session::{CreateSessionRequest, SessionType};
use crate::app::server_functions::websocket_sessions;
use log;

pub struct SessionManager {
    pub room_id= ReadSignal<Option<Uuid>>,
    set_room_id= WriteSignal<Option<Uuid>>,
}

impl SessionManager {
    pub fn new() -> Self {
        let (room_id, set_room_id) = create_signal::<Option<Uuid>>(None);
        
        Self {
            room_id,
            set_room_id,
        }
    }

    pub fn create_or_join_session(&self, test_id= String, test_name: String) {
        let set_room_id = self.set_room_id;
        
        spawn_local(async move {
            match websocket_sessions::get_test_sessions_by_test_id(test_id.clone()).await {
                Ok(sessions) => {
                    if let Some(active_session) = sessions.iter().find(|s| {
                        let now = Utc::now();
                        let active_threshold = now - chrono::Duration::minutes(5);
                        s.last_active > active_threshold && s.start_time.is_none() && s.end_time.is_none()
                    }) {
                        log::info!("Joining existing session: {}", active_session.id);
                        set_room_id.set(Some(active_session.id));
                    } else {
                        log::info!("Creating new session for test: {}", test_name);
                        let request = CreateSessionRequest {
                            name: format!("Test Session for {}", test_name),
                            description: Some(format!("Test session for {}", test_id)),
                            session_type: Some(SessionType::Test),
                            test_id= Some(test_id),
                            max_users: Some(30),
                            is_private: Some(false),
                            password: None,
                            metadata: None,
                        };

                        match websocket_sessions::create_session(request).await {
                            Ok(session) => {
                                log::info!("Created new session: {}", session.id);
                                set_room_id.set(Some(session.id));
                            }
                            Err(e) => {
                                log::error!("Failed to create session: {}", e);
                            }
                        }
                    }
                }
                Err(e) => {
                    log::error!("Failed to fetch test sessions: {}", e);
                }
            }
        });
    }
}
use leptos::prelude::*;
pub mod anonymous_student_test;
pub mod connection_status;
pub mod navigation;
pub mod participants_list;
pub mod question_card;
pub mod student_select;
pub mod test_controls;
pub mod test_session;
pub mod types;
pub mod utils;
pub mod websocket_handler;

pub use anonymous_student_test::*;
pub use connection_status::*;
pub use navigation::*;
pub use participants_list::*;
pub use question_card::*;
pub use student_select::*;
pub use test_controls::*;
pub use test_session::*;
pub use types::*;
pub use utils::*;
pub use websocket_handler::*;
use leptos::prelude::*;
use leptos::prelude::*;
use std::time::Duration as StdDuration;

#[cfg(feature = "hydrate")]
use wasm_bindgen::JsValue; // Add this import

#[cfg(feature = "hydrate")]
pub fn set_interval_with_handle<F>(f: F, delay: StdDuration) -> Result<IntervalHandle, JsValue>
where
    F: Fn() + 'static,
{
    use wasm_bindgen::prelude::*;
    use wasm_bindgen::JsCast;

    let callback = Closure::wrap(Box::new(f) as Box<dyn Fn()>);
    let handle = web_sys::window()
        .unwrap()
        .set_interval_with_callback_and_timeout_and_arguments_0(
            callback.as_ref().unchecked_ref(),
            delay.as_millis() as i32,
        )?;

    callback.forget();
    Ok(IntervalHandle(handle))
}

#[cfg(feature = "hydrate")]
pub fn set_timeout_with_handle<F>(f: F, delay: StdDuration) -> Result<TimeoutHandle, JsValue>
where
    F: FnOnce() + 'static,
{
    use wasm_bindgen::prelude::*;
    use wasm_bindgen::JsCast;

    let callback = Closure::once(Box::new(f) as Box<dyn FnOnce()>);
    let handle = web_sys::window()
        .unwrap()
        .set_timeout_with_callback_and_timeout_and_arguments_0(
            callback.as_ref().unchecked_ref(),
            delay.as_millis() as i32,
        )?;

    callback.forget();
    Ok(TimeoutHandle(handle))
}

#[cfg(feature = "hydrate")]
pub struct IntervalHandle(i32);

#[cfg(feature = "hydrate")]
impl IntervalHandle {
    pub fn clear(&self) {
        web_sys::window()
            .unwrap()
            .clear_interval_with_handle(self.0);
    }
}

#[cfg(feature = "hydrate")]
pub struct TimeoutHandle(i32);

#[cfg(feature = "hydrate")]
impl TimeoutHandle {
    pub fn clear(&self) {
        web_sys::window().unwrap().clear_timeout_with_handle(self.0);
    }
}

// Non-hydrate versions (no-ops)
#[cfg(not(feature = "hydrate"))]
pub fn set_interval_with_handle<F>(_f: F, _delay: StdDuration) -> Result<IntervalHandle, ()>
where
    F: Fn() + 'static,
{
    Ok(IntervalHandle)
}

#[cfg(not(feature = "hydrate"))]
pub fn set_timeout_with_handle<F>(_f: F, _delay: StdDuration) -> Result<TimeoutHandle, ()>
where
    F: FnOnce() + 'static,
{
    Ok(TimeoutHandle)
}

#[cfg(not(feature = "hydrate"))]
pub struct IntervalHandle;

#[cfg(not(feature = "hydrate"))]
impl IntervalHandle {
    pub fn clear(&self) {}
}

#[cfg(not(feature = "hydrate"))]
pub struct TimeoutHandle;

#[cfg(not(feature = "hydrate"))]
impl TimeoutHandle {
    pub fn clear(&self) {}
}
use super::types::Role;
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn NavigationControls(
    #[prop(into)] role: Signal<Role>,
    #[prop(into)] is_test_active: Signal<bool>,
    #[prop(into)] is_submitted: Signal<bool>,
    #[prop(into)] should_disable_inputs: Signal<bool>,
    #[prop(into)] current_card_index: Signal<usize>,
    #[prop(into)] total_questions: Signal<usize>,
    #[prop(into)] selected_student_id: Signal<Option<i32>>,
    #[prop(into)] on_previous: Callback<()>,
    #[prop(into)] on_next: Callback<()>,
    #[prop(into)] on_submit: Callback<()>,
) -> impl IntoView {
    view! {
        <Show when=move || is_test_active.get() || matches!(role.get(), Role::Teacher)>
            <div class="flex flex-wrap items-center justify-center gap-4 mt-8">
                <button
                    class="flex items-center justify-center px-5 py-2 bg-white border border-gray-200 rounded-lg shadow-sm text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                    disabled=move || (current_card_index.get() == 0 || should_disable_inputs())
                    on:click=move |_| on_previous.call(())
                >
                    <span class="mr-1">"â†"</span>
                    "Previous"
                </button>

                {move || {
                    let is_last = current_card_index.get() == total_questions.get().saturating_sub(1);

                    if is_last && matches!(role.get(), Role::Teacher) && is_test_active.get() && !is_submitted.get() {
                        view! {
                            <button
                                class="flex items-center justify-center px-5 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg shadow-sm hover:from-blue-700 hover:to-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                on:click=move |_| on_submit.call(())
                                disabled=move || (selected_student_id.get().is_none() || should_disable_inputs())
                            >
                                "Submit Assessment"
                                <span class="ml-1">"âœ“"</span>
                            </button>
                        }.into_any()
                    } else if !is_last {
                        view! {
                            <button
                                class="flex items-center justify-center px-5 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg shadow-sm hover:from-blue-700 hover:to-purple-700 transition-colors"
                                on:click=move |_| on_next.call(())
                                disabled=move || should_disable_inputs()
                            >
                                "Next"
                                <span class="ml-1">"â†’"</span>
                            </button>
                        }.into_any()
                    } else {
                        view! { <div></div> }.into_any()
                    }
                }}
            </div>
        </Show>
    }
}
use chrono::{DateTime, Utc};
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Copy, PartialEq, Debug)]
pub enum ConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Error,
}

#[derive(Debug, Clone)]
pub struct QuestionResponse {
    pub answer: String,
    pub comment: String,
    pub selected_options: Option<Vec<String>>,
}

impl QuestionResponse {
    pub fn new() -> Self {
        Self {
            answer: String::new(),
            comment: String::new(),
            selected_options: None,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Role {
    Teacher,
    Student,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct ConnectedStudent {
    pub student_id: String,
    pub name: String,
    pub status: String,
}

#[derive(Debug, Clone)]
pub struct TestSessionState {
    pub room_id: Option<Uuid>,
    pub role: Role,
    pub connected_students: Vec<ConnectedStudent>,
    pub connection_status: ConnectionStatus,
    pub error_message: Option<String>,
    pub current_card_index: usize,
    pub responses: std::collections::HashMap<i32, QuestionResponse>,
    pub selected_student_id: Option<i32>,
    pub is_test_active: bool,
    pub is_submitted: bool,
    pub remaining_time: Option<i32>,
}

impl Default for TestSessionState {
    fn default() -> Self {
        Self {
            room_id: None,
            role: Role::Unknown,
            connected_students: Vec::new(),
            connection_status: ConnectionStatus::Disconnected,
            error_message: None,
            current_card_index: 0,
            responses: std::collections::HashMap::new(),
            selected_student_id: None,
            is_test_active: false,
            is_submitted: false,
            remaining_time: None,
        }
    }
}
use leptos::prelude::*;
use super::types::{QuestionResponse, Role};
use crate::app::components::test_components::font_controls::FontSettings;
use crate::app::models::question::{Question, QuestionType};
use std::collections::HashMap;

#[component]
pub fn QuestionCard(
    question: Question,
    #[prop(into)] role: Signal<Role>,
    #[prop(into)] responses: Signal<HashMap<i32, QuestionResponse>>,
    #[prop(into)] should_disable_inputs: Signal<bool>,
    #[prop(into)] font_settings: Signal<FontSettings>,
    #[prop(into)] on_answer_change: Callback<(i32, String)>,
    #[prop(into)] on_comment_change: Callback<(i32, String)>,
    #[prop(into)] on_weighted_selection: Callback<(i32, Vec<String>)>,
) -> impl IntoView {
    let question_for_answer = question.clone();
    let question_for_comment = question.clone();

    view! {
        <div class="bg-white rounded-xl shadow-lg overflow-hidden w-full max-w-4xl" style="min-height: 450px;">
            <div class="p-8 flex flex-col justify-start items-center w-full h-full overflow-y-auto">
                {/* Question Section */}
                <div class="text-center w-full overflow-auto mb-6">
                    <p class=move || format!("text-gray-800 break-words mb-8 {}", font_settings.get().get_question_classes())>
                        {question.word_problem.clone()}
                    </p>
                </div>

                {/* Answer Section */}
                <Show when=move || matches!(role.get(), Role::Teacher)>
                    <div class="w-full mt-2">
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            "Your Answer:"
                        </label>
                        <AnswerInput
                            question=question_for_answer.clone()
                            responses=responses
                            should_disable_inputs=should_disable_inputs
                            font_settings=font_settings
                            on_answer_change=on_answer_change
                            on_weighted_selection=on_weighted_selection
                        />
                    </div>
                </Show>

                {/* Teacher Comments Section */}
                <Show when=move || matches!(role.get(), Role::Teacher)>
                    <div class="w-full mt-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            "Teacher Comments:"
                        </label>
                        <CommentInput
                            question=question_for_comment.clone()
                            responses=responses
                            on_comment_change=on_comment_change
                        />
                    </div>
                </Show>
            </div>
        </div>
    }
}

#[component]
fn AnswerInput(
    question: Question,
    #[prop(into)] responses: Signal<HashMap<i32, QuestionResponse>>,
    #[prop(into)] should_disable_inputs: Signal<bool>,
    #[prop(into)] font_settings: Signal<FontSettings>,
    #[prop(into)] on_answer_change: Callback<(i32, String)>,
    #[prop(into)] on_weighted_selection: Callback<(i32, Vec<String>)>,
) -> impl IntoView {
    let qnumber = question.qnumber;

    match question.question_type {
        QuestionType::MultipleChoice => view! {
            <div class="space-y-2 max-h-48 overflow-y-auto">
                <For
                    each=move || question.options.clone()
                    key=|option| option.clone()
                    children=move |option| {
                        let option_value = option.clone();
                        let option_value_clone = option_value.clone();
                        let is_checked = Memo::new(move |_| {
                            responses.with(|r| {
                                r.get(&qnumber)
                                 .map(|resp| resp.answer == option_value_clone.clone())
                                 .unwrap_or(false)
                            })
                        });

                        view! {
                            <label class="flex items-center p-3 rounded-lg border border-gray-200 hover:border-blue-400 hover:bg-blue-50 transition-colors cursor-pointer">
                                <input
                                    type="radio"
                                    name=format!("q_{}", qnumber)
                                    value=option_value.clone()
                                    class="h-4 w-4 text-blue-600 focus:ring-blue-500"
                                    prop:checked=move || is_checked()
                                    prop:disabled=should_disable_inputs.get()
                                    on:change=move |ev| {
                                        if !should_disable_inputs.get() {
                                            let value = event_target_value(&ev);
                                            on_answer_change.call((qnumber, value));
                                        }
                                    }
                                />
                                <span class=move || format!("ml-2 break-words {}", font_settings.get().get_answer_classes())>{option_value}</span>
                            </label>
                        }
                    }
                />
            </div>
        }.into_any(),
        QuestionType::WeightedMultipleChoice => {
            let weighted_options = question.get_weighted_options();
            let q_clone_for_calc = question.clone();

            view! {
                <div class="space-y-3">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                        <p><strong>"Multiple selections allowed."</strong> " Each answer has different point values."</p>
                    </div>

                    <div class="space-y-2">
                        {weighted_options.clone().into_iter().enumerate().map(|(index, option)| {
                            let option_clone = option.clone();
                            let option_text = option.text.clone();
                            let option_text_for_memo = option_text.clone();
                            let option_text_for_change = option_text.clone();
                            let choice_number = index + 1;

                            let is_selected = Memo::new(move |_| {
                                responses.with(|r| {
                                    r.get(&qnumber)
                                        .and_then(|resp| resp.selected_options.as_ref())
                                        .map(|opts| opts.contains(&option_text_for_memo))
                                        .unwrap_or(false)
                                })
                            });

                            view! {
                                <div class=move || {
                                    let base_classes = "group flex items-center justify-between p-3 rounded-lg border transition-all duration-200";
                                    if option_clone.is_selectable {
                                        format!("{} border-gray-200 hover:border-blue-300 hover:bg-blue-50/50 cursor-pointer", base_classes)
                                    } else {
                                        format!("{} border-gray-200 bg-gray-50 cursor-not-allowed opacity-60", base_classes)
                                    }
                                }
                                on:click=move |_| {
                                    if option_clone.is_selectable && !should_disable_inputs.get() {
                                        let current_selected = responses.with(|r| {
                                            r.get(&qnumber)
                                                .and_then(|resp| resp.selected_options.as_ref())
                                                .cloned()
                                                .unwrap_or_default()
                                        });

                                        let mut new_selected = current_selected;
                                        if new_selected.contains(&option_text_for_change) {
                                            new_selected.retain(|x| x != &option_text_for_change);
                                        } else {
                                            new_selected.push(option_text_for_change.clone());
                                        }

                                        on_weighted_selection.call((qnumber, new_selected));
                                    }
                                }>
                                    <div class="flex items-center gap-3">
                                        <div class="relative flex-shrink-0">
                                            {if option_clone.is_selectable {
                                                view! {
                                                    <div class=move || {
                                                        if is_selected() {
                                                            "w-5 h-5 rounded border-2 border-blue-500 bg-blue-500 flex items-center justify-center"
                                                        } else {
                                                            "w-5 h-5 rounded border-2 border-gray-300 group-hover:border-blue-400 transition-colors"
                                                        }
                                                    }>
                                                        <Show when=move || is_selected()>
                                                            <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                            </svg>
                                                        </Show>
                                                    </div>
                                                }.into_any()
                                            } else {
                                                view! {
                                                    <div class="w-5 h-5 rounded border-2 border-gray-300 bg-gray-100"></div>
                                                }.into_any()
                                            }}
                                        </div>
                                        <div class="flex items-start gap-3">
                                            <span class="text-xs text-gray-500 font-medium mt-1 min-w-[1rem]">
                                                {choice_number}
                                            </span>
                                            <span class=move || format!("leading-relaxed break-words {}", font_settings.get().get_answer_classes())>
                                                {option_clone.text.clone()}
                                            </span>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class=move || {
                                            if option_clone.points >= 0 {
                                                "text-green-600 font-semibold text-sm"
                                            } else {
                                                "text-red-600 font-semibold text-sm"
                                            }
                                        }>
                                            {if option_clone.points >= 0 { "+" } else { "" }}
                                            {option_clone.points}
                                            " pts"
                                        </span>
                                        {if !option_clone.is_selectable {
                                            view! {
                                                <span class="text-xs text-gray-400 italic">"(info only)"</span>
                                            }.into_any()
                                        } else {
                                            view! { <span></span> }.into_any()
                                        }}
                                    </div>
                                </div>
                            }
                        }).collect_view()}
                    </div>

                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                        <div class="text-sm text-gray-700">
                            "Current score: "
                            <span class="font-semibold text-indigo-600">
                                {move || {
                                    let selected = responses.with(|r| {
                                        r.get(&qnumber)
                                            .and_then(|resp| resp.selected_options.as_ref())
                                            .cloned()
                                            .unwrap_or_default()
                                    });
                                    q_clone_for_calc.calculate_weighted_score(&selected)
                                }}
                                " / " {question.point_value} " points"
                            </span>
                        </div>
                    </div>
                </div>
            }.into_any()
        },
        QuestionType::TrueFalse => {
            let is_true = Memo::new(move |_| {
                responses.with(|r| {
                    r.get(&qnumber)
                     .map(|resp| resp.answer == "true")
                     .unwrap_or(false)
                })
            });
            let is_false = Memo::new(move |_| {
                responses.with(|r| {
                    r.get(&qnumber)
                     .map(|resp| resp.answer == "false")
                     .unwrap_or(false)
                })
            });

            // Combined class computation for True button
            let true_button_class = move || {
                let base = "px-6 py-3 w-full rounded-lg font-medium text-center transition-colors";
                let disabled_cursor = if should_disable_inputs() { " cursor-not-allowed" } else { "" };
                
                if is_true() {
                    format!("{} bg-green-500 text-white border-transparent{}", base, disabled_cursor)
                } else {
                    format!("{} bg-white text-gray-800 border-gray-200 border{}", base, disabled_cursor)
                }
            };

            // Combined class computation for False button
            let false_button_class = move || {
                let base = "px-6 py-3 w-full rounded-lg font-medium text-center transition-colors";
                let disabled_cursor = if should_disable_inputs() { " cursor-not-allowed" } else { "" };
                
                if is_false() {
                    format!("{} bg-red-500 text-white border-transparent{}", base, disabled_cursor)
                } else {
                    format!("{} bg-white text-gray-800 border-gray-200 border{}", base, disabled_cursor)
                }
            };

            view! {
                <div class="w-full flex flex-col sm:flex-row gap-4 items-center justify-center">
                    <button
                        type="button"
                        class=true_button_class
                        on:click=move |_| {
                            if !should_disable_inputs.get() {
                                on_answer_change.call((qnumber, "true".to_string()));
                            }
                        }
                    >
                        <span class=move || font_settings.get().get_answer_classes()>
                            "Yes" //manually changed from "True" to "Yes" for clarity
                        </span>
                    </button>
                    <button
                        type="button"
                        class=false_button_class
                        on:click=move |_| {
                            if !should_disable_inputs.get() {
                                on_answer_change.call((qnumber, "false".to_string()));
                            }
                        }
                    >
                        <span class=move || font_settings.get().get_answer_classes()>
                            "No" //manually changed from "False" to "No" for clarity
                        </span>
                    </button>
                </div>
            }.into_any()
        },
        _ => {
            let answer_value = Memo::new(move |_| {
                responses.with(|r| {
                    r.get(&qnumber)
                     .map(|resp| resp.answer.clone())
                     .unwrap_or_default()
                })
            });

            view! {
                <div>
                    <textarea
                        class=move || format!("w-full p-3 border border-gray-200 rounded-lg focus:ring-blue-500 focus:border-blue-500 {}", font_settings.get().get_answer_classes())
                        prop:value=move || answer_value()
                        prop:disabled={should_disable_inputs()}
                        on:input=move |ev| {
                            if !should_disable_inputs.get() {
                                let value = event_target_value(&ev);
                                on_answer_change.call((qnumber, value));
                            }
                        }
                        placeholder="Enter your answer here..."
                        rows="3"
                    ></textarea>
                </div>
            }.into_any()
        }
    }
}

#[component]
fn CommentInput(
    question: Question,
    #[prop(into)] responses: Signal<HashMap<i32, QuestionResponse>>,
    #[prop(into)] on_comment_change: Callback<(i32, String)>,
) -> impl IntoView {
    let qnumber = question.qnumber;
    let comment_value = Memo::new(move |_| {
        responses.with(|r| {
            r.get(&qnumber)
                .map(|resp| resp.comment.clone())
                .unwrap_or_default()
        })
    });

    view! {
        <div>
            <textarea
                class="w-full p-3 border border-gray-200 rounded-lg focus:ring-blue-500 focus:border-blue-500"
                prop:value=move || comment_value()
                on:input=move |ev| {
                    let value = event_target_value(&ev);
                    on_comment_change.call((qnumber, value));
                }
                placeholder="Add teacher comments or notes here..."
                rows="2"
            ></textarea>
        </div>
    }
}
use leptos::prelude::*;
pub mod scoring;
pub use scoring::*;
use leptos::prelude::*;
pub mod student_charts;
pub mod student_results_summary;
pub mod test_pie_chart;

// Re-export commonly used types and components
pub use student_results_summary::{
    AssessmentSummary, Progress, StudentResultsSummary, TestDetail, TestHistoryEntry,
};

// Only export server functions when SSR feature is enabled
#[cfg(feature = "ssr")]
pub use student_results_summary::get_student_results;

// Always export chart components (they handle their own feature gating internally)
pub use student_charts::{
    AssessmentProgressChart, AssessmentRadarChart, PerformanceDistributionChart,
    TestAreaPerformanceChart, TestScoresTimelineChart,
};
pub use test_pie_chart::*;
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;

#[component]
pub fn Header() -> impl IntoView {
    view! {
        <header class="sticky top-0 z-50 w-full bg-[#F9F9F8] backdrop-blur bg-opacity-90">
            <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center h-20">
                    {/* Logo and brand name */}
                    <div class="flex items-center transform hover:scale-105 transition-transform duration-200">
                        <A href="/dashboard" class="flex items-center">
                            <div class="rounded-lg ">
                                <img
                                    src="/assets/teapot2.png"
                                    alt="Teapot Testing"
                                    class="h-24 w-auto "
                                />
                            </div>
                            <div class="hidden sm:block">
                                <div class="font-montserrat text-4xl font-bold text-[#2E3A59] leading-tight">
                                    "teapot"
                                </div>
                            </div>
                        </A>
                    </div>

                    {/* User Account */}
                    <div class="flex items-center transform hover:scale-105 transition-transform duration-200">
                        <A
                            href="/myaccount"
                            class="flex items-center space-x-2 bg-[#2E3A59] hover:bg-opacity-80 text-[#F9F9F8] px-4 py-2 rounded-lg transition-colors duration-200 text-sm font-medium"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                        </A>
                    </div>

                    {/* Mobile menu button - hidden on desktop */}
                    <div class="md:hidden flex items-center">
                        <button class="text-[#DADADA] hover:text-[#2E3A59] focus:outline-none transition-colors duration-200">
                            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M4 6h16M4 12h16m-7 6h7"
                                ></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </header>
    }
}
use crate::app::models::user::{SessionUser, User};
use crate::app::server_functions::users::{get_user, update_user};
use leptos::ev;
use leptos::prelude::*;
use leptos::task::spawn_local;

#[component]
pub fn UpdateProfileModal(
    #[prop(into)] show: Signal<bool>,
    #[prop(into)] on_close: Callback<()>,
    #[prop(into)] on_success: Callback<()>,
) -> impl IntoView {
    // Get the current user from context (provided by AuthProvider)
    let current_user = use_context::<ReadSignal<Option<SessionUser>>>()
        .expect("AuthProvider should provide current_user");

    // Create a derived signal for user_id to avoid unnecessary refetching
    let user_id = Memo::new(move |_| current_user.get().map(|user| user.id));

    // State for form inputs
    let (first_name, set_first_name) = signal(String::new());
    let (last_name, set_last_name) = signal(String::new());
    let (phone_number, set_phone_number) = signal(String::new());

    // State for feedback messages
    let (success_message, set_success_message) = signal(None::<String>);
    let (error_message, set_error_message) = signal(None::<String>);
    let (is_submitting, set_is_submitting) = signal(false);

    // Fetch current user data to pre-populate form
    let user_resource = Resource::new(
        move || (user_id.get(), show.get()), // Refetch when modal is shown
        move |(id, _)| async move {
            match id {
                Some(user_id) => get_user(user_id).await.ok(),
                None => None,
            }
        },
    );

    // Pre-populate form when user data is fetched
    Effect::new(move |_| {
        if let Some(Some(user)) = user_resource.get() {
            if let Some(first) = user.first_name.clone() {
                set_first_name(first);
            }
            if let Some(last) = user.last_name.clone() {
                set_last_name(last);
            }
            if let Some(phone) = user.phone_number.clone() {
                set_phone_number(phone);
            }
        }
    });

    // Reset form state when modal is closed
    Effect::new(move |_| {
        if !show.get() {
            set_success_message(None);
            set_error_message(None);
            set_is_submitting(false);
        }
    });

    // Handle form submission
    let on_submit = move |ev: ev::SubmitEvent| {
        ev.prevent_default();

        // Clear previous messages
        set_success_message(None);
        set_error_message(None);
        set_is_submitting(true);

        let current_first_name = first_name.get();
        let current_last_name = last_name.get();
        let current_phone_number = phone_number.get();
        let on_success_callback = on_success.clone();

        // We need the original user data to update only the fields we want to change
        spawn_local(async move {
            if let Some(user_id) = user_id.get() {
                match get_user(user_id).await {
                    Ok(mut user) => {
                        // Update only the fields we want to change
                        user.first_name = Some(current_first_name);
                        user.last_name = Some(current_last_name);
                        user.phone_number = Some(current_phone_number);

                        // Send the update request
                        match update_user(user).await {
                            Ok(_) => {
                                set_success_message(Some(
                                    "Profile updated successfully!".to_string(),
                                ));
                                // Notify parent component of success
                                on_success_callback.call(());
                                // Wait briefly to show success message before closing
                                set_timeout(
                                    move || {
                                        on_close.call(());
                                    },
                                    std::time::Duration::from_millis(1500),
                                );
                            }
                            Err(e) => {
                                set_error_message(Some(format!("Failed to update profile: {}", e)));
                            }
                        }
                    }
                    Err(e) => {
                        set_error_message(Some(format!("Failed to fetch user data: {}", e)));
                    }
                }
            } else {
                set_error_message(Some("User not authenticated".to_string()));
            }

            set_is_submitting(false);
        });
    };

    let close_modal = move |_| {
        on_close.call(());
    };

    // Only render modal content when shown
    view! {
        {move || if show.get() {
            view! {
                <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center overflow-y-auto">
                    <div class="bg-white text-[#2E3A59] p-6 rounded-md shadow-lg max-w-md w-full mx-4"
                         role="dialog"
                         aria-modal="true">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold text-[#2E3A59]">"Update Profile"</h2>
                            <button
                                type="button"
                                class="text-gray-400 hover:text-gray-600"
                                on:click=close_modal
                                aria-label="Close"
                            >
                                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>

                        <form on:submit=on_submit>
                            // Success message
                            {move || success_message.get().map(|msg| view! {
                                <div class="mb-4 p-2 bg-green-100 text-green-700 rounded">
                                    {msg}
                                </div>
                            })}

                            // Error message
                            {move || error_message.get().map(|msg| view! {
                                <div class="mb-4 p-2 bg-red-100 text-red-700 rounded">
                                    {msg}
                                </div>
                            })}

                            <div class="mb-4">
                                <label for="firstName" class="block text-[#2E3A59] text-sm font-medium mb-1">
                                    "First Name"
                                </label>
                                <input
                                    type="text"
                                    id="firstName"
                                    value={move || first_name.get()}
                                    on:input=move |ev| {
                                        set_first_name(event_target_value(&ev));
                                    }
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59]"
                                />
                            </div>

                            <div class="mb-4">
                                <label for="lastName" class="block text-[#2E3A59] text-sm font-medium mb-1">
                                    "Last Name"
                                </label>
                                <input
                                    type="text"
                                    id="lastName"
                                    value={move || last_name.get()}
                                    on:input=move |ev| {
                                        set_last_name(event_target_value(&ev));
                                    }
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59]"
                                />
                            </div>

                            <div class="mb-4">
                                <label for="phoneNumber" class="block text-[#2E3A59] text-sm font-medium mb-1">
                                    "Phone Number"
                                </label>
                                <input
                                    type="tel"
                                    id="phoneNumber"
                                    value={move || phone_number.get()}
                                    on:input=move |ev| {
                                        set_phone_number(event_target_value(&ev));
                                    }
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59]"
                                />
                            </div>

                            <div class="flex items-center justify-between mt-6">
                                <button
                                    type="submit"
                                    class="bg-[#2E3A59] text-white py-2 px-6 rounded-md hover:bg-[#DADADA] transition disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled=move || is_submitting.get()
                                >
                                    {move || if is_submitting.get() { "Updating..." } else { "Update Profile" }}
                                </button>

                                <button
                                    type="button"
                                    on:click=close_modal
                                    class="text-[#2E3A59] hover:underline"
                                >
                                    "Cancel"
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            }
        } else {
            view! { <div> </div> }
        }}
    }
}
use leptos::prelude::*;
pub mod saml_admin;
pub use saml_admin::*;

pub mod saml_admin_content;
pub use saml_admin_content::*;
use crate::app::components::admin::saml_admin_content::SamlAdminContent;
use crate::app::components::settings::bulk_enrollment_modal::BulkUploadModal;
use crate::app::middleware::global_settings::{try_use_settings, try_use_settings_loading};
use crate::app::models::global::{GlobalSetting, SettingsCache};
use crate::app::models::setting_data::UserSettings;
use crate::app::models::user::SessionUser;
use crate::app::models::user::UserRole;
use crate::app::server_functions::globals::{
    get_global_settings, restore_student_ids_from_file, toggle_student_protection,
};
use crate::app::server_functions::user_settings::{
    get_user_settings, update_dark_mode, update_pinned_sidebar,
};
use leptos::prelude::*;
use leptos::prelude::*;
#[cfg(feature = "hydrate")]
use {
    wasm_bindgen::closure::Closure,
    wasm_bindgen::JsCast,
    web_sys::{Event, FileList, HtmlInputElement},
};

#[component]
pub fn SettingsModal(
    #[prop(into)] show: ReadSignal<bool>,
    #[prop(into)] on_close: Callback<()>,
    #[prop(into)] user_id: i64,
) -> impl IntoView {
    let (selected_tab, set_selected_tab) = signal("General".to_string());

    // Load user settings
    let user_settings_resource = Resource::new(
        move || user_id,
        |user_id| async move { get_user_settings(user_id).await },
    );

    view! {
        <Show when=move || show.get()>
            // Modal Backdrop
            <div class="fixed inset-0 bg-black bg-opacity-60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                // Modal Container
                <div class="bg-gray-800 rounded-lg shadow-2xl w-full max-w-5xl h-5/6 flex overflow-hidden border border-gray-700">

                    // Sidebar
                    <div class="w-64 bg-gray-900 border-r border-gray-700 flex flex-col">
                        // Header
                        <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                            <h2 class="text-lg font-semibold text-gray-100">"Settings"</h2>
                            <button
                                class="text-gray-400 hover:text-gray-200 text-xl leading-none"
                                on:click=move |_| on_close.call(())
                            >
                                "Ã—"
                            </button>
                        </div>

                        // Navigation
                        <div class="flex-1 overflow-y-auto">
                            <div class="p-2">
                                // Core Category
                                <div class="mb-4">
                                    <div class="text-xs uppercase text-gray-500 font-semibold mb-2 px-2">"Core (beta)"</div>
                                    <nav class="space-y-1">
                                        <SettingsNavButton
                                            label="General"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="Editor"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="Files & Links"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="Appearance"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                    </nav>
                                </div>

                                // Plugins Category
                                <div class="mb-4">
                                    <div class="text-xs uppercase text-gray-500 font-semibold mb-2 px-2">"Admin Settings (beta)"</div>
                                    <nav class="space-y-1">
                                        <SettingsNavButton
                                            label="School-wide Settings"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="Promote Students"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="SAML Configuration"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                    </nav>
                                </div>

                                // Advanced Category
                                <div>
                                    <div class="text-xs uppercase text-gray-500 font-semibold mb-2 px-2">"Advanced (beta)"</div>
                                    <nav class="space-y-1">
                                        <SettingsNavButton
                                            label="Hotkeys"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="Developer Settings"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                        <SettingsNavButton
                                            label="About"
                                            selected=selected_tab
                                            on_select=set_selected_tab
                                        />
                                    </nav>
                                </div>
                            </div>
                        </div>
                    </div>

                    // Main Content Area
                    <div class="flex-1 flex flex-col">
                        // Content Header
                        <div class="p-6 border-b border-gray-700">
                            <h3 class="text-xl font-semibold text-gray-100">{move || selected_tab.get()}</h3>
                        </div>

                        // Content Body
                        <div class="flex-1 p-6 overflow-y-auto">
                            <Suspense fallback=move || view! {
                                <div class="flex items-center justify-center h-32">
                                    <div class="text-gray-400">"Loading settings..."</div>
                                </div>
                            }>
                                {move || {
                                    user_settings_resource.get().map(|settings_result| {
                                        match settings_result {
                                            Ok(settings) => view! {
                                                <SettingsContent
                                                    selected_tab=selected_tab
                                                    user_settings=settings
                                                    user_id=user_id
                                                />
                                            }.into_any(),
                                            Err(_) => view! {
                                                <div class="text-red-400">"Error loading settings"</div>
                                            }.into_any()
                                        }
                                    })
                                }}
                            </Suspense>
                        </div>
                    </div>
                </div>
            </div>
        </Show>
    }
}

#[component]
fn SettingsNavButton(
    #[prop(into)] label: String,
    selected: ReadSignal<String>,
    on_select: WriteSignal<String>,
) -> impl IntoView {
    let label_clone = label.clone();
    let is_selected = move || selected.get() == label_clone;

    view! {
        <button
            class=move || format!(
                "w-full text-left px-3 py-2 rounded text-sm transition-colors {}",
                if is_selected() {
                    "bg-gray-800 text-white"
                } else {
                    "text-gray-300 hover:bg-gray-800 hover:text-white"
                }
            )
            on:click={
                let label = label.clone();
                move |_| on_select.set(label.clone())
            }
        >
            {label}
        </button>
    }
}

#[component]
fn SettingsContent(
    selected_tab: ReadSignal<String>,
    user_settings: UserSettings,
    user_id: i64,
) -> impl IntoView {
    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");
    let (show_bulk_upload_modal, set_show_bulk_upload_modal) = signal(false);
    let (refresh_trigger, set_refresh_trigger) = signal(0);

    // Create reactive signals for settings that sync with server
    let (dark_mode, set_dark_mode) = signal(user_settings.ui.dark_mode);
    let (pin_sidebar, set_pin_sidebar) = signal(user_settings.ui.pinned_sidebar);

    // Server actions for updating settings
    let update_dark_mode_action = Action::new(move |&new_value: &bool| async move {
        match update_dark_mode(user_id, new_value).await {
            Ok(_) => {
                set_dark_mode.set(new_value);
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to update dark mode: {}", e);
                Err(e)
            }
        }
    });

    let update_pin_sidebar_action = Action::new(move |&new_value: &bool| async move {
        match update_pinned_sidebar(user_id, new_value).await {
            Ok(_) => {
                set_pin_sidebar.set(new_value);
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to update pinned sidebar: {}", e);
                Err(e)
            }
        }
    });

    view! {
        <div class="space-y-6">
            {move || match selected_tab.get().as_str() {
                "General" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Language">
                            <SettingsButton label="English" />
                            <SettingsButton label="EspaÃ±ol" />
                            <SettingsButton label="FranÃ§ais" />
                        </SettingsSection>
                        <SettingsSection title="Startup">
                            <SettingsButton label="Open last vault" />
                            <SettingsButton label="Show welcome screen" />
                        </SettingsSection>
                        <SettingsSection title="Preferences">
                            <ToggleSwitch
                                label="Permanently pin sidebar"
                                checked=pin_sidebar
                                on_toggle=Callback::new(move |value| {
                                    update_pin_sidebar_action.dispatch(value);
                                })
                                description="Keep the sidebar closed always until setting turned off"
                            />
                        </SettingsSection>
                    </div>
                }.into_any(),

                "Editor" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Display">
                            <SettingsButton label="Show line numbers" />
                            <SettingsButton label="Word wrap" />
                            <SettingsButton label="Show frontmatter" />
                        </SettingsSection>
                        <SettingsSection title="Behavior">
                            <SettingsButton label="Auto-save" />
                            <SettingsButton label="Vim key bindings" />
                        </SettingsSection>
                    </div>
                }.into_any(),

                "Files & Links" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Files">
                            <SettingsButton label="Confirm file deletion" />
                            <SettingsButton label="Always update internal links" />
                            <SettingsButton label="Use [[Wikilinks]]" />
                        </SettingsSection>
                        <SettingsSection title="Attachments">
                            <SettingsButton label="Attachment folder path" />
                            <SettingsButton label="Automatically update internal links" />
                        </SettingsSection>
                    </div>
                }.into_any(),

                "Appearance" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Theme">
                            <ToggleSwitch
                                label="Dark mode"
                                checked=dark_mode
                                on_toggle=Callback::new(move |value| {
                                    update_dark_mode_action.dispatch(value);
                                })
                                description="Toggle dark mode theme"
                            />
                            <SettingsButton label="Light mode" />
                            <SettingsButton label="System default" />
                        </SettingsSection>
                        <SettingsSection title="Interface">
                            <SettingsButton label="Show tab bar" />
                            <SettingsButton label="Show status bar" />
                        </SettingsSection>
                    </div>
                }.into_any(),

                "Promote Students" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Promote Students">
                            <button
                                on:click=move |_| set_show_bulk_upload_modal(true)
                            >
                                <SettingsButton label="Promote students in bulk" />
                            </button>
                            <SettingsButton label="Promote students manually" navigate=true />
                        </SettingsSection>

                        <Show when=move || show_bulk_upload_modal()>
                            <BulkUploadModal
                                set_show_modal=set_show_bulk_upload_modal
                                set_refresh_trigger=set_refresh_trigger
                            />
                        </Show>
                    </div>
                }.into_any(),

                "Developer Settings" => view! {
                    <div class="space-y-4">
                        <SettingsSection title="Developer Settings">
                            <Show when=move || user.get().map(|u| u.is_super_admin()).unwrap_or(false)>
                                <StudentProtectionToggleSafe />
                            </Show>
                        </SettingsSection>
                    </div>
                }.into_any(),

                "SAML Configuration" => view! {
                    <div class="space-y-4">
                        <Show when=move || user.get().map(|u| matches!(u.role, UserRole::Admin | UserRole::SuperAdmin)).unwrap_or(false)>
                            <SamlAdminContent user_id=user_id />
                        </Show>
                        <Show when=move || !user.get().map(|u| matches!(u.role, UserRole::Admin | UserRole::SuperAdmin)).unwrap_or(false)>
                            <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                                "You do not have permission to view SAML settings."
                            </div>
                        </Show>
                    </div>
                }.into_any(),

                _ => view! {
                    <div class="space-y-4">
                        <SettingsSection title=&selected_tab.get()>
                            <SettingsButton label="Option 1" />
                            <SettingsButton label="Option 2" />
                            <SettingsButton label="Option 3" />
                        </SettingsSection>
                    </div>
                }.into_any(),
            }}
        </div>
    }
}

#[component]
fn SettingsSection(#[prop(into)] title: String, children: Children) -> impl IntoView {
    view! {
        <div class="space-y-3">
            <h4 class="text-sm font-medium text-gray-300 uppercase tracking-wide">{title}</h4>
            <div class="space-y-2">
                {children()}
            </div>
        </div>
    }
}

#[component]
fn SettingsButton(
    #[prop(into)] label: String,
    #[prop(into, optional)] navigate: bool,
) -> impl IntoView {
    view! {
        <button class="w-full flex items-center justify-between px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded border border-gray-600 hover:border-gray-500 transition-colors text-gray-200 hover:text-white">
            <span>{label}</span>
            {if navigate {
                view! {
                    <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                }.into_any()
            } else {
                view! {}.into_any()
            }}
        </button>
    }
}

#[component]
fn ToggleSwitch(
    #[prop(into)] label: String,
    #[prop(into)] checked: ReadSignal<bool>,
    #[prop(into)] on_toggle: Callback<bool>,
    #[prop(into, optional)] description: Option<String>,
) -> impl IntoView {
    view! {
        <div class="flex items-center justify-between py-3 px-4 bg-gray-700 hover:bg-gray-600 rounded border border-gray-600 hover:border-gray-500 transition-colors">
            <div class="flex-1">
                <div class="text-gray-200 font-medium">{label}</div>
                {description.map(|desc| view! {
                    <div class="text-sm text-gray-400 mt-1">{desc}</div>
                })}
            </div>

            <button
                class=move || format!(
                    "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-700 {}", if checked.get() { "bg-blue-600" } else { "bg-gray-500"}
                )
                on:click=move |_| on_toggle.call(!checked.get())
            >
                <span
                    class=move || format!(
                        "inline-block h-4 w-4 transform rounded-full bg-white transition {}",
                        if checked.get() {"translate-x-6"} else {"translate-x-1"}
                    )
                />
            </button>
        </div>
    }
}

#[component]
fn StudentProtectionToggleInner(settings: ReadSignal<SettingsCache>) -> impl IntoView {
    let (show_key_modal, set_show_key_modal) = signal(false);
    let (show_file_modal, set_show_file_modal) = signal(false); // NEW
    let (mapping_key, set_mapping_key) = signal(String::new());
    let (selected_file, set_selected_file) = signal(Option::<String>::None); // NEW
    let (is_processing, set_is_processing) = signal(false);
    let (status_message, set_status_message) = signal(Option::<String>::None);

    // Create a local signal to track the toggle state that can be updated
    let (protection_enabled, set_protection_enabled) = signal(settings.get().student_protections);

    // Update local state when settings change
    Effect::new(move |_| {
        set_protection_enabled.set(settings.get().student_protections);
    });

    let toggle_protection_action = Action::new(move |(enable, key): &(bool, Option<String>)| {
        let enable = *enable;
        let key = key.clone();
        async move {
            set_is_processing.set(true);
            set_status_message.set(None);

            match toggle_student_protection(enable, key).await {
                Ok(message) => {
                    set_status_message.set(Some(message.clone()));
                    set_protection_enabled.set(enable);

                    if !enable && message.contains("mapping") {
                        set_status_message.set(Some(format!("{}\n\nPlease check your downloads folder or server logs for the mapping file location.", message)));
                    }
                }
                Err(e) => {
                    set_status_message.set(Some(format!("Error: {}", e)));
                }
            }

            set_is_processing.set(false);
            set_show_key_modal.set(false);
            set_mapping_key.set(String::new());
        }
    });

    // NEW: File upload action
    let restore_from_file_action = Action::new(move |file_content: &String| {
        let file_content = file_content.clone();
        async move {
            set_is_processing.set(true);
            set_status_message.set(None);

            match restore_student_ids_from_file(file_content).await {
                Ok(message) => {
                    set_status_message.set(Some(message));
                    set_protection_enabled.set(false);
                }
                Err(e) => {
                    set_status_message.set(Some(format!("Error: {}", e)));
                }
            }

            set_is_processing.set(false);
            set_show_file_modal.set(false);
            set_selected_file.set(None);
        }
    });

    // File change handler with better error handling
    #[cfg(feature = "hydrate")]
    let handle_file_change = move |event: Event| {
        let input = event
            .target()
            .unwrap()
            .dyn_into::<HtmlInputElement>()
            .unwrap();

        if let Some(files) = input.files() {
            if files.length() > 0 {
                if let Some(file) = files.get(0) {
                    let file_name = file.name();

                    // Validate file type
                    if !file_name.ends_with(".csv") {
                        set_status_message.set(Some("Error: Please select a CSV file".to_string()));
                        return;
                    }

                    set_selected_file.set(Some(file_name.clone()));
                    set_status_message.set(Some(format!("Selected file: {}", file_name)));

                    // Read file content
                    let file_reader = web_sys::FileReader::new().unwrap();
                    let reader_clone = file_reader.clone();

                    let onload = Closure::wrap(Box::new(move |_: Event| {
                        if let Ok(content) = reader_clone.result() {
                            if let Some(text) = content.as_string() {
                                // Validate CSV content has expected headers
                                let lines: Vec<&str> = text.lines().collect();
                                if lines.is_empty() {
                                    set_status_message
                                        .set(Some("Error: CSV file is empty".to_string()));
                                    return;
                                }

                                let header = lines[0].to_lowercase();
                                if !header.contains("app_id") || !header.contains("student_id") {
                                    set_status_message.set(Some("Error: CSV file must contain 'app_id' and 'student_id' columns".to_string()));
                                    return;
                                }

                                if lines.len() < 2 {
                                    set_status_message.set(Some(
                                        "Error: CSV file contains no data rows".to_string(),
                                    ));
                                    return;
                                }

                                set_status_message.set(Some(format!(
                                    "File validated. Found {} data rows. Ready to restore.",
                                    lines.len() - 1
                                )));
                                restore_from_file_action.dispatch(text);
                            }
                        }
                    }) as Box<dyn FnMut(_)>);

                    file_reader.set_onload(Some(onload.as_ref().unchecked_ref()));
                    onload.forget();

                    let onerror = Closure::wrap(Box::new(move |_: Event| {
                        set_status_message.set(Some("Error: Failed to read file".to_string()));
                    }) as Box<dyn FnMut(_)>);

                    file_reader.set_onerror(Some(onerror.as_ref().unchecked_ref()));
                    onerror.forget();

                    let _ = file_reader.read_as_text(&file);
                }
            }
        }
    };

    let handle_toggle = move |enable: bool| {
        if enable {
            toggle_protection_action.dispatch((true, None));
        } else {
            set_show_key_modal.set(true);
        }
    };

    view! {
        <div class="space-y-4">
            <div class="p-4 bg-red-900 border border-red-700 rounded-lg">
                <div class="flex items-start space-x-3">
                    <svg class="w-6 h-6 text-red-400 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.728-.833-2.498 0L3.316 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                    </svg>
                    <div>
                        <h3 class="text-lg font-medium text-red-200">"DANGER ZONE"</h3>
                        <p class="text-sm text-red-300 mt-1">
                            "Student Data Protection Mode will replace all student IDs with anonymized app IDs. This operation affects the entire database and requires a mapping key to restore."
                        </p>
                    </div>
                </div>
            </div>

            <ToggleSwitch
                label="Student Data Protection Mode"
                checked=protection_enabled
                on_toggle=Callback::new(move |value| {
                    handle_toggle(value);
                })
                description="When enabled, replaces student IDs with anonymized app IDs"
            />

            // NEW: File upload button (only show when protection is enabled)
            <Show when=move || protection_enabled.get()>
                <div class="p-4 bg-blue-900 border border-blue-700 rounded-lg">
                    <h4 class="text-blue-200 font-medium mb-2">"Restore from Mapping File"</h4>
                    <p class="text-sm text-blue-300 mb-3">
                        "Upload the CSV mapping file that was exported when protection was enabled to restore original student IDs."
                    </p>
                    <button
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded text-white transition-colors"
                        on:click=move |_| set_show_file_modal.set(true)
                    >
                        "Upload Mapping File"
                    </button>
                </div>
            </Show>

            <Show when=move || status_message.get().is_some()>
                <div class=move || {
                    let msg = status_message.get().unwrap_or_default();
                    if msg.starts_with("Error:") {
                        "p-3 bg-red-900 border border-red-700 rounded text-red-200 text-sm whitespace-pre-line"
                    } else {
                        "p-3 bg-green-900 border border-green-700 rounded text-green-200 text-sm whitespace-pre-line"
                    }
                }>
                    {move || status_message.get().unwrap_or_default()}
                </div>
            </Show>

            <Show when=move || is_processing.get()>
                <div class="p-3 bg-blue-900 border border-blue-700 rounded text-blue-200 text-sm">
                    "Processing... This may take a few moments."
                </div>
            </Show>

            <Show when=move || show_file_modal.get()>
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 max-w-md w-full mx-4">
                        <h3 class="text-lg font-semibold text-gray-100 mb-4">
                            "Upload Mapping File"
                        </h3>
                        <p class="text-sm text-gray-300 mb-4">
                            "Select the CSV file that was exported when student protection was enabled (student_id_mapping.csv)."
                        </p>

                        <div class="mb-4">
                            {
                                #[cfg(feature = "hydrate")]
                                {
                                    view! {
                                        <input
                                            type="file"
                                            accept=".csv"
                                            class="hidden"
                                            id="mapping-file-input"
                                            on:change=handle_file_change
                                        />
                                    }
                                }
                            }
                            <label
                                for="mapping-file-input"
                                class="block w-full p-3 border-2 border-dashed border-gray-600 rounded-lg text-center cursor-pointer hover:border-gray-500 transition-colors"
                            >
                                <svg class="w-8 h-8 text-gray-400 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                <span class="text-gray-300">
                                    {move || selected_file.get().unwrap_or_else(|| "Click to select CSV file".to_string())}
                                </span>
                            </label>
                        </div>

                        <div class="flex justify-end space-x-3">
                            <button
                                class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-gray-100 transition-colors"
                                on:click=move |_| {
                                    set_show_file_modal.set(false);
                                    set_selected_file.set(None);
                                }
                            >
                                "Cancel"
                            </button>
                        </div>
                    </div>
                </div>
            </Show>
        </div>
    }
}

#[component]
fn StudentProtectionToggleSafe() -> impl IntoView {
    // Try to get contexts safely
    let settings_context = try_use_settings();
    let loading_context = try_use_settings_loading();

    // Handle the case where contexts are not available
    match (settings_context, loading_context) {
        (Some((settings, _)), Some(loading)) => view! {
            {move || {
                if loading.get() {
                    view! {
                        <div class="text-gray-400">"Loading protection settings..."</div>
                    }.into_any()
                } else {
                    view! {
                        <StudentProtectionToggleInner settings=settings />
                    }.into_any()
                }
            }}
        }
        .into_any(),
        _ => view! {
            <div class="text-red-400">
                "Settings context not available. Make sure SettingsProvider wraps this component."
            </div>
        }
        .into_any(),
    }
}
use leptos::prelude::*;
use crate::app::server_functions::bulk_enrollment::upload_bulk_enrollment;

use leptos::ev::Event;
use leptos::prelude::*;
use std::sync::mpsc;

#[cfg(feature = "hydrate")]
use {
    js_sys::Array,
    wasm_bindgen::{closure::Closure, JsCast},
    web_sys::{FileList, HtmlInputElement},
};

#[component]
pub fn BulkUploadModal(
    set_show_modal: WriteSignal<bool>,
    set_refresh_trigger: WriteSignal<i32>,
) -> impl IntoView {
    let (upload_status, set_upload_status) = signal(String::new());
    let (is_uploading, set_is_uploading) = signal(false);
    let (imported_count, set_imported_count) = signal(0);

    // Define these signals and handlers for all feature configurations
    let (file_selected, set_file_selected) = signal(false);

    #[cfg(feature = "hydrate")]
    let (file, set_file) = create_signal::<Option<web_sys::File>>(None);

    // Create the event handlers - they need to exist in all configurations
    let on_file_change = {
        #[cfg(feature = "hydrate")]
        {
            move |ev: Event| {
                let target = ev.target();
                let input_element = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());

                if let Some(input) = input_element {
                    let files = input.files();
                    if let Some(files) = files {
                        if files.length() > 0 {
                            if let Some(first_file) = files.item(0) {
                                set_file(Some(first_file));
                                set_file_selected(true);
                            }
                        }
                    }
                }
            }
        }
        #[cfg(not(feature = "hydrate"))]
        {
            move |_ev: Event| {
                // Server-side fallback - just update the UI state
                set_file_selected(true);
            }
        }
    };

    let handle_upload = {
        #[cfg(feature = "hydrate")]
        {
            move |_| {
                set_is_uploading(true);
                set_upload_status(String::new());
                set_imported_count(0);

                if let Some(selected_file) = file() {
                    spawn_local(async move {
                        match upload_file(selected_file).await {
                            Ok(count) => {
                                set_upload_status(format!(
                                    "Successfully imported {} enrollments",
                                    count
                                ));
                                set_imported_count(count);
                                set_refresh_trigger.update(|count| *count += 1);
                                set_is_uploading(false);
                                set_show_modal(false);
                            }
                            Err(e) => {
                                set_upload_status(format!("Upload failed: {}", e));
                                set_is_uploading(false);
                            }
                        }
                    });
                } else {
                    set_upload_status("Please select a file first".to_string());
                    set_is_uploading(false);
                }
            }
        }
    };

    let download_template = {
        #[cfg(feature = "hydrate")]
        {
            move |_| {
                let template_content = include_str!("promotion_demo.csv");
                let blob =
                    web_sys::Blob::new_with_str_sequence(&Array::of1(&template_content.into()))
                        .unwrap_or_else(|_| web_sys::Blob::new().unwrap());

                let url = web_sys::Url::create_object_url_with_blob(&blob).unwrap_or_default();

                if let Some(window) = web_sys::window() {
                    if let Some(document) = window.document() {
                        if let Ok(a) = document.create_element("a") {
                            let _ = a.set_attribute("href", &url);
                            let _ = a.set_attribute("download", "promotion_demo_template.csv");

                            if let Some(html_element) = a.dyn_ref::<web_sys::HtmlElement>() {
                                html_element.click();
                            }
                        }
                    }
                }
            }
        }
    };

    view! {
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-[#F9F9F8] p-6 rounded-lg shadow-xl max-w-md w-full">
                <h3 class="text-xl font-bold mb-4">"Bulk Student Upload"</h3>

                <input
                    type="file"
                    accept=".csv"
                    on:change=on_file_change
                    class="w-full p-2 border rounded mb-4"
                />

                <div class="text-sm text-gray-600 mb-4 flex justify-between items-center">
                    <span>"Expected CSV format with student details (NOTE: column headings and fields are case specific. Capitalization matters.)"</span>

                    // Conditionally render the download button
                    {move || {
                        cfg_if::cfg_if! {
                            if #[cfg(feature = "hydrate")] {
                                view! {
                                    <button
                                        class="text-blue-500 hover:underline"
                                        on:click=download_template
                                    >
                                        "Download Template"
                                    </button>
                                }.into_any()
                            } else {
                                view! {
                                    <span class="text-gray-400">"Download Template (unavailable)"</span>
                                }.into_any()
                            }
                        }
                    }}
                </div>

                {move || {
                    if !upload_status().is_empty() {
                        let status_class = if upload_status().contains("failed") {
                            "text-red-500"
                        } else {
                            "text-green-500"
                        };

                        Some(view! {
                            <div class={format!("mt-2 {}", status_class)}>
                                {upload_status()}
                                {move || if imported_count() > 0 {
                                    format!(" ({} students)", imported_count())
                                } else {
                                    "".to_string()
                                }}
                            </div>
                        })
                    } else {
                        None
                    }
                }}

                <div class="flex justify-end gap-2 mt-4">
                    <button
                        type="button"
                        class="px-4 py-2 text-white bg-[#F44336] rounded hover:bg-[#D32F2F]"
                        on:click=move |_| set_show_modal(false)
                    >
                        "Cancel"
                    </button>

                    // Conditionally render the upload button
                    {move || {
                        cfg_if::cfg_if! {
                            if #[cfg(feature = "hydrate")] {
                                view! {
                                    <button
                                        type="button"
                                        class="px-4 py-2 bg-[#4CAF50] text-white rounded hover:bg-[#388E3C]"
                                        disabled=move || !file_selected() || is_uploading()
                                        on:click=handle_upload
                                    >
                                        {move || if is_uploading() { "Uploading..." } else { "Upload" }}
                                    </button>
                                }.into_any()
                            } else {
                                view! {
                                    <button
                                        type="button"
                                        class="px-4 py-2 bg-gray-400 text-white rounded cursor-not-allowed"
                                        disabled=true
                                    >
                                        "Upload (unavailable)"
                                    </button>
                                }.into_any()
                            }
                        }
                    }}
                </div>
            </div>
        </div>
    }
}

#[cfg(feature = "hydrate")]
async fn upload_file(file: web_sys::File) -> Result<usize, String> {
    // Create a future that resolves when the file is read
    let file_content_future =
        wasm_bindgen_futures::JsFuture::from(js_sys::Promise::new(&mut |resolve, reject| {
            let reader = web_sys::FileReader::new().unwrap();
            let reader_clone = reader.clone();

            let onload_callback = Closure::once(move |_event: web_sys::ProgressEvent| {
                if let Ok(result) = reader_clone.result() {
                    if let Some(text) = result.as_string() {
                        resolve
                            .call1(&wasm_bindgen::JsValue::NULL, &text.into())
                            .unwrap();
                    } else {
                        reject
                            .call1(
                                &wasm_bindgen::JsValue::NULL,
                                &"Failed to get file content as string".into(),
                            )
                            .unwrap();
                    }
                } else {
                    reject
                        .call1(
                            &wasm_bindgen::JsValue::NULL,
                            &"Failed to get file content".into(),
                        )
                        .unwrap();
                }
            });

            reader.set_onload(Some(onload_callback.as_ref().unchecked_ref()));
            let _ = reader.read_as_text(&file);
            onload_callback.forget();
        }))
        .await
        .map_err(|e| format!("Error reading file: {:?}", e))?;

    // Extract the file content as a string
    let file_contents = file_content_future
        .as_string()
        .ok_or_else(|| "Failed to convert file content to string".to_string())?;

    // Call the server function with the file contents
    crate::app::server_functions::bulk_enrollment::upload_bulk_enrollment(file_contents)
        .await
        .map_err(|e| e.to_string())
}
use leptos::prelude::*;
pub mod sequence_progress_bar;
pub use sequence_progress_bar::*;

pub mod overview;
pub use overview::*;

pub mod assessments;
pub use assessments::*;
use leptos::prelude::*;
pub mod bulk_enrollment_modal;
pub mod settings_modal;
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent,
};
use crate::app::components::test_components::test_instructions::TestInstructions;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::question::QuestionType;
use crate::app::models::score::CreateScoreRequest;
use crate::app::models::student::Student;
use crate::app::models::test::Test;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::students::get_students;
use crate::app::server_functions::{
    questions::get_questions, scores::add_score, tests::get_tests, users::get_user,
};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::collections::HashMap;

#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

#[derive(Debug, Clone)]
struct QuestionResponse {
    answer: String,
    comment: String,
}

#[component]
pub fn GridTest() -> impl IntoView {
    // Get test_id from URL parameters
    let params = use_params_map();
    let test_id = move || params.with(|params| params.get("test_id").cloned().unwrap_or_default());
    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");
    let user_resource = LocalResource::new(
        move || user.get().map(|u| u.id),
        move |id| async move {
            match id {
                Some(user_id) => match get_user(user_id).await {
                    Ok(user) => Some(user),
                    Err(e) => {
                        log::error!("Failed to fetch user from database: {}", e);
                        None
                    }
                },
                None => None,
            }
        },
    );
    // Create resource to fetch test details
    let test_details = Resource::new(test_id.clone(), move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return None;
        }
        match get_tests().await {
            Ok(tests) => tests.into_iter().find(|test| test.test_id == tid),
            Err(e) => {
                log::error!("Failed to fetch test details: {}", e);
                None
            }
        }
    });

    // Create resource for questions
    let questions = Resource::new(test_id, move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return Vec::new();
        }
        match get_questions(tid).await {
            Ok(questions) => {
                // Validate all questions are true/false type
                for q in &questions {
                    if q.question_type != QuestionType::TrueFalse {
                        log::error!("GridTest requires all questions to be TrueFalse type. Found question {} with type {:?}", 
                            q.qnumber, q.question_type);
                    }
                }
                questions
            }
            Err(e) => {
                log::error!("Failed to fetch questions: {}", e);
                Vec::new()
            }
        }
    });

    // Store responses for each question
    let (responses, set_responses) = signal(HashMap::<i32, QuestionResponse>::new());
    let (selected_student_id, set_selected_student_id) = signal(None::<i32>);

    // Track if test is submitted
    let (is_submitted, set_is_submitted) = signal(false);

    // Currently selected question for commenting
    let (selected_question, set_selected_question) = signal(None::<i32>);

    // Get evaluator ID
    let evaluator_id = Memo::new(move |_| match user.get() {
        Some(user_data) => user_data.id.to_string(),
        None => "0".to_string(),
    });

    // Handler for toggling answer
    let toggle_answer = move |qnumber: i32| {
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert(QuestionResponse {
                answer: "true".to_string(), // Default to "true" since all cells start as "correct"
                comment: String::new(),
            });
            // Toggle between true and false
            response.answer = if response.answer == "true" {
                "false".to_string()
            } else {
                "true".to_string()
            };
        });

        // Set this question as selected for comments
        set_selected_question.set(Some(qnumber));
    };

    // Handler for updating comment
    let handle_comment_change = move |value: String| {
        if let Some(qnumber) = selected_question.get() {
            set_responses.update(|r| {
                let response = r.entry(qnumber).or_insert(QuestionResponse {
                    answer: "true".to_string(), // Default to "true"
                    comment: String::new(),
                });
                response.comment = value;
            });
        }
    };

    // Submit handler
    let handle_submit = Action::new(move |_: &()| async move {
        let current_responses = responses.get();
        let current_test_id = test_id();

        let student_id = selected_student_id.get().unwrap_or(0);
        let evaluator = evaluator_id();
        let test_variant = 1;

        let mut test_scores = Vec::new();
        let mut comments = Vec::new();

        if let Some(questions) = questions.get() {
            // Sort questions by qnumber to ensure correct order
            let mut sorted_questions = questions.clone();
            sorted_questions.sort_by_key(|q| q.qnumber);

            for question in sorted_questions {
                let response = current_responses
                    .get(&question.qnumber)
                    .cloned()
                    .unwrap_or_else(|| {
                        // Default response is "true" (correct) if not explicitly marked wrong
                        QuestionResponse {
                            answer: "true".to_string(),
                            comment: String::new(),
                        }
                    });

                // Calculate score - "true" means correct (full points), "false" means incorrect (0 points)
                let score = if response.answer == "true" {
                    question.point_value
                } else {
                    0
                };

                test_scores.push(score);
                comments.push(response.comment);
            }
        }

        // Create score request
        let score_request = CreateScoreRequest {
            student_id,
            test_id: current_test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
        };

        // Submit score to server
        match add_score(score_request).await {
            Ok(score) => {
                log::info!(
                    "Successfully submitted score for student {}",
                    score.student_id
                );
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to submit score: {}", e);
                Err(e)
            }
        }
    });

    // Calculate square grid dimensions
    let grid_dimensions = Memo::new(move |_| {
        if let Some(questions_list) = questions.get() {
            let count = questions_list.len();
            if count == 0 {
                return (0, 0);
            }

            // Calculate dimensions for a perfect square grid
            let sqrt = (count as f64).sqrt().ceil() as usize;

            // Make sure grid is square - use same value for rows and columns
            (sqrt, sqrt)
        } else {
            (0, 0)
        }
    });

    // Calculate cell size based on question count
    let cell_size_class = Memo::new(move |_| {
        if let Some(questions_list) = questions.get() {
            let count = questions_list.len();
            // Determine appropriate cell size based on question count
            if count > 100 {
                "text-xs" // Extremely small text for very many questions
            } else if count > 64 {
                "text-sm" // Very small text for many questions
            } else if count > 36 {
                "text-base" // Small text for lots of questions
            } else if count > 16 {
                "text-lg" // Normal text for medium count
            } else if count > 9 {
                "text-xl" // Larger text for few questions
            } else {
                "text-2xl" // Very large text for very few questions
            }
        } else {
            "text-base" // Default size
        }
    });

    // Create a memo for the currently selected question's comment
    let selected_comment = Memo::new(move |_| {
        if let Some(qnumber) = selected_question.get() {
            responses.with(|r| {
                r.get(&qnumber)
                    .map(|resp| resp.comment.clone())
                    .unwrap_or_default()
            })
        } else {
            String::new()
        }
    });

    view! {
        <div class="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50">
            {/* Header with Student Selection and Evaluator - Enhanced styling */}
            <div class="bg-white/80 backdrop-blur-sm border-b border-gray-200/50 shadow-lg sticky top-0 z-10">
                <div class="max-w-7xl mx-auto px-6 py-5">
                    <div class="flex flex-col lg:flex-row items-center justify-between gap-4">
                        <div class="flex-1 w-full lg:w-auto">
                            <StudentSelect set_selected_student_id=set_selected_student_id />
                        </div>

                        <div class="flex items-center gap-3 bg-gradient-to-r from-indigo-50 to-purple-50 px-4 py-2 rounded-full border border-indigo-200/50">
                            <span class="text-sm font-medium text-gray-700">
                                {"Evaluator: "}
                                <span class="text-indigo-600 font-semibold">
                                    {move || match user_resource.get() {
                                        Some(Some(user)) => format!("{} {}", user.first_name.unwrap_or("None".to_string()), user.last_name.unwrap_or("None".to_string())),
                                        Some(None) => evaluator_id(),
                                        None => "Loading...".to_string(),
                                    }}
                                </span>
                            </span>
                        </div>
                    </div>

                    {/* Test Title - Enhanced */}
                    <div class="mt-4 text-center">
                        <h1 class="text-3xl font-bold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
                            {move || match &test_details.get() {
                                Some(Some(test)) => test.name.clone(),
                                _ => test_id()
                            }}
                        </h1>
                        <div class="mt-2 h-1 w-20 bg-gradient-to-r from-indigo-400 to-purple-400 rounded-full mx-auto"></div>
                    </div>

                    {/* Test Instructions */}
                    <Suspense fallback=move || view! { <div></div> }>
                        {move || match test_details.get() {
                            Some(Some(test)) => view! {
                                <div class="max-w-7xl mx-auto px-6 mb-6">
                                    <TestInstructions instructions=test.instructions.clone() />
                                </div>
                            }.into_any(),
                            _ => view! { <div></div> }.into_any()
                        }}
                    </Suspense>
                </div>
            </div>

            {/* Main container - Enhanced layout */}
            <div class="max-w-7xl mx-auto px-6 py-8">
                <Suspense
                    fallback=move || view! {
                        <div class="flex justify-center items-center min-h-[60vh]">
                            <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl p-12 border border-gray-200/50">
                                <div class="flex flex-col items-center gap-4">
                                    <div class="w-12 h-12 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                                    <p class="text-gray-600 font-medium">"Loading assessment..."</p>
                                </div>
                            </div>
                        </div>
                    }
                >
                    {move || match (questions.get(), test_details.get()) {
                        (None, _) => view! {
                            <div class="flex justify-center items-center min-h-[60vh]">
                                <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl p-12 border border-gray-200/50">
                                    <div class="flex flex-col items-center gap-4">
                                        <div class="w-12 h-12 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                                        <p class="text-gray-600 font-medium">"Loading assessment..."</p>
                                    </div>
                                </div>
                            </div>
                        }.into_any(),
                        (Some(questions), _) if questions.is_empty() => {
                            view! {
                                <div class="flex justify-center items-center min-h-[60vh]">
                                    <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl p-12 border border-red-200/50">
                                        <div class="flex flex-col items-center gap-4">
                                            <div class="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center">
                                                <span class="text-red-600 text-2xl">"!"</span>
                                            </div>
                                            <p class="text-red-600 font-medium text-center">"No questions found for this test ID."</p>
                                        </div>
                                    </div>
                                </div>
                            }.into_any()
                        },
                        (Some(questions), _) => {
                            // Check if all questions are TrueFalse type
                            let has_invalid_questions = questions.iter().any(|q| q.question_type != QuestionType::TrueFalse);

                            if has_invalid_questions {
                                view! {
                                    <div class="flex justify-center items-center min-h-[60vh]">
                                        <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl p-12 border border-red-200/50">
                                            <div class="flex flex-col items-center gap-4">
                                                <div class="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center">
                                                    <span class="text-red-600 text-2xl">"âš "</span>
                                                </div>
                                                <p class="text-red-600 font-medium text-center max-w-md">
                                                    "Error: This test contains questions that are not True/False type. GridTest requires all questions to be True/False."
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                }.into_any()
                            } else {
                                let (rows, cols) = grid_dimensions();
                                let questions_clone = questions.clone();
                                let questions_count = questions.len();
                                let sorted_questions = Memo::new(move |_| {
                                    let mut sorted = questions_clone.clone();
                                    sorted.sort_by_key(|q| q.qnumber);
                                    sorted
                                });

                                let current_cell_size = cell_size_class();

                                view! {
                                    <div class="grid grid-cols-1 xl:grid-cols-3 gap-8 items-start">
                                        {/* Grid container - Enhanced design */}
                                        <div class="xl:col-span-2 h-full">
                                            <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-gray-200/50 p-6">
                                                <div class="flex items-center gap-3 mb-6">
                                                    <h2 class="text-xl font-semibold text-gray-800">"Assessment Grid"</h2>
                                                    <div class="flex-1 h-px bg-gradient-to-r from-gray-200 to-transparent"></div>
                                                    <span class="text-sm text-gray-500 bg-gray-100 px-3 py-1 rounded-full">
                                                        {format!("{} questions", questions_count)}
                                                    </span>
                                                </div>

                                                <div class="relative">
                                                    <div
                                                        class="grid w-full"
                                                        style=move || format!(
                                                            "grid-template-columns: repeat({}, minmax(0, 1fr)); grid-template-rows: repeat({}, minmax(0, 1fr)); gap: 3px; background-color: #f8fafc;",
                                                            cols, rows
                                                        )
                                                    >
                                                        {move || {
                                                            sorted_questions().into_iter().map(|question| {
                                                                let qnumber = question.qnumber;
                                                                let display_text = question.word_problem.clone();

                                                                let is_correct = Memo::new(move |_| {
                                                                    responses.with(|r| {
                                                                        r.get(&qnumber)
                                                                         .map(|resp| resp.answer == "true")
                                                                         .unwrap_or(true) // Default to true if not explicitly marked
                                                                    })
                                                                });

                                                                let is_selected = Memo::new(move |_| {
                                                                    selected_question.get() == Some(qnumber)
                                                                });

                                                                let has_comment = Memo::new(move |_| {
                                                                    responses.with(|r| {
                                                                        r.get(&qnumber)
                                                                         .map(|resp| !resp.comment.is_empty())
                                                                         .unwrap_or(false)
                                                                    })
                                                                });

                                                                view! {
                                                                    <div
                                                                        class="relative flex items-center justify-center cursor-pointer transition-all duration-200 rounded-lg min-h-[50px] group hover:shadow-md border-2"
                                                                        class=bg-gradient-to-br=move || is_correct()
                                                                        class=from-emerald-50=move || is_correct()
                                                                        class=to-green-100=move || is_correct()
                                                                        class=ring-3=move || is_selected()
                                                                        class=ring-indigo-400=move || is_selected()
                                                                        class=shadow-lg=move || is_selected()
                                                                        class=scale-105=move || is_selected()
                                                                        class=border-green-300=move || is_correct()
                                                                        class=border-red-400=move || !is_correct()
                                                                        class=bg-red-300=move || !is_correct()
                                                                        on:click=move |_| toggle_answer(qnumber)
                                                                    >
                                                                        <span class=format!("select-none font-bold text-gray-700 px-2 py-2 text-center {} group-hover:scale-110 transition-transform", current_cell_size)
                                                                    //class=text-white=move || !is_correct()
                                                                    class=text-gray-700=move || is_correct()
                                                                    >
                                                                            {display_text}
                                                                        </span>

                                                                        {/* Comment indicator */}
                                                                        {move || if has_comment() {
                                                                            view! {
                                                                                <div class="absolute -bottom-1 -right-1 w-4 h-4 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-full flex items-center justify-center shadow-sm">
                                                                                    <span class="text-xs">"ðŸ’¬"</span>
                                                                                </div>
                                                                            }.into_any()
                                                                        } else {
                                                                            view! { <div></div> }.into_any()
                                                                        }}
                                                                    </div>
                                                                }
                                                            }).collect_view()
                                                        }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Comments and Submit section - Enhanced sidebar */}
                                        <div class="space-y-6">
                                            {/* Comments section */}
                                            <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-gray-200/50 p-6">
                                                <div class="flex items-center gap-3 mb-4">
                                                    <div class="w-3 h-3 bg-gradient-to-r from-purple-400 to-pink-400 rounded-full"></div>
                                                    <h3 class="text-lg font-semibold text-gray-800">"Comments"</h3>
                                                </div>

                                                {move || match selected_question.get() {
                                                    Some(qnumber) => {
                                                        let question_text = sorted_questions().iter()
                                                            .find(|q| q.qnumber == qnumber)
                                                            .map(|q| q.word_problem.clone())
                                                            .unwrap_or_default();

                                                        view! {
                                                            <div class="space-y-4">
                                                                <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-xl border border-indigo-200/50">
                                                                    <div class="flex items-center gap-2 mb-2">
                                                                        <span class="text-lg font-bold text-indigo-600">
                                                                            {question_text.clone()}
                                                                        </span>
                                                                    </div>
                                                                    <p class="text-sm text-gray-600">"Selected for commenting"</p>
                                                                </div>

                                                                <div>
                                                                    <label class="block text-sm font-medium text-gray-700 mb-2">
                                                                        "Add your comments:"
                                                                    </label>
                                                                    <textarea
                                                                        class="w-full p-4 border border-gray-200 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-200 resize-none bg-white/80 backdrop-blur-sm"
                                                                        prop:value=move || selected_comment()
                                                                        on:input=move |ev| {
                                                                            let value = event_target_value(&ev);
                                                                            handle_comment_change(value);
                                                                        }
                                                                        placeholder="Add any comments, notes, or feedback here..."
                                                                        rows="4"
                                                                    ></textarea>
                                                                </div>
                                                            </div>
                                                        }.into_any()
                                                    },
                                                    None => view! {
                                                        <div class="text-center py-8">
                                                            <div class="w-16 h-16 bg-gradient-to-br from-gray-100 to-gray-200 rounded-full flex items-center justify-center mx-auto mb-4">
                                                                <span class="text-gray-400 text-2xl">"ðŸ’­"</span>
                                                            </div>
                                                            <p class="text-gray-500 text-sm">
                                                                "Click any grid cell to select it and add comments"
                                                            </p>
                                                        </div>
                                                    }.into_any()
                                                }}
                                            </div>

                                            {/* Submit section */}
                                            <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-gray-200/50 p-6">
                                                <div class="flex items-center gap-3 mb-4">
                                                    <h3 class="text-lg font-semibold text-gray-800">"Submit Assessment"</h3>
                                                </div>

                                                {move || if !is_submitted.get() {
                                                    view! {
                                                        <div class="space-y-4">

                                                            <button
                                                                class="w-full flex items-center justify-center gap-3 px-6 py-4 bg-gradient-to-r from-indigo-600 via-purple-600 to-indigo-700 text-white rounded-xl shadow-lg hover:shadow-xl transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none transform hover:scale-105 active:scale-95"
                                                                on:click=move |_| {
                                                                    handle_submit.dispatch(());
                                                                    set_is_submitted.set(true);
                                                                }
                                                                disabled=move || selected_student_id.get().is_none()
                                                            >
                                                                <span class="font-semibold">"Submit Assessment"</span>
                                                                <span class="text-lg">"âœ“"</span>
                                                            </button>

                                                            {move || if selected_student_id.get().is_none() {
                                                                view! {
                                                                    <p class="text-xs text-amber-600 text-center bg-amber-50 px-3 py-2 rounded-lg border border-amber-200">
                                                                        "Please select a student before submitting"
                                                                    </p>
                                                                }.into_any()
                                                            } else {
                                                                view! { <div></div> }.into_any()
                                                            }}
                                                        </div>
                                                    }.into_any()
                                                } else {
                                                    view! {
                                                        <div class="text-center space-y-4">
                                                            <div class="w-20 h-20 bg-gradient-to-br from-green-400 to-emerald-500 rounded-full flex items-center justify-center mx-auto shadow-lg">
                                                                <span class="text-white text-3xl">"âœ“"</span>
                                                            </div>

                                                            <div class="space-y-2">
                                                                <h4 class="text-lg font-semibold text-gray-800">
                                                                    "Assessment Submitted!"
                                                                </h4>
                                                                <p class="text-sm text-gray-600">
                                                                    "Your assessment has been successfully submitted and saved."
                                                                </p>
                                                            </div>

                                                            <button
                                                                class="w-full flex items-center justify-center gap-3 px-6 py-4 bg-gradient-to-r from-gray-700 to-gray-800 text-white rounded-xl shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-105 active:scale-95"
                                                                on:click=move |_| {
                                                                    let navigate= use_navigate();
                                                                    navigate("/dashboard", Default::default());
                                                                }
                                                            >
                                                                <span class="text-lg">"ðŸ "</span>
                                                                <span class="font-semibold">"Return to Dashboard"</span>
                                                            </button>
                                                        </div>
                                                    }.into_any()
                                                }}
                                            </div>
                                        </div>
                                    </div>
                                }.into_any()
                            }
                        }
                    }}
                </Suspense>
            </div>
        </div>
    }
}

// StudentSelect component with improved styling from FlashCardSet
#[component]
pub fn StudentSelect(set_selected_student_id: WriteSignal<Option<i32>>) -> impl IntoView {
    // Extract information in the event student is anonymized
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    // Get mapping service for de-anonymization
    let (student_mapping_service, _) = use_student_mapping_service();

    // Fetch students from server
    let get_students_action = Action::new(|_: &()| async move {
        match get_students().await {
            Ok(fetched_students) => fetched_students,
            Err(e) => {
                log::error!("Failed to fetch students: {}", e);
                Vec::new()
            }
        }
    });

    // Create enhanced student data with de-anonymization info
    let enhanced_students = Memo::new(move |_| {
        let students_data = get_students_action
            .value()
            .get()
            .as_ref()
            .cloned()
            .unwrap_or_default();

        if anonymization_enabled() {
            let mapping_service = student_mapping_service.get();
            students_data
                .into_iter()
                .map(|student| {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &student,
                        mapping_service.as_ref(),
                    );
                    (student, Some(de_anon))
                })
                .collect::<Vec<_>>()
        } else {
            students_data
                .into_iter()
                .map(|student| (student, None))
                .collect::<Vec<_>>()
        }
    });

    // Dispatch action only once on component mount
    Effect::new(move |_| {
        get_students_action.dispatch(());
    });

    view! {
        <div class="mb-2 max-w-[20rem]">
            <label class="block text-sm font-medium mb-1">"Select Student:"</label>
            <select
                class="w-full p-2 border rounded-md"
                on:change=move |ev| {
                    let value = event_target_value(&ev).parse().ok();
                    set_selected_student_id.set(value);
                }
            >
                <option value="">"Select a student..."</option>
                <Suspense fallback=move || view! {
                    <option>"Loading students..."</option>
                }>
                    {move || {
                        enhanced_students().into_iter().map(|(student, de_anon_opt)| {
                            // Determine display values based on anonymization status
                            let display_text = if let Some(de_anon) = &de_anon_opt {
                                // Use de-anonymized display name and ID
                                format!("{} - {}", de_anon.display_name, de_anon.display_id)
                            } else {
                                // Use original student data
                                format!(
                                    "{} {} - {}",
                                    student.firstname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.lastname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.student_id
                                )
                            };

                            view! {
                                <option value={student.student_id.to_string()}>
                                    {display_text}
                                </option>
                            }
                        }).collect_view()
                    }}
                </Suspense>
            </select>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::flash_cards::*;
use crate::app::models::score::CreateScoreRequest;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::{
    questions::get_questions, scores::add_score, tests::get_tests, users::get_user,
};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use log;
use std::collections::HashMap;

#[component]
pub fn FlashCardSet() -> impl IntoView {
    // Get test_id from URL parameters
    let params = use_params_map();
    let test_id = move || params.with(|params| params.get("test_id").cloned().unwrap_or_default());
    let user = context::expect_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");

    // Create resource to fetch test details
    let test_details = Resource::new(test_id.clone(), move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return None;
        }
        match get_tests().await {
            Ok(tests) => tests.into_iter().find(|test| test.test_id == tid),
            Err(e) => {
                log::error!("Failed to fetch test details: {}", e);
                None
            }
        }
    });

    // Create resource that depends on the test_id from URL
    let questions = Resource::new(test_id, move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return Vec::new();
        }
        match get_questions(tid).await {
            Ok(mut questions) => {
                // Sort questions by qnumber to ensure consistent ordering
                questions.sort_by_key(|q| q.qnumber);
                questions
            }
            Err(e) => {
                log::error!("Failed to fetch questions: {}", e);
                Vec::new()
            }
        }
    });

    // Get evaluator ID
    let evaluator_id = Memo::new(move |_| match user.get() {
        Some(user_data) => user_data.id.to_string(),
        None => "0".to_string(),
    });

    // Create submission action using the helper
    let submission_action = create_submission_action(
        Signal::derive(test_id),
        Signal::derive(move || questions.get()),
        Signal::derive(evaluator_id),
    );

    view! {
        <Suspense
            fallback=move || view! {
                <div class="flex items-center justify-center h-96">
                    <div class="flex flex-col items-center gap-4">
                        <div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                        <p class="text-gray-500 text-sm">"Loading questions..."</p>
                    </div>
                </div>
            }
        >
            {move || match (questions.get(), test_details.get()) {
                (None, _) => view! {
                    <div class="flex items-center justify-center h-96">
                        <div class="text-center">
                            <div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                            <p class="text-gray-500">"Loading..."</p>
                        </div>
                    </div>
                }.into_any(),
                (Some(questions_vec), _) if questions_vec.is_empty() => {
                    view! {
                        <div class="flex items-center justify-center h-96">
                            <div class="text-center">
                                <div class="w-16 h-16 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4">
                                    <svg class="w-8 h-8 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z"></path>
                                    </svg>
                                </div>
                                <p class="text-gray-500">"No questions found for this test."</p>
                            </div>
                        </div>
                    }.into_any()
                },
                (Some(questions_vec), test_data) => {
                    view! {
                        <FlashCardContainer
                            questions=questions_vec
                            test_details=test_data.flatten()
                            user=user.get()
                            on_submit=Callback::new(move |data| {
                                submission_action.dispatch(data);
                            })
                        />
                    }.into_any()
                }
            }}
        </Suspense>
    }
}
use crate::app::components::auth::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent,
};
use crate::app::components::test_components::font_controls::{
    use_font_settings, FontControls, FontSettings,
};
use crate::app::components::test_components::test_instructions::TestInstructions;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::question::QuestionType;
use crate::app::models::score::CreateScoreRequest;
use crate::app::models::student::Student;
use crate::app::models::test::Test;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::students::get_students;
use crate::app::server_functions::{
    questions::get_questions, scores::add_score, tests::get_tests, users::get_user,
};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::collections::HashMap;

#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

#[derive(Debug, Clone)]
struct QuestionResponse {
    answer: String,
    comment: String,
    selected_options: Option<Vec<String>>,
}
impl QuestionResponse {
    fn new() -> Self {
        Self {
            answer: String::new(),
            comment: String::new(),
            selected_options: None,
        }
    }
}

#[component]
pub fn FlashCardSet() -> impl IntoView {
    // Get test_id from URL parameters
    let params = use_params_map();
    let test_id = move || params.with(|params| params.get("test_id").cloned().unwrap_or_default());
    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not Found");
    let (font_settings, set_font_settings) = use_font_settings();

    // Add state for collapsible sections
    let (shortcuts_expanded, set_shortcuts_expanded) = signal(false);
    let (instructions_expanded, set_instructions_expanded) = signal(false);

    let user_data = Resource::new(
        move || user.get().map(|u| u.id),
        move |id| async move {
            match id {
                Some(user_id) => match get_user(user_id).await {
                    Ok(user) => Some(user),
                    Err(e) => {
                        log::error!("Failed to fetch user data: {}", e);
                        None
                    }
                },
                None => None,
            }
        },
    );

    // Create resource to fetch test details
    let test_details = Resource::new(test_id.clone(), move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return None;
        }
        match get_tests().await {
            Ok(tests) => tests.into_iter().find(|test| test.test_id == tid),
            Err(e) => {
                log::error!("Failed to fetch test details: {}", e);
                None
            }
        }
    });

    // Create resource that depends on the test_id from URL
    let questions = Resource::new(test_id, move |tid| async move {
        if tid.is_empty() {
            log::warn!("No test ID provided in URL");
            return Vec::new();
        }
        match get_questions(tid).await {
            Ok(mut questions) => {
                // Sort questions by qnumber to ensure consistent ordering
                questions.sort_by_key(|q| q.qnumber);
                questions
            }
            Err(e) => {
                log::error!("Failed to fetch questions: {}", e);
                Vec::new()
            }
        }
    });

    // Store responses for each question with memo to prevent unnecessary re-renders
    let (responses, set_responses) = signal(HashMap::<i32, QuestionResponse>::new());
    let (selected_student_id, set_selected_student_id) = signal(None::<i32>);

    // Flashcard state
    let (current_card_index, set_current_card_index) = signal(0);
    let (is_submitted, set_is_submitted) = signal(false);

    // Get evaluator ID
    let evaluator_id = Memo::new(move |_| match user.get() {
        Some(user_data) => user_data.id.to_string(),
        None => "0".to_string(),
    });

    // Handler for answer updates - using a local memo to prevent full re-renders
    let handle_answer_change = move |qnumber: i32, value: String| {
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert_with(QuestionResponse::new);
            response.answer = value;
        });
    };

    //Handler for weighted multiple choice selection
    let handle_weighted_selection = move |qnumber: i32, selected_options: Vec<String>| {
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert_with(QuestionResponse::new);
            response.selected_options = Some(selected_options.clone()); // Use correct field name
                                                                        // Also update answer field with JSON for compatibility
            response.answer = serde_json::to_string(&selected_options).unwrap_or_default();
        });
    };

    // Handler for comment updates
    let handle_comment_change = move |qnumber: i32, value: String| {
        set_responses.update(|r| {
            let response = r.entry(qnumber).or_insert_with(QuestionResponse::new);
            response.comment = value;
        });
    };

    // Navigation handlers
    let go_to_next_card = move |_ev| {
        set_current_card_index.update(|index| {
            if let Some(questions_vec) = questions.get() {
                *index = (*index + 1).min(questions_vec.len() - 1);
            }
        });
    };

    let go_to_previous_card = move |_ev| {
        set_current_card_index.update(|index| {
            *index = index.saturating_sub(1);
        });
    };

    // Jump to specific question (for keyboard shortcuts)
    let jump_to_question = move |question_number: usize| {
        questions.with(|questions_opt| {
            if let Some(questions_vec) = questions_opt {
                if question_number > 0 && question_number <= questions_vec.len() {
                    set_current_card_index.set(question_number - 1);
                }
            }
        });
    };

    // Focus comments box
    let focus_comments = move || {
        #[cfg(feature = "hydrate")]
        {
            if let Some(window) = web_sys::window() {
                if let Some(document) = window.document() {
                    if let Some(textarea) = document
                        .query_selector("textarea[placeholder*='notes']")
                        .ok()
                        .flatten()
                    {
                        let _ = textarea.unchecked_ref::<web_sys::HtmlElement>().focus();
                    }
                }
            }
        }
    };

    // De-focus/blur current active element
    let blur_active_element = move || {
        #[cfg(feature = "hydrate")]
        {
            if let Some(window) = web_sys::window() {
                if let Some(document) = window.document() {
                    // Get the currently active element and blur it directly
                    if let Some(active_element) = document.active_element() {
                        log::info!("Blurring element: {}", active_element.tag_name());

                        // Try multiple approaches to ensure blur works
                        if let Some(html_element) = active_element.dyn_ref::<web_sys::HtmlElement>()
                        {
                            let _ = html_element.blur();
                        }

                        // Additional approaches for stubborn elements
                        if let Some(input_element) =
                            active_element.dyn_ref::<web_sys::HtmlInputElement>()
                        {
                            let _ = input_element.blur();
                        }

                        if let Some(textarea_element) =
                            active_element.dyn_ref::<web_sys::HtmlTextAreaElement>()
                        {
                            let _ = textarea_element.blur();
                        }
                    }

                    // Force focus to main container to ensure nothing has focus
                    if let Some(main_container) =
                        document.query_selector(".min-h-screen").ok().flatten()
                    {
                        if let Some(html_element) = main_container.dyn_ref::<web_sys::HtmlElement>()
                        {
                            let _ = html_element.focus();

                            // Immediately blur it so nothing has focus
                            let _ = html_element.blur();
                        }
                    }
                }
            }
        }
    };

    // Submit handler
    let handle_submit = Action::new(move |_: &()| async move {
        let current_responses = responses.get();
        let current_test_id = test_id();

        let student_id = selected_student_id.get().unwrap_or(0);
        let evaluator = evaluator_id();
        let test_variant = 1;

        let mut test_scores = Vec::new();
        let mut comments = Vec::new();

        if let Some(questions) = questions.get() {
            let mut sorted_questions = questions.clone();
            sorted_questions.sort_by_key(|q| q.qnumber);

            for question in sorted_questions {
                if let Some(response) = current_responses.get(&question.qnumber) {
                    let score = match question.question_type {
                        QuestionType::WeightedMultipleChoice => {
                            // Calculate weighted score
                            if let Some(ref selected_opts) = response.selected_options {
                                // Use correct field name
                                question.calculate_weighted_score(selected_opts)
                            } else {
                                0
                            }
                        }
                        _ => {
                            // Regular scoring logic
                            if response.answer == question.correct_answer {
                                question.point_value
                            } else {
                                0
                            }
                        }
                    };

                    test_scores.push(score);
                    comments.push(response.comment.clone());
                } else {
                    test_scores.push(0);
                    comments.push(String::new());
                }
            }
        }

        let score_request = CreateScoreRequest {
            student_id,
            test_id: current_test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
        };

        match add_score(score_request).await {
            Ok(score) => {
                log::info!(
                    "Successfully submitted score for student {}",
                    score.student_id
                );
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to submit score: {}", e);
                Err(e)
            }
        }
    });

    // Keyboard event handler
    #[cfg(feature = "hydrate")]
    {
        use leptos::ev::KeyboardEvent;

        let handle_keydown = move |ev: KeyboardEvent| {
            let target = ev.target().unwrap();
            let tag_name = target
                .unchecked_ref::<web_sys::Element>()
                .tag_name()
                .to_lowercase();

            // Handle Tab to blur from textarea/input
            if ev.key().as_str() == "Tab" && (tag_name == "textarea" || tag_name == "input") {
                if let Some(html_element) = target.dyn_ref::<web_sys::HtmlElement>() {
                    let _ = html_element.blur();
                    ev.prevent_default();
                }
                return;
            }

            // Only handle navigation shortcuts when not typing in input fields
            if tag_name == "input" || tag_name == "textarea" || tag_name == "select" {
                return;
            }

            match ev.key().as_str() {
                "ArrowRight" | "n" | "N" => {
                    ev.prevent_default();
                    set_current_card_index.update(|index| {
                        if let Some(questions_vec) = questions.get() {
                            *index = (*index + 1).min(questions_vec.len() - 1);
                        }
                    });
                }
                "ArrowLeft" | "p" | "P" => {
                    ev.prevent_default();
                    set_current_card_index.update(|index| {
                        *index = index.saturating_sub(1);
                    });
                }
                "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" => {
                    if !ev.ctrl_key() && !ev.alt_key() && !ev.meta_key() {
                        ev.prevent_default();
                        if let Ok(num) = ev.key().parse::<usize>() {
                            // Check if we're on a multiple choice question
                            if let Some(questions_vec) = questions.get() {
                                let current_question = &questions_vec[current_card_index.get()];
                                match current_question.question_type {
                                    QuestionType::MultipleChoice => {
                                        if num <= current_question.options.len() {
                                            let option = current_question.options[num - 1].clone();
                                            handle_answer_change(current_question.qnumber, option);
                                        }
                                    }
                                    QuestionType::WeightedMultipleChoice => {
                                        let weighted_options =
                                            current_question.get_weighted_options();
                                        if num <= weighted_options.len() {
                                            let option = &weighted_options[num - 1];
                                            if option.is_selectable {
                                                let current_selected = responses.with(|r| {
                                                    r.get(&current_question.qnumber)
                                                        .and_then(|resp| {
                                                            resp.selected_options.as_ref()
                                                        })
                                                        .cloned()
                                                        .unwrap_or_default()
                                                });

                                                let mut new_selected = current_selected;
                                                if new_selected.contains(&option.text) {
                                                    new_selected.retain(|x| x != &option.text);
                                                } else {
                                                    new_selected.push(option.text.clone());
                                                }

                                                handle_weighted_selection(
                                                    current_question.qnumber,
                                                    new_selected,
                                                );
                                            }
                                        }
                                    }
                                    QuestionType::TrueFalse => {
                                        if num == 1 {
                                            handle_answer_change(
                                                current_question.qnumber,
                                                "true".to_string(),
                                            );
                                        } else if num == 2 {
                                            handle_answer_change(
                                                current_question.qnumber,
                                                "false".to_string(),
                                            );
                                        }
                                    }
                                    _ => {
                                        // For other question types, jump to question
                                        jump_to_question(num);
                                    }
                                }
                            }
                        }
                    }
                }
                "c" | "C" => {
                    if !ev.ctrl_key() && !ev.alt_key() && !ev.meta_key() {
                        ev.prevent_default();
                        focus_comments();
                    }
                }
                "Enter" => {
                    if ev.ctrl_key() || ev.meta_key() {
                        ev.prevent_default();
                        if let Some(questions_vec) = questions.get() {
                            if current_card_index.get() == questions_vec.len() - 1
                                && !is_submitted.get()
                            {
                                // Submit on last question
                                if selected_student_id.get().is_some() {
                                    handle_submit.dispatch(());
                                    set_is_submitted.set(true);
                                }
                            } else {
                                set_current_card_index.update(|index| {
                                    *index = (*index + 1).min(questions_vec.len() - 1);
                                });
                            }
                        }
                    }
                }
                _ => {}
            }
        };

        Effect::new(move |_| {
            let window = web_sys::window().unwrap();
            let document = window.document().unwrap();

            let closure = wasm_bindgen::closure::Closure::wrap(
                Box::new(handle_keydown) as Box<dyn Fn(KeyboardEvent)>
            );

            document
                .add_event_listener_with_callback("keydown", closure.as_ref().unchecked_ref())
                .unwrap();

            closure.forget(); // Keep the closure alive
        });
    }

    // Memoize the percentage calculation to avoid recalculating on every render
    let calculate_answered_percentage = Memo::new(move |_| {
        let answered_count = responses.with(|r| {
            questions
                .get()
                .map(|q| {
                    q.iter()
                        .filter(|question| {
                            r.get(&question.qnumber)
                                .map(|resp| !resp.answer.trim().is_empty())
                                .unwrap_or(false)
                        })
                        .count() as f32
                })
                .unwrap_or(0.0)
        });

        let total = questions.get().map(|q| q.len() as f32).unwrap_or(1.0);
        (answered_count / total) * 100.0
    });

    view! {
        <div class="min-h-screen bg-gray-50" tabindex="-1">
            {/* Minimal Top Bar */}
            <div class="sticky top-0 z-10 bg-white/80 backdrop-blur-md border-b border-gray-100">
                <div class="max-w-5xl mx-auto px-6 py-3">
                    <div class="flex items-center justify-between">
                        {/* Left: Student Select */}
                        <div class="flex-shrink-0">
                            <StudentSelect set_selected_student_id=set_selected_student_id />
                        </div>

                        {/* Center: Test Title */}
                        <div class="flex-1 text-center px-8">
                            <h1 class="text-lg font-medium text-gray-900 truncate">
                                {move || match &test_details.get() {
                                    Some(Some(test)) => test.name.clone(),
                                    _ => test_id()
                                }}
                            </h1>
                        </div>

                        {/* Right: Controls */}
                        <div class="flex items-center gap-3">
                            <FontControls
                                font_settings=font_settings
                                set_font_settings=set_font_settings
                            />
                            <div class="text-sm text-gray-500 font-medium hidden sm:block">
                                {move || match user_data.get() {
                                    Some(Some(user)) => format!("{} {}",
                                        user.first_name.unwrap_or("".to_string()),
                                        user.last_name.unwrap_or("".to_string())
                                    ).trim().to_string(),
                                    Some(None) => evaluator_id(),
                                    None => "Loading...".to_string(),
                                }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* Instructions - Collapsible */}
            <div class="max-w-5xl mx-auto px-6 pt-4">
                <Suspense fallback=move || view! { <div></div> }>
                    {move || match test_details.get() {
                        Some(Some(test)) => {
                            if test.instructions.as_ref().map_or(false, |inst| !inst.is_empty()) {
                                view! {
                                    <div class="mb-2">
                                        <button
                                            class="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 font-medium"
                                            on:click=move |_| set_instructions_expanded.update(|x| *x = !*x)
                                        >
                                            <svg class=move || format!("w-4 h-4 transition-transform {}",
                                                if instructions_expanded() { "rotate-90" } else { "" }
                                            ) fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                            </svg>
                                            "Test Instructions"
                                        </button>
                                        <Show when=move || instructions_expanded()>
                                            <div class="mt-2">
                                                <TestInstructions instructions=test.instructions.clone() />
                                            </div>
                                        </Show>
                                    </div>
                                }.into_any()
                            } else {
                                view! { <div></div> }.into_any()
                            }
                        },
                        _ => view! { <div></div> }.into_any()
                    }}
                </Suspense>
            </div>

            {/* Keyboard Shortcuts Help - Collapsible */}
            <div class="max-w-5xl mx-auto px-6">
                <div class="mb-4">
                    <button
                        class="flex items-center gap-2 text-sm text-blue-600 hover:text-blue-800 font-medium"
                        on:click=move |_| set_shortcuts_expanded.update(|x| *x = !*x)
                    >
                        <svg class=move || format!("w-4 h-4 transition-transform {}",
                            if shortcuts_expanded() { "rotate-90" } else { "" }
                        ) fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                        "Keyboard Shortcuts"
                    </button>
                    <Show when=move || shortcuts_expanded()>
                        <div class="mt-2 bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                                <span>"â† â†’ or P/N: Navigate (works in textarea)"</span>
                                <span>"1-9: Select answers (Ctrl+1-9 in textarea)"</span>
                                <span>"Ctrl+Enter: Next/Submit (works everywhere)"</span>
                                <span>"C or Ctrl+C: Focus comments"</span>
                            </div>
                        </div>
                    </Show>
                </div>
            </div>

            {/* Main Content */}
            <div class="max-w-5xl mx-auto px-6 pb-8">
                <Suspense
                    fallback=move || view! {
                        <div class="flex items-center justify-center h-96">
                            <div class="flex flex-col items-center gap-4">
                                <div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                <p class="text-gray-500 text-sm">"Loading questions..."</p>
                            </div>
                        </div>
                    }
                >
                    {move || match (questions.get(), test_details.get()) {
                        (None, _) => view! {
                            <div class="flex items-center justify-center h-96">
                                <div class="text-center">
                                    <div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                                    <p class="text-gray-500">"Loading..."</p>
                                </div>
                            </div>
                        }.into_any(),
                        (Some(questions), _) if questions.is_empty() => {
                            view! {
                                <div class="flex items-center justify-center h-96">
                                    <div class="text-center">
                                        <div class="w-16 h-16 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <svg class="w-8 h-8 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z"></path>
                                            </svg>
                                        </div>
                                        <p class="text-gray-500">"No questions found for this test."</p>
                                    </div>
                                </div>
                            }.into_any()
                        },
                        (Some(questions), _) => {
                            let total_questions = questions.len();

                            // Create a memo to get the current question
                            let current_question = Memo::new(move |_| {
                                questions.get(current_card_index.get()).cloned().unwrap_or_else(|| {
                                    log::warn!("Question index out of bounds");
                                    questions.first().cloned().unwrap_or_else(|| panic!("No questions available"))
                                })
                            });

                            view! {
                                <div class="space-y-6">
                                    {/* Progress Section */}
                                    <div class="text-center space-y-3">
                                        {/* Minimalist Progress Bar */}
                                        <div class="w-full max-w-md mx-auto">
                                            <div class="bg-gray-100 rounded-full h-1">
                                                <div
                                                    class="bg-gradient-to-r from-blue-500 to-indigo-600 h-1 rounded-full transition-all duration-700 ease-out"
                                                    style=move || format!("width: {}%", calculate_answered_percentage())
                                                ></div>
                                            </div>
                                        </div>

                                        {/* Question Counter */}
                                        <div class="flex items-center justify-center gap-6 text-sm">
                                            <span class="text-gray-500">
                                                "Question " {move || current_card_index.get() + 1} " of " {total_questions}
                                            </span>
                                            <span class="px-3 py-1 bg-indigo-50 text-indigo-700 rounded-full font-medium">
                                                {move || current_question().point_value} " points"
                                            </span>
                                        </div>
                                    </div>

                                    {/* Card Container - Compact */}
                                    <div class="max-w-4xl mx-auto">
                                        <div class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
                                            {/* Question Header - Compact */}
                                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border-b border-gray-100 px-6 py-3">
                                                <div class="flex items-center justify-between">
                                                    <h2 class="text-lg font-semibold text-gray-900">
                                                        "Question " {move || current_card_index.get() + 1}
                                                    </h2>
                                                    <span class="text-sm text-gray-600 font-medium">
                                                        {move || current_question().point_value} " points"
                                                    </span>
                                                </div>
                                            </div>

                                            <div class="p-6">
                                                {/* Question - Compact */}
                                                <div class="mb-6">
                                                    <div class=move || {
                                                        let question_text = current_question().word_problem.clone();
                                                        let is_long = question_text.len() > 10;
                                                        let alignment = if is_long { "text-left" } else { "text-center" };
                                                        format!("leading-relaxed {} {}", font_settings.get().get_question_classes(), alignment)
                                                    }>
                                                        {move || current_question().word_problem.clone()}
                                                    </div>
                                                </div>

                                                {/* Answer Section - Compact */}
                                                <div class="space-y-4">
                                                    {move || {
                                                        let q = current_question();
                                                        let q_clone_for_calc = q.clone();
                                                        let q_point_value = q.point_value;
                                                        match q.question_type {
                                                            QuestionType::MultipleChoice => view! {
                                                                <div class="space-y-2">
                                                                    {q.options.clone().into_iter().enumerate().map(|(index, option)| {
                                                                        let option_value = option.clone();
                                                                        let option_value_clone = option_value.clone();
                                                                        let qnumber = q.qnumber;
                                                                        let choice_number = index + 1;
                                                                        let is_checked = Memo::new(move |_| {
                                                                            responses.with(|r| {
                                                                                r.get(&qnumber)
                                                                                 .map(|resp| resp.answer == option_value_clone.clone())
                                                                                 .unwrap_or(false)
                                                                            })
                                                                        });

                                                                        view! {
                                                                            <label class="group flex items-start gap-3 p-3 rounded-lg border border-gray-200 hover:border-blue-300 hover:bg-blue-50/50 transition-all duration-200 cursor-pointer">
                                                                                <div class="relative flex-shrink-0 mt-0.5">
                                                                                    <input
                                                                                        type="radio"
                                                                                        name=format!("q_{}", qnumber)
                                                                                        value=option_value.clone()
                                                                                        class="sr-only"
                                                                                        prop:checked=move || is_checked()
                                                                                        on:change=move |ev| {
                                                                                            let value = event_target_value(&ev);
                                                                                            handle_answer_change(qnumber, value);
                                                                                        }
                                                                                    />
                                                                                    <div class=move || {
                                                                                        if is_checked() {
                                                                                            "w-5 h-5 rounded-full border-2 border-blue-500 bg-blue-500 flex items-center justify-center"
                                                                                        } else {
                                                                                            "w-5 h-5 rounded-full border-2 border-gray-300 group-hover:border-blue-400 transition-colors"
                                                                                        }
                                                                                    }>
                                                                                        <Show when=move || is_checked()>
                                                                                            <div class="w-2 h-2 bg-white rounded-full"></div>
                                                                                        </Show>
                                                                                    </div>
                                                                                </div>
                                                                                <div class="flex-1 flex items-start gap-3">
                                                                                    <span class="text-xs text-gray-500 font-medium mt-1 min-w-[1rem]">
                                                                                        {choice_number}
                                                                                    </span>
                                                                                    <span class=move || format!("leading-relaxed {}", font_settings.get().get_answer_classes())>
                                                                                        {option_value}
                                                                                    </span>
                                                                                </div>
                                                                            </label>
                                                                        }
                                                                    }).collect_view()}
                                                                </div>
                                                            },
                                                            QuestionType::WeightedMultipleChoice => {
                                                                let qnumber = q.qnumber;
                                                                let weighted_options = q.get_weighted_options();

                                                                view! {
                                                                    <div class="space-y-3">
                                                                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">
                                                                            <p><strong>"Multiple selections allowed."</strong> " Each answer has different point values."</p>
                                                                        </div>

                                                                        <div class="space-y-2">
                                                                            {weighted_options.clone().into_iter().enumerate().map(|(index, option)| {
                                                                                let option_clone = option.clone();
                                                                                let option_text = option.text.clone();
                                                                                let option_text_for_memo = option_text.clone();
                                                                                let option_text_for_change = option_text.clone();
                                                                                let choice_number = index + 1;
                                                                                let qnumber = q.qnumber;

                                                                                let is_selected = Memo::new(move |_| {
                                                                                    responses.with(|r| {
                                                                                        r.get(&qnumber)
                                                                                            .and_then(|resp| resp.selected_options.as_ref())
                                                                                            .map(|opts| opts.contains(&option_text_for_memo))
                                                                                            .unwrap_or(false)
                                                                                    })
                                                                                });

                                                                                view! {
                                                                                    <div class=move || {
                                                                                        let base_classes = "group flex items-center justify-between p-3 rounded-lg border transition-all duration-200";
                                                                                        if option_clone.is_selectable {
                                                                                            format!("{} border-gray-200 hover:border-blue-300 hover:bg-blue-50/50 cursor-pointer", base_classes)
                                                                                        } else {
                                                                                            format!("{} border-gray-200 bg-gray-50 cursor-not-allowed opacity-60", base_classes)
                                                                                        }
                                                                                    }
                                                                                    on:click=move |_| {
                                                                                        if option_clone.is_selectable {
                                                                                            let current_selected = responses.with(|r| {
                                                                                                r.get(&qnumber)
                                                                                                    .and_then(|resp| resp.selected_options.as_ref())
                                                                                                    .cloned()
                                                                                                    .unwrap_or_default()
                                                                                            });

                                                                                            let mut new_selected = current_selected;
                                                                                            if new_selected.contains(&option_text_for_change) {
                                                                                                new_selected.retain(|x| x != &option_text_for_change);
                                                                                            } else {
                                                                                                new_selected.push(option_text_for_change.clone());
                                                                                            }

                                                                                            handle_weighted_selection(qnumber, new_selected);
                                                                                        }
                                                                                    }>
                                                                                        <div class="flex items-center gap-3">
                                                                                            <div class="relative flex-shrink-0">
                                                                                                {if option_clone.is_selectable {
                                                                                                    view! {
                                                                                                        <div class=move || {
                                                                                                            if is_selected() {
                                                                                                                "w-5 h-5 rounded border-2 border-blue-500 bg-blue-500 flex items-center justify-center"
                                                                                                            } else {
                                                                                                                "w-5 h-5 rounded border-2 border-gray-300 group-hover:border-blue-400 transition-colors"
                                                                                                            }
                                                                                                        }>
                                                                                                            <Show when=move || is_selected()>
                                                                                                                <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                                                                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                                                                                </svg>
                                                                                                            </Show>
                                                                                                        </div>
                                                                                                    }.into_any()
                                                                                                } else {
                                                                                                    view! {
                                                                                                        <div class="w-5 h-5 rounded border-2 border-gray-300 bg-gray-100"></div>
                                                                                                    }.into_any()
                                                                                                }}
                                                                                            </div>
                                                                                            <div class="flex items-start gap-3">
                                                                                                <span class="text-xs text-gray-500 font-medium mt-1 min-w-[1rem]">
                                                                                                    {choice_number}
                                                                                                </span>
                                                                                                <span class=move || format!("leading-relaxed {}", font_settings.get().get_answer_classes())>
                                                                                                    {option_clone.text.clone()}
                                                                                                </span>
                                                                                            </div>
                                                                                        </div>
                                                                                        <div class="flex items-center gap-2">
                                                                                            <span class=move || {
                                                                                                if option_clone.points >= 0 {
                                                                                                    "text-green-600 font-semibold text-sm"
                                                                                                } else {
                                                                                                    "text-red-600 font-semibold text-sm"
                                                                                                }
                                                                                            }>
                                                                                                {if option_clone.points >= 0 { "+" } else { "" }}
                                                                                                {option_clone.points}
                                                                                                " pts"
                                                                                            </span>
                                                                                            {if !option_clone.is_selectable {
                                                                                                view! {
                                                                                                    <span class="text-xs text-gray-400 italic">"(info only)"</span>
                                                                                                }.into_any()
                                                                                            } else {
                                                                                                view! { <span></span> }.into_any()
                                                                                            }}
                                                                                        </div>
                                                                                    </div>
                                                                                }
                                                                            }).collect_view()}
                                                                        </div>

                                                                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                                                                            <div class="text-sm text-gray-700">
                                                                                "Current score: "
                                                                                <span class="font-semibold text-indigo-600">
                                                                                    {move || {
                                                                                        let selected = responses.with(|r| {
                                                                                            r.get(&qnumber)
                                                                                                .and_then(|resp| resp.selected_options.as_ref())
                                                                                                .cloned()
                                                                                                .unwrap_or_default()
                                                                                        });
                                                                                        q_clone_for_calc.calculate_weighted_score(&selected)
                                                                                    }}
                                                                                    " / " {q_point_value} " points"
                                                                                </span>
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                }
                                                            }
                                                            QuestionType::TrueFalse => {
                                                                let qnumber = q.qnumber;
                                                                let is_true = Memo::new(move |_| {
                                                                    responses.with(|r| {
                                                                        r.get(&qnumber)
                                                                         .map(|resp| resp.answer == "true")
                                                                         .unwrap_or(false)
                                                                    })
                                                                });
                                                                let is_false = Memo::new(move |_| {
                                                                    responses.with(|r| {
                                                                        r.get(&qnumber)
                                                                         .map(|resp| resp.answer == "false")
                                                                         .unwrap_or(false)
                                                                    })
                                                                });

                                                                view! {
                                                                    <div class="flex gap-4">
                                                                        <button
                                                                            type="button"
                                                                            class=move || format!("flex-1 py-3 px-4 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 {}",
                                                                                if is_true() {
                                                                                    "bg-green-500 text-white shadow-lg transform scale-105"
                                                                                } else {
                                                                                    "bg-white text-gray-700 border-2 border-gray-200 hover:border-green-400 hover:bg-green-50"
                                                                                }
                                                                            )
                                                                            on:click=move |_| {
                                                                                handle_answer_change(qnumber, "true".to_string());
                                                                            }
                                                                        >
                                                                            <span class="text-xs text-gray-500 font-medium">1</span>
                                                                            <span class=move || font_settings.get().get_answer_classes()>
                                                                                "Yes" //manually
                                                                            //changed to "Yes" for consistency
                                                                            </span>
                                                                        </button>
                                                                        <button
                                                                            type="button"
                                                                            class=move || format!("flex-1 py-3 px-4 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 {}",
                                                                                if is_false() {
                                                                                    "bg-red-500 text-white shadow-lg transform scale-105"
                                                                                } else {
                                                                                    "bg-white text-gray-700 border-2 border-gray-200 hover:border-red-400 hover:bg-red-50"
                                                                                }
                                                                            )
                                                                            on:click=move |_| {
                                                                                handle_answer_change(qnumber, "false".to_string());
                                                                            }
                                                                        >
                                                                            <span class="text-xs text-gray-500 font-medium">2</span>
                                                                            <span class=move || font_settings.get().get_answer_classes()>
                                                                                "No" //manually
                                                                            //changed to "No" for consistency
                                                                            </span>
                                                                        </button>
                                                                    </div>
                                                                }
                                                            }
                                                            _ => {
                                                                let qnumber = q.qnumber;
                                                                let answer_value = Memo::new(move |_| {
                                                                    responses.with(|r| {
                                                                        r.get(&qnumber)
                                                                         .map(|resp| resp.answer.clone())
                                                                         .unwrap_or_default()
                                                                    })
                                                                });

                                                                view! {
                                                                    <div>
                                                                        <textarea
                                                                            class=move || format!("w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none transition-all duration-200 {}",
                                                                                font_settings.get().get_answer_classes())
                                                                            prop:value=move || answer_value()
                                                                            on:input=move |ev| {
                                                                                let value = event_target_value(&ev);
                                                                                handle_answer_change(qnumber, value);
                                                                            }
                                                                            placeholder="Type your answer here..."
                                                                            rows="3"
                                                                        ></textarea>
                                                                    </div>
                                                                }
                                                            }
                                                        }
                                                    }}

                                                    {/* Comments Section - Compact */}
                                                    <div class="border-t border-gray-100 pt-4">
                                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                                            "Notes & Comments " <span class="text-xs text-gray-400">"(Press C to focus)"</span>
                                                        </label>
                                                        {move || {
                                                            let qnumber = current_question().qnumber;

                                                            // Create a memo for the comment value to prevent unnecessary re-renders
                                                            let comment_value = Memo::new(move |_| {
                                                                responses.with(|r| {
                                                                    r.get(&qnumber)
                                                                     .map(|resp| resp.comment.clone())
                                                                     .unwrap_or_default()
                                                                })
                                                            });

                                                            view! {
                                                                <textarea
                                                                    class="w-full p-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none transition-all duration-200 text-sm"
                                                                    prop:value=move || comment_value()
                                                                    on:input=move |ev| {
                                                                        let value = event_target_value(&ev);
                                                                        handle_comment_change(qnumber, value);
                                                                    }
                                                                    placeholder="Add any notes or observations about this question..."
                                                                    rows="2"
                                                                ></textarea>
                                                            }
                                                        }}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Navigation - Compact */}
                                    <div class="flex items-center justify-center gap-4 pt-4">
                                        <button
                                            class="flex items-center gap-2 px-4 py-2 bg-white border border-gray-200 rounded-lg text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 shadow-sm"
                                            disabled=move || current_card_index.get() == 0
                                            on:click=go_to_previous_card
                                        >
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                            </svg>
                                            "Previous"
                                        </button>

                                        {move || {
                                            if current_card_index.get() == total_questions - 1 {
                                                view! {
                                                    <Show when=move || !is_submitted.get() fallback=move || view! {
                                                        <button
                                                            class="flex items-center gap-2 px-6 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105"
                                                            on:click=move |_| {
                                                                let navigate= use_navigate();
                                                                navigate("/dashboard", Default::default());
                                                            }
                                                        >
                                                            "Return to Dashboard"
                                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                                                            </svg>
                                                        </button>
                                                    }>
                                                        <button
                                                            class="flex items-center gap-2 px-6 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-lg hover:from-blue-700 hover:to-indigo-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                                                            on:click=move |_| {
                                                                handle_submit.dispatch(());
                                                                set_is_submitted.set(true);
                                                            }
                                                            disabled=move || selected_student_id.get().is_none()
                                                        >
                                                            "Submit Assessment"
                                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                                            </svg>
                                                        </button>
                                                    </Show>
                                                }.into_any()
                                            } else {
                                                view! {
                                                    <button
                                                        class="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-lg hover:from-blue-700 hover:to-indigo-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105"
                                                        on:click=go_to_next_card
                                                    >
                                                        "Next"
                                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                                        </svg>
                                                    </button>
                                                }.into_any()
                                            }
                                        }}
                                    </div>

                                    {/* Success Message */}
                                    <Show when=move || is_submitted.get()>
                                        <div class="text-center pt-4">
                                            <div class="inline-flex items-center gap-3 px-6 py-3 bg-green-50 border border-green-200 rounded-lg text-green-800">
                                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                                </svg>
                                                "Assessment submitted successfully!"
                                            </div>
                                        </div>
                                    </Show>
                                </div>
                            }.into_any()
                        }
                    }}
                </Suspense>
            </div>
        </div>
    }
}

// StudentSelect component with improved performance
#[component]
pub fn StudentSelect(set_selected_student_id: WriteSignal<Option<i32>>) -> impl IntoView {
    // Extract information in the event student is anonymized
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    // Get mapping service for de-anonymization
    let (student_mapping_service, _) = use_student_mapping_service();

    // Fetch students from server
    let get_students_action = Action::new(|_: &()| async move {
        match get_students().await {
            Ok(fetched_students) => fetched_students,
            Err(e) => {
                log::error!("Failed to fetch students: {}", e);
                Vec::new()
            }
        }
    });

    // Create enhanced student data with de-anonymization info
    let enhanced_students = Memo::new(move |_| {
        let students_data = get_students_action
            .value()
            .get()
            .as_ref()
            .cloned()
            .unwrap_or_default();

        if anonymization_enabled() {
            let mapping_service = student_mapping_service.get();
            students_data
                .into_iter()
                .map(|student| {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &student,
                        mapping_service.as_ref(),
                    );
                    (student, Some(de_anon))
                })
                .collect::<Vec<_>>()
        } else {
            students_data
                .into_iter()
                .map(|student| (student, None))
                .collect::<Vec<_>>()
        }
    });

    // Dispatch action only once on component mount
    Effect::new(move |_| {
        get_students_action.dispatch(());
    });

    view! {
        <div class="min-w-[200px]">
            <select
                class="w-full px-3 py-2 text-sm border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white transition-all duration-200"
                on:change=move |ev| {
                    let value = event_target_value(&ev).parse().ok();
                    set_selected_student_id.set(value);
                }
            >
                <option value="">"Select student..."</option>
                <Suspense fallback=move || view! {
                    <option>"Loading..."</option>
                }>
                    {move || {
                        enhanced_students().into_iter().map(|(student, de_anon_opt)| {
                            // Determine display values based on anonymization status
                            let display_text = if let Some(de_anon) = &de_anon_opt {
                                // Use de-anonymized display name and ID
                                format!("{} - {}", de_anon.display_name, de_anon.display_id)
                            } else {
                                // Use original student data
                                format!(
                                    "{} {} - {}",
                                    student.firstname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.lastname.as_ref().unwrap_or(&"Unknown".to_string()),
                                    student.student_id
                                )
                            };

                            view! {
                                <option value={student.student_id.to_string()}>
                                    {display_text}
                                </option>
                            }
                        }).collect_view()
                    }}
                </Suspense>
            </select>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::question::{Question, QuestionType, WeightedOption};
use crate::app::models::score::{QuestionResponse, CreateScoreRequest};
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct ScoringEngine;

impl ScoringEngine {
    /// Calculate score for a single question based on student's answer
    pub fn calculate_question_score(
        question: &Question,
        student_answer: &str,
        comment: &str,
    ) -> Result<QuestionResponse, String> {
        match &question.question_type {
            QuestionType::WeightedMultipleChoice => {
                Self::score_weighted_multiple_choice(question, student_answer, comment)
            }
            QuestionType::MultipleChoice => {
                Self::score_traditional_multiple_choice(question, student_answer, comment)
            }
            QuestionType::TrueFalse => {
                Self::score_true_false(question, student_answer, comment)
            }
            _ => Err(format!(
                "Question type {:?} is not supported for automated scoring",
                question.question_type
            )),
        }
    }

    /// Score a weighted multiple choice question
    fn score_weighted_multiple_choice(
        question: &Question,
        student_answer: &str,
        comment: &str,
    ) -> Result<QuestionResponse, String> {
        if let Some(weighted_options) = &question.weighted_options {
            // Find the selected option
            let selected_option = weighted_options
                .iter()
                .find(|opt| opt.text.trim().eq_ignore_ascii_case(student_answer.trim()));

            match selected_option {
                Some(option) => {
                    let max_points = weighted_options
                        .iter()
                        .map(|opt| opt.points)
                        .max()
                        .unwrap_or(0);

                    Ok(QuestionResponse::new(
                        question.qnumber,
                        student_answer.to_string(),
                        option.points,
                        max_points,
                        comment.to_string(),
                        option.is_correct,
                    ))
                }
                None => {
                    // Student provided an answer not in the options - give 0 points
                    let max_points = weighted_options
                        .iter()
                        .map(|opt| opt.points)
                        .max()
                        .unwrap_or(0);

                    Ok(QuestionResponse::new(
                        question.qnumber,
                        student_answer.to_string(),
                        0,
                        max_points,
                        format!("{} (Answer not found in options)", comment),
                        false,
                    ))
                }
            }
        } else {
            Err("Weighted multiple choice question missing weighted options".to_string())
        }
    }

    /// Score a traditional multiple choice question
    fn score_traditional_multiple_choice(
        question: &Question,
        student_answer: &str,
        comment: &str,
    ) -> Result<QuestionResponse, String> {
        let is_correct = question.correct_answer.eq_ignore_ascii_case(student_answer);
        let points_earned = if is_correct { question.point_value } else { 0 };

        Ok(QuestionResponse::new(
            question.qnumber,
            student_answer.to_string(),
            points_earned,
            question.point_value,
            comment.to_string(),
            is_correct,
        ))
    }

    /// Score a true/false question
    fn score_true_false(
        question: &Question,
        student_answer: &str,
        comment: &str,
    ) -> Result<QuestionResponse, String> {
        let is_correct = question.correct_answer.eq_ignore_ascii_case(student_answer);
        let points_earned = if is_correct { question.point_value } else { 0 };

        Ok(QuestionResponse::new(
            question.qnumber,
            student_answer.to_string(),
            points_earned,
            question.point_value,
            comment.to_string(),
            is_correct,
        ))
    }

    /// Score an entire test given questions and student responses
    pub fn score_test(
        questions: &[Question],
        student_responses: &HashMap<i32, (String, String)>, // qnumber -> (answer, comment)
        student_id= i32,
        test_id= String,
        test_variant: i32,
        evaluator: String,
    ) -> Result<CreateScoreRequest, String> {
        let mut question_responses = Vec::new();
        let mut errors = Vec::new();

        for question in questions {
            let (student_answer, comment) = student_responses
                .get(&question.qnumber)
                .cloned()
                .unwrap_or_else(|| ("".to_string(), "No answer provided".to_string()));

            match Self::calculate_question_score(question, &student_answer, &comment) {
                Ok(response) => question_responses.push(response),
                Err(e) => errors.push(format!("Question {}: {}", question.qnumber, e)),
            }
        }

        if !errors.is_empty() {
            return Err(format!("Scoring errors: {}", errors.join("; ")));
        }

        // Sort responses by question number to ensure consistent ordering
        question_responses.sort_by_key(|r| r.qnumber);

        Ok(CreateScoreRequest::new_with_responses(
            student_id,
            test_id,
            question_responses,
            test_variant,
            evaluator,
        ))
    }

    /// Get detailed analytics for a scored test
    pub fn analyze_test_performance(
        questions: &[Question],
        question_responses: &[QuestionResponse],
    ) -> TestPerformanceAnalysis {
        let mut analysis = TestPerformanceAnalysis::new();

        for response in question_responses {
            analysis.total_questions += 1;
            
            if !response.student_answer.trim().is_empty() {
                analysis.questions_answered += 1;
            }
            
            if response.is_correct {
                analysis.questions_correct += 1;
            }
            
            analysis.total_points_earned += response.points_earned;
            analysis.total_points_possible += response.max_possible_points;

            // Analyze by question type
            if let Some(question) = questions.iter().find(|q| q.qnumber == response.qnumber) {
                let type_stats = analysis.question_type_breakdown
                    .entry(question.question_type.clone())
                    .or_insert_with(QuestionTypeStats::new);
                
                type_stats.total += 1;
                type_stats.points_earned += response.points_earned;
                type_stats.points_possible += response.max_possible_points;
                
                if response.is_correct {
                    type_stats.correct += 1;
                }
            }

            // Track individual question performance
            analysis.question_details.push(QuestionPerformance {
                qnumber: response.qnumber,
                points_earned: response.points_earned,
                max_possible_points: response.max_possible_points,
                percentage: if response.max_possible_points > 0 {
                    (response.points_earned as f64 / response.max_possible_points as f64) * 100.0
                } else {
                    0.0
                },
                is_correct: response.is_correct,
                student_answer: response.student_answer.clone(),
                comment: response.comment.clone(),
            });
        }

        // Calculate overall percentage
        analysis.overall_percentage = if analysis.total_points_possible > 0 {
            (analysis.total_points_earned as f64 / analysis.total_points_possible as f64) * 100.0
        } else {
            0.0
        };

        analysis
    }
}

#[derive(Debug, Clone)]
pub struct TestPerformanceAnalysis {
    pub total_questions: usize,
    pub questions_answered: usize,
    pub questions_correct: usize,
    pub total_points_earned: i32,
    pub total_points_possible: i32,
    pub overall_percentage: f64,
    pub question_type_breakdown: HashMap<QuestionType, QuestionTypeStats>,
    pub question_details: Vec<QuestionPerformance>,
}

impl TestPerformanceAnalysis {
    fn new() -> Self {
        Self {
            total_questions: 0,
            questions_answered: 0,
            questions_correct: 0,
            total_points_earned: 0,
            total_points_possible: 0,
            overall_percentage: 0.0,
            question_type_breakdown: HashMap::new(),
            question_details: Vec::new(),
        }
    }

    /// Get the grade based on percentage (you can customize this)
    pub fn get_letter_grade(&self) -> String {
        match self.overall_percentage {
            p if p >= 97.0 => "A+".to_string(),
            p if p >= 93.0 => "A".to_string(),
            p if p >= 90.0 => "A-".to_string(),
            p if p >= 87.0 => "B+".to_string(),
            p if p >= 83.0 => "B".to_string(),
            p if p >= 80.0 => "B-".to_string(),
            p if p >= 77.0 => "C+".to_string(),
            p if p >= 73.0 => "C".to_string(),
            p if p >= 70.0 => "C-".to_string(),
            p if p >= 67.0 => "D+".to_string(),
            p if p >= 65.0 => "D".to_string(),
            _ => "F".to_string(),
        }
    }

    /// Get strengths and weaknesses based on question type performance
    pub fn get_performance_insights(&self) -> Vec<String> {
        let mut insights = Vec::new();

        for (question_type, stats) in &self.question_type_breakdown {
            let percentage = if stats.points_possible > 0 {
                (stats.points_earned as f64 / stats.points_possible as f64) * 100.0
            } else {
                0.0
            };

            let performance_level = match percentage {
                p if p >= 90.0 => "excellent",
                p if p >= 80.0 => "good",
                p if p >= 70.0 => "fair", 
                _ => "needs improvement",
            };

            insights.push(format!(
                "{:?} questions: {:.1}% ({} out of {}) - {}",
                question_type, percentage, stats.correct, stats.total, performance_level
            ));
        }

        insights
    }
}

#[derive(Debug, Clone)]
pub struct QuestionTypeStats {
    pub total: usize,
    pub correct: usize,
    pub points_earned: i32,
    pub points_possible: i32,
}

impl QuestionTypeStats {
    fn new() -> Self {
        Self {
            total: 0,
            correct: 0,
            points_earned: 0,
            points_possible: 0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct QuestionPerformance {
    pub qnumber: i32,
    pub points_earned: i32,
    pub max_possible_points: i32,
    pub percentage: f64,
    pub is_correct: bool,
    pub student_answer: String,
    pub comment: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::app::models::question::{Question, QuestionType, WeightedOption};

    #[test]
    fn test_weighted_multiple_choice_scoring() {
        let weighted_options = vec![
            WeightedOption::new("Excellent approach".to_string(), 10, true),
            WeightedOption::new("Good approach".to_string(), 7, false),
            WeightedOption::new("Fair approach".to_string(), 4, false),
            WeightedOption::new("Poor approach".to_string(), 1, false),
        ];

        let question = Question::new_weighted(
            "What's the best way to solve this problem?".to_string(),
            weighted_options,
            1,
            "test-id".to_string(),
        );

        // Test scoring different answers
        let response1 = ScoringEngine::calculate_question_score(
            &question,
            "Excellent approach",
            "Great job!",
        ).unwrap();
        
        assert_eq!(response1.points_earned, 10);
        assert_eq!(response1.max_possible_points, 10);
        assert!(response1.is_correct);

        let response2 = ScoringEngine::calculate_question_score(
            &question,
            "Good approach", 
            "Nice work",
        ).unwrap();
        
        assert_eq!(response2.points_earned, 7);
        assert_eq!(response2.max_possible_points, 10);
        assert!(!response2.is_correct);
    }

    #[test]
    fn test_traditional_multiple_choice_compatibility() {
        let question = Question::new(
            "What is 2 + 2?".to_string(),
            5,
            QuestionType::MultipleChoice,
            vec!["3".to_string(), "4".to_string(), "5".to_string()],
            "4".to_string(),
            1,
            "test-id".to_string(),
        );

        let correct_response = ScoringEngine::calculate_question_score(
            &question,
            "4",
            "Correct!",
        ).unwrap();

        assert_eq!(correct_response.points_earned, 5);
        assert_eq!(correct_response.max_possible_points, 5);
        assert!(correct_response.is_correct);

        let incorrect_response = ScoringEngine::calculate_question_score(
            &question,
            "3",
            "Try again",
        ).unwrap();

        assert_eq!(incorrect_response.points_earned, 0);
        assert_eq!(incorrect_response.max_possible_points, 5);
        assert!(!incorrect_response.is_correct);
    }
}
use crate::app::server_functions::auth::{
    request_password_reset, reset_password, validate_reset_token,
};
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::components::Params;
use leptos_router::hooks::{use_navigate, use_params};
use log::info;
use std::time::Duration;

#[component]
pub fn RequestPasswordResetForm() -> impl IntoView {
    let (email, set_email) = signal("".to_string());
    let (message, set_message) = create_signal::<Option<(String, bool)>>(None);

    // Create an action to handle the form submission
    let request_reset = Action::new(move |_: &()| {
        let email = email.get();

        async move {
            match request_password_reset(email).await {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((response.message, true)));
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(err) => {
                    set_message.set(Some((format!("Error: {}", err), false)));
                }
            }
        }
    });

    view! {
        <div class="p-4 bg-white rounded shadow-md max-w-md mx-auto mt-10">
            <h2 class="text-2xl font-bold mb-4">"Reset Your Password"</h2>
            <p class="mb-4 text-gray-600">"Enter your email address and we will send you a link to reset your password."</p>

            {move || {
                message.get().map(|(msg, is_success)| {
                    let bg_class = if is_success { "bg-green-100 text-green-700" } else { "bg-red-100 text-red-700" };
                    view! {
                        <div class={format!("mb-4 p-3 rounded {}", bg_class)}>{msg}</div>
                    }
                })
            }}

            <form on:submit=move |ev| {
                ev.prevent_default();
                request_reset.dispatch(());
            }>
                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="email">"Email"</label>
                    <input
                        id="email"
                        type="email"
                        class="w-full p-2 border rounded"
                        required="true"
                        prop:value=move || email.get()
                        on:input=move |ev| {
                            set_email.set(event_target_value(&ev));
                        }
                    />
                </div>

                <button
                    type="submit"
                    class="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    prop:disabled=move || request_reset.pending().get()
                >
                    {move || {
                        if request_reset.pending().get() {
                            "Sending..."
                        } else {
                            "Send Reset Link"
                        }
                    }}
                </button>
            </form>

            <div class="mt-4 text-center">
                <a href="/login" class="text-blue-500 hover:underline">"Back to Login"</a>
            </div>
        </div>
    }
}

#[component]
pub fn ResetPasswordForm() -> impl IntoView {
    // Get the token from the URL
    #[derive(Params, PartialEq, Clone, Debug)]
    struct ResetParams {
        token: String,
    }

    let params = use_params::<ResetParams>();
    let token = move || params.get().map(|p| p.token).unwrap_or_default();

    let (password, set_password) = signal("".to_string());
    let (confirm_password, set_confirm_password) = signal("".to_string());
    let (message, set_message) = create_signal::<Option<(String, bool)>>(None);
    let (token_valid, set_token_valid) = signal(false);
    let (token_checked, set_token_checked) = signal(false);

    // Validate the token when the component mounts
    Effect::new(move |_| {
        let token_value = token();
        if !token_value.is_empty() {
            spawn_local(async move {
                match validate_reset_token(token_value).await {
                    Ok(valid) => {
                        set_token_valid.set(valid);
                        if !valid {
                            set_message.set(Some(("Invalid or expired reset token. Please request a new password reset.".to_string(), false)));
                        }
                    }
                    Err(_) => {
                        set_token_valid.set(false);
                        set_message.set(Some(("Error validating reset token. Please try again or request a new password reset.".to_string(), false)));
                    }
                }
                set_token_checked.set(true);
            });
        }
    });

    // Create an action to handle the form submission
    let perform_reset = Action::new(move |_: &()| {
        let password_value = password.get();
        let confirm_value = confirm_password.get();
        let token_value = token();

        async move {
            // Client-side validation
            if password_value.trim().is_empty() {
                set_message.set(Some(("Password cannot be empty".to_string(), false)));
                return;
            }

            if password_value != confirm_value {
                set_message.set(Some(("Passwords do not match".to_string(), false)));
                return;
            }

            if password_value.len() < 8 {
                set_message.set(Some((
                    "Password must be at least 8 characters".to_string(),
                    false,
                )));
                return;
            }

            // Server-side reset
            match reset_password(token_value, password_value).await {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((
                            format!("{}. Redirecting to login page...", response.message),
                            true,
                        )));
                        // Redirect to login page after 3 seconds
                        let navigate = use_navigate();
                        set_timeout(
                            move || {
                                navigate("/login", Default::default());
                            },
                            Duration::new(3000, 0),
                        );
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(err) => {
                    set_message.set(Some((format!("Error: {}", err), false)));
                }
            }
        }
    });

    view! {
        <div class="p-4 bg-white rounded shadow-md max-w-md mx-auto mt-10">
            <h2 class="text-2xl font-bold mb-4">"Set New Password"</h2>

            {move || {
                message.get().map(|(msg, is_success)| {
                    let bg_class = if is_success { "bg-green-100 text-green-700" } else { "bg-red-100 text-red-700" };
                    view! {
                        <div class={format!("mb-4 p-3 rounded {}", bg_class)}>{msg}</div>
                    }
                })
            }}

            {move || {
                if !token_checked.get() {
                    view! { <div class="text-center py-4">"Validating reset token..."</div> }.into_any()
                } else if token_valid.get() {
                    view! {
                        <form on:submit=move |ev| {
                            ev.prevent_default();
                            perform_reset.dispatch(());
                        }>
                            <div class="mb-4">
                                <label class="block text-gray-700 mb-2" for="password">"New Password"</label>
                                <input
                                    id="password"
                                    type="password"
                                    class="w-full p-2 border rounded"
                                    required="true"
                                    prop:value=move || password.get()
                                    on:input=move |ev| {
                                        set_password.set(event_target_value(&ev));
                                    }
                                />
                                <p class="text-xs text-gray-500 mt-1">"Must be at least 8 characters"</p>
                            </div>

                            <div class="mb-4">
                                <label class="block text-gray-700 mb-2" for="confirm-password">"Confirm New Password"</label>
                                <input
                                    id="confirm-password"
                                    type="password"
                                    class="w-full p-2 border rounded"
                                    required="true"
                                    prop:value=move || confirm_password.get()
                                    on:input=move |ev| {
                                        set_confirm_password.set(event_target_value(&ev));
                                    }
                                />
                            </div>

                            <button
                                type="submit"
                                class="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                prop:disabled=move || perform_reset.pending().get()
                            >
                                {move || {
                                    if perform_reset.pending().get() {
                                        "Updating..."
                                    } else {
                                        "Set New Password"
                                    }
                                }}
                            </button>
                        </form>
                    }.into_any()
                } else {
                    view! {
                        <div class="text-center">
                            <p class="mb-4">"This password reset link is invalid or has expired."</p>
                            <a href="/forgot-password" class="text-blue-500 hover:underline">"Request a new reset link"</a>
                        </div>
                    }.into_any()
                }
            }}

            <div class="mt-4 text-center">
                <a href="/login" class="text-blue-500 hover:underline">"Back to Login"</a>
            </div>
        </div>
    }
}
use crate::app::models::employee::{Employee, EmployeeRole, StatusEnum, UpdateEmployeeRequest};
use crate::app::models::student::GradeEnum;
use crate::app::server_functions::employees::edit_employee;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use leptos::task::spawn_local;
use log::info;
use std::rc::Rc;
use std::str::FromStr;
use strum::IntoEnumIterator;
use validator::Validate;

// Define consistent styling constants to match employee_details.rs
const INFO_CONTAINER_STYLE: &str =
    "h-full p-6 border-t-8 border-[#00356B] shadow-lg rounded-lg flex flex-col";
const FORM_GROUP_STYLE: &str = "mb-4";
const FORM_LABEL_STYLE: &str = "block text-stone-400 text-xs mb-1";
const FORM_INPUT_STYLE: &str = "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500";
const FORM_SELECT_STYLE: &str = "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500";
const ERROR_MESSAGE_STYLE: &str = "text-red-500 text-sm mb-4";
const BUTTON_CONTAINER_STYLE: &str =
    "mt-4 pt-4 flex border-t gap-2 justify-end sticky bottom-0 bg-[#F9F9F8] w-full";
const BUTTON_PRIMARY_STYLE: &str = "px-4 py-2 bg-green-500 text-white rounded-lg font-bold";
const BUTTON_SECONDARY_STYLE: &str = "px-4 py-2 bg-gray-200 rounded-lg font-bold hover:bg-gray-300";

#[component]
pub fn UpdateEmployeeForm(
    employee: Rc<Employee>,
    #[prop(into)] on_cancel: Callback<()>,
    #[prop(into)] on_save: Callback<()>,
) -> impl IntoView {
    let (id, set_new_id) = signal(employee.id.clone());
    let (new_firstname, set_new_firstname) = signal(employee.firstname.clone());
    let (new_lastname, set_new_lastname) = signal(employee.lastname.clone());
    let (new_status, set_new_status) = signal(employee.status.to_string().clone());
    let (new_role, set_new_role) = signal(employee.role.to_string());

    let (yes_no_grade, set_yes_no_grade) = if new_role() == "Teacher" {
        signal(true)
    } else {
        signal(false)
    };

    let (new_grade, set_new_grade) = match &employee.role {
        EmployeeRole::Teacher { grade } => {
            signal(grade.clone().expect("Some value received").to_string())
        }
        _ => signal(String::from("None")),
    };

    let (error_message, set_error_message) = signal(String::new());
    let (if_error, set_if_error) = signal(false);

    let handle_submit_update_employee = move |ev: SubmitEvent| {
        ev.prevent_default();

        let convert_status_to_enum = match StatusEnum::from_str(&new_status()) {
            Ok(employee_status) => employee_status,
            Err(_) => {
                set_if_error(true);
                set_error_message("Invalid employee status".to_string());
                return;
            }
        };

        let convert_role_to_enum = if new_role() == "Teacher" {
            let grade_enum = GradeEnum::from_str(&new_grade()).ok();
            EmployeeRole::Teacher { grade: grade_enum }
        } else {
            match EmployeeRole::from_str(&new_role()) {
                Ok(role) => role,
                Err(_) => {
                    set_if_error(true);
                    set_error_message("Invalid employee role".to_string());
                    return;
                }
            }
        };

        let update_employee_request = UpdateEmployeeRequest {
            id: id(),
            firstname: new_firstname(),
            lastname: new_lastname(),
            status: convert_status_to_enum,
            role: convert_role_to_enum,
            grade: GradeEnum::from_str(&new_grade()).ok(),
        };

        log::info!("Update Employee Request successful");
        match update_employee_request.validate() {
            Ok(_) => {
                log::info!("Validation passed");
            }
            Err(e) => {
                log::error!("Validatino failed: {:?}", e);
                set_if_error(true);
                set_error_message(format!("Validation error: {:?}", e));
                return;
            }
        }

        spawn_local(async move {
            match edit_employee(update_employee_request).await {
                Ok(_) => {
                    log::info!("Successfully updated employee");
                    on_save(());
                }
                Err(e) => {
                    set_if_error(true);
                    set_error_message(format!("Error updating employee: {:?}", e));
                }
            }
        });
    };

    view! {
        <div class=INFO_CONTAINER_STYLE>
            <Show when=move || if_error()>
                <p class=ERROR_MESSAGE_STYLE>{error_message()}</p>
            </Show>
            <h2 class="text-xl font-bold mb-4">"Update Employee"</h2>
            <form on:submit=handle_submit_update_employee class="flex-grow">
                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"First Name"</label>
                    <input
                        type="text"
                        class=FORM_INPUT_STYLE
                        placeholder="Enter first name"
                        value=new_firstname()
                        on:input=move |ev| set_new_firstname(event_target_value(&ev))
                        required
                    />
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Last Name"</label>
                    <input
                        type="text"
                        class=FORM_INPUT_STYLE
                        placeholder="Enter last name"
                        value=new_lastname()
                        on:input=move |ev| set_new_lastname(event_target_value(&ev))
                        required
                    />
                </div>
                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"System ID"</label>
                    <input
                        type="text"
                        class=FORM_INPUT_STYLE
                        value=id()
                        readonly
                    />
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Status"</label>
                    <select
                        class=FORM_SELECT_STYLE
                        on:change=move |ev| set_new_status(event_target_value(&ev))
                    >
                        {StatusEnum::iter().map(|status| view! {
                            <option value=format!("{}", status) selected=(status.to_string() == new_status())>
                                {format!("{}", status)}
                            </option>
                        }).collect::<Vec<_>>()}
                    </select>
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Role"</label>
                    <select
                        class=FORM_SELECT_STYLE
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            set_new_role(value.clone());
                            set_yes_no_grade(value == "Teacher");
                        }
                    >
                        <option value="" disabled selected>"Select a role"</option>
                        {EmployeeRole::iter().map(|role| view! {
                            <option value=format!("{}", role) selected=(role.to_string() == new_role())>
                                {format!("{}", role)}
                            </option>
                        }).collect::<Vec<_>>()}
                    </select>
                </div>

                <Show when=move || yes_no_grade()>
                    <div class=FORM_GROUP_STYLE>
                        <label class=FORM_LABEL_STYLE>"Assigned Grade"</label>
                        <select
                            class=FORM_SELECT_STYLE
                            on:change=move |ev| set_new_grade(event_target_value(&ev))
                        >
                            {GradeEnum::iter().map(|grade| view! {
                                <option value=format!("{}", grade) selected=(grade.to_string() == new_grade())>
                                    {format!("{}", grade)}
                                </option>
                            }).collect::<Vec<_>>()}
                        </select>
                    </div>
                </Show>

                <div class=BUTTON_CONTAINER_STYLE>
                    <button
                        type="button"
                        class=BUTTON_SECONDARY_STYLE
                        on:click=move |_| on_cancel(())
                    >
                        "Cancel"
                    </button>
                    <button
                        type="submit"
                        class=BUTTON_PRIMARY_STYLE
                    >
                        "Save Changes"
                    </button>
                </div>
            </form>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::employee::{Employee, EmployeeRole};
use leptos::prelude::*;
use std::rc::Rc;

const TABLE_CONTAINER_STYLE: &str =
    "bg-[#F9F9F8] rounded-lg shadow-sm border border-[#DADADA] overflow-hidden";
const TABLE_HEADER_STYLE: &str =
    "py-5 px-6 flex justify-between items-center border-b border-[#2E3A59] bg-[#2E3A59]";
const TABLE_WRAPPER_STYLE: &str = "overflow-x-auto h-[34rem]";
const TABLE_STYLE: &str = "min-w-full divide-y divide-[#DADADA]";
const HEADER_CELL_STYLE: &str =
    "px-6 py-3 text-left text-sm font-medium text-[#2E3A59] uppercase tracking-wider";
const CELL_STYLE: &str = "px-6 py-4 whitespace-nowrap text-sm bg-[#F9F9F8]";
const SELECTED_ROW_STYLE: &str =
    "bg-[#DADADA] border-l-4 border-r-2 border-t-2 border-b-2 border-[#2E3A59]";

#[component]
pub fn TeacherTable(
    #[prop(into)] teachers: Resource<i32, Option<Vec<Employee>>>,
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] role_filter: Signal<String>,
    #[prop(into)] selected_employee: Signal<Option<Rc<Employee>>>,
    #[prop(into)] set_selected_employee: WriteSignal<Option<Rc<Employee>>>,
    #[prop(into)] is_panel_expanded: Signal<bool>,
) -> impl IntoView {
    let filtered_teachers = Memo::new(move |_| {
        let search = search_term().trim().to_lowercase();
        let role = role_filter();

        teachers
            .get()
            .unwrap_or(None)
            .unwrap_or_default()
            .into_iter()
            .filter(|teacher| {
                // For teachers, only filter by search term since they're already filtered by role
                let matches_search = search.is_empty()
                    || teacher.firstname.to_lowercase().contains(&search)
                    || teacher.lastname.to_lowercase().contains(&search);

                // If role filter is set to something other than Teacher, don't show any teachers
                let matches_role = role.is_empty() || role == "Teacher";

                matches_search && matches_role
            })
            .collect::<Vec<_>>()
    });

    // Create a derived class for the container based on panel expansion state
    let container_class = Memo::new(move |_| {
        if is_panel_expanded() {
            // Less width when panel is expanded
            format!(
                "{} transition-all duration-300 ease-in-out",
                TABLE_CONTAINER_STYLE
            )
        } else {
            // Full width when panel is collapsed
            format!(
                "{} transition-all duration-300 ease-in-out",
                TABLE_CONTAINER_STYLE
            )
        }
    });

    view! {
        <div class=move || container_class()>
            <div class=TABLE_HEADER_STYLE>
                <h2 class="text-xl font-medium text-white">
                    "Teachers"
                </h2>
                <span class="text-sm text-white">
                    {move || {
                        let count = filtered_teachers().len();
                        format!("{} {}", count, if count == 1 { "teacher" } else { "teachers" })
                    }}
                </span>
            </div>
            <div class=TABLE_WRAPPER_STYLE>
                <div class="overflow-y-auto max-h-full">
                    <table class=TABLE_STYLE>
                        <thead class="bg-[#DADADA] sticky top-0 z-10">
                            <tr>
                                <th class=HEADER_CELL_STYLE>"ID"</th>
                                <th class=HEADER_CELL_STYLE>"First Name"</th>
                                <th class=HEADER_CELL_STYLE>"Last Name"</th>
                                <th class=HEADER_CELL_STYLE>"Status"</th>
                                <th class=HEADER_CELL_STYLE>"Grade"</th>
                            </tr>
                        </thead>
                        <Suspense fallback=move || view! {
                            <tr>
                                <td colspan="6" class="text-center p-8">
                                    <div class="inline-block h-6 w-6 animate-spin rounded-full border-2 border-[#DADADA] border-t-[#2E3A59]"></div>
                                </td>
                            </tr>
                        }>
                            <tbody>
                                {move || {
                                    let teachers = filtered_teachers();
                                    if teachers.is_empty() {
                                        view! {
                                            <tr>
                                                <td colspan="6" class="px-6 py-12 text-center text-sm text-gray-500">
                                                    "No teachers match your search criteria"
                                                </td>
                                            </tr>
                                        }.into_any()
                                    } else {
                                        teachers.into_iter().map(|teacher| {
                                            let teacher_rc = Rc::new(teacher.clone());
                                            let teacher_cmp = Rc::new(teacher.clone());
                                            let is_selected = move || selected_employee() == Some(teacher_cmp.clone());
                                            view! {
                                                <tr
                                                    class=move || if is_selected() {
                                                        format!("{} {}", SELECTED_ROW_STYLE, "cursor-pointer")
                                                    } else {
                                                        "hover:bg-opacity-20 cursor-pointer border-b border-[#DADADA]".to_string()
                                                    }
                                                    on:click=move |_| set_selected_employee(Some(teacher_rc.clone()))
                                                >
                                                    <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59]")>{teacher.id}</td>
                                                    <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{&teacher.firstname}</td>
                                                    <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] font-medium")>{&teacher.lastname}</td>
                                                    <td class=CELL_STYLE>
                                                        <span class=format!("px-2 py-1 text-sm font-medium rounded-full {}",
                                                            if teacher.status.to_string() == "Active" {
                                                                "bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]"
                                                            } else {
                                                                "bg-[#F44336] bg-opacity-40 text-[#2E3A59]"
                                                            })>
                                                            {teacher.status.to_string()}
                                                        </span>
                                                    </td>
                                                    <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] text-opacity-70")>
                                                        {match &teacher.role {
                                                            EmployeeRole::Teacher { grade } =>
                                                                grade.as_ref().map_or("Not Assigned".to_string(), |g| g.to_string()),
                                                            _ => "N/A".to_string()
                                                        }}
                                                    </td>
                                                </tr>
                                            }
                                        }).collect_view()
                                    }
                                }}
                            </tbody>
                        </Suspense>
                    </table>
                </div>
            </div>
        </div>
    }
}
use crate::app::models::user::{User, UserRole};
use crate::app::server_functions::users::update_user_permissions;
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn RoleSelector(
    user: User,
    current_user_role: UserRole,
    current_user_id: i64,
    #[prop(into)] on_role_updated: Callback<()>,
) -> impl IntoView {
    let (is_open, set_is_open) = signal(false);
    let (is_updating, set_is_updating) = signal(false);

    // Check if this is the current user (to prevent self-demotion)
    let is_current_user = user.id == current_user_id;

    // Determine which roles the current user can assign
    let available_roles = move || -> Vec<UserRole> {
        let mut roles = match current_user_role {
            UserRole::SuperAdmin => vec![
                UserRole::Guest,
                UserRole::User,
                UserRole::Teacher,
                UserRole::Admin,
                UserRole::SuperAdmin,
            ],
            UserRole::Admin => vec![
                UserRole::Guest,
                UserRole::User,
                UserRole::Teacher,
                UserRole::Admin,
            ],
            _ => vec![], // Only admins and superadmins can change roles
        };

        // If this is the current user, remove roles that would be a demotion
        if is_current_user {
            roles.retain(|&role| {
                // Keep roles that are equal or higher than current role
                match (current_user_role, role) {
                    (UserRole::SuperAdmin, _) => role == UserRole::SuperAdmin,
                    (UserRole::Admin, _) => matches!(role, UserRole::Admin | UserRole::SuperAdmin),
                    (UserRole::Teacher, _) => matches!(
                        role,
                        UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
                    ),
                    (UserRole::User, _) => matches!(
                        role,
                        UserRole::User | UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
                    ),
                    (UserRole::Guest, _) => true, // Guests can be promoted to anything
                }
            });
        }

        roles
    };

    let can_manage_roles =
        move || -> bool { matches!(current_user_role, UserRole::Admin | UserRole::SuperAdmin) };

    let update_role = Action::new(move |new_role: &UserRole| {
        let new_role = *new_role;
        let user_id = user.id;

        async move {
            set_is_updating(true);

            match update_user_permissions(user_id, new_role).await {
                Ok(_) => {
                    log::info!("Successfully updated user role");
                    on_role_updated(());
                    set_is_open(false);
                }
                Err(e) => {
                    log::error!("Failed to update user role: {:?}", e);
                }
            }

            set_is_updating(false);
        }
    });

    let role_badge_style = move |role: &UserRole| -> String {
        let base_style = "px-2 py-1 text-xs font-medium rounded-md border";
        let color_style = match role {
            UserRole::SuperAdmin => "text-red-700 bg-red-100 border-red-300",
            UserRole::Admin => "text-orange-700 bg-orange-100 border-orange-300",
            UserRole::Teacher => "text-blue-700 bg-blue-100 border-blue-300",
            UserRole::User => "text-green-700 bg-green-100 border-green-300",
            UserRole::Guest => "text-gray-700 bg-gray-100 border-gray-300",
        };
        format!("{} {}", base_style, color_style)
    };

    let can_edit_this_user = move || -> bool {
        can_manage_roles() && (!is_current_user || current_user_role == UserRole::SuperAdmin)
    };

    view! {
        <div class="relative inline-block">
            {move || if can_edit_this_user() {
                view! {
                    <div>
                        <button
                            class=format!(
                                "{} {} cursor-pointer select-none",
                                role_badge_style(&user.role),
                                if is_updating() { "opacity-50" } else { "hover:opacity-80" }
                            )
                            on:click=move |e| {
                                e.stop_propagation();
                                set_is_open(!is_open());
                            }
                            disabled=move || is_updating()
                            title=move || if is_current_user { "Edit your role (limited options)" } else { "Change user role" }
                        >
                            <span class="flex items-center gap-1">
                                {move || if is_updating() {
                                    "Updating...".to_string()
                                } else {
                                    user.role.to_string()
                                }}
                                <svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </span>
                        </button>

                        // Dropdown menu with better positioning
                        <Show when=move || is_open()>
                            <div class="absolute right-0 mt-1 w-36 bg-white rounded-md shadow-lg border border-gray-200 z-50 overflow-hidden">
                                <div class="py-1">
                                    {available_roles().into_iter().map(|role| {
                                        let role_display = role.to_string();
                                        let is_current = role == user.role;
                                        let role_for_click = role;

                                        view! {
                                            <button
                                                class=move || format!(
                                                    "w-full text-left px-3 py-2 text-xs font-medium transition-colors flex items-center gap-2 {}",
                                                    if is_current {
                                                        "bg-gray-100 text-gray-900 cursor-default"
                                                    } else {
                                                        "text-gray-700 hover:bg-gray-50 hover:text-gray-900"
                                                    }
                                                )
                                                on:click=move |e| {
                                                    e.stop_propagation();
                                                    if !is_current {
                                                        update_role.dispatch(role_for_click);
                                                    }
                                                }
                                                disabled=move || is_current || is_updating()
                                            >
                                                <span class=format!("inline-block w-2 h-2 rounded-full {}",
                                                    match role {
                                                        UserRole::SuperAdmin => "bg-red-500",
                                                        UserRole::Admin => "bg-orange-500",
                                                        UserRole::Teacher => "bg-blue-500",
                                                        UserRole::User => "bg-green-500",
                                                        UserRole::Guest => "bg-gray-500",
                                                    }
                                                )></span>
                                                <span>{role_display}</span>
                                                {if is_current {
                                                    view! { <span class="text-gray-500 ml-auto">"âœ“"</span> }.into_any()
                                                } else {
                                                    view! {}.into_any()
                                                }}
                                            </button>
                                        }
                                    }).collect_view()}
                                </div>
                            </div>
                        </Show>
                    </div>
                }.into_any()
            } else {
                // Non-admin users or users viewing themselves (non-superadmin) see a static badge
                view! {
                    <span class=role_badge_style(&user.role)>
                        {user.role.to_string()}
                        {if is_current_user && can_manage_roles() {
                            view! { <span class="ml-1 text-xs opacity-60">"(you)"</span> }.into_any()
                        } else {
                            view! {}.into_any()
                        }}
                    </span>
                }.into_any()
            }}

            // Click outside to close dropdown
            <Show when=move || is_open()>
                <div
                    class="fixed inset-0 z-40"
                    on:click=move |_| set_is_open(false)
                ></div>
            </Show>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::employee::EmployeeRole;
use leptos::prelude::*;
use strum::IntoEnumIterator;

const SEARCH_CONTAINER_STYLE: &str = "flex flex-wrap gap-4 items-end mb-8 mt-20";
const INPUT_STYLE: &str = "w-full px-4 py-2 bg-white border border-gray-200 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-gray-200 transition-all duration-200";
const LABEL_STYLE: &str = "block text-sm font-medium text-gray-700 mb-1";
const BUTTON_STYLE: &str = "px-4 py-2 text-sm font-medium text-gray-600 bg-white border border-[#DADADA] rounded-md shadow-sm hover:bg-gray-50 transition-all duration-200";

#[component]
pub fn SearchFilter(
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] set_search_term: WriteSignal<String>,
    #[prop(into)] role_filter: Signal<String>,
    #[prop(into)] set_role_filter: WriteSignal<String>,
    #[prop(into)] on_clear_filters: Callback<()>,
) -> impl IntoView {
    view! {
        <div class=SEARCH_CONTAINER_STYLE>
            <div class="flex-1 min-w-64">
                <label for="search" class=LABEL_STYLE>"Search Employees"</label>
                <div class="relative">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none text-gray-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input
                        type="text"
                        name="search"
                        id="search"
                        class=format!("{} pl-10", INPUT_STYLE)
                        placeholder="Search by name..."
                        prop:value={search_term}
                        on:input=move |ev| set_search_term(event_target_value(&ev))
                    />
                </div>
            </div>

            <div class="w-64">
                <label for="role-filter" class=LABEL_STYLE>"Filter by Role"</label>
                <select
                    id="role-filter"
                    class=INPUT_STYLE
                    prop:value={role_filter}
                    on:change=move |ev| set_role_filter(event_target_value(&ev))
                >
                    <option value="">"All Roles"</option>
                    {EmployeeRole::iter().map(|role| view! {
                        <option value=format!("{}", role)>
                            {format!("{}", role)}
                        </option>
                    }).collect::<Vec<_>>()}
                </select>
            </div>

            <div>
                <button
                    type="button"
                    class=BUTTON_STYLE
                    on:click=move |_| on_clear_filters.call(())
                >
                    "Clear Filters"
                </button>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::teacher_page::update_employee_form::UpdateEmployeeForm;
use crate::app::models::employee::{Employee, EmployeeRole};
use leptos::prelude::*;
use std::rc::Rc;

// Updated consistent color scheme and styling
const THEME_PRIMARY: &str = "#003366";
const THEME_PRIMARY_LIGHT: &str = "#5D7A9E";
const THEME_GRAY_BG: &str = "#F0F2F5";

// Improved consistent styling with better naming
const CARD_CONTAINER: &str =
    "h-[95%] bg-[#F9F9F8] p-3 sm:mb-3 mb-2 pb-2 border-t-8 border-[#2E3A59] shadow-md rounded-lg flex flex-col";
const SECTION_CONTAINER: &str = "bg-white p-5 rounded-lg border border-[#DADADA] shadow-sm";
const SECTION_TITLE: &str =
    "text-sm font-semibold text-[#2E3A59] mb-3 pb-2 border-b border-[#DADADA]";
const INFO_TITLE: &str = "text-xs text-[#2E3A59] text-opacity-70 font-medium";
const INFO_VALUE: &str = "text-[#2E3A59] mt-1";
const INFO_GROUP: &str = "mb-4";
const BUTTON_CONTAINER: &str =
    "mt-6 pt-4 flex gap-3 justify-end sticky bottom-0 bg-[#F9F9F8] border-t border-[#DADADA]";
const BUTTON_PRIMARY: &str =
    "px-4 py-2 bg-[#2E3A59] rounded-md font-medium text-[#F9F9F8] hover:bg-opacity-80 transition-colors";
const BUTTON_SECONDARY: &str = "px-4 py-2 bg-[#F9F9F8] rounded-md font-medium text-gray-600 bg-white hover:bg-gray-50 transition-colors border  shadow-sm border-[#DADADA]";
const BUTTON_ACCENT: &str = "px-4 py-2 bg-[#F9F9F8] rounded-md font-medium text-[#2E3A59] hover:bg-opacity-30 hover:bg-[#DADADA] transition-colors border border-[#DADADA]";

#[component]
pub fn EmployeeDetails(
    #[prop()] employee: Rc<Employee>,
    #[prop(into)] on_close: Callback<()>,
    #[prop(into)] call_refresh: Callback<()>,
) -> impl IntoView {
    let (updating_employee, set_updating_employee) = signal(false);

    // Create a memo for the employee to ensure stable references
    let employee_memo = Memo::new(move |_| employee.clone());

    // Create explicit callbacks for the UpdateEmployeeForm
    let on_cancel = Callback::new(move |()| {
        set_updating_employee(false);
    });

    let on_save = Callback::new(move |()| {
        set_updating_employee(false);
        call_refresh.call(());
    });

    view! {
        <Show when=move || updating_employee()>
            <UpdateEmployeeForm
                employee=employee_memo()
                on_cancel=on_cancel
                on_save=on_save
            />
        </Show>
        <Show when=move || !updating_employee()>
            <div class=CARD_CONTAINER>
                <div class="flex items-center justify-between mb-6">
                    <h2 class="text-xl font-bold text-[#2E3A59]">
                        {move || format!("{} {}", employee_memo().firstname, employee_memo().lastname)}
                    </h2>
                    <div class="px-3 py-1 rounded-full bg-[#2E3A59] text-white text-xs font-medium">
                        {move || employee_memo().status.to_string()}
                    </div>
                </div>

                <div class="flex-grow overflow-y-auto space-y-6">
                    // Basic Information Section
                    <div>
                        <h3 class=SECTION_TITLE>"Employee Information"</h3>
                        <div class=SECTION_CONTAINER>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class=INFO_GROUP>
                                    <div class=INFO_TITLE>"Employee ID"</div>
                                    <div class=INFO_VALUE>{move || format!("#{}", employee_memo().id)}</div>
                                </div>
                                <div class=INFO_GROUP>
                                    <div class=INFO_TITLE>"Role"</div>
                                    <div class=INFO_VALUE>{move || employee_memo().role.to_string()}</div>
                                </div>
                                {move || {
                                    let employee = employee_memo();
                                    match &employee.role {
                                        EmployeeRole::Teacher { grade } => {
                                            view! {
                                                <div class=INFO_GROUP>
                                                    <div class=INFO_TITLE>"Assigned Grade"</div>
                                                    <div class=INFO_VALUE>
                                                        {grade.as_ref().map_or(
                                                            view! { <span class="text-gray-400">"Not Assigned"</span> },
                                                            |g| view! { <span class="font-medium">{g.to_string()}</span> }
                                                        )}
                                                    </div>
                                                </div>
                                            }.into_any()
                                        }
                                        _ => view! {}.into_any()
                                    }
                                }}
                            </div>
                        </div>
                    </div>
                </div>
                <div class=BUTTON_CONTAINER>
                    <button
                        type="button"
                        class=BUTTON_SECONDARY
                        on:click=move |_| on_close.call(())
                    >
                        "Close"
                    </button>
                    <button
                        type="button"
                        class=BUTTON_PRIMARY
                        on:click=move |_| set_updating_employee(true)
                    >
                        "Edit Employee"
                    </button>
                </div>
            </div>
        </Show>
    }
}
use leptos::prelude::*;
use crate::app::models::employee::Employee;
use crate::app::models::teacher::DeleteTeacherRequest;
use crate::app::server_functions::employees::delete_employee;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use log::{error, info, warn};
use std::rc::Rc;

#[component]
pub fn DeleteConfirmation(
    #[prop(into)] selected_employee: Signal<Option<Rc<Employee>>>,
    #[prop(into)] on_cancel: Callback<()>,
    #[prop(into)] on_delete: Callback<()>,
) -> impl IntoView {
    log::info!("DeleteConfirmation component initialized");

    // Input field state
    let (confirm_id, set_confirm_id) = signal(String::new());

    let handle_delete_employee = move |ev: SubmitEvent| {
        ev.prevent_default();
        log::info!("Delete form submitted");

        if let Some(employee_to_be_deleted) = selected_employee() {
            let validated_confirm_id = confirm_id()
                .parse::<i32>()
                .expect("Delete confirmation ID was processed correctly");

            if validated_confirm_id == employee_to_be_deleted.id {
                let delete_teacher_request = DeleteTeacherRequest::new(validated_confirm_id);

                spawn_local(async move {
                    let delete_result = delete_employee(delete_teacher_request).await;

                    match delete_result {
                        Ok(_deleted_employee) => on_delete.call(()),
                        Err(e) => {
                            println!("Error deleting = {:?}", e);
                            on_cancel.call(());
                        }
                    };
                });
            } else {
                on_cancel.call(());
                log::info!("Delete was cancelled");
            }
        }
    };

    view! {
        <Show
            when=move || {
                let is_some = selected_employee().is_some();
                log::info!("DeleteConfirmation <Show> condition: {}", is_some);
                is_some
            }
            fallback=move || {
                log::warn!("DeleteConfirmation rendering fallback (no employee)");
                view! { <div></div> }
            }
        >
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full">
                    <h3 class="text-xl font-bold mb-4">"Confirm Delete"</h3>

                    {move || {
                        log::info!("Rendering employee name section");
                        selected_employee().map(|emp| {
                            view! {
                                <p class="mb-4">
                                    "To confirm deletion, please enter the employee's full name: "
                                    <span class="font-semibold">
                                        {emp.id}
                                    </span>
                                </p>
                            }
                        })
                    }}

                    <form on:submit=handle_delete_employee>
                        <input
                            type="text"
                            class="w-full p-2 border rounded mb-4"
                            placeholder="Enter full name"
                            on:input=move |ev| set_confirm_id(event_target_value(&ev))
                            required
                        />
                        <div class="flex justify-end gap-2">
                            <button
                                type="button"
                                class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                                on:click=move |_| on_cancel.call(())
                            >
                                "Cancel"
                            </button>
                            <button
                                type="submit"
                                class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                "Delete"
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </Show>
    }
}
use crate::app::components::teacher_page::role_selector::RoleSelector;
use crate::app::models::user::{User, UserRole};
use leptos::prelude::*;
use leptos::prelude::*;

const TABLE_CONTAINER_STYLE: &str =
    "bg-[#F9F9F8] rounded-lg shadow-sm border border-[#DADADA] overflow-hidden";
const TABLE_HEADER_STYLE: &str =
    "py-5 px-6 flex justify-between items-center border-b border-[#2E3A59] bg-[#2E3A59]";
const TABLE_WRAPPER_STYLE: &str = "overflow-x-auto h-[34rem]";
const TABLE_STYLE: &str = "min-w-full divide-y divide-[#DADADA]";
const HEADER_CELL_STYLE: &str =
    "px-6 py-3 text-left text-sm font-medium text-[#2E3A59] uppercase tracking-wider";
const CELL_STYLE: &str = "px-6 py-4 whitespace-nowrap text-sm bg-[#F9F9F8]";

#[component]
pub fn UserTable(
    #[prop(into)] users: Resource<i32, Option<Vec<User>>>,
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] is_panel_expanded: Signal<bool>,
    #[prop(into)] current_user_role: Signal<UserRole>, // Add this prop
    #[prop(into)] current_user_id: Signal<i64>,
    set_refresh_trigger: WriteSignal<i32>,
) -> impl IntoView {
    let filtered_users = Memo::new(move |_| {
        let search = search_term().trim().to_lowercase();

        users
            .get()
            .unwrap_or(None)
            .unwrap_or_default()
            .into_iter()
            .filter(|user| {
                let matches_search = search.is_empty()
                    || user
                        .first_name
                        .as_ref()
                        .map(|name| name.to_lowercase().contains(&search))
                        .unwrap_or(false)
                    || user
                        .last_name
                        .as_ref()
                        .map(|name| name.to_lowercase().contains(&search))
                        .unwrap_or(false)
                    || user.email.to_lowercase().contains(&search)
                    || user.username.to_lowercase().contains(&search)
                    || user.role.to_string().to_lowercase().contains(&search)
                    || user
                        .account_status
                        .to_string()
                        .to_lowercase()
                        .contains(&search);

                matches_search
            })
            .collect::<Vec<_>>()
    });

    let container_class = Memo::new(move |_| {
        format!(
            "{} transition-all duration-300 ease-in-out",
            TABLE_CONTAINER_STYLE
        )
    });

    view! {
        <div class=move || container_class()>
            <div class=TABLE_HEADER_STYLE>
                <h2 class="text-xl font-medium text-white">
                    "Users"
                </h2>
                <span class="text-sm text-white">
                    {move || {
                        let count = filtered_users().len();
                        format!("{} {}", count, if count == 1 {"user"} else {"users"})
                    }}
                </span>
            </div>
            <div class=TABLE_WRAPPER_STYLE>
                <table class=TABLE_STYLE>
                    <thead class="bg-[#DADADA] sticky top-0 z-10">
                        <tr>
                            <th class=HEADER_CELL_STYLE>"Username"</th>
                            <th class=HEADER_CELL_STYLE>"First Name"</th>
                            <th class=HEADER_CELL_STYLE>"Last Name"</th>
                            <th class=HEADER_CELL_STYLE>"Email"</th>
                            <th class=HEADER_CELL_STYLE>"Phone"</th>
                            <th class=HEADER_CELL_STYLE>"Account Status"</th>
                            <th class=HEADER_CELL_STYLE>"Role"</th>
                        </tr>
                    </thead>
                    <Suspense fallback=move || view! {
                        <tr>
                            <td colspan="7" class="text-center p-8">
                                <div class="inline-block h-6 w-6 animate-spin rounded-full border-2 border-[#DADADA] border-t-[#2E3A59]"></div>
                            </td>
                        </tr>
                    }>
                        <tbody>
                            {move || {
                                let users = filtered_users();
                                if users.is_empty() {
                                    view! {
                                        <tr>
                                            <td colspan="7" class="px-6 py-12 text-center text-sm text-gray-500">
                                                "No users match your search criteria"
                                            </td>
                                        </tr>
                                    }.into_any()
                                } else {
                                    users.into_iter().map(|user| {
                                        let username = user.username.clone();
                                        let first_name = user.first_name.clone().unwrap_or_default();
                                        let last_name = user.last_name.clone().unwrap_or_default();
                                        let email = user.email.clone();
                                        let phone = user.phone_number.clone().unwrap_or_default();
                                        let status = user.account_status.to_string();
                                        let user_for_role_selector = user.clone();

                                        view! {
                                            <tr class="hover:bg-[#DADADA] hover:bg-opacity-70 cursor-pointer border-b border-[#DADADA]">
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59]")>{username}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{first_name}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{last_name}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{email}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{phone}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{status}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>
                                                    <RoleSelector
                                                        user=user_for_role_selector
                                                        current_user_role=current_user_role()
                                                        current_user_id=current_user_id().into()
                                                        on_role_updated=Callback::new(move |_: ()| {
                                                            log::info!("Role updated, refreshing users");
                                                            set_refresh_trigger.update(|n| *n += 1);
                                                        })
                                                    />
                                                </td>
                                            </tr>
                                        }
                                    }).collect_view()
                                }
                            }}
                        </tbody>
                    </Suspense>
                </table>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::employee::Employee;
use leptos::prelude::*;
use std::rc::Rc;

const TABLE_CONTAINER_STYLE: &str =
    "bg-[#F9F9F8] rounded-lg shadow-sm border border-[#DADADA] overflow-hidden";
const TABLE_HEADER_STYLE: &str =
    "py-5 px-6 flex justify-between items-center border-b border-[#2E3A59] bg-[#2E3A59]";
const TABLE_WRAPPER_STYLE: &str = "overflow-x-auto h-[34rem]";
const TABLE_STYLE: &str = "min-w-full divide-y divide-[#DADADA]";
const HEADER_CELL_STYLE: &str =
    "px-6 py-3 text-left text-sm font-medium text-[#2E3A59] uppercase tracking-wider";
const CELL_STYLE: &str = "px-6 py-4 whitespace-nowrap text-sm bg-[#F9F9F8]";
const SELECTED_ROW_STYLE: &str =
    "bg-[#DADADA] border-l-4 border-r-2 border-t-2 border-b-2 border-[#2E3A59]";

#[component]
pub fn EmployeeTable(
    #[prop(into)] employees: Resource<i32, Option<Vec<Employee>>>,
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] role_filter: Signal<String>,
    #[prop(into)] selected_employee: Signal<Option<Rc<Employee>>>,
    #[prop(into)] set_selected_employee: WriteSignal<Option<Rc<Employee>>>,
    #[prop(into)] is_panel_expanded: Signal<bool>,
) -> impl IntoView {
    let filtered_employees = Memo::new(move |_| {
        let search = search_term().trim().to_lowercase();
        let role = role_filter();

        employees
            .get()
            .unwrap_or(None)
            .unwrap_or_default()
            .into_iter()
            .filter(|employee| {
                // Filter by search term
                let matches_search = search.is_empty()
                    || employee.firstname.to_lowercase().contains(&search)
                    || employee.lastname.to_lowercase().contains(&search);

                // Filter by role
                let matches_role = role.is_empty() || employee.role.to_string().contains(&role);

                matches_search && matches_role
            })
            .collect::<Vec<_>>()
    });

    // Create a derived class for the container based on panel expansion state
    let container_class = Memo::new(move |_| {
        if is_panel_expanded() {
            // Less width when panel is expanded
            format!(
                "{} transition-all duration-300 ease-in-out",
                TABLE_CONTAINER_STYLE
            )
        } else {
            // Full width when panel is collapsed
            format!(
                "{} transition-all duration-300 ease-in-out",
                TABLE_CONTAINER_STYLE
            )
        }
    });

    view! {
        <div class=move || container_class()>
            <div class=TABLE_HEADER_STYLE>
                <h2 class="text-xl font-medium text-white">
                    "Employees"
                </h2>
                <span class="text-sm text-white">
                    {move || {
                        let count = filtered_employees().len();
                        format!("{} {}", count, if count == 1 { "employee" } else { "employees" })
                    }}
                </span>
            </div>
            <div class=TABLE_WRAPPER_STYLE>
                <table class=TABLE_STYLE>
                    <thead class="bg-[#DADADA] sticky top-0 z-10">
                        <tr>
                            <th class=HEADER_CELL_STYLE>"ID"</th>
                            <th class=HEADER_CELL_STYLE>"First Name"</th>
                            <th class=HEADER_CELL_STYLE>"Last Name"</th>
                            <th class=HEADER_CELL_STYLE>"Status"</th>
                            <th class=HEADER_CELL_STYLE>"Role"</th>
                        </tr>
                    </thead>
                    <Suspense fallback=move || view! {
                        <tr>
                            <td colspan="6" class="text-center p-8">
                                <div class="inline-block h-6 w-6 animate-spin rounded-full border-2 border-[#DADADA] border-t-[#2E3A59]"></div>
                            </td>
                        </tr>
                    }>
                        <tbody>
                            {move || {
                                let employees = filtered_employees();
                                if employees.is_empty() {
                                    view! {
                                        <tr>
                                            <td colspan="6" class="px-6 py-12 text-center text-sm text-gray-500">
                                                "No employees match your search criteria"
                                            </td>
                                        </tr>
                                    }.into_any()
                                } else {
                                    employees.into_iter().map(|employee| {
                                        let employee_rc = Rc::new(employee.clone());
                                        let employee_cmp = Rc::new(employee.clone());
                                        let is_selected = move || selected_employee() == Some(employee_cmp.clone());
                                        view! {
                                            <tr
                                                class=move || if is_selected() {
                                                    format!("{} {}", SELECTED_ROW_STYLE, "cursor-pointer")
                                                } else {
                                                    "hover:bg-[#DADADA] hover:bg-opacity-70 cursor-pointer border-b border-[#DADADA]".to_string()
                                                }
                                                on:click=move |_| set_selected_employee(Some(employee_rc.clone()))
                                            >
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59]")>{employee.id}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{&employee.firstname}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{&employee.lastname}</td>
                                                <td class=CELL_STYLE>
                                                    <span class=format!("px-2 py-1 text-xs font-medium rounded-full {}",
                                                        if employee.status.to_string() == "Active" {
                                                            "bg-[#4CAF50] bg-opacity-40 text-green-800 font-medium"
                                                        } else {
                                                            "bg-[#FF9800] bg-opacity-40 font-medium text-gray-700"
                                                        })>
                                                        {employee.status.to_string()}
                                                    </span>
                                                </td>
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] text-opacity-70")>{employee.role.to_string()}</td>
                                            </tr>
                                        }
                                    }).collect_view()
                                }
                            }}
                        </tbody>
                    </Suspense>
                </table>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::employee::{AddNewEmployeeRequest, EmployeeRole, StatusEnum};
use crate::app::models::student::GradeEnum;
use crate::app::server_functions::employees::add_employee;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use std::str::FromStr;
use strum::IntoEnumIterator;
use validator::Validate;

// Define consistent styling constants to match employee_details.rs
const INFO_CONTAINER_STYLE: &str =
    "h-full p-6 border-t-8 border-[#00356B] shadow-lg rounded-lg flex flex-col";
const FORM_GROUP_STYLE: &str = "mb-4";
const FORM_LABEL_STYLE: &str = "block text-stone-400 text-xs mb-1";
const FORM_INPUT_STYLE: &str = "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500";
const FORM_SELECT_STYLE: &str = "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500";
const ERROR_MESSAGE_STYLE: &str = "text-red-500 text-sm mb-4";
const BUTTON_CONTAINER_STYLE: &str =
    "mt-4 pt-4 flex border-t gap-2 justify-end sticky bottom-0 bg-[#F9F9F8] w-full";
const BUTTON_PRIMARY_STYLE: &str = "px-4 py-2 bg-green-500 text-white rounded-lg font-bold";
const BUTTON_SECONDARY_STYLE: &str = "px-4 py-2 bg-gray-200 rounded-lg font-bold hover:bg-gray-300";

#[component]
pub fn AddEmployeeForm(
    #[prop(into)] on_cancel: Callback<()>,
    #[prop(into)] on_save: Callback<()>,
) -> impl IntoView {
    let (new_firstname, set_new_firstname) = signal(String::new());
    let (new_lastname, set_new_lastname) = signal(String::new());
    let (new_status, set_new_status) = signal(String::from("Not Applicable"));
    let (new_role, set_new_role) = signal(String::new());
    let (yes_no_grade, set_yes_no_grade) = signal(false);
    let (new_grade, set_new_grade) = signal(String::from("None"));
    let (error_message, set_error_message) = signal(String::new());
    let (if_error, set_if_error) = signal(false);

    let handle_submit_new_employee = move |ev: SubmitEvent| {
        ev.prevent_default();

        let convert_status_to_enum = match StatusEnum::from_str(&new_status()) {
            Ok(employee_status) => employee_status,
            Err(_) => {
                set_if_error(true);
                set_error_message("Invalid employee status".to_string());
                return;
            }
        };

        let convert_role_to_enum = if new_role() == "Teacher" {
            let grade_enum = GradeEnum::from_str(&new_grade()).ok();
            EmployeeRole::Teacher { grade: grade_enum }
        } else {
            match EmployeeRole::from_str(&new_role()) {
                Ok(role) => role,
                Err(_) => {
                    set_if_error(true);
                    set_error_message("Invalid employee role".to_string());
                    return;
                }
            }
        };

        let add_employee_request = AddNewEmployeeRequest {
            firstname: new_firstname(),
            lastname: new_lastname(),
            status: convert_status_to_enum,
            role: convert_role_to_enum,
            grade: GradeEnum::from_str(&new_grade()).ok(),
        };

        if let Err(_) = add_employee_request.validate() {
            set_if_error(true);
            set_error_message("All fields required".to_string());
            return;
        }

        spawn_local(async move {
            match add_employee(add_employee_request).await {
                Ok(_) => on_save(()),
                Err(e) => {
                    set_if_error(true);
                    set_error_message(format!("Error adding employee: {:?}", e));
                }
            }
        });
    };

    view! {
        <div class=INFO_CONTAINER_STYLE>
            <Show when=move || if_error()>
                <p class=ERROR_MESSAGE_STYLE>{error_message()}</p>
            </Show>
            <h2 class="text-xl font-bold mb-4">"Add New Employee"</h2>
            <form on:submit=handle_submit_new_employee class="flex-grow">
                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"First Name"</label>
                    <input
                        type="text"
                        class=FORM_INPUT_STYLE
                        placeholder="Enter first name"
                        on:input=move |ev| set_new_firstname(event_target_value(&ev))
                        required
                    />
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Last Name"</label>
                    <input
                        type="text"
                        class=FORM_INPUT_STYLE
                        placeholder="Enter last name"
                        on:input=move |ev| set_new_lastname(event_target_value(&ev))
                        required
                    />
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Status"</label>
                    <select
                        class=FORM_SELECT_STYLE
                        on:change=move |ev| set_new_status(event_target_value(&ev))
                    >
                        <option value="" disabled selected>"Select Employee Status"</option>
                        {StatusEnum::iter().map(|status| view! {
                            <option>{format!("{}", status)}</option>
                        }).collect::<Vec<_>>()}
                    </select>
                </div>

                <div class=FORM_GROUP_STYLE>
                    <label class=FORM_LABEL_STYLE>"Role"</label>
                    <select
                        class=FORM_SELECT_STYLE
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            set_new_role(value.clone());
                            set_yes_no_grade(value == "Teacher");
                        }
                    >
                        <option value="" disabled selected>"Select a role"</option>
                        {EmployeeRole::iter().map(|role| view! {
                            <option>{format!("{}", role)}</option>
                        }).collect::<Vec<_>>()}
                    </select>
                </div>

                <Show when=move || yes_no_grade()>
                    <div class=FORM_GROUP_STYLE>
                        <label class=FORM_LABEL_STYLE>"Assigned Grade"</label>
                        <select
                            class=FORM_SELECT_STYLE
                            on:change=move |ev| set_new_grade(event_target_value(&ev))
                        >
                            <option value="" disabled selected>"Select Grade"</option>
                            {GradeEnum::iter().map(|grade| view! {
                                <option>{format!("{}", grade)}</option>
                            }).collect::<Vec<_>>()}
                        </select>
                    </div>
                </Show>

                <div class=BUTTON_CONTAINER_STYLE>
                    <button
                        type="button"
                        class=BUTTON_SECONDARY_STYLE
                        on:click=move |_| on_cancel(())
                    >
                        "Cancel"
                    </button>
                    <button
                        type="submit"
                        class=BUTTON_PRIMARY_STYLE
                    >
                        "Save"
                    </button>
                </div>
            </form>
        </div>
    }
}
use crate::app::models::auth::SamlConfig;
use crate::app::models::user::UserRole;
use crate::app::server_functions::saml_auth::{
    create_saml_config, delete_saml_config, get_saml_config_details, get_saml_institutions,
    toggle_saml_config, update_saml_config, SamlInstitution,
};
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn SamlAdminContent(user_id: i64) -> impl IntoView {
    let (institutions, set_institutions) = create_signal::<Vec<SamlInstitution>>(Vec::new());
    let (show_add_form, set_show_add_form) = signal(false);
    let (show_edit_form, set_show_edit_form) = signal(false);
    let (editing_config, set_editing_config) = create_signal::<Option<SamlConfig>>(None);
    let (loading, set_loading) = signal(false);
    let (message, set_message) = create_signal::<Option<(String, bool)>>(None);
    let (show_delete_confirm, set_show_delete_confirm) = signal(false);
    let (delete_target, set_delete_target) = create_signal::<Option<(String, String)>>(None);

    // Form fields for adding/editing SAML config
    let (institution_name, set_institution_name) = signal("".to_string());
    let (entity_id, set_entity_id) = signal("".to_string());
    let (sso_url, set_sso_url) = signal("".to_string());
    let (slo_url, set_slo_url) = signal("".to_string());
    let (x509_cert, set_x509_cert) = signal("".to_string());
    let (metadata_url, set_metadata_url) = signal("".to_string());
    let (config_active, set_config_active) = signal(true);

    // Load institutions on component mount
    let load_institutions = Action::new(move |_: &()| async move {
        match get_saml_institutions().await {
            Ok(institutions_list) => {
                set_institutions.set(institutions_list);
                Ok(())
            }
            Err(e) => {
                log::info!("Failed to load SAML institutions: {:?}", e);
                set_message.set(Some((format!("Failed to load institutions: {}", e), false)));
                Err(e)
            }
        }
    });

    // Load institutions on mount
    Effect::new(move |_| {
        load_institutions.dispatch(());
    });

    // Clear form helper
    let clear_form = move || {
        set_institution_name.set("".to_string());
        set_entity_id.set("".to_string());
        set_sso_url.set("".to_string());
        set_slo_url.set("".to_string());
        set_x509_cert.set("".to_string());
        set_metadata_url.set("".to_string());
        set_config_active.set(true);
        set_editing_config.set(None);
    };

    // Add configuration action
    let handle_add_config = Action::new(move |_: &()| {
        let institution_name = institution_name.get();
        let entity_id = entity_id.get();
        let sso_url = sso_url.get();
        let slo_url = slo_url.get();
        let x509_cert = x509_cert.get();
        let metadata_url = metadata_url.get();

        async move {
            set_loading.set(true);
            set_message.set(None);

            // Basic validation
            if institution_name.trim().is_empty()
                || entity_id.trim().is_empty()
                || sso_url.trim().is_empty()
                || x509_cert.trim().is_empty()
            {
                set_message.set(Some((
                    "All required fields must be filled".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            // Validate URLs
            if !sso_url.starts_with("http") {
                set_message.set(Some((
                    "SSO URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            if !slo_url.is_empty() && !slo_url.starts_with("http") {
                set_message.set(Some((
                    "SLO URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            if !metadata_url.is_empty() && !metadata_url.starts_with("http") {
                set_message.set(Some((
                    "Metadata URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            let slo_url_opt = if slo_url.trim().is_empty() {
                None
            } else {
                Some(slo_url)
            };
            let metadata_url_opt = if metadata_url.trim().is_empty() {
                None
            } else {
                Some(metadata_url)
            };

            match create_saml_config(
                institution_name.clone(),
                entity_id,
                sso_url,
                slo_url_opt,
                x509_cert,
                metadata_url_opt,
            )
            .await
            {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((response.message, true)));
                        clear_form();
                        set_show_add_form.set(false);
                        load_institutions.dispatch(());
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("Failed to create SAML config: {}", e),
                        false,
                    )));
                }
            }

            set_loading.set(false);
        }
    });

    // Edit configuration action
    let handle_edit_config = Action::new(move |config_id: &String| {
        let config_id = config_id.clone();
        async move {
            set_loading.set(true);
            match get_saml_config_details(config_id).await {
                Ok(config) => {
                    set_institution_name.set(config.institution_name.clone());
                    set_entity_id.set(config.entity_id.clone());
                    set_sso_url.set(config.sso_url.clone());
                    set_slo_url.set(config.slo_url.clone().unwrap_or_default());
                    set_x509_cert.set(config.x509_cert.clone());
                    set_config_active.set(config.active);
                    set_editing_config.set(Some(config));
                    set_show_edit_form.set(true);
                    set_show_add_form.set(false);
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("Failed to load configuration: {}", e),
                        false,
                    )));
                }
            }
            set_loading.set(false);
        }
    });

    // Update configuration action
    let handle_update_config = Action::new(move |_: &()| {
        let config = editing_config.get();
        let institution_name = institution_name.get();
        let entity_id = entity_id.get();
        let sso_url = sso_url.get();
        let slo_url = slo_url.get();
        let x509_cert = x509_cert.get();
        let metadata_url = metadata_url.get();
        let active = config_active.get();

        async move {
            if let Some(config) = config {
                set_loading.set(true);
                set_message.set(None);

                // Basic validation
                if institution_name.trim().is_empty()
                    || entity_id.trim().is_empty()
                    || sso_url.trim().is_empty()
                    || x509_cert.trim().is_empty()
                {
                    set_message.set(Some((
                        "All required fields must be filled".to_string(),
                        false,
                    )));
                    set_loading.set(false);
                    return;
                }

                let slo_url_opt = if slo_url.trim().is_empty() {
                    None
                } else {
                    Some(slo_url)
                };
                let metadata_url_opt = if metadata_url.trim().is_empty() {
                    None
                } else {
                    Some(metadata_url)
                };

                match update_saml_config(
                    config.id.to_string(),
                    institution_name,
                    entity_id,
                    sso_url,
                    slo_url_opt,
                    x509_cert,
                    metadata_url_opt,
                    active,
                )
                .await
                {
                    Ok(response) => {
                        if response.success {
                            set_message.set(Some((response.message, true)));
                            clear_form();
                            set_show_edit_form.set(false);
                            load_institutions.dispatch(());
                        } else {
                            set_message.set(Some((response.message, false)));
                        }
                    }
                    Err(e) => {
                        set_message.set(Some((
                            format!("Failed to update SAML config: {}", e),
                            false,
                        )));
                    }
                }

                set_loading.set(false);
            }
        }
    });

    // Delete configuration action
    let handle_delete_config = Action::new(move |config_id: &String| {
        let config_id = config_id.clone();
        async move {
            set_loading.set(true);
            match delete_saml_config(config_id).await {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((response.message, true)));
                        load_institutions.dispatch(());
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("Failed to delete SAML config: {}", e),
                        false,
                    )));
                }
            }
            set_loading.set(false);
        }
    });

    // Toggle configuration status action
    let handle_toggle_config = Action::new(move |config_id: &String| {
        let config_id = config_id.clone();
        async move {
            set_loading.set(true);
            match toggle_saml_config(config_id).await {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((response.message, true)));
                        load_institutions.dispatch(());
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("Failed to toggle SAML config: {}", e),
                        false,
                    )));
                }
            }
            set_loading.set(false);
        }
    });

    view! {
        <div class="space-y-6">
            // Message display
            {move || {
                message.get().map(|(msg, is_success)| {
                    let bg_class = if is_success {
                        "bg-green-900 border-green-700 text-green-200"
                    } else {
                        "bg-red-900 border-red-700 text-red-200"
                    };
                    view! {
                        <div class={format!("border px-4 py-3 rounded {}", bg_class)}>
                            {msg}
                        </div>
                    }
                })
            }}

            // Header with Add button
            <div class="flex justify-between items-center">
                <h4 class="text-lg font-medium text-gray-300">"SAML Institutions"</h4>
                <button
                    class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm disabled:bg-gray-500"
                    on:click=move |_| {
                        if show_edit_form.get() {
                            set_show_edit_form.set(false);
                            clear_form();
                        }
                        set_show_add_form.update(|show| *show = !*show);
                        if show_add_form.get() {
                            clear_form();
                        }
                    }
                    prop:disabled=move || loading.get()
                >
                    {move || if show_add_form.get() { "Cancel" } else { "Add Institution" }}
                </button>
            </div>

            // Add form
            {move || {
                if show_add_form.get() && !show_edit_form.get() {
                    view! {
                        <SamlConfigForm
                            title="Add SAML Configuration"
                            submit_label="Create Configuration"
                            loading=loading
                            institution_name=institution_name
                            set_institution_name=set_institution_name
                            entity_id=entity_id
                            set_entity_id=set_entity_id
                            sso_url=sso_url
                            set_sso_url=set_sso_url
                            slo_url=slo_url
                            set_slo_url=set_slo_url
                            x509_cert=x509_cert
                            set_x509_cert=set_x509_cert
                            metadata_url=metadata_url
                            set_metadata_url=set_metadata_url
                            config_active=config_active
                            set_config_active=set_config_active
                            on_submit=Callback::new(move |_| handle_add_config.dispatch(()))
                            on_cancel=Callback::new(move |_| {
                                set_show_add_form.set(false);
                                clear_form();
                            })
                        />
                    }.into_any()
                } else {
                    view! { <div></div> }.into_any()
                }
            }}

            // Edit form
            {move || {
                if show_edit_form.get() {
                    view! {
                        <SamlConfigForm
                            title="Edit SAML Configuration"
                            submit_label="Update Configuration"
                            loading=loading
                            institution_name=institution_name
                            set_institution_name=set_institution_name
                            entity_id=entity_id
                            set_entity_id=set_entity_id
                            sso_url=sso_url
                            set_sso_url=set_sso_url
                            slo_url=slo_url
                            set_slo_url=set_slo_url
                            x509_cert=x509_cert
                            set_x509_cert=set_x509_cert
                            metadata_url=metadata_url
                            set_metadata_url=set_metadata_url
                            config_active=config_active
                            set_config_active=set_config_active
                            on_submit=Callback::new(move |_| handle_update_config.dispatch(()))
                            on_cancel=Callback::new(move |_| {
                                set_show_edit_form.set(false);
                                clear_form();
                            })
                        />
                    }.into_any()
                } else {
                    view! { <div></div> }.into_any()
                }
            }}

            // Institutions list
            <div class="space-y-3">
                {move || {
                    let institutions_list = institutions.get();
                    if institutions_list.is_empty() {
                        view! {
                            <div class="p-4 text-center text-gray-400 bg-gray-800 rounded border border-gray-600">
                                <p>"No SAML institutions configured yet."</p>
                                <p class="text-sm mt-1">"Click 'Add Institution' to get started."</p>
                            </div>
                        }.into_any()
                    } else {
                        view! {
                            <div class="space-y-2">
                                {institutions_list.into_iter().map(|institution| {
                                    let institution_id_for_edit = institution.id.clone();
                                    let institution_id_for_delete = institution.id.clone();
                                    let institution_id_for_toggle = institution.id.clone();
                                    let institution_name_for_delete = institution.name.clone();
                                    let institution_name_display = institution.name.clone();
                                    let institution_id_display = institution.id.clone();
                                    let institution_active = institution.active;

                                    view! {
                                        <div class="p-4 bg-gray-800 rounded border border-gray-600 hover:bg-gray-750">
                                            <div class="flex items-center justify-between">
                                                <div>
                                                    <h5 class="font-medium text-gray-200">{institution_name_display}</h5>
                                                    <p class="text-sm text-gray-400">
                                                        "Institution ID: " {institution_id_display}
                                                    </p>
                                                </div>
                                                <div class="flex items-center space-x-2">
                                                    {if institution_active {
                                                        view! {
                                                            <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-900 text-green-200">
                                                                "Active"
                                                            </span>
                                                        }.into_any()
                                                    } else {
                                                        view! {
                                                            <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-900 text-red-200">
                                                                "Inactive"
                                                            </span>
                                                        }.into_any()
                                                    }}
                                                    <button
                                                        class="text-blue-400 hover:text-blue-300 text-sm disabled:text-gray-500"
                                                        on:click=move |_| handle_edit_config.dispatch(institution_id_for_edit.clone())
                                                        prop:disabled=move || loading.get()
                                                    >
                                                        "Edit"
                                                    </button>
                                                    <button
                                                        class="text-yellow-400 hover:text-yellow-300 text-sm disabled:text-gray-500"
                                                        on:click=move |_| handle_toggle_config.dispatch(institution_id_for_toggle.clone())
                                                        prop:disabled=move || loading.get()
                                                    >
                                                        {if institution_active { "Disable" } else { "Enable" }}
                                                    </button>
                                                    <button
                                                        class="text-red-400 hover:text-red-300 text-sm disabled:text-gray-500"
                                                        on:click=move |_| {
                                                            set_delete_target.set(Some((institution_id_for_delete.clone(), institution_name_for_delete.clone())));
                                                            set_show_delete_confirm.set(true);
                                                        }
                                                        prop:disabled=move || loading.get()
                                                    >
                                                        "Delete"
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    }
                                }).collect::<Vec<_>>()}
                            </div>
                        }.into_any()
                    }
                }}
            </div>

            // Service Provider Info
            <div class="bg-blue-900 border border-blue-700 rounded p-4">
                <h5 class="text-md font-medium text-blue-200 mb-3">"Service Provider Information"</h5>
                <p class="text-blue-300 mb-3 text-sm">
                    "Provide this information to your identity provider administrators:"
                </p>
                <div class="bg-gray-800 border border-gray-600 rounded p-3 font-mono text-sm">
                    <div class="space-y-1 text-gray-300">
                        <div>
                            <span class="text-blue-300">"Entity ID:"</span>
                            <span class="ml-2">{move || format!("{}/saml/metadata", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                        </div>
                        <div>
                            <span class="text-blue-300">"ACS URL:"</span>
                            <span class="ml-2">{move || format!("{}/saml/acs", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                        </div>
                        <div>
                            <span class="text-blue-300">"SLS URL:"</span>
                            <span class="ml-2">{move || format!("{}/saml/sls", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                        </div>
                    </div>
                </div>
            </div>

            // Delete confirmation modal - moved to correct scope
            {move || {
                if show_delete_confirm.get() {
                    if let Some((config_id, institution_name)) = delete_target.get() {
                        view! {
                            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div class="bg-gray-800 p-6 rounded-lg border border-gray-600 max-w-md w-full mx-4">
                                    <h3 class="text-lg font-medium text-gray-200 mb-4">"Confirm Deletion"</h3>
                                    <p class="text-gray-300 mb-6">
                                        "Are you sure you want to delete the SAML configuration for '"
                                        <span class="font-semibold">{institution_name}</span>
                                        "'? This action cannot be undone."
                                    </p>
                                    <div class="flex justify-end space-x-3">
                                        <button
                                            class="px-4 py-2 bg-gray-600 text-gray-200 rounded hover:bg-gray-500"
                                            on:click=move |_| {
                                                set_show_delete_confirm.set(false);
                                                set_delete_target.set(None);
                                            }
                                        >
                                            "Cancel"
                                        </button>
                                        <button
                                            class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
                                            on:click=move |_| {
                                                handle_delete_config.dispatch(config_id.clone());
                                                set_show_delete_confirm.set(false);
                                                set_delete_target.set(None);
                                            }
                                        >
                                            "Delete"
                                        </button>
                                    </div>
                                </div>
                            </div>
                        }.into_any()
                    } else {
                        view! { <div></div> }.into_any()
                    }
                } else {
                    view! { <div></div> }.into_any()
                }
            }}
        </div>
    }
}

#[component]
fn SamlConfigForm(
    #[prop(into)] title: String,
    #[prop(into)] submit_label: String,
    #[prop(into)] loading: ReadSignal<bool>,
    #[prop(into)] institution_name: ReadSignal<String>,
    #[prop(into)] set_institution_name: WriteSignal<String>,
    #[prop(into)] entity_id: ReadSignal<String>,
    #[prop(into)] set_entity_id: WriteSignal<String>,
    #[prop(into)] sso_url: ReadSignal<String>,
    #[prop(into)] set_sso_url: WriteSignal<String>,
    #[prop(into)] slo_url: ReadSignal<String>,
    #[prop(into)] set_slo_url: WriteSignal<String>,
    #[prop(into)] x509_cert: ReadSignal<String>,
    #[prop(into)] set_x509_cert: WriteSignal<String>,
    #[prop(into)] metadata_url: ReadSignal<String>,
    #[prop(into)] set_metadata_url: WriteSignal<String>,
    #[prop(into)] config_active: ReadSignal<bool>,
    #[prop(into)] set_config_active: WriteSignal<bool>,
    #[prop(into)] on_submit: Callback<()>,
    #[prop(into)] on_cancel: Callback<()>,
) -> impl IntoView {
    view! {
        <div class="bg-gray-800 p-4 rounded border border-gray-600">
            <h5 class="text-md font-medium text-gray-200 mb-3">{title}</h5>
            <form on:submit=move |ev| {
                ev.prevent_default();
                if !loading.get() {
                    on_submit.call(());
                }
            }>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1">
                            "Institution Name" <span class="text-red-400">"*"</span>
                        </label>
                        <input
                            type="text"
                            class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            prop:value=move || institution_name.get()
                            on:input=move |ev| set_institution_name.set(event_target_value(&ev))
                            prop:disabled=move || loading.get()
                            placeholder="University of Example"
                        />
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1">
                            "Entity ID" <span class="text-red-400">"*"</span>
                        </label>
                        <input
                            type="text"
                            class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            prop:value=move || entity_id.get()
                            on:input=move |ev| set_entity_id.set(event_target_value(&ev))
                            prop:disabled=move || loading.get()
                            placeholder="https://idp.example.edu/saml/metadata"
                        />
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1">
                            "SSO URL" <span class="text-red-400">"*"</span>
                        </label>
                        <input
                            type="url"
                            class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            prop:value=move || sso_url.get()
                            on:input=move |ev| set_sso_url.set(event_target_value(&ev))
                            prop:disabled=move || loading.get()
                            placeholder="https://idp.example.edu/saml/sso"
                        />
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1">
                            "SLO URL (Optional)"
                        </label>
                        <input
                            type="url"
                            class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            prop:value=move || slo_url.get()
                            on:input=move |ev| set_slo_url.set(event_target_value(&ev))
                            prop:disabled=move || loading.get()
                            placeholder="https://idp.example.edu/saml/slo"
                        />
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1">
                            "Metadata URL (Optional)"
                        </label>
                        <input
                            type="url"
                            class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            prop:value=move || metadata_url.get()
                            on:input=move |ev| set_metadata_url.set(event_target_value(&ev))
                            prop:disabled=move || loading.get()
                            placeholder="https://idp.example.edu/saml/metadata"
                        />
                    </div>

                    <div class="flex items-center">
                        <label class="flex items-center text-sm font-medium text-gray-300">
                            <input
                                type="checkbox"
                                class="mr-2 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500"
                                prop:checked=move || config_active.get()
                                on:change=move |ev| set_config_active.set(event_target_checked(&ev))
                                prop:disabled=move || loading.get()
                            />
                            "Active Configuration"
                        </label>
                    </div>
                </div>

                <div class="mt-4">
                    <label class="block text-sm font-medium text-gray-300 mb-1">
                        "X.509 Certificate" <span class="text-red-400">"*"</span>
                    </label>
                    <textarea
                        rows="4"
                        class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"
                        prop:value=move || x509_cert.get()
                        on:input=move |ev| set_x509_cert.set(event_target_value(&ev))
                        prop:disabled=move || loading.get()
                        placeholder="-----BEGIN CERTIFICATE-----
MIIEbzCCA1egAwIBAgIJAIYhQeZPzfH3MA0GCSqGSIb3DQEBCwUAMIGBMQswCQYD...
-----END CERTIFICATE-----"
                    ></textarea>
                </div>

                <div class="mt-4 flex justify-end space-x-3">
                    <button
                        type="button"
                        class="px-3 py-2 bg-gray-600 text-gray-200 rounded hover:bg-gray-500 text-sm disabled:bg-gray-500"
                        on:click=move |_| on_cancel.call(())
                        prop:disabled=move || loading.get()
                    >
                        "Cancel"
                    </button>
                    <button
                        type="submit"
                        class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-sm"
                        prop:disabled=move || loading.get()
                    >
                        {move || {
                            if loading.get() {
                                "Processing...".to_string()
                            } else {
                                submit_label.clone()
                            }
                        }}
                    </button>
                </div>
            </form>
        </div>
    }
}
use crate::app::models::user::{SessionUser, UserRole};
use crate::app::server_functions::saml_auth::{
    create_saml_config, get_saml_institutions, SamlInstitution,
};
use leptos::prelude::*;
use leptos::task::spawn_local;

#[component]
pub fn SamlAdminPanel() -> impl IntoView {
    let current_user = use_context::<ReadSignal<Option<SessionUser>>>().unwrap();
    let (institutions, set_institutions) = create_signal::<Vec<SamlInstitution>>(Vec::new());
    let (show_add_form, set_show_add_form) = signal(false);
    let (loading, set_loading) = signal(false);
    let (message, set_message) = create_signal::<Option<(String, bool)>>(None);

    // Form fields for adding new SAML config
    let (institution_name, set_institution_name) = signal("".to_string());
    let (entity_id, set_entity_id) = signal("".to_string());
    let (sso_url, set_sso_url) = signal("".to_string());
    let (slo_url, set_slo_url) = signal("".to_string());
    let (x509_cert, set_x509_cert) = signal("".to_string());
    let (metadata_url, set_metadata_url) = signal("".to_string());

    // Check if user has admin privileges
    let is_admin = move || {
        current_user
            .get()
            .map(|user| matches!(user.role, UserRole::Admin | UserRole::SuperAdmin))
            .unwrap_or(false)
    };

    // Load institutions on component mount
    Effect::new(move |_| {
        if is_admin() {
            spawn_local(async move {
                match get_saml_institutions().await {
                    Ok(institutions_list) => {
                        set_institutions.set(institutions_list);
                    }
                    Err(e) => {
                        log::info!("Failed to load SAML institutions: {:?}", e);
                        set_message
                            .set(Some((format!("Failed to load institutions: {}", e), false)));
                    }
                }
            });
        }
    });

    let handle_add_config = Action::new(move |_: &()| {
        let institution_name = institution_name.get();
        let entity_id = entity_id.get();
        let sso_url = sso_url.get();
        let slo_url = slo_url.get();
        let x509_cert = x509_cert.get();
        let metadata_url = metadata_url.get();

        async move {
            set_loading.set(true);
            set_message.set(None);

            // Basic validation
            if institution_name.trim().is_empty()
                || entity_id.trim().is_empty()
                || sso_url.trim().is_empty()
                || x509_cert.trim().is_empty()
            {
                set_message.set(Some((
                    "All required fields must be filled".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            // Validate URLs
            if !sso_url.starts_with("http") {
                set_message.set(Some((
                    "SSO URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            if !slo_url.is_empty() && !slo_url.starts_with("http") {
                set_message.set(Some((
                    "SLO URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            if !metadata_url.is_empty() && !metadata_url.starts_with("http") {
                set_message.set(Some((
                    "Metadata URL must be a valid HTTP/HTTPS URL".to_string(),
                    false,
                )));
                set_loading.set(false);
                return;
            }

            let slo_url_opt = if slo_url.trim().is_empty() {
                None
            } else {
                Some(slo_url)
            };
            let metadata_url_opt = if metadata_url.trim().is_empty() {
                None
            } else {
                Some(metadata_url)
            };

            match create_saml_config(
                institution_name.clone(),
                entity_id,
                sso_url,
                slo_url_opt,
                x509_cert,
                metadata_url_opt,
            )
            .await
            {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((response.message, true)));

                        // Clear form
                        set_institution_name.set("".to_string());
                        set_entity_id.set("".to_string());
                        set_sso_url.set("".to_string());
                        set_slo_url.set("".to_string());
                        set_x509_cert.set("".to_string());
                        set_metadata_url.set("".to_string());
                        set_show_add_form.set(false);

                        // Reload institutions
                        spawn_local(async move {
                            if let Ok(institutions_list) = get_saml_institutions().await {
                                set_institutions.set(institutions_list);
                            }
                        });
                    } else {
                        set_message.set(Some((response.message, false)));
                    }
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("Failed to create SAML config: {}", e),
                        false,
                    )));
                }
            }

            set_loading.set(false);
        }
    });

    view! {
        <div class="max-w-6xl mx-auto p-6">
            <div class="mb-6">
                <h1 class="text-3xl font-bold text-gray-900">"SAML Administration"</h1>
                <p class="mt-2 text-gray-600">"Manage SAML single sign-on configurations for institutions"</p>
            </div>

            {move || {
                if !is_admin() {
                    view! {
                        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                            "Access denied. Administrator privileges required."
                        </div>
                    }.into_any()
                } else {
                    view! {
                        <div class="space-y-6">
                            {move || {
                                message.get().map(|(msg, is_success)| {
                                    let bg_class = if is_success { "bg-green-100 border-green-400 text-green-700" } else { "bg-red-100 border-red-400 text-red-700" };
                                    view! {
                                        <div class={format!("border px-4 py-3 rounded {}", bg_class)}>
                                            {msg}
                                        </div>
                                    }
                                })
                            }}

                            // Header with Add button
                            <div class="flex justify-between items-center">
                                <h2 class="text-xl font-semibold text-gray-900">"SAML Institutions"</h2>
                                <button
                                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                                    on:click=move |_| set_show_add_form.update(|show| *show = !*show)
                                >
                                    {move || if show_add_form.get() { "Cancel" } else { "Add Institution" }}
                                </button>
                            </div>

                            // Add form
                            {move || {
                                if show_add_form.get() {
                                    view! {
                                        <div class="bg-gray-50 p-6 rounded-lg">
                                            <h3 class="text-lg font-medium text-gray-900 mb-4">"Add SAML Configuration"</h3>
                                            <form on:submit=move |ev| {
                                                ev.prevent_default();
                                                if !loading.get() {
                                                    handle_add_config.dispatch(());
                                                }
                                            }>
                                                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                                    <div>
                                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                                            "Institution Name" <span class="text-red-500">"*"</span>
                                                        </label>
                                                        <input
                                                            type="text"
                                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                            prop:value=move || institution_name.get()
                                                            on:input=move |ev| set_institution_name.set(event_target_value(&ev))
                                                            prop:disabled=move || loading.get()
                                                            placeholder="University of Example"
                                                        />
                                                    </div>

                                                    <div>
                                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                                            "Entity ID" <span class="text-red-500">"*"</span>
                                                        </label>
                                                        <input
                                                            type="text"
                                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                            prop:value=move || entity_id.get()
                                                            on:input=move |ev| set_entity_id.set(event_target_value(&ev))
                                                            prop:disabled=move || loading.get()
                                                            placeholder="https://idp.example.edu/saml/metadata"
                                                        />
                                                    </div>

                                                    <div>
                                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                                            "SLO URL (Optional)"
                                                        </label>
                                                        <input
                                                            type="url"
                                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                            prop:value=move || slo_url.get()
                                                            on:input=move |ev| set_slo_url.set(event_target_value(&ev))
                                                            prop:disabled=move || loading.get()
                                                            placeholder="https://idp.example.edu/saml/slo"
                                                        />
                                                    </div>

                                                    <div>
                                                        <label class="block text-sm font-medium text-gray-700 mb-2">
                                                            "Metadata URL (Optional)"
                                                        </label>
                                                        <input
                                                            type="url"
                                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                            prop:value=move || metadata_url.get()
                                                            on:input=move |ev| set_metadata_url.set(event_target_value(&ev))
                                                            prop:disabled=move || loading.get()
                                                            placeholder="https://idp.example.edu/saml/metadata"
                                                        />
                                                    </div>
                                                </div>

                                                <div class="mt-6">
                                                    <label class="block text-sm font-medium text-gray-700 mb-2">
                                                        "X.509 Certificate" <span class="text-red-500">"*"</span>
                                                    </label>
                                                    <textarea
                                                        rows="6"
                                                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent font-mono text-sm"
                                                        prop:value=move || x509_cert.get()
                                                        on:input=move |ev| set_x509_cert.set(event_target_value(&ev))
                                                        prop:disabled=move || loading.get()
                                                        placeholder="-----BEGIN CERTIFICATE-----
MIIEbzCCA1egAwIBAgIJAIYhQeZPzfH3MA0GCSqGSIb3DQEBCwUAMIGBMQswCQYD...
-----END CERTIFICATE-----"
                                                    ></textarea>
                                                    <p class="mt-1 text-sm text-gray-600">
                                                        "Paste the X.509 certificate from your identity provider"
                                                    </p>
                                                </div>

                                                <div class="mt-6 flex justify-end space-x-3">
                                                    <button
                                                        type="button"
                                                        class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                                                        on:click=move |_| set_show_add_form.set(false)
                                                        prop:disabled=move || loading.get()
                                                    >
                                                        "Cancel"
                                                    </button>
                                                    <button
                                                        type="submit"
                                                        class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                                        prop:disabled=move || loading.get()
                                                    >
                                                        {move || {
                                                            if loading.get() {
                                                                "Creating..."
                                                            } else {
                                                                "Create Configuration"
                                                            }
                                                        }}
                                                    </button>
                                                </div>
                                            </form>
                                        </div>
                                    }.into_any()
                                } else {
                                    view! { <div></div> }.into_any()
                                }
                            }}

                            // Institutions list
                            <div class="bg-white shadow rounded-lg">
                                <div class="px-6 py-4 border-b border-gray-200">
                                    <h3 class="text-lg font-medium text-gray-900">"Configured Institutions"</h3>
                                </div>
                                <div class="overflow-hidden">
                                    {move || {
                                        let institutions_list = institutions.get();
                                        if institutions_list.is_empty() {
                                            view! {
                                                <div class="p-6 text-center text-gray-500">
                                                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
                                                    </svg>
                                                    <p class="mt-2">"No SAML institutions configured yet."</p>
                                                    <p class="text-sm">"Click 'Add Institution' to get started."</p>
                                                </div>
                                            }.into_any()
                                        } else {
                                            view! {
                                                <div class="divide-y divide-gray-200">
                                                    {institutions_list.into_iter().map(|institution| {
                                                        view! {
                                                            <div class="p-6 hover:bg-gray-50">
                                                                <div class="flex items-center justify-between">
                                                                    <div class="flex items-center">
                                                                        <div class="flex-shrink-0">
                                                                            <div class="h-10 w-10 bg-blue-100 rounded-lg flex items-center justify-center">
                                                                                <svg class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
                                                                                </svg>
                                                                            </div>
                                                                        </div>
                                                                        <div class="ml-4">
                                                                            <h4 class="text-lg font-medium text-gray-900">{institution.name.clone()}</h4>
                                                                            <p class="text-sm text-gray-500">
                                                                                "Institution ID: " {institution.id}
                                                                            </p>
                                                                        </div>
                                                                    </div>
                                                                    <div class="flex items-center space-x-2">
                                                                        {if institution.active {
                                                                            view! {
                                                                                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                                                                    "Active"
                                                                                </span>
                                                                            }.into_any()
                                                                        } else {
                                                                            view! {
                                                                                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                                                                                    "Inactive"
                                                                                </span>
                                                                            }.into_any()
                                                                        }}
                                                                        <button class="text-indigo-600 hover:text-indigo-900 text-sm font-medium">
                                                                            "Edit"
                                                                        </button>
                                                                        <button class="text-red-600 hover:text-red-900 text-sm font-medium">
                                                                            "Delete"
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        }
                                                    }).collect::<Vec<_>>()}
                                                </div>
                                            }.into_any()
                                        }
                                    }}
                                </div>
                            </div>

                            // SAML Service Provider Info
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-6">
                                <h3 class="text-lg font-medium text-blue-900 mb-4">"Service Provider Information"</h3>
                                <p class="text-blue-800 mb-4">
                                    "Provide this information to your identity provider administrators:"
                                </p>
                                <div class="bg-white border border-blue-200 rounded p-4 font-mono text-sm">
                                    <div class="space-y-2">
                                        <div>
                                            <strong class="text-blue-900">"Entity ID:"</strong>
                                            <span class="ml-2 text-gray-700">{move || format!("{}/saml/metadata", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                                        </div>
                                        <div>
                                            <strong class="text-blue-900">"ACS URL:"</strong>
                                            <span class="ml-2 text-gray-700">{move || format!("{}/saml/acs", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                                        </div>
                                        <div>
                                            <strong class="text-blue-900">"SLS URL:"</strong>
                                            <span class="ml-2 text-gray-700">{move || format!("{}/saml/sls", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                                        </div>
                                        <div>
                                            <strong class="text-blue-900">"Metadata URL:"</strong>
                                            <span class="ml-2 text-gray-700">{move || format!("{}/saml/metadata", std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:3000".to_string()))}</span>
                                        </div>
                                    </div>
                                </div>
                                <p class="mt-4 text-sm text-blue-700">
                                    "Note: Make sure your BASE_URL environment variable is set correctly for production use."
                                </p>
                            </div>
                        </div>
                    }.into_any()
                }
            }}
        </div>
    }
}
use crate::app::components::assessment_page::assessment_form::{
    basic_info_section::BasicInfoSection, benchmark_section::BenchmarkSection,
    test_selection_section::TestSelectionSection,
};
use crate::app::components::assessment_page::sequence_builder::SequenceBuilder;
use crate::app::components::assessment_page::shared::{
    hooks::UseAssessmentForm, types::AssessmentFormState,
};
use crate::app::models::assessment::{
    CreateNewAssessmentRequest, RangeCategory, UpdateAssessmentRequest,
};
use crate::app::models::test::Test;
use crate::app::server_functions::assessments::{add_assessment, update_assessment};
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn AssessmentForm(
    show_modal: ReadSignal<bool>,
    set_show_modal: WriteSignal<bool>,
    form_hook: UseAssessmentForm,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    courses_resource: Resource<(), Result<Vec<crate::app::models::course::Course>, ServerFnError>>,
    on_success: impl Fn() + 'static + Copy,
) -> impl IntoView {
    // Form submission logic
    let submit_form = Action::new(move |_: &()| {
        let state = form_hook.state.get();
        let editing = form_hook.editing.get();
        let selected_id = form_hook.selected_assessment_id.get();

        async move {
            let composite = calculate_composite_score(&state, &tests_resource).await;

            if editing && selected_id.is_some() {
                if state.use_sequences {
                    let request = UpdateAssessmentRequest::new_with_sequence(
                        state.name,
                        state.frequency,
                        state.grade,
                        state.version,
                        selected_id.unwrap(),
                        composite,
                        state.risk_benchmarks,
                        state.national_benchmarks,
                        state.subject,
                        state.scope,
                        state.course_id,
                        state.test_sequence,
                    );
                    update_assessment(request).await
                } else {
                    let request = UpdateAssessmentRequest::new(
                        state.name,
                        state.frequency,
                        state.grade,
                        state.version,
                        selected_id.unwrap(),
                        state.selected_tests,
                        composite,
                        state.risk_benchmarks,
                        state.national_benchmarks,
                        state.subject,
                        state.scope,
                        state.course_id,
                    );
                    update_assessment(request).await
                }
            } else {
                if state.use_sequences {
                    let request = CreateNewAssessmentRequest::new_with_sequence(
                        state.name,
                        state.frequency,
                        state.grade,
                        state.version,
                        composite,
                        state.risk_benchmarks,
                        state.national_benchmarks,
                        state.subject,
                        state.scope,
                        state.course_id,
                        state.test_sequence,
                    );
                    add_assessment(request).await
                } else {
                    let request = CreateNewAssessmentRequest::new(
                        state.name,
                        state.frequency,
                        state.grade,
                        state.version,
                        state.selected_tests,
                        composite,
                        state.risk_benchmarks,
                        state.national_benchmarks,
                        state.subject,
                        state.scope,
                        state.course_id,
                    );
                    add_assessment(request).await
                }
            }
        }
    });

    // Handle form submission success
    Effect::new(move |_| {
        if let Some(Ok(_)) = submit_form.value().get() {
            form_hook.reset_form.call(()); // FIXED: Added ()
            set_show_modal.set(false);
            on_success();
        }
    });

    view! {
        <Show when=move || show_modal.get()>
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 modal-overlay">
                <div class="bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[90vh] flex flex-col modal-content">
                    <FormHeader
                        editing=form_hook.editing
                        on_close=move || {
                            set_show_modal.set(false);
                            form_hook.reset_form.call(());  // FIXED: Added ()
                        }
                    />

                    <div class="flex-1 overflow-y-auto bg-white">
                        <div class="p-6 bg-white">
                            <form on:submit=move |ev| {
                                ev.prevent_default();
                                submit_form.dispatch(());
                            }>
                                <div class="space-y-6">
                                    <BasicInfoSection
                                        state=form_hook.state
                                        set_state=form_hook.set_state
                                        courses_resource=courses_resource
                                    />

                                    <TestManagementSection
                                        state=form_hook.state
                                        set_state=form_hook.set_state
                                        tests_resource=tests_resource
                                    />

                                    <BenchmarkSections
                                        state=form_hook.state
                                        set_state=form_hook.set_state
                                    />
                                </div>
                            </form>
                        </div>
                    </div>

                    <FormFooter
                        editing=form_hook.editing
                        on_cancel=move || {
                            set_show_modal.set(false);
                            form_hook.reset_form.call(());  // FIXED: Added ()
                        }
                        on_submit=move || submit_form.dispatch(())
                    />
                </div>
            </div>
        </Show>
    }
}

#[component]
fn FormHeader(editing: ReadSignal<bool>, on_close: impl Fn() + 'static + Copy) -> impl IntoView {
    view! {
        <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center z-10 rounded-t-lg">
            <h2 class="text-xl font-medium text-[#2E3A59]">
                {move || if editing.get() { "Edit Assessment" } else { "Create New Assessment" }}
            </h2>
            <button
                class="text-gray-400 hover:text-gray-600 text-2xl leading-none p-1 hover:bg-gray-100 rounded transition-colors"
                on:click=move |_| on_close()
            >
                "Ã—"
            </button>
        </div>
    }
}

#[component]
fn TestManagementSection(
    state: ReadSignal<AssessmentFormState>,
    set_state: WriteSignal<AssessmentFormState>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
) -> impl IntoView {
    view! {
        <div class="border-t border-gray-200 pt-6 bg-white">
            <div class="mb-4 bg-white p-4 rounded-lg">
                <h3 class="text-lg font-medium mb-3 text-gray-900">"Test Management"</h3>
                <div class="flex items-center space-x-4">
                    <label class="inline-flex items-center">
                        <input
                            type="radio"
                            name="test_mode"
                            class="form-radio h-4 w-4 text-[#2E3A59] focus:ring-[#2E3A59] border-gray-300"
                            prop:checked={move || !state.get().use_sequences}
                            on:change=move |_| set_state.update(|s| s.use_sequences = false)
                        />
                        <span class="ml-2 text-sm text-gray-700">"Simple Test List"</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input
                            type="radio"
                            name="test_mode"
                            class="form-radio h-4 w-4 text-[#2E3A59] focus:ring-[#2E3A59] border-gray-300"
                            prop:checked={move || state.get().use_sequences}
                            on:change=move |_| set_state.update(|s| s.use_sequences = true)
                        />
                        <span class="ml-2 text-sm text-gray-700">"Advanced Sequencing"</span>
                    </label>
                </div>
                <p class="text-xs text-gray-500 mt-1">
                    "Advanced sequencing allows you to control test flow with requirements and branching logic."
                </p>
            </div>

            <div class="bg-white">
                <Show
                    when=move || !state.get().use_sequences
                    fallback=move || view! {
                        <div class="bg-white p-4 rounded-lg">
                            <SequenceBuilder
                                state=state
                                set_state=set_state
                                tests_resource=tests_resource
                            />
                        </div>
                    }
                >
                    <div class="bg-white p-4 rounded-lg">
                        <TestSelectionSection
                            state=state
                            set_state=set_state
                            tests_resource=tests_resource
                        />
                    </div>
                </Show>
            </div>
        </div>
    }
}

#[component]
fn BenchmarkSections(
    state: ReadSignal<AssessmentFormState>,
    set_state: WriteSignal<AssessmentFormState>,
) -> impl IntoView {
    let handle_risk_benchmarks_change = move |benchmarks: Option<Vec<RangeCategory>>| {
        set_state.update(|s| s.risk_benchmarks = benchmarks);
    };

    let handle_national_benchmarks_change = move |benchmarks: Option<Vec<RangeCategory>>| {
        set_state.update(|s| s.national_benchmarks = benchmarks);
    };

    view! {
        <div class="space-y-6">
            <div class="border-t border-gray-200 pt-6 bg-white p-4 rounded-lg">
                <h3 class="text-lg font-medium mb-4 text-gray-900">"Risk Benchmarks"</h3>
                <BenchmarkSection
                    benchmarks=Signal::derive(move || state.get().risk_benchmarks)
                    set_benchmarks=handle_risk_benchmarks_change
                    section_type="risk"
                />
            </div>

            <div class="border-t border-gray-200 pt-6 bg-white p-4 rounded-lg">
                <h3 class="text-lg font-medium mb-4 text-gray-900">"National Benchmarks"</h3>
                <BenchmarkSection
                    benchmarks=Signal::derive(move || state.get().national_benchmarks)
                    set_benchmarks=handle_national_benchmarks_change
                    section_type="national"
                />
            </div>
        </div>
    }
}

#[component]
fn FormFooter(
    editing: ReadSignal<bool>,
    on_cancel: impl Fn() + 'static + Copy,
    on_submit: impl Fn() + 'static + Copy,
) -> impl IntoView {
    view! {
        <div class="sticky bottom-0 bg-white border-t border-gray-200 px-6 py-4 flex justify-end space-x-3 rounded-b-lg">
            <button
                type="button"
                class="px-4 py-2 bg-gray-100 text-gray-700 rounded border border-gray-300 hover:bg-gray-200 transition-colors text-sm font-medium"
                on:click=move |_| on_cancel()
            >
                "Cancel"
            </button>
            <button
                type="submit"
                class="px-4 py-2 bg-[#2E3A59] text-white rounded shadow-sm hover:bg-[#1e293b] transition-colors text-sm font-medium"
                on:click=move |ev| {
                    ev.prevent_default();
                    on_submit();
                }
            >
                {move || if editing.get() { "Update Assessment" } else { "Create Assessment" }}
            </button>
        </div>
    }
}

async fn calculate_composite_score(
    state: &AssessmentFormState,
    tests_resource: &Resource<(), Result<Vec<Test>, ServerFnError>>,
) -> Option<i32> {
    let tests_to_sum = if state.use_sequences {
        if state.test_sequence.is_empty() {
            return None;
        }
        state
            .test_sequence
            .iter()
            .map(|seq_item| seq_item.test_id)
            .collect()
    } else {
        if state.selected_tests.is_empty() {
            return None;
        }
        state.selected_tests.clone()
    };

    tests_resource
        .get()
        .and_then(|result| result.ok())
        .map(|tests| {
            tests
                .iter()
                .filter(|test| {
                    let test_uuid = Uuid::parse_str(&test.test_id).unwrap_or_default();
                    tests_to_sum.contains(&test_uuid)
                })
                .map(|test| test.score)
                .sum()
        })
}
use crate::app::components::assessment_page::shared::types::{
    is_variation_test, AssessmentFormState,
};
use crate::app::models::test::Test;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn TestSelectionSection(
    state: ReadSignal<AssessmentFormState>,
    set_state: WriteSignal<AssessmentFormState>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
) -> impl IntoView {
    view! {
        <div class="bg-white p-4 rounded-lg">
            <label class="block text-sm font-medium mb-3 text-gray-700">"Tests"</label>
            {move || tests_resource.get().map(|tests_result| {
                match tests_result {
                    Ok(tests) => {
                        // Filter out variation tests for simple selection
                        let main_tests: Vec<Test> = tests.into_iter()
                            .filter(|test| !is_variation_test(test))
                            .collect();

                        view! {
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-64 overflow-y-auto p-3 bg-gray-50 rounded-md border border-gray-200">
                                {main_tests.into_iter().map(|test| {
                                    let test_id = Uuid::parse_str(&test.test_id).expect("Did not convert uuid to string");
                                    let test_name = test.name.clone();

                                    view! {
                                        <TestCheckbox
                                            test_id=test_id
                                            test_name=test_name
                                            selected_tests=Signal::derive(move || state.get().selected_tests)
                                            on_toggle=move |test_id: Uuid, checked: bool| {
                                                set_state.update(|s| {
                                                    if checked && !s.selected_tests.contains(&test_id) {
                                                        s.selected_tests.push(test_id);
                                                    } else if !checked {
                                                        s.selected_tests.retain(|&id| id != test_id);
                                                    }
                                                });
                                            }
                                        />
                                    }
                                }).collect_view()}
                            </div>
                        }
                    },
                    Err(e) => view! {
                        <div class="p-4 bg-red-50 text-red-700 rounded border border-red-200">
                            "Error loading tests: " {e.to_string()}
                        </div>
                    }
                }
            })}
        </div>
    }
}

#[component]
fn TestCheckbox(
    test_id: Uuid,
    test_name: String,
    selected_tests: Signal<Vec<Uuid>>,
    on_toggle: impl Fn(Uuid, bool) + 'static + Copy,
) -> impl IntoView {
    view! {
        <div class="flex items-center space-x-2 p-2 rounded hover:bg-white transition-colors">
            <input
                type="checkbox"
                id={format!("test-{}", test_id)}
                class="h-4 w-4 text-[#2E3A59] rounded border-gray-300 focus:ring-[#2E3A59]"
                prop:checked={move || selected_tests.get().contains(&test_id)}
                on:change=move |ev| {
                    let checked = event_target_checked(&ev);
                    on_toggle(test_id, checked);
                }
            />
            <label for={format!("test-{}", test_id)} class="text-sm text-gray-700 cursor-pointer">
                {test_name}
            </label>
        </div>
    }
}
use leptos::prelude::*;
pub mod assessment_form;
pub mod basic_info_section;
pub mod test_selection_section;
pub mod benchmark_section;

pub use assessment_form::AssessmentForm;
use leptos::prelude::*;
use crate::app::models::assessment::RangeCategory;
use leptos::prelude::*;

#[component]
pub fn BenchmarkSection(
    benchmarks: Signal<Option<Vec<RangeCategory>>>,
    set_benchmarks: impl Fn(Option<Vec<RangeCategory>>) + 'static + Copy,
    section_type: &'static str,
) -> impl IntoView {
    let (benchmark_min, set_benchmark_min) = signal(0);
    let (benchmark_max, set_benchmark_max) = signal(0);
    let (benchmark_label, set_benchmark_label) = signal(String::new());

    let add_benchmark = move |_| {
        let min = benchmark_min.get();
        let max = benchmark_max.get();
        let label = benchmark_label.get();

        if !label.is_empty() && min < max {
            let new_benchmark = RangeCategory::new(min, max, label);
            let mut current = benchmarks.get().unwrap_or_default();
            current.push(new_benchmark);
            set_benchmarks(Some(current));

            set_benchmark_min.set(0);
            set_benchmark_max.set(0);
            set_benchmark_label.set(String::new());
        }
    };

    view! {
        <div class="space-y-4">
            // Existing benchmarks display
            <div class="space-y-3">
                {move || {
                    let benchmarks_list = benchmarks.get().unwrap_or_default();
                    benchmarks_list.into_iter().map(|benchmark| {
                        let benchmark_label_clone = benchmark.label.clone();
                        view! {
                            <div class="flex items-center justify-between bg-gray-50 p-4 rounded-lg border border-gray-200 hover:bg-gray-100 transition-colors">
                                <div class="flex items-center space-x-3 text-gray-900">
                                    <span class="font-medium text-sm min-w-0 flex-shrink-0">{benchmark.label}</span>
                                    <span class="text-gray-400">"|"</span>
                                    <div class="flex items-center space-x-2 text-sm text-gray-700">
                                        <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-medium">{benchmark.min}</span>
                                        <span class="text-gray-500">"to"</span>
                                        <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-medium">{benchmark.max}</span>
                                    </div>
                                </div>
                                <button
                                    type="button"
                                    class="text-sm text-red-600 hover:text-red-800 hover:bg-red-50 px-3 py-1.5 rounded-md transition-colors flex-shrink-0 font-medium"
                                    on:click=move |_| {
                                        let mut current = benchmarks.get().unwrap_or_default();
                                        current.retain(|b| b.label != benchmark_label_clone);
                                        set_benchmarks(Some(current));
                                    }
                                >
                                    "Remove"
                                </button>
                            </div>
                        }
                    }).collect_view()
                }}
            </div>

            // Add new benchmark form
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <h6 class="text-sm font-medium text-gray-700 mb-3">"Add New "{section_type}" Benchmark"</h6>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">"Min Score"</label>
                        <input
                            type="number"
                            class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-900"
                            placeholder="0"
                            min="0"
                            prop:value={move || benchmark_min.get()}
                            on:input=move |ev| {
                                if let Ok(v) = event_target_value(&ev).parse::<i32>() {
                                    set_benchmark_min.set(v);
                                }
                            }
                        />
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">"Max Score"</label>
                        <input
                            type="number"
                            class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-900"
                            placeholder="100"
                            min="0"
                            prop:value={move || benchmark_max.get()}
                            on:input=move |ev| {
                                if let Ok(v) = event_target_value(&ev).parse::<i32>() {
                                    set_benchmark_max.set(v);
                                }
                            }
                        />
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">"Category Label"</label>
                        <input
                            type="text"
                            class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-900"
                            placeholder="e.g., Mastery, Developing"
                            prop:value={move || benchmark_label.get()}
                            on:input=move |ev| set_benchmark_label.set(event_target_value(&ev))
                        />
                    </div>
                    <div>
                        <button
                            type="button"
                            class="w-full px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md border border-blue-600 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            on:click=add_benchmark
                            disabled=move || {
                                let label_empty = benchmark_label.get().trim().is_empty();
                                let invalid_range = benchmark_min.get() >= benchmark_max.get();
                                label_empty || invalid_range
                            }
                        >
                            "Add Benchmark"
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
}
use crate::app::components::assessment_page::shared::types::AssessmentFormState;
use crate::app::models::assessment::{ScopeEnum, SubjectEnum};
use crate::app::models::student::GradeEnum;
use leptos::html;
use leptos::prelude::*;
use strum::IntoEnumIterator;
#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

#[component]
pub fn BasicInfoSection(
    state: ReadSignal<AssessmentFormState>,
    set_state: WriteSignal<AssessmentFormState>,
    courses_resource: Resource<(), Result<Vec<crate::app::models::course::Course>, ServerFnError>>,
) -> impl IntoView {
    // Create node refs for the select elements
    let subject_ref = create_node_ref::<html::Select>();
    let grade_ref = create_node_ref::<html::Select>();
    let scope_ref = create_node_ref::<html::Select>();

    // Effect to update subject select when state changes
    Effect::new(move |_| {
        let current_state = state.get();
        if let Some(subject_element) = subject_ref.get() {
            match current_state.subject {
                Some(subject) => {
                    let formatted = format!("{}", subject);
                    log::info!("Setting subject select to: {}", formatted);
                    subject_element.set_value(&formatted);
                }
                None => {
                    log::info!("Setting subject select to empty");
                    subject_element.set_value("");
                }
            }
        }
    });

    // Effect to update grade select when state changes
    Effect::new(move |_| {
        let current_state = state.get();
        if let Some(grade_element) = grade_ref.get() {
            match current_state.grade {
                Some(grade) => {
                    let formatted = format!("{}", grade);
                    log::info!("Setting grade select to: {}", formatted);
                    grade_element.set_value(&formatted);
                }
                None => {
                    log::info!("Setting grade select to empty");
                    grade_element.set_value("");
                }
            }
        }
    });

    // Effect to update scope select when state changes
    Effect::new(move |_| {
        let current_state = state.get();
        if let Some(scope_element) = scope_ref.get() {
            match current_state.scope {
                Some(scope) => {
                    let formatted = format!("{}", scope);
                    log::info!("Setting scope select to: {}", formatted);
                    scope_element.set_value(&formatted);
                }
                None => {
                    log::info!("Setting scope select to empty");
                    scope_element.set_value("");
                }
            }
        }
    });

    view! {
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 bg-white p-4 rounded-lg">
            <div>
                <label for="name" class="block text-sm font-medium mb-1 text-gray-700">"Name"</label>
                <input
                    type="text"
                    id="name"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] text-gray-900 bg-white"
                    prop:value={move || state.get().name}
                    on:input=move |ev| set_state.update(|s| s.name = event_target_value(&ev))
                    required
                />
            </div>

            <div>
                <label for="subject" class="block text-sm font-medium mb-1 text-gray-700">"Subject"</label>
                <select
                    node_ref=subject_ref
                    id="subject"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] bg-white text-gray-900"
                    on:change=move |ev| {
                        let value = event_target_value(&ev);
                        log::info!("Subject select changed to: {}", value);
                        if value.is_empty() {
                            set_state.update(|s| s.subject = None);
                        } else {
                            match value.parse::<SubjectEnum>() {
                                Ok(subject_enum) => set_state.update(|s| s.subject = Some(subject_enum)),
                                Err(_) => log::info!("Failed to parse subject: {}", value)
                            }
                        }
                    }
                >
                    <option value="" class="text-gray-900 bg-white">"None"</option>
                    {SubjectEnum::iter().map(|option| {
                        let option_value = format!("{}", option);
                        view! {
                            <option value=option_value.clone() class="text-gray-900 bg-white">
                                {option_value}
                            </option>
                        }
                    }).collect::<Vec<_>>()}
                </select>
            </div>

            <div>
                <label for="grade" class="block text-sm font-medium mb-1 text-gray-700">"Grade"</label>
                <select
                    node_ref=grade_ref
                    id="grade"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] bg-white text-gray-900"
                    on:change=move |ev| {
                        let value = event_target_value(&ev);
                        log::info!("Grade select changed to: {}", value);
                        if value.is_empty() {
                            set_state.update(|s| s.grade = None);
                        } else {
                            match value.parse::<GradeEnum>() {
                                Ok(grade_enum) => set_state.update(|s| s.grade = Some(grade_enum)),
                                Err(_) => log::info!("Failed to parse grade: {}", value)
                            }
                        }
                    }
                >
                    <option value="" class="text-gray-900 bg-white">"None"</option>
                    {GradeEnum::iter().map(|grade| {
                        let option_value = format!("{}", grade);
                        view! {
                            <option value=option_value.clone() class="text-gray-900 bg-white">
                                {option_value}
                            </option>
                        }
                    }).collect::<Vec<_>>()}
                </select>
            </div>

            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="frequency" class="block text-sm font-medium mb-1 text-gray-700">"Frequency (per year)"</label>
                    <input
                        type="number"
                        id="frequency"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] text-gray-900 bg-white"
                        prop:value={move || state.get().frequency.unwrap_or(0)}
                        on:input=move |ev| {
                            let value = event_target_value(&ev);
                            if value.is_empty() {
                                set_state.update(|s| s.frequency = None);
                            } else if let Ok(f) = value.parse::<i32>() {
                                set_state.update(|s| s.frequency = Some(f));
                            }
                        }
                    />
                </div>

                <div>
                    <label for="version" class="block text-sm font-medium mb-1 text-gray-700">"Version"</label>
                    <input
                        type="number"
                        id="version"
                        min="1"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] text-gray-900 bg-white"
                        prop:value={move || state.get().version}
                        on:input=move |ev| {
                            if let Ok(v) = event_target_value(&ev).parse::<i32>() {
                                set_state.update(|s| s.version = v);
                            }
                        }
                        required
                    />
                </div>
            </div>

            <div>
                <label for="scope" class="block text-sm font-medium mb-1 text-gray-700">"Scope"</label>
                <select
                    node_ref=scope_ref
                    id="scope"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] bg-white text-gray-900"
                    on:change=move |ev| {
                        let value = event_target_value(&ev);
                        log::info!("Scope select changed to: {}", value);
                        if value.is_empty() {
                            set_state.update(|s| s.scope = None);
                        } else {
                            match value.parse::<ScopeEnum>() {
                                Ok(scope_enum) => set_state.update(|s| s.scope = Some(scope_enum)),
                                Err(_) => log::info!("Failed to parse scope: {}", value)
                            }
                        }
                    }
                >
                    <option value="" class="text-gray-900 bg-white">"None"</option>
                    {ScopeEnum::iter().map(|option| {
                        let option_value = format!("{}", option);
                        view! {
                            <option value=option_value.clone() class="text-gray-900 bg-white">
                                {option_value}
                            </option>
                        }
                    }).collect::<Vec<_>>()}
                </select>
            </div>

            // Course selection (show when scope is Course)
            <Show when=move || state.get().scope == Some(ScopeEnum::Course)>
                <div>
                    <label for="course" class="block text-sm font-medium mb-1 text-gray-700">"Course"</label>
                    <select
                        id="course"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:border-[#2E3A59] bg-white text-gray-900"
                        prop:value={move || state.get().course_id.map(|id| id.to_string()).unwrap_or_default()}
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            if let Ok(course_id) = value.parse::<i32>() {
                                set_state.update(|s| s.course_id = Some(course_id));
                            } else {
                                set_state.update(|s| s.course_id = None);
                            }
                        }
                    >
                        <option value="">"Select a course"</option>
                        {move || {
                            courses_resource.get().map(|courses_result| {
                                match courses_result {
                                    Ok(courses) => {
                                        courses.into_iter().map(|course| {
                                            view! {
                                                <option value=course.id.to_string()>
                                                    {course.name}
                                                </option>
                                            }
                                        }).collect_view()
                                    },
                                    Err(_) => view! {}.into_any()
                                }
                            }).unwrap_or_default()
                        }}
                    </select>
                </div>
            </Show>
        </div>
    }
}
use crate::app::components::assessment_page::sequence_builder::{
    sequence_flow::SequenceFlow, test_add_panel::TestAddPanel,
};
use crate::app::components::assessment_page::shared::{
    hooks::{use_sequence_builder, UseSequenceBuilder},
    types::AssessmentFormState,
};
use crate::app::models::test::Test;
use leptos::prelude::*;

#[component]
pub fn SequenceBuilder(
    state: ReadSignal<AssessmentFormState>,
    set_state: WriteSignal<AssessmentFormState>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
) -> impl IntoView {
    let sequence_builder = use_sequence_builder();

    // Sync sequence changes to main state
    let update_sequence = move |new_sequence| {
        set_state.update(|s| s.test_sequence = new_sequence);
    };

    view! {
        <div class="sequence-builder bg-white p-6 rounded-lg border border-gray-200">
            <h4 class="text-gray-900 text-lg font-medium mb-4">"Advanced Visual Sequence Builder"</h4>

            <TestAddPanel
                tests_resource=tests_resource
                sequence_builder=sequence_builder.clone()
                current_sequence=Signal::derive(move || state.get().test_sequence)
                on_sequence_change=update_sequence
            />

            <SequenceFlow
                sequence=Signal::derive(move || state.get().test_sequence)
                tests_resource=tests_resource
                sequence_builder=sequence_builder
                on_sequence_change=update_sequence
            />
        </div>
    }
}
use crate::app::components::assessment_page::shared::{
    hooks::UseSequenceBuilder, types::get_behavior_display_props,
};
use crate::app::models::assessment_sequences::{
    SequenceBehavior, TestSequenceItem, VariationLevel,
};
use crate::app::models::test::Test;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn SequenceNode(
    seq_item: TestSequenceItem,
    all_tests: Vec<Test>,
    index: usize,
    sequence_builder: UseSequenceBuilder,
    current_sequence: Signal<Vec<TestSequenceItem>>,
    on_sequence_change: impl Fn(Vec<TestSequenceItem>) + 'static + Copy,
) -> impl IntoView {
    let item_test_id = seq_item.test_id;
    let has_variations = seq_item
        .variation_levels
        .as_ref()
        .map(|v| !v.is_empty())
        .unwrap_or(false);
    let variations = seq_item.variation_levels.clone().unwrap_or_default();

    let (node_color, icon, border_color, behavior_name) =
        get_behavior_display_props(&seq_item.sequence_behavior);

    let test = all_tests
        .iter()
        .find(|t| Uuid::parse_str(&t.test_id).unwrap_or_default() == item_test_id);
    let test_name = test
        .map(|t| t.name.clone())
        .unwrap_or_else(|| "Unknown".to_string());
    let short_name = if test_name.len() > 16 {
        format!("{}...", &test_name[0..13])
    } else {
        test_name.clone()
    };

    let dragging_item = sequence_builder.state.with(|s| s.dragging_item);
    let (show_details, set_show_details) = signal(false);

    let handle_drag_start = move |ev: leptos::ev::DragEvent| {
        ev.stop_propagation();
        if let Some(dt) = ev.data_transfer() {
            let _ = dt.set_data("text/plain", &index.to_string());
            let _ = dt.set_effect_allowed("move");
        }
        sequence_builder
            .set_state
            .update(|s| s.dragging_item = Some(index));
    };

    let handle_drop = move |ev: leptos::ev::DragEvent| {
        ev.prevent_default();
        ev.stop_propagation();

        if let Some(dt) = ev.data_transfer() {
            if let Ok(data) = dt.get_data("text/plain") {
                if let Ok(source_index) = data.parse::<usize>() {
                    if source_index != index {
                        let new_sequence = sequence_builder.reorder_sequence.call((
                            source_index,
                            index,
                            current_sequence.get(),
                        ));
                        on_sequence_change(new_sequence);
                    }
                }
            }
        }
        sequence_builder
            .set_state
            .update(|s| s.dragging_item = None);
    };

    let remove_test = move |_| {
        let new_sequence = sequence_builder
            .remove_from_sequence
            .call((item_test_id, current_sequence.get()));
        on_sequence_change(new_sequence);
    };

    view! {
        <div class="flex flex-col items-center w-48 min-h-96">
            // Main Test Node
            {
                let sequence_node_class = move || {
                    let base = "sequence-node relative group cursor-move transition-all duration-200 hover:scale-105 z-10";
                    if dragging_item == Some(index) {
                        format!("{} opacity-50", base)
                    } else {
                        base.to_string()
                    }
                };

                view! {
                    <div
                        class=sequence_node_class
                        draggable="true"
                        on:dragstart=handle_drag_start
                        on:dragover=move |ev: leptos::ev::DragEvent| {
                            ev.prevent_default();
                            ev.stop_propagation();
                        }
                        on:drop=handle_drop
                        on:dragend=move |_| {
                            sequence_builder.set_state.update(|s| s.dragging_item = None);
                        }
                    >
                        <div
                            class="w-20 h-20 rounded-full flex flex-col items-center justify-center text-white font-bold shadow-xl hover:shadow-2xl transition-shadow duration-200 relative"
                            style=format!("background: linear-gradient(135deg, {}, {}); border: 3px solid {}", node_color, node_color, border_color)
                        >
                            <div class="text-lg mb-1">{icon}</div>
                            <div class="text-xs font-bold bg-black bg-opacity-20 rounded-full w-5 h-5 flex items-center justify-center">
                                {seq_item.sequence_order}
                            </div>
                        </div>

                        // Action buttons
                        <div class="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity flex space-x-1 z-20">
                            <button
                                type="button"
                                class="w-6 h-6 bg-blue-500 text-white rounded-full text-xs hover:bg-blue-600 transition-colors shadow-md"
                                on:click=move |ev| {
                                    ev.stop_propagation();
                                    set_show_details.update(|val| *val = !*val);
                                }
                                title="View details"
                            >
                                "â“˜"
                            </button>
                            <button
                                type="button"
                                class="w-6 h-6 bg-red-500 text-white rounded-full text-xs hover:bg-red-600 transition-colors shadow-md"
                                on:click=remove_test
                                title="Remove test"
                            >
                                "Ã—"
                            </button>
                        </div>
                    </div>
                }
            }

            // Node Info
            <div class="mt-4 text-center w-full px-2">
                <div class="text-sm font-semibold text-gray-800 truncate mb-1" title={test_name.clone()}>
                    {short_name}
                </div>
                <div class="text-xs text-gray-600 bg-gray-100 rounded-full px-2 py-1 mb-1">
                    {behavior_name}
                </div>
                {if seq_item.sequence_behavior == SequenceBehavior::Attainment {
                    view! {
                        <div class="text-xs text-green-700 font-medium bg-green-100 rounded-full px-2 py-1 mb-1">
                            "Requires "{seq_item.required_score.unwrap_or(70)}"%"
                        </div>
                    }.into_any()
                } else {
                    view! {}.into_any()
                }}
                {if has_variations {
                    view! {
                        <div class="text-xs text-orange-600 font-bold bg-orange-100 rounded-full px-2 py-1">
                            {format!("{} Variation{}", variations.len(), if variations.len() == 1 { "" } else { "s" })}
                        </div>
                    }.into_any()
                } else {
                    view! {}.into_any()
                }}
            </div>

            // Variation Stack
            {if has_variations {
                view! {
                    <div class="mt-6 flex flex-col items-center">
                        <div class="bg-red-100 text-red-700 px-3 py-1 rounded-full text-xs font-bold border border-red-200 mb-3">
                            "ON FAIL â†“"
                        </div>
                        <VariationStack variations=variations all_tests=all_tests item_test_id=item_test_id />
                    </div>
                }.into_any()
            } else {
                view! { <div class="h-12"></div> }.into_any()
            }}

            // Details Panel
            <Show when=move || show_details.get()>
                <div class="mt-8 bg-white border border-gray-200 rounded-lg shadow-xl p-4 w-full max-w-sm z-30 relative">
                    <h6 class="font-semibold text-gray-800 mb-3 text-center">"Test Details"</h6>
                    <div class="space-y-3 text-sm">
                        <div class="bg-gray-50 p-2 rounded">
                            <div class="font-medium text-gray-700">"Name:"</div>
                            <div class="text-gray-900">{test_name.clone()}</div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="font-medium text-gray-700">"Behavior:"</div>
                                <div class="text-gray-900">{behavior_name}</div>
                            </div>
                            <div class="bg-gray-50 p-2 rounded">
                                <div class="font-medium text-gray-700">"Order:"</div>
                                <div class="text-gray-900">{seq_item.sequence_order}</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 text-center">
                        <button
                            type="button"
                            class="text-xs bg-gray-100 text-gray-700 px-3 py-1 rounded hover:bg-gray-200 transition-colors"
                            on:click=move |_| set_show_details.set(false)
                        >
                            "Close Details"
                        </button>
                    </div>
                </div>
            </Show>
        </div>
    }
}

#[component]
fn VariationStack(
    variations: Vec<VariationLevel>,
    all_tests: Vec<Test>,
    item_test_id: Uuid,
) -> impl IntoView {
    view! {
        <div class="flex flex-col items-center space-y-6 w-full">
            {variations.iter().enumerate().map(|(var_index, variation)| {
                let var_test = all_tests.iter().find(|t| {
                    Uuid::parse_str(&t.test_id).unwrap_or_default() == variation.test_id
                });
                let var_name = var_test.map(|t| t.name.clone()).unwrap_or_else(|| "Unknown".to_string());
                let is_same_test = variation.test_id == item_test_id;
                let display_icon = if is_same_test { "ðŸ“‹" } else { "ðŸ”„" };
                let var_short_name = if is_same_test {
                    "Same Test".to_string()
                } else if var_name.len() > 14 {
                    format!("{}...", &var_name[0..11])
                } else {
                    var_name.clone()
                };

                let (var_color, var_border) = match variation.level {
                    1 => ("#fb923c", "#ea580c"),
                    2 => ("#f97316", "#c2410c"),
                    3 => ("#ea580c", "#9a3412"),
                    _ => ("#f97316", "#c2410c")
                };

                view! {
                    <div class="relative group w-full flex flex-col items-center">
                        <div
                            class="w-16 h-16 rounded-full flex flex-col items-center justify-center text-white font-bold shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105 relative"
                            style=format!("background: linear-gradient(135deg, {}, {}); border: 2px solid {}", var_color, var_border, var_border)
                            title=format!("Level {} Variation: {} ({}% required)", variation.level, var_name, variation.required_score.unwrap_or(60))
                        >
                            <div class="text-sm font-bold">"L"{variation.level}</div>
                            <div class="text-xs bg-black bg-opacity-20 rounded px-1">
                                {variation.required_score.unwrap_or(60)}"%"
                            </div>
                        </div>

                        <div class="mt-3 text-center w-full px-2">
                            <div class="text-xs font-semibold text-orange-800 truncate mb-1" title={var_name.clone()}>
                                {var_short_name}
                            </div>
                            <div class="text-xs text-orange-600 bg-orange-100 rounded-full px-2 py-1 mb-1">
                                {if is_same_test {
                                    format!("{} Retry L{}", display_icon, variation.level)
                                } else {
                                    format!("{} {}", display_icon, variation.description.clone())
                                }}
                            </div>
                            <div class="text-xs text-orange-700 font-medium">
                                "Level "{variation.level}" â€¢ "{variation.max_attempts.unwrap_or(2)}" attempts"
                            </div>
                        </div>

                        {if var_index < variations.len() - 1 {
                            view! {
                                <div class="flex flex-col items-center mt-4">
                                    <div class="bg-red-100 text-red-600 px-2 py-1 rounded-full text-xs font-medium border border-red-200 mb-2">
                                        "STILL FAIL â†“"
                                    </div>
                                </div>
                            }.into_any()
                        } else {
                            view! {}.into_any()
                        }}
                    </div>
                }
            }).collect_view()}

            <div class="mt-6 flex flex-col items-center">
                <div class="bg-purple-100 text-purple-700 px-4 py-2 rounded-lg text-xs font-bold border border-purple-200 mb-2 text-center">
                    "ðŸš¨ TEACHER INTERVENTION"
                </div>
                <div class="text-xs text-gray-600 text-center max-w-40">
                    "All remediation attempts exhausted"
                </div>
            </div>
        </div>
    }
}
use super::variation_manager::VariationManager;
use crate::app::components::assessment_page::shared::{
    hooks::UseSequenceBuilder,
    types::{is_variation_test, SequenceBuilderState},
};
use crate::app::models::assessment_sequences::{
    SequenceBehavior, TestSequenceItem, VariationLevel,
};
use crate::app::models::test::Test;
use leptos::prelude::*;
use strum::IntoEnumIterator;
use uuid::Uuid;

#[component]
pub fn TestAddPanel(
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    sequence_builder: UseSequenceBuilder,
    current_sequence: Signal<Vec<TestSequenceItem>>,
    on_sequence_change: impl Fn(Vec<TestSequenceItem>) + 'static + Copy,
) -> impl IntoView {
    let (selected_test_for_sequence, set_selected_test_for_sequence) =
        create_signal::<Option<Uuid>>(None);
    let (sequence_behavior, set_sequence_behavior) = signal(SequenceBehavior::Node);
    let (required_score, set_required_score) = create_signal::<Option<i32>>(None);
    let (show_variations_panel, set_show_variations_panel) = signal(false);

    let (current_variations, set_current_variations) = create_signal::<Vec<VariationLevel>>(vec![]);

    let add_test_to_sequence = move |_| {
        if let Some(test_id) = selected_test_for_sequence.get() {
            let order = sequence_builder.state.get().sequence_counter;

            // CRITICAL FIX: Create the test item with the captured variations
            let new_item = match sequence_behavior.get() {
                SequenceBehavior::Attainment => {
                    let mut item = TestSequenceItem::new_attainment(
                        test_id,
                        order,
                        required_score.get().unwrap_or(70),
                        None,
                        None,
                    );
                    // CRITICAL FIX: Add the variations that were built up in the panel
                    let variations = current_variations.get();
                    if !variations.is_empty() {
                        item.variation_levels = Some(variations);
                    }
                    item
                }
                SequenceBehavior::Node => TestSequenceItem::new_node(test_id, order),
                SequenceBehavior::Optional => TestSequenceItem::new_optional(test_id, order),
                SequenceBehavior::Diagnostic => TestSequenceItem::new_diagnostic(test_id, order),
                SequenceBehavior::Remediation => {
                    TestSequenceItem::new_remediation(test_id, order, vec![])
                }
                SequenceBehavior::Branching => {
                    TestSequenceItem::new_branching(test_id, order, vec![])
                }
            };

            let mut current_seq = current_sequence.get();
            current_seq.push(new_item);
            current_seq.sort_by_key(|item| item.sequence_order);
            on_sequence_change(current_seq);

            // Update the sequence counter
            sequence_builder
                .set_state
                .update(|s| s.sequence_counter = order + 1);

            // Reset form
            set_selected_test_for_sequence.set(None);
            set_sequence_behavior.set(SequenceBehavior::Node);
            set_required_score.set(None);
            set_show_variations_panel.set(false);
            set_current_variations.set(vec![]); // CRITICAL FIX: Reset variations
        }
    };

    // Get available tests (not already used in sequence)
    let get_available_tests = move || -> Vec<Test> {
        let all_tests = tests_resource
            .get()
            .map(|r| r.ok())
            .flatten()
            .unwrap_or_default();

        //uncomment these lines to prevent re-using the same test within a sequence
        /*let current_seq = current_sequence.get();
        let used_test_ids: std::collections::HashSet<Uuid> =
            current_seq.iter().map(|item| item.test_id).collect();*/

        all_tests
            .into_iter()
            /*.filter(|test| {
                let test_uuid = Uuid::parse_str(&test.test_id).unwrap_or_default();
                !used_test_ids.contains(&test_uuid) && !is_variation_test(test)
            })*/
            .collect()
    };

    view! {
        <div class="add-test-panel bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
            <h5 class="text-gray-700 font-medium mb-3">"Add Test to Sequence"</h5>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">"Test"</label>
                    <select
                        class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-blue-500"
                        prop:value={move || selected_test_for_sequence.get().map(|id| id.to_string()).unwrap_or_default()}
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            if value.is_empty() {
                                set_selected_test_for_sequence.set(None);
                            } else if let Ok(uuid) = Uuid::parse_str(&value) {
                                set_selected_test_for_sequence.set(Some(uuid));
                            }
                        }
                    >
                        <option value="">"Select a test"</option>
                        {move || {
                            get_available_tests().into_iter().map(|test| {
                                view! {
                                    <option value=test.test_id.clone() class="text-gray-900">
                                        {test.name.clone()}
                                    </option>
                                }
                            }).collect_view()
                        }}
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">"Behavior"</label>
                    <select
                        class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-blue-500"
                        prop:value={move || format!("{:?}", sequence_behavior.get())}
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            match value.as_str() {
                                "Node" => {
                                    set_sequence_behavior.set(SequenceBehavior::Node);
                                    set_show_variations_panel.set(false);
                                },
                                "Attainment" => {
                                    set_sequence_behavior.set(SequenceBehavior::Attainment);
                                    set_show_variations_panel.set(true);
                                },
                                "Optional" => {
                                    set_sequence_behavior.set(SequenceBehavior::Optional);
                                    set_show_variations_panel.set(false);
                                },
                                "Diagnostic" => {
                                    set_sequence_behavior.set(SequenceBehavior::Diagnostic);
                                    set_show_variations_panel.set(false);
                                },
                                "Remediation" => {
                                    set_sequence_behavior.set(SequenceBehavior::Remediation);
                                    set_show_variations_panel.set(false);
                                },
                                "Branching" => {
                                    set_sequence_behavior.set(SequenceBehavior::Branching);
                                    set_show_variations_panel.set(false);
                                },
                                _ => {}
                            }
                        }
                    >
                        <option value="" class="text-gray-900">"Select Node Behavior"</option>
                        {SequenceBehavior::iter().map(|behavior| {
                            view! {
                                <option value=format!("{:?}", behavior) class="text-gray-900">
                                    {format!("{:?}", behavior)}
                                </option>
                            }
                        }).collect::<Vec<_>>()}
                    </select>
                </div>

                <Show when=move || matches!(sequence_behavior.get(), SequenceBehavior::Attainment)>
                    <div>
                        <label class="block text-sm font-medium text-gray-600 mb-1">"Required Score"</label>
                        <input
                            type="number"
                            class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-blue-500"
                            placeholder="70"
                            prop:value={move || required_score.get().unwrap_or(70)}
                            on:input=move |ev| {
                                if let Ok(score) = event_target_value(&ev).parse::<i32>() {
                                    set_required_score.set(Some(score));
                                }
                            }
                        />
                    </div>
                </Show>
            </div>

            <Show when=move || show_variations_panel.get() && matches!(sequence_behavior.get(), SequenceBehavior::Attainment)>
                <VariationManager
                    tests_resource=tests_resource
                    current_sequence=current_sequence
                    variations=current_variations
                    set_variations=set_current_variations
                    main_test_id=selected_test_for_sequence.get()
                />
            </Show>

            <div class="flex justify-end">
                <button
                    type="button"
                    class="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    on:click=add_test_to_sequence
                    disabled=move || selected_test_for_sequence.get().is_none()
                >
                    "Add to Sequence"
                </button>
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod sequence_builder;
pub mod sequence_flow;
pub mod sequence_node;
pub mod test_add_panel;
pub mod variation_manager;

pub use sequence_builder::SequenceBuilder;
pub use sequence_flow::SequenceFlow;
pub use sequence_node::SequenceNode;
pub use variation_manager::VariationManager;
use crate::app::components::assessment_page::shared::types::is_variation_test;
use crate::app::models::assessment_sequences::{TestSequenceItem, VariationLevel};
use crate::app::models::test::Test;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn VariationManager(
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    current_sequence: Signal<Vec<TestSequenceItem>>,
    variations: ReadSignal<Vec<VariationLevel>>,
    set_variations: WriteSignal<Vec<VariationLevel>>,
    main_test_id: Option<Uuid>,
) -> impl IntoView {
    let (editing_variation_index, set_editing_variation_index) =
        create_signal::<Option<usize>>(None);

    // Form fields for adding/editing variations
    let (var_test_id, set_var_test_id) = create_signal::<Option<Uuid>>(None);
    let (var_level, set_var_level) = signal(1);
    let (var_description, set_var_description) = signal(String::new());
    let (var_required_score, set_var_required_score) = signal(60);
    let (var_max_attempts, set_var_max_attempts) = signal(2);
    let (use_same_test, set_use_same_test) = signal(true);

    // Get available variation tests
    let get_available_variation_tests = move || -> Vec<Test> {
        let all_tests = tests_resource
            .get()
            .map(|r| r.ok())
            .flatten()
            .unwrap_or_default();
        /*let current_seq = current_sequence.get();
        let current_variations = variations.get();

        let used_test_ids: std::collections::HashSet<Uuid> = current_seq
            .iter()
            .flat_map(|item| {
                let mut ids = vec![item.test_id];
                if let Some(variations) = &item.variation_levels {
                    ids.extend(variations.iter().map(|v| v.test_id));
                }
                ids
            })
            .chain(current_variations.iter().map(|v| v.test_id))
            .collect();*/

        all_tests
            .into_iter()
            /*.filter(|test| {
                let test_uuid = Uuid::parse_str(&test.test_id).unwrap_or_default();
                !used_test_ids.contains(&test_uuid) && is_variation_test(test)
            })*/
            .collect()
    };

    let reset_variation_form = move || {
        set_var_test_id.set(None);
        set_var_level.set(1);
        set_var_description.set(String::new());
        set_var_required_score.set(60);
        set_var_max_attempts.set(2);
        set_editing_variation_index.set(None);
        set_use_same_test.set(true);
    };

    let save_variation = move |_| {
        let final_test_id = if use_same_test.get() {
            main_test_id.unwrap_or_else(|| var_test_id.get().unwrap_or_default())
        } else {
            var_test_id.get().unwrap_or_default()
        };

        if final_test_id != Uuid::default() {
            let new_variation = VariationLevel {
                level: var_level.get(),
                test_id: final_test_id,
                required_score: Some(var_required_score.get()),
                max_attempts: Some(var_max_attempts.get()),
                description: var_description.get(),
            };

            let mut current_variations = variations.get();

            if let Some(index) = editing_variation_index.get() {
                current_variations[index] = new_variation;
            } else {
                current_variations.push(new_variation);
            }

            current_variations.sort_by_key(|v| v.level);
            set_variations.set(current_variations);
            reset_variation_form();
        }
    };

    let edit_variation = move |index: usize| {
        let variation_list = variations.get();
        if let Some(variation) = variation_list.get(index) {
            let is_same_test = main_test_id
                .map(|main_id| main_id == variation.test_id)
                .unwrap_or(false);

            set_var_test_id.set(Some(variation.test_id));
            set_var_level.set(variation.level);
            set_var_description.set(variation.description.clone());
            set_var_required_score.set(variation.required_score.unwrap_or(60));
            set_var_max_attempts.set(variation.max_attempts.unwrap_or(2));
            set_editing_variation_index.set(Some(index));
            set_use_same_test.set(is_same_test);
        }
    };

    let remove_variation = move |index: usize| {
        let mut variation_list = variations.get(); // CRITICAL FIX: Use passed variations
        variation_list.remove(index);
        set_variations.set(variation_list); // CRITICAL FIX: Update passed variations
        reset_variation_form();
    };

    view! {
        <div class="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4">
            <div class="flex items-center justify-between mb-3">
                <h6 class="text-orange-800 font-medium">"Multi-Level Variation Tests (On Fail)"</h6>
            </div>
            <p class="text-xs text-orange-700 mb-4">
                "Students will progress through these variations vertically if they fail the main test. Maximum 3 levels."
            </p>

            <VariationStackDisplay
                variations=variations
                tests_resource=tests_resource
                main_test_id=main_test_id
                on_edit=edit_variation
                on_remove=remove_variation
            />

            // Add/Edit Variation Form
            <div class="bg-white rounded-lg border border-orange-200 p-4">
                <div class="text-sm font-medium text-orange-800 mb-3">
                    {move || if editing_variation_index.get().is_some() { "Edit Variation" } else { "Add New Variation" }}
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="col-span-2 mb-4">
                        <div class="flex items-center space-x-2">
                            <label class="inline-flex items-center">
                                <input
                                    type="radio"
                                    name="test_selection_mode"
                                    class="form-radio h-4 w-4 text-orange-600"
                                    prop:checked={move || use_same_test.get()}
                                    on:change=move |_| set_use_same_test.set(true)
                                />
                                <span class="ml-2 text-sm text-orange-700">"Use same test as main (different difficult/attempts)"</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input
                                    type="radio"
                                    name="test_selection_mode"
                                    class="form-radio h-4 w-4 text-orange-600"
                                    prop:checked={move || !use_same_test.get()}
                                    on:change=move |_| set_use_same_test.set(false)
                                />
                                <span class="ml-2 text-sm text-orange-700">"Use different test"</span>
                            </label>
                        </div>
                    </div>

                    <Show when=move || !use_same_test.get()>
                        <div>
                            <label class="block text-xs font-medium text-orange-700 mb-1">"Variation Test"</label>
                            <select
                                class="w-full px-3 py-2 border border-orange-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-orange-500 text-sm"
                                prop:value={move || var_test_id.get().map(|id| id.to_string()).unwrap_or_default()}
                                on:change=move |ev| {
                                    let value = event_target_value(&ev);
                                    if value.is_empty() {
                                        set_var_test_id.set(None);
                                    } else if let Ok(uuid) = Uuid::parse_str(&value) {
                                        set_var_test_id.set(Some(uuid));
                                    }
                                }
                            >
                                <option value="">"Select variation test"</option>
                                {move || {
                                    get_available_variation_tests().into_iter().map(|test| {
                                        view! {
                                            <option value=test.test_id.clone() class="text-gray-900">
                                                {test.name.clone()}
                                            </option>
                                        }
                                    }).collect_view()
                                }}
                            </select>
                        </div>
                    </Show>

                    <Show when=move || use_same_test.get()>
                        <div>
                            <label class="block text-xs font-medium text-orange-700 mb-1">"Using Main Test"</label>
                            <div class="w-full px-3 py-2 border border-orange-300 rounded-md bg-orange-50 text-orange-800 text-sm">
                                {move || {
                                    if let Some(main_id) = main_test_id {
                                        let all_tests = tests_resource
                                            .get()
                                            .map(|r| r.ok())
                                            .flatten()
                                            .unwrap_or_default();
                                        all_tests.iter()
                                            .find(|t| Uuid::parse_str(&t.test_id).unwrap_or_default() == main_id)
                                            .map(|t|format!("ðŸ“‹ {} (Main Test)", t.name))
                                            .unwrap_or_else(|| "Main Test".to_string())
                                    } else {
                                        "Main Test".to_string()
                                    }
                                }}
                            </div>
                        </div>
                    </Show>

                    <div>
                        <label class="block text-xs font-medium text-orange-700 mb-1">"Level (1-3)"</label>
                        <select
                            class="w-full px-3 py-2 border border-orange-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-orange-500 text-sm"
                            prop:value={move || var_level.get().to_string()}
                            on:change=move |ev| {
                                if let Ok(level) = event_target_value(&ev).parse::<i32>() {
                                    set_var_level.set(level);
                                }
                            }
                        >
                            <option value="1">"Level 1 (First try)"</option>
                            <option value="2">"Level 2 (Second try)"</option>
                            <option value="3">"Level 3 (Final try)"</option>
                        </select>
                    </div>

                    <div>
                        <label class="block text-xs font-medium text-orange-700 mb-1">"Description"</label>
                        <input
                            type="text"
                            class="w-full px-3 py-2 border border-orange-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-orange-500 text-sm"
                            placeholder="e.g., Practice Mode, Guided Version"
                            prop:value={move || var_description.get()}
                            on:input=move |ev| set_var_description.set(event_target_value(&ev))
                        />
                    </div>

                    <div>
                        <label class="block text-xs font-medium text-orange-700 mb-1">"Required Score %"</label>
                        <input
                            type="number"
                            min="0"
                            max="100"
                            class="w-full px-3 py-2 border border-orange-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-orange-500 text-sm"
                            prop:value={move || var_required_score.get()}
                            on:input=move |ev| {
                                if let Ok(score) = event_target_value(&ev).parse::<i32>() {
                                    set_var_required_score.set(score);
                                }
                            }
                        />
                    </div>
                </div>

                <div class="flex justify-between items-center">
                    <div class="text-xs text-orange-600">
                        {move || {
                            let count = variations.get().len(); // CRITICAL FIX: Use passed variations
                            if count >= 3 && editing_variation_index.get().is_none() {
                                "Maximum 3 variations reached".to_string()
                            } else {
                                format!("{}/3 variations used", count)
                            }
                        }}
                    </div>

                    <div class="flex space-x-2">
                        <Show when=move || editing_variation_index.get().is_some()>
                            <button
                                type="button"
                                class="px-3 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
                                on:click=move |_| reset_variation_form()
                            >
                                "Cancel"
                            </button>
                        </Show>

                        <button
                            type="button"
                            class="px-3 py-1 text-xs bg-orange-600 text-white rounded hover:bg-orange-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            on:click=save_variation
                            disabled=move || {
                                let has_test = use_same_test.get() || var_test_id.get().is_some();
                                let has_description = !var_description.get().trim().is_empty();
                                let count = variations.get().len();
                                let is_editing = editing_variation_index.get().is_some();

                                !has_test || !has_description || (count >= 3 && !is_editing)
                            }
                        >
                            {move || if editing_variation_index.get().is_some() { "Update" } else { "Add Variation" }}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    }
}

#[component]
fn VariationStackDisplay(
    variations: ReadSignal<Vec<VariationLevel>>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    main_test_id: Option<Uuid>,
    on_edit: impl Fn(usize) + 'static + Copy,
    on_remove: impl Fn(usize) + 'static + Copy,
) -> impl IntoView {
    view! {
        <div class="mb-4">
            <div class="text-sm font-medium text-orange-800 mb-2">"Current Variation Stack"</div>
            <div class="bg-white rounded-lg border border-orange-200 p-3">
                {move || {
                    variations.with(|variation_list| {
                        if variation_list.is_empty() {
                            view! {
                                <div class="text-center text-gray-500 py-4">
                                    <div class="mb-2">"ðŸ“"</div>
                                    <div class="text-xs">"No variations added yet"</div>
                                    <div class="text-xs text-gray-400">"Add up to 3 levels below"</div>
                                </div>
                            }.into_any()
                        } else {
                            let all_tests = tests_resource.get().map(|r| r.ok()).flatten().unwrap_or_default();

                            view! {
                                <div class="flex flex-col items-center space-y-3">
                                    {variation_list.iter().enumerate().map(|(index, variation)| {
                                        let test = all_tests.iter().find(|t| {
                                            Uuid::parse_str(&t.test_id).unwrap_or_default() == variation.test_id
                                        });
                                        let test_name = test.map(|t| t.name.clone()).unwrap_or_else(|| "Unknown".to_string());

                                        // Check if this variation uses the same test as main
                                        let is_same_test = main_test_id
                                            .map(|main_id| main_id == variation.test_id)
                                            .unwrap_or(false);

                                        let level_color = match variation.level {
                                            1 => "#fb923c",
                                            2 => "#f97316",
                                            3 => "#ea580c",
                                            _ => "#f97316"
                                        };

                                        view! {
                                            <div class="relative group">
                                                <div
                                                    class="w-16 h-16 rounded-full flex flex-col items-center justify-center text-white font-bold text-xs shadow-md border-2"
                                                    style=format!("background-color: {}; border-color: {}", level_color, level_color)
                                                >
                                                    <div class="text-sm">"L"{variation.level}</div>
                                                    <div class="text-xs">{variation.required_score.unwrap_or(60)}"%"</div>
                                                </div>

                                                <div class="absolute -bottom-12 left-1/2 transform -translate-x-1/2 text-center">
                                                    <div class="text-xs font-medium text-orange-700 whitespace-nowrap max-w-20 truncate">
                                                        {if is_same_test {
                                                            format!("ðŸ“‹ {}", test_name)
                                                        } else {
                                                            format!("ðŸ”„ {}", test_name)
                                                        }}
                                                    </div>
                                                    <div class="text-xs text-orange-600">{variation.description.clone()}</div>
                                                </div>

                                                <div class="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity flex space-x-1">
                                                    <button
                                                        type="button"
                                                        class="w-5 h-5 bg-blue-500 text-white rounded-full text-xs hover:bg-blue-600 transition-colors"
                                                        on:click=move |_| on_edit(index)
                                                        title="Edit"
                                                    >
                                                        "âœŽ"
                                                    </button>
                                                    <button
                                                        type="button"
                                                        class="w-5 h-5 bg-red-500 text-white rounded-full text-xs hover:bg-red-600 transition-colors"
                                                        on:click=move |_| on_remove(index)
                                                        title="Remove"
                                                    >
                                                        "Ã—"
                                                    </button>
                                                </div>
                                            </div>

                                            {if index < variation_list.len() - 1 {
                                                view! {
                                                    <div class="text-orange-400">
                                                        <svg width="16" height="20" viewBox="0 0 16 20" fill="currentColor">
                                                            <path d="M8 18l-4-4h3V2h2v12h3l-4 4z"/>
                                                        </svg>
                                                    </div>
                                                }.into_any()
                                            } else {
                                                view! {}.into_any()
                                            }}
                                        }
                                    }).collect_view()}

                                    {if !variation_list.is_empty() {
                                        view! {
                                            <div class="mt-2 px-3 py-1 bg-gray-100 rounded-full">
                                                <div class="text-xs text-gray-600">"Teacher Intervention"</div>
                                            </div>
                                        }.into_any()
                                    } else {
                                        view! {}.into_any()
                                    }}
                                </div>
                            }.into_any()
                        }
                    })
                }}
            </div>
        </div>
    }
}
use super::sequence_node::SequenceNode;
use crate::app::components::assessment_page::shared::hooks::UseSequenceBuilder;
use crate::app::models::assessment_sequences::TestSequenceItem;
use crate::app::models::test::Test;
use leptos::prelude::*;

#[component]
pub fn SequenceFlow(
    sequence: Signal<Vec<TestSequenceItem>>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    sequence_builder: UseSequenceBuilder,
    on_sequence_change: impl Fn(Vec<TestSequenceItem>) + 'static + Copy,
) -> impl IntoView {
    view! {
        <div class="sequence-flow-container bg-white border-2 border-dashed border-gray-300 rounded-lg p-6 min-h-96">
            <div class="flex items-center justify-between mb-6">
                <h5 class="text-gray-700 font-medium">"Visual Sequence Flow with Vertical Variation Stacks"</h5>
                <div class="text-sm text-gray-500">
                    {move || {
                        let count = sequence.get().len();
                        format!("{} test{} in sequence", count, if count == 1 { "" } else { "s" })
                    }}
                </div>
            </div>

            {move || {
                let seq = sequence.get();
                if seq.is_empty() {
                    view! {
                        <div class="flex items-center justify-center h-48 text-gray-500 text-sm">
                            <div class="text-center">
                                <div class="mb-4 text-4xl">"ðŸ”„"</div>
                                <div class="text-lg font-medium mb-2">"No tests in sequence yet"</div>
                                <div class="text-gray-400">"Add tests above to build your assessment flow"</div>
                            </div>
                        </div>
                    }.into_any()
                } else {
                    let all_tests = tests_resource.get().map(|r| r.ok()).flatten().unwrap_or_default();

                    view! {
                        <div class="overflow-x-auto pb-4">
                            <div class="flex items-start gap-8 min-w-fit" style="min-width: max-content;">
                                {seq.iter().enumerate().map(|(index, seq_item)| {
                                    view! {
                                        <div class="flex items-start shrink-0">
                                            <SequenceNode
                                                seq_item=seq_item.clone()
                                                all_tests=all_tests.clone()
                                                index=index
                                                sequence_builder=sequence_builder.clone()
                                                current_sequence=sequence
                                                on_sequence_change=on_sequence_change
                                            />

                                            {if index < seq.len() - 1 {
                                                view! {
                                                    <div class="flex items-center justify-center h-20 mx-4 mt-16">
                                                        <div class="flex flex-col items-center">
                                                            <div class="bg-blue-100 text-blue-700 px-2 py-1 rounded-full text-xs font-medium mb-1">
                                                                "PASS"
                                                            </div>
                                                            <svg width="32" height="16" viewBox="0 0 32 16" fill="currentColor" class="text-blue-500">
                                                                <path d="M24 8l-4-4v3H4v2h16v3l4-4z"/>
                                                            </svg>
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            } else {
                                                view! {
                                                    <div class="flex items-center justify-center h-20 mx-4 mt-16">
                                                        <div class="bg-green-100 text-green-700 px-3 py-2 rounded-full text-sm font-medium">
                                                            "ðŸŽ¯ COMPLETE"
                                                        </div>
                                                    </div>
                                                }.into_any()
                                            }}
                                        </div>
                                    }
                                }).collect_view()}
                            </div>
                        </div>

                        <SequenceFlowLegend />
                    }.into_any()
                }
            }}
        </div>
    }
}

#[component]
fn SequenceFlowLegend() -> impl IntoView {
    view! {
        <div class="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="bg-blue-50 rounded-lg border border-blue-200 p-4">
                <h6 class="text-sm font-semibold mb-3 text-blue-900">"Test Behaviors"</h6>
                <div class="space-y-2">
                    <LegendItem color="bg-green-500" label="Attainment (âœ“)" description="Requires specific score to pass" />
                    <LegendItem color="bg-blue-500" label="Node (â†’)" description="Simple progression test" />
                    <LegendItem color="bg-gray-500" label="Optional (?)" description="Can be skipped" />
                    <LegendItem color="bg-purple-500" label="Diagnostic (ðŸ“Š)" description="Assessment only" />
                </div>
            </div>

            <div class="bg-orange-50 rounded-lg border border-orange-200 p-4">
                <h6 class="text-sm font-semibold mb-3 text-orange-900">"Variation System"</h6>
                <div class="space-y-2">
                    <LegendItem color="bg-orange-400" label="Level 1" description="First remediation attempt" />
                    <LegendItem color="bg-orange-500" label="Level 2" description="Second remediation attempt" />
                    <LegendItem color="bg-orange-600" label="Level 3" description="Final remediation attempt" />
                </div>
                <div class="mt-3 p-2 bg-orange-100 rounded text-xs text-orange-800">
                    <span class="font-medium">"Flow:"</span>
                    " Student fails main â†’ L1 â†’ L2 â†’ L3 â†’ Teacher intervention"
                </div>
            </div>
        </div>
    }
}

#[component]
fn LegendItem(
    color: &'static str,
    label: &'static str,
    description: &'static str,
) -> impl IntoView {
    view! {
        <div class="flex items-center text-xs text-blue-800">
            <div class=format!("w-4 h-4 rounded-full {} mr-3", color)></div>
            <div class="flex-1">
                <span class="font-medium">{label}</span>
                <div class="text-blue-600">{description}</div>
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod assessment_form;
pub mod assessment_list;
pub mod sequence_builder;
pub mod shared;
use super::types::*;
use crate::app::models::assessment::Assessment;
use leptos::prelude::*;
use leptos::prelude::*;
use uuid::Uuid;

#[derive(Clone)]
pub struct UseAssessmentForm {
    pub state: ReadSignal<AssessmentFormState>,
    pub set_state: WriteSignal<AssessmentFormState>,
    pub editing: ReadSignal<bool>,
    pub set_editing: WriteSignal<bool>,
    pub selected_assessment_id: ReadSignal<Option<Uuid>>,
    pub set_selected_assessment_id: WriteSignal<Option<Uuid>>,
    pub reset_form: Callback<()>,
    pub load_assessment: Callback<Assessment>,
}

pub fn use_assessment_form() -> UseAssessmentForm {
    let (state, set_state) = signal(AssessmentFormState::default());
    let (editing, set_editing) = signal(false);
    let (selected_assessment_id, set_selected_assessment_id) = create_signal::<Option<Uuid>>(None);

    let reset_form = Callback::new(move |_: ()| {
        set_state.set(AssessmentFormState::default());
        set_editing.set(false);
        set_selected_assessment_id.set(None);
    });

    let load_assessment = Callback::new(move |assessment: Assessment| {
        log::info!("Loading assessment for editing: {:?}", assessment.name);

        // Start with default state to ensure all fields are properly initialized
        let mut new_state = AssessmentFormState {
            // Populate all the basic fields
            name: assessment.name.clone(),
            frequency: assessment.frequency,
            grade: assessment.grade,
            version: assessment.version,
            subject: assessment.subject,
            scope: assessment.scope,
            course_id: assessment.course_id,
            risk_benchmarks: assessment.risk_benchmarks.clone(),
            national_benchmarks: assessment.national_benchmarks.clone(),

            ..AssessmentFormState::default()
        };

        // Handle test sequences vs simple test selection
        if let Some(sequence) = assessment.test_sequence.clone() {
            if !sequence.is_empty() {
                // Assessment uses sequences
                log::info!(
                    "Loading assessment with sequences: {} items",
                    sequence.len()
                );
                new_state.use_sequences = true;
                new_state.test_sequence = sequence;
                new_state.selected_tests = vec![]; // Clear simple test selection
            } else {
                // Assessment has empty sequence, use simple test selection
                log::info!(
                    "Loading assessment with empty sequence, using simple tests: {} items",
                    assessment.tests.len()
                );
                new_state.use_sequences = false;
                new_state.test_sequence = vec![];
                new_state.selected_tests = assessment.tests.clone();
            }
        } else {
            // No sequence data, definitely using simple test selection
            log::info!(
                "Loading assessment with simple tests: {} items",
                assessment.tests.len()
            );
            new_state.use_sequences = false;
            new_state.test_sequence = vec![];
            new_state.selected_tests = assessment.tests.clone();
        }

        log::info!(
            "Final state - use_sequences: {}, selected_tests: {:?}, test_sequence: {:?}",
            new_state.use_sequences,
            new_state.selected_tests,
            new_state.test_sequence
        );

        // Apply the state
        set_state.set(new_state);
        set_editing.set(true);
        set_selected_assessment_id.set(Some(assessment.id));
    });

    UseAssessmentForm {
        state,
        set_state,
        editing,
        set_editing,
        selected_assessment_id,
        set_selected_assessment_id,
        reset_form,
        load_assessment,
    }
}

#[derive(Clone)]
pub struct UseSequenceBuilder {
    pub state: ReadSignal<SequenceBuilderState>,
    pub set_state: WriteSignal<SequenceBuilderState>,
    pub add_test_to_sequence: Callback<
        (
            Uuid,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        ),
        Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
    >,
    pub remove_from_sequence: Callback<
        (
            Uuid,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        ),
        Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
    >,
    pub reorder_sequence: Callback<
        (
            usize,
            usize,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        ),
        Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
    >,
}

pub fn use_sequence_builder() -> UseSequenceBuilder {
    let (state, set_state) = signal(SequenceBuilderState::default());

    let add_test_to_sequence = Callback::new(
        move |(test_id, current_sequence): (
            Uuid,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        )|
              -> Vec<crate::app::models::assessment_sequences::TestSequenceItem> {
            let current_state = state.get();
            let order = current_state.sequence_counter;

            let new_item = match current_state.sequence_behavior {
                crate::app::models::assessment_sequences::SequenceBehavior::Attainment => {
                    let mut item =
                        crate::app::models::assessment_sequences::TestSequenceItem::new_attainment(
                            test_id,
                            order,
                            current_state.required_score.unwrap_or(70),
                            None,
                            None,
                        );
                    if !current_state.variation_levels.is_empty() {
                        item.variation_levels = Some(current_state.variation_levels.clone());
                    }
                    item
                }
                crate::app::models::assessment_sequences::SequenceBehavior::Node => {
                    crate::app::models::assessment_sequences::TestSequenceItem::new_node(
                        test_id, order,
                    )
                }
                crate::app::models::assessment_sequences::SequenceBehavior::Optional => {
                    crate::app::models::assessment_sequences::TestSequenceItem::new_optional(
                        test_id, order,
                    )
                }
                crate::app::models::assessment_sequences::SequenceBehavior::Diagnostic => {
                    crate::app::models::assessment_sequences::TestSequenceItem::new_diagnostic(
                        test_id, order,
                    )
                }
                crate::app::models::assessment_sequences::SequenceBehavior::Remediation => {
                    crate::app::models::assessment_sequences::TestSequenceItem::new_remediation(
                        test_id,
                        order,
                        vec![],
                    )
                }
                crate::app::models::assessment_sequences::SequenceBehavior::Branching => {
                    crate::app::models::assessment_sequences::TestSequenceItem::new_branching(
                        test_id,
                        order,
                        vec![],
                    )
                }
            };

            let mut updated_sequence = current_sequence;
            updated_sequence.push(new_item);
            updated_sequence.sort_by_key(|item| item.sequence_order);

            // Update counter
            set_state.update(|s| s.sequence_counter = order + 1);

            updated_sequence
        },
    );

    let remove_from_sequence = Callback::new(
        move |(test_id, current_sequence): (
            Uuid,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        )|
              -> Vec<crate::app::models::assessment_sequences::TestSequenceItem> {
            let mut updated = current_sequence;
            updated.retain(|item| item.test_id != test_id);

            // Reorder
            for (index, item) in updated.iter_mut().enumerate() {
                item.sequence_order = (index + 1) as i32;
            }

            updated
        },
    );

    let reorder_sequence = Callback::new(
        move |(source_index, target_index, current_sequence): (
            usize,
            usize,
            Vec<crate::app::models::assessment_sequences::TestSequenceItem>,
        )|
              -> Vec<crate::app::models::assessment_sequences::TestSequenceItem> {
            if source_index == target_index {
                return current_sequence;
            }

            let mut updated = current_sequence;
            if source_index < updated.len() && target_index < updated.len() {
                let item = updated.remove(source_index);
                updated.insert(target_index, item);

                // Reorder sequence numbers
                for (index, item) in updated.iter_mut().enumerate() {
                    item.sequence_order = (index + 1) as i32;
                }
            }

            updated
        },
    );

    UseSequenceBuilder {
        state,
        set_state,
        add_test_to_sequence,
        remove_from_sequence,
        reorder_sequence,
    }
}
use leptos::prelude::*;
pub mod types;
pub mod hooks;
use crate::app::models::assessment::{Assessment, RangeCategory, ScopeEnum, SubjectEnum};
use crate::app::models::assessment_sequences::{
    SequenceBehavior, TestSequenceItem, VariationLevel,
};
use crate::app::models::student::GradeEnum;
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;
use uuid::Uuid;

#[derive(Clone, Debug)]
pub struct AssessmentFormState {
    pub name: String,
    pub frequency: Option<i32>,
    pub grade: Option<GradeEnum>,
    pub version: i32,
    pub subject: Option<SubjectEnum>,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
    pub selected_tests: Vec<Uuid>,
    pub test_sequence: Vec<TestSequenceItem>,
    pub use_sequences: bool,
    pub risk_benchmarks: Option<Vec<RangeCategory>>,
    pub national_benchmarks: Option<Vec<RangeCategory>>,
}

impl Default for AssessmentFormState {
    fn default() -> Self {
        Self {
            name: String::new(),
            frequency: None,
            grade: None,
            version: 1,
            subject: None,
            scope: None,
            course_id: None,
            selected_tests: vec![],
            test_sequence: vec![],
            use_sequences: false,
            risk_benchmarks: None,
            national_benchmarks: None,
        }
    }
}

#[derive(Clone, Debug)]
pub struct SequenceBuilderState {
    pub sequence_counter: i32,
    pub dragging_item: Option<usize>,
    pub show_sequence_details: Option<usize>,
    pub selected_test_for_sequence: Option<Uuid>,
    pub sequence_behavior: SequenceBehavior,
    pub required_score: Option<i32>,
    pub variation_levels: Vec<VariationLevel>,
    pub show_variations_panel: bool,
    pub editing_variation_index: Option<usize>,
}

impl Default for SequenceBuilderState {
    fn default() -> Self {
        Self {
            sequence_counter: 1,
            dragging_item: None,
            show_sequence_details: None,
            selected_test_for_sequence: None,
            sequence_behavior: SequenceBehavior::Node,
            required_score: None,
            variation_levels: vec![],
            show_variations_panel: false,
            editing_variation_index: None,
        }
    }
}

#[derive(Clone, Debug)]
pub struct BenchmarkFormState {
    pub min: i32,
    pub max: i32,
    pub label: String,
}

impl Default for BenchmarkFormState {
    fn default() -> Self {
        Self {
            min: 0,
            max: 0,
            label: String::new(),
        }
    }
}

// Common utility functions
pub fn is_variation_test(test: &Test) -> bool {
    test.name.contains(" - ")
        && (test.name.to_lowercase().contains("randomized")
            || test.name.to_lowercase().contains("distinct")
            || test.name.to_lowercase().contains("practice")
            || test.comments.to_lowercase().contains("variation:"))
}

pub fn get_behavior_display_props(
    behavior: &SequenceBehavior,
) -> (&'static str, &'static str, &'static str, &'static str) {
    match behavior {
        SequenceBehavior::Node => ("#3b82f6", "â†’", "#2563eb", "Node"),
        SequenceBehavior::Attainment => ("#10b981", "âœ“", "#059669", "Attainment"),
        SequenceBehavior::Optional => ("#6b7280", "?", "#4b5563", "Optional"),
        SequenceBehavior::Diagnostic => ("#8b5cf6", "ðŸ“Š", "#7c3aed", "Diagnostic"),
        SequenceBehavior::Remediation => ("#f59e0b", "ðŸ”§", "#d97706", "Remediation"),
        SequenceBehavior::Branching => ("#eab308", "âš¡", "#ca8a04", "Branching"),
    }
}
use crate::app::components::assessment_page::assessment_list::sequence_visualization::SequenceVisualization;
use crate::app::components::test_item::TestItem;
use crate::app::models::assessment::Assessment;
use crate::app::models::test::Test;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn AssessmentCard(
    assessment: Assessment,
    tests: Vec<Test>,
    on_edit: impl Fn(Assessment) + 'static + Copy,
    on_delete: impl Fn(Uuid) + 'static + Copy,
) -> impl IntoView {
    let assessment_clone = assessment.clone();
    let assessment_id = assessment.id;
    let assessment_name = assessment.name.clone();
    let assessment_subject = assessment.subject.clone();
    let assessment_grade = assessment.grade.clone();
    let (expanded, set_expanded) = signal(false);

    let uses_sequences = assessment.test_sequence.is_some()
        && !assessment.test_sequence.as_ref().unwrap().is_empty();

    // Combined style computation
    let expandable_style = move || {
        let max_height = if expanded.get() { "800px" } else { "0" };
        let opacity = if expanded.get() { "1" } else { "0" };
        format!("max-height: {}; opacity: {}", max_height, opacity)
    };

    view! {
        <div class="bg-white rounded-lg shadow-sm border border-gray-100 hover:shadow-md transition-shadow overflow-hidden">
            <button
                class="w-full text-left p-4 focus:outline-none"
                on:click=move |_| set_expanded.update(|val| *val = !*val)
            >
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="font-medium">{assessment_name.clone()}</h3>
                        <div class="flex items-center space-x-2 text-sm text-gray-500">
                            <span>"("{assessment_subject.as_ref().map(|s| s.to_string()).unwrap_or_else(|| "No Subject".to_string())}")"</span>
                            {if uses_sequences {
                                view! { <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs">"Sequenced"</span> }
                            } else {
                                view! { <span class="bg-gray-100 text-gray-600 px-2 py-1 rounded text-xs">"Legacy"</span> }
                            }}
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <div class="text-sm text-gray-500">
                            {assessment_grade.map(|g| format!("{:?}", g)).unwrap_or_else(|| "Any".to_string())}
                        </div>
                        <button
                            class="text-xs px-3 py-1 bg-blue-100 rounded-full text-blue-600 hover:bg-blue-200 transition-colors"
                            on:click=move |ev| {
                                ev.stop_propagation();
                                on_edit(assessment_clone.clone());
                            }
                        >
                            "Edit"
                        </button>
                        <button
                            class="text-xs px-3 py-1 bg-red-50 rounded-full text-red-600 hover:bg-red-100 transition-colors"
                            on:click=move |ev| {
                                ev.stop_propagation();
                                on_delete(assessment_id);
                            }
                        >
                            "Delete"
                        </button>
                    </div>
                </div>
            </button>

            // Expandable details section - FIXED: Combined styles
            <div
                class="border-t border-gray-100 overflow-hidden transition-all duration-300 ease-in-out"
                style=expandable_style
            >
                <div class="p-4">
                    <AssessmentDetails
                        assessment=assessment.clone()
                        tests=tests.clone()
                        uses_sequences=uses_sequences
                    />
                </div>
            </div>
        </div>
    }
}

#[component]
fn AssessmentDetails(
    assessment: Assessment,
    tests: Vec<Test>,
    uses_sequences: bool,
) -> impl IntoView {
    if uses_sequences {
        view! {
            <div>
                <h4 class="text-sm font-medium mb-3">"Test Sequence Flow"</h4>
                <SequenceVisualization
                    sequence={assessment.test_sequence.clone().unwrap_or_default()}
                    tests={tests}
                />
            </div>
        }
        .into_any()
    } else {
        view! {
            <div>
                <h4 class="text-sm font-medium mb-2">"Tests"</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                    {assessment.tests.iter().map(|test_id| {
                        if let Some(test) = tests.iter().find(|t| {
                            Uuid::parse_str(&t.test_id).unwrap_or_default() == *test_id
                        }) {
                            view! {
                                <TestItem
                                    test=test.clone()
                                    test_id=test.test_id.clone()
                                    test_name=test.name.clone()
                                />
                            }.into_any()
                        } else {
                            view! { <div>"Unknown Test"</div> }.into_any()
                        }
                    }).collect_view()}
                </div>
            </div>
        }
        .into_any()
    }
}
use crate::app::components::assessment_page::shared::types::get_behavior_display_props;
use crate::app::models::assessment_sequences::{SequenceBehavior, TestSequenceItem};
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn SequenceVisualization(sequence: Vec<TestSequenceItem>, tests: Vec<Test>) -> impl IntoView {
    let sequence = signal(sequence).0;
    let tests = signal(tests).0;

    view! {
        <div class="relative">
            <div class="flex flex-wrap gap-4 items-center">
                {move || {
                    let seq = sequence.get();
                    let all_tests = tests.get();

                    seq.iter().enumerate().map(|(index, item)| {
                        let test = all_tests.iter().find(|t| {
                            Uuid::parse_str(&t.test_id).unwrap_or_default() == item.test_id
                        });

                        let (bg_color, icon, border_color, _) = get_behavior_display_props(&item.sequence_behavior);

                        view! {
                            <div class="flex items-center">
                                <div class=format!("relative p-3 rounded-lg border-2 {} {} min-w-32",
                                    get_bg_class(&item.sequence_behavior),
                                    get_border_class(&item.sequence_behavior))>
                                    <div class="flex items-center space-x-2">
                                        <span class="text-lg">{icon}</span>
                                        <div>
                                            <div class="text-xs font-medium">
                                                {test.map(|t| t.name.clone()).unwrap_or_else(|| "Unknown".to_string())}
                                            </div>
                                            <div class="text-xs text-gray-500">
                                                {format!("{:?}", item.sequence_behavior)}
                                            </div>
                                        </div>
                                    </div>
                                    <div class="absolute -top-2 -left-2 w-6 h-6 bg-[#2E3A59] text-white rounded-full flex items-center justify-center text-xs font-bold">
                                        {item.sequence_order}
                                    </div>
                                </div>

                                // Connection arrow
                                {if index < seq.len() - 1 {
                                    view! {
                                        <div class="mx-2 text-gray-400">
                                            <svg width="24" height="16" viewBox="0 0 24 16" fill="currentColor">
                                                <path d="M16 8l-4-4v3H0v2h12v3l4-4z"/>
                                            </svg>
                                        </div>
                                    }.into_any()
                                } else {
                                    view! { <div></div> }.into_any()
                                }}
                            </div>
                        }
                    }).collect_view()
                }}
            </div>
        </div>
    }
}

fn get_bg_class(behavior: &SequenceBehavior) -> &'static str {
    match behavior {
        SequenceBehavior::Node => "bg-blue-50",
        SequenceBehavior::Attainment => "bg-green-50",
        SequenceBehavior::Optional => "bg-gray-50",
        SequenceBehavior::Diagnostic => "bg-purple-50",
        SequenceBehavior::Remediation => "bg-orange-50",
        SequenceBehavior::Branching => "bg-yellow-50",
    }
}

fn get_border_class(behavior: &SequenceBehavior) -> &'static str {
    match behavior {
        SequenceBehavior::Node => "border-blue-200",
        SequenceBehavior::Attainment => "border-green-200",
        SequenceBehavior::Optional => "border-gray-200",
        SequenceBehavior::Diagnostic => "border-purple-200",
        SequenceBehavior::Remediation => "border-orange-200",
        SequenceBehavior::Branching => "border-yellow-200",
    }
}
use crate::app::components::assessment_page::assessment_list::assessment_card::AssessmentCard;
use crate::app::models::assessment::Assessment;
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;
use uuid::Uuid;

#[component]
pub fn AssessmentList(
    assessments: Vec<Assessment>,
    tests: Vec<Test>,
    on_edit: impl Fn(Assessment) + 'static + Copy,
    on_delete: impl Fn(Uuid) + 'static + Copy,
) -> impl IntoView {
    view! {
        <div class="bg-white rounded-lg shadow-sm mb-8 overflow-hidden">
            <div class="border-b border-[#DADADA] px-6 py-4">
                <h2 class="text-xl font-medium text-[#2E3A59]">"All Assessments"</h2>
            </div>
            <div class="p-6">
                {if assessments.is_empty() {
                    view! {
                        <div class="text-center py-12">
                            <div class="text-gray-400 text-6xl mb-4">"ðŸ“‹"</div>
                            <h3 class="text-lg font-medium text-gray-900 mb-2">"No assessments yet"</h3>
                            <p class="text-gray-500">"Create your first assessment to get started"</p>
                        </div>
                    }.into_any()
                } else {
                    view! {
                        <div class="grid grid-cols-1 gap-4">
                            {assessments.into_iter().map(|assessment| {
                                view! {
                                    <AssessmentCard
                                        assessment=assessment
                                        tests=tests.clone()
                                        on_edit=on_edit
                                        on_delete=on_delete
                                    />
                                }
                            }).collect_view()}
                        </div>
                    }.into_any()
                }}
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod assessment_card;
pub mod assessment_list;
pub mod sequence_visualization;

pub use assessment_list::AssessmentList;
use leptos::prelude::*;
pub mod flash_card_set1;
pub use flash_card_set1::FlashCardSet;

pub mod grid_test;
pub use grid_test::GridTest;
use leptos::prelude::*;
pub mod authorization_components;
pub mod enhanced_login_form;
pub mod login_form;
pub mod reset_password_components;
pub mod saml_login_form;
pub mod server_auth_components;
pub mod test_saml;
use crate::app::models::score::Score;
use crate::app::models::test::Test;
use leptos::html;
use leptos::prelude::*;
use leptos::prelude::*;
#[cfg(feature = "hydrate")]
use {gloo_utils::format::JsValueSerdeExt, wasm_bindgen::prelude::*, wasm_bindgen::JsValue};

// Import needed for Plotly
#[cfg(feature = "hydrate")]
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = Plotly)]
    pub fn newPlot(div_id: &str, data: &JsValue, layout: &JsValue, config: &JsValue);
}

// Define color scheme
fn color_primary() -> &'static str {
    "rgb(255, 122, 89)"
} // Warm orange/coral
fn color_secondary() -> &'static str {
    "rgb(247, 148, 89)"
} // Light orange
fn color_tertiary() -> &'static str {
    "rgb(255, 172, 130)"
} // Pale orange
fn color_text() -> &'static str {
    "rgb(66, 71, 76)"
} // Dark slate for text
fn color_low() -> &'static str {
    "rgb(247, 114, 89)"
} // Red-orange for low scores
fn color_medium() -> &'static str {
    "rgb(255, 166, 77)"
} // Medium orange for mid scores
fn color_high() -> &'static str {
    "rgb(255, 145, 115)"
} // Orange for high scores

// Common chart configuration
#[cfg(feature = "hydrate")]
fn get_common_config() -> JsValue {
    let config = js_sys::Object::new();
    js_sys::Reflect::set(
        &config,
        &JsValue::from_str("displayModeBar"),
        &JsValue::from_bool(false),
    )
    .unwrap();
    js_sys::Reflect::set(
        &config,
        &JsValue::from_str("responsive"),
        &JsValue::from_bool(true),
    )
    .unwrap();
    config.into()
}

// Common chart layout settings
#[cfg(feature = "hydrate")]
fn apply_common_layout_settings(layout: &js_sys::Object) {
    // Set font family for the entire plot
    js_sys::Reflect::set(&layout, &JsValue::from_str("font"), &{
        let font = js_sys::Object::new();
        js_sys::Reflect::set(
            &font,
            &JsValue::from_str("family"),
            &JsValue::from_str("Inter, system-ui, sans-serif"),
        )
        .unwrap();
        js_sys::Reflect::set(
            &font,
            &JsValue::from_str("color"),
            &JsValue::from_str(color_text()),
        )
        .unwrap();
        font.into()
    })
    .unwrap();

    // Set plot background color
    js_sys::Reflect::set(
        &layout,
        &JsValue::from_str("paper_bgcolor"),
        &JsValue::from_str("rgba(0,0,0,0)"),
    )
    .unwrap();

    js_sys::Reflect::set(
        &layout,
        &JsValue::from_str("plot_bgcolor"),
        &JsValue::from_str("rgba(0,0,0,0)"),
    )
    .unwrap();

    // Add subtle grid lines
    js_sys::Reflect::set(&layout, &JsValue::from_str("xaxis"), &{
        let axis = js_sys::Object::new();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("showgrid"),
            &JsValue::from_bool(false),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("zeroline"),
            &JsValue::from_bool(false),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("showline"),
            &JsValue::from_bool(true),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("linecolor"),
            &JsValue::from_str("rgba(0,0,0,0.1)"),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("linewidth"),
            &JsValue::from_f64(1.0),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("ticks"),
            &JsValue::from_str("outside"),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("tickcolor"),
            &JsValue::from_str("rgba(0,0,0,0.1)"),
        )
        .unwrap();
        axis.into()
    })
    .unwrap();

    js_sys::Reflect::set(&layout, &JsValue::from_str("yaxis"), &{
        let axis = js_sys::Object::new();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("showgrid"),
            &JsValue::from_bool(true),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("gridcolor"),
            &JsValue::from_str("rgba(0,0,0,0.05)"),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("zeroline"),
            &JsValue::from_bool(false),
        )
        .unwrap();
        js_sys::Reflect::set(
            &axis,
            &JsValue::from_str("showline"),
            &JsValue::from_bool(false),
        )
        .unwrap();
        js_sys::Reflect::set(&axis, &JsValue::from_str("ticks"), &JsValue::from_str("")).unwrap();
        axis.into()
    })
    .unwrap();

    // Add padding
    js_sys::Reflect::set(&layout, &JsValue::from_str("margin"), &{
        let margin = js_sys::Object::new();
        js_sys::Reflect::set(&margin, &JsValue::from_str("l"), &JsValue::from_f64(50.0)).unwrap();
        js_sys::Reflect::set(&margin, &JsValue::from_str("r"), &JsValue::from_f64(30.0)).unwrap();
        js_sys::Reflect::set(&margin, &JsValue::from_str("t"), &JsValue::from_f64(40.0)).unwrap();
        js_sys::Reflect::set(&margin, &JsValue::from_str("b"), &JsValue::from_f64(50.0)).unwrap();
        js_sys::Reflect::set(&margin, &JsValue::from_str("pad"), &JsValue::from_f64(0.0)).unwrap();
        margin.into()
    })
    .unwrap();
}

// Function to render test plot
#[cfg(feature = "hydrate")]
pub fn render_test_plot(
    test_id: String,
    test_name: String,
    score_data: Vec<(Score, Test)>,
) -> impl IntoView {
    // Create a unique div id for this plot
    let plot_div_id = format!("plot-{}", test_id.replace("-", ""));
    let plot_div_id_clone = plot_div_id.clone();
    let plot_div_ref = create_node_ref::<html::Div>();

    let test_name_clone = test_name.clone();

    // Function to create the plot after component is mounted
    Effect::new(move |_| {
        // Extract score data for plotting
        let scores: Vec<i32> = score_data.iter().map(|(s, _)| s.get_total()).collect();
        let dates: Vec<String> = score_data
            .iter()
            .map(|(s, _)| format!("{:?}", s.date_administered))
            .collect();

        // Create JS data for Plotly
        let plot_data = js_sys::Array::new();
        let trace = js_sys::Object::new();

        // Set the trace properties
        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("x"),
            &JsValue::from_serde(&dates).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("y"),
            &JsValue::from_serde(&scores).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("type"),
            &JsValue::from_str("scatter"),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("mode"),
            &JsValue::from_str("lines+markers"),
        )
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("marker"), &{
            let marker = js_sys::Object::new();
            js_sys::Reflect::set(
                &marker,
                &JsValue::from_str("color"),
                &JsValue::from_str(color_primary()),
            )
            .unwrap();
            js_sys::Reflect::set(&marker, &JsValue::from_str("size"), &JsValue::from_f64(8.0))
                .unwrap();
            marker.into()
        })
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("line"), &{
            let line = js_sys::Object::new();
            js_sys::Reflect::set(
                &line,
                &JsValue::from_str("color"),
                &JsValue::from_str(color_primary()),
            )
            .unwrap();
            js_sys::Reflect::set(&line, &JsValue::from_str("width"), &JsValue::from_f64(2.0))
                .unwrap();
            js_sys::Reflect::set(
                &line,
                &JsValue::from_str("shape"),
                &JsValue::from_str("spline"),
            )
            .unwrap();
            line.into()
        })
        .unwrap();

        plot_data.push(&trace);

        // Create layout
        let layout = js_sys::Object::new();

        // Add title with subtle styling
        js_sys::Reflect::set(&layout, &JsValue::from_str("title"), &{
            let title = js_sys::Object::new();
            js_sys::Reflect::set(
                &title,
                &JsValue::from_str("text"),
                &JsValue::from_str(&format!("{} Progress", test_name_clone.clone())),
            )
            .unwrap();
            js_sys::Reflect::set(&title, &JsValue::from_str("font"), &{
                let font = js_sys::Object::new();
                js_sys::Reflect::set(&font, &JsValue::from_str("size"), &JsValue::from_f64(16.0))
                    .unwrap();
                js_sys::Reflect::set(
                    &font,
                    &JsValue::from_str("color"),
                    &JsValue::from_str(color_text()),
                )
                .unwrap();
                font.into()
            })
            .unwrap();
            title.into()
        })
        .unwrap();

        // Apply common layout settings
        apply_common_layout_settings(&layout);

        // Specific settings for this chart
        js_sys::Reflect::set(&layout, &JsValue::from_str("xaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Date"),
                )
                .unwrap();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("standoff"),
                    &JsValue::from_f64(10.0),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            js_sys::Reflect::set(
                &axis,
                &JsValue::from_str("showgrid"),
                &JsValue::from_bool(false),
            )
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(&layout, &JsValue::from_str("yaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Score"),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("height"),
            &JsValue::from_f64(300.0),
        )
        .unwrap();

        // Get common config
        let config = get_common_config();

        // Call Plotly to create the chart
        newPlot(&plot_div_id_clone, &plot_data, &layout, &config);
    });

    // Create div for the plot and attach event listener to render after mount
    view! {
        <div class="my-6 rounded-xl shadow-sm bg-white overflow-hidden">
            <div class="px-6 py-4">
                <h4 class="text-lg font-medium text-gray-800">{test_name.clone()} " Progress"</h4>
                <div id={plot_div_id.clone()} class="h-80 w-full mt-2" node_ref={plot_div_ref}></div>
            </div>
        </div>
    }
}

// Function to render test distribution chart
#[cfg(feature = "hydrate")]
pub fn render_test_distribution(
    assessment_id: String,
    scores: Vec<(Score, Test)>,
) -> impl IntoView {
    let plot_div_id = format!("distribution-{}", assessment_id.replace("-", ""));
    let plot_div_id_clone = plot_div_id.clone();
    let plot_div_ref = create_node_ref::<html::Div>();

    Effect::new(move |_| {
        // Group scores by test name
        let mut test_scores = std::collections::HashMap::new();
        for (score, test) in &scores {
            let entry = test_scores
                .entry(test.name.clone())
                .or_insert_with(Vec::new);
            entry.push(score.get_total());
        }

        // Create data for the bar chart
        let plot_data = js_sys::Array::new();
        let trace = js_sys::Object::new();

        let test_names: Vec<String> = test_scores.keys().cloned().collect();
        let averages: Vec<f64> = test_scores
            .values()
            .map(|scores| {
                let sum: i32 = scores.iter().sum();
                sum as f64 / scores.len() as f64
            })
            .collect();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("x"),
            &JsValue::from_serde(&test_names).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("y"),
            &JsValue::from_serde(&averages).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("type"),
            &JsValue::from_str("bar"),
        )
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("marker"), &{
            let marker = js_sys::Object::new();

            // Create gradient colors for bars
            let colors = js_sys::Array::new();
            for (i, _) in test_names.iter().enumerate() {
                let color_index = i % 3;
                let color = match color_index {
                    0 => color_primary(),
                    1 => color_secondary(),
                    _ => color_tertiary(),
                };
                colors.push(&JsValue::from_str(color));
            }

            js_sys::Reflect::set(&marker, &JsValue::from_str("color"), &colors).unwrap();

            js_sys::Reflect::set(
                &marker,
                &JsValue::from_str("opacity"),
                &JsValue::from_f64(0.9),
            )
            .unwrap();

            marker.into()
        })
        .unwrap();

        plot_data.push(&trace);

        // Create layout
        let layout = js_sys::Object::new();

        // Add title with subtle styling
        js_sys::Reflect::set(&layout, &JsValue::from_str("title"), &{
            let title = js_sys::Object::new();
            js_sys::Reflect::set(
                &title,
                &JsValue::from_str("text"),
                &JsValue::from_str("Test Score Distribution"),
            )
            .unwrap();
            js_sys::Reflect::set(&title, &JsValue::from_str("font"), &{
                let font = js_sys::Object::new();
                js_sys::Reflect::set(&font, &JsValue::from_str("size"), &JsValue::from_f64(16.0))
                    .unwrap();
                js_sys::Reflect::set(
                    &font,
                    &JsValue::from_str("color"),
                    &JsValue::from_str(color_text()),
                )
                .unwrap();
                font.into()
            })
            .unwrap();
            title.into()
        })
        .unwrap();

        // Apply common layout settings
        apply_common_layout_settings(&layout);

        // Specific settings for this chart
        js_sys::Reflect::set(&layout, &JsValue::from_str("xaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Subject"),
                )
                .unwrap();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("standoff"),
                    &JsValue::from_f64(10.0),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(&layout, &JsValue::from_str("yaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Average Score"),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("height"),
            &JsValue::from_f64(300.0),
        )
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("bargap"),
            &JsValue::from_f64(0.3),
        )
        .unwrap();

        // Get common config
        let config = get_common_config();

        // Call Plotly to create the chart
        newPlot(&plot_div_id_clone, &plot_data, &layout, &config);
    });

    view! {
        <div class="my-6 rounded-xl shadow-sm bg-white overflow-hidden">
            <div class="px-6 py-4">
                <h4 class="text-lg font-medium text-gray-800">"Test Score Distribution"</h4>
                <div id={plot_div_id.clone()} class="h-80 w-full mt-2" node_ref={plot_div_ref}></div>
            </div>
        </div>
    }
}

// Function to render overall student progress chart
#[cfg(feature = "hydrate")]
pub fn render_overall_progress(scores: Vec<Score>) -> impl IntoView {
    let plot_div_id = "overall-progress-plot";
    let plot_div_ref = create_node_ref::<html::Div>();

    Effect::new(move |_| {
        if scores.is_empty() {
            return;
        }

        // Group scores by date
        let mut score_by_date = std::collections::HashMap::new();
        for score in &scores {
            let date = format!("{:?}", score.date_administered);
            let entry = score_by_date.entry(date).or_insert_with(Vec::new);
            entry.push(score.get_total());
        }

        // Calculate average for each date
        let mut dates: Vec<String> = score_by_date.keys().cloned().collect();
        dates.sort(); // Sort dates chronologically

        let averages: Vec<f64> = dates
            .iter()
            .map(|date| {
                let scores = score_by_date.get(date).unwrap();
                let sum: i32 = scores.iter().sum();
                sum as f64 / scores.len() as f64
            })
            .collect();

        // Create JS data for Plotly
        let plot_data = js_sys::Array::new();
        let trace = js_sys::Object::new();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("x"),
            &JsValue::from_serde(&dates).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("y"),
            &JsValue::from_serde(&averages).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("type"),
            &JsValue::from_str("scatter"),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("mode"),
            &JsValue::from_str("lines+markers"),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("fill"),
            &JsValue::from_str("tozeroy"),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("fillcolor"),
            &JsValue::from_str("rgba(255, 122, 89, 0.1)"),
        )
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("marker"), &{
            let marker = js_sys::Object::new();
            js_sys::Reflect::set(
                &marker,
                &JsValue::from_str("color"),
                &JsValue::from_str(color_primary()),
            )
            .unwrap();
            js_sys::Reflect::set(&marker, &JsValue::from_str("size"), &JsValue::from_f64(8.0))
                .unwrap();
            marker.into()
        })
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("line"), &{
            let line = js_sys::Object::new();
            js_sys::Reflect::set(
                &line,
                &JsValue::from_str("color"),
                &JsValue::from_str(color_primary()),
            )
            .unwrap();
            js_sys::Reflect::set(&line, &JsValue::from_str("width"), &JsValue::from_f64(2.5))
                .unwrap();
            js_sys::Reflect::set(
                &line,
                &JsValue::from_str("shape"),
                &JsValue::from_str("spline"),
            )
            .unwrap();
            line.into()
        })
        .unwrap();

        plot_data.push(&trace);

        // Create layout
        let layout = js_sys::Object::new();

        // Add title with subtle styling
        js_sys::Reflect::set(&layout, &JsValue::from_str("title"), &{
            let title = js_sys::Object::new();
            js_sys::Reflect::set(
                &title,
                &JsValue::from_str("text"),
                &JsValue::from_str("Performance Trend"),
            )
            .unwrap();
            js_sys::Reflect::set(&title, &JsValue::from_str("font"), &{
                let font = js_sys::Object::new();
                js_sys::Reflect::set(&font, &JsValue::from_str("size"), &JsValue::from_f64(18.0))
                    .unwrap();
                js_sys::Reflect::set(
                    &font,
                    &JsValue::from_str("color"),
                    &JsValue::from_str(color_text()),
                )
                .unwrap();
                font.into()
            })
            .unwrap();
            title.into()
        })
        .unwrap();

        // Apply common layout settings
        apply_common_layout_settings(&layout);

        // Specific settings for this chart
        js_sys::Reflect::set(&layout, &JsValue::from_str("xaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Date"),
                )
                .unwrap();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("standoff"),
                    &JsValue::from_f64(10.0),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(&layout, &JsValue::from_str("yaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Average Score"),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("height"),
            &JsValue::from_f64(350.0),
        )
        .unwrap();

        // Get common config
        let config = get_common_config();

        // Call Plotly to create the chart
        newPlot(plot_div_id, &plot_data, &layout, &config);
    });

    view! {
        <div class="mt-6 rounded-xl shadow-sm bg-white overflow-hidden">
            <div class="px-6 py-4">
                <h3 class="text-xl font-medium text-gray-800">"Performance Trend"</h3>
                <div id={plot_div_id} class="h-96 w-full mt-2" node_ref={plot_div_ref}></div>
            </div>
        </div>
    }
}

// Function to render score distribution chart
#[cfg(feature = "hydrate")]
pub fn render_score_distribution(scores: Vec<Score>) -> impl IntoView {
    let plot_div_id = "score-distribution-plot";
    let plot_div_ref = create_node_ref::<html::Div>();

    Effect::new(move |_| {
        if scores.is_empty() {
            return;
        }

        // Group scores by range
        let mut score_ranges = vec![0, 0, 0, 0, 0]; // 0-20, 21-40, 41-60, 61-80, 81-100

        for score in &scores {
            let total = score.get_total();
            if total <= 20 {
                score_ranges[0] += 1;
            } else if total <= 40 {
                score_ranges[1] += 1;
            } else if total <= 60 {
                score_ranges[2] += 1;
            } else if total <= 80 {
                score_ranges[3] += 1;
            } else {
                score_ranges[4] += 1;
            }
        }

        let range_labels = vec!["0-20", "21-40", "41-60", "61-80", "81-100"];

        // Create JS data for Plotly
        let plot_data = js_sys::Array::new();
        let trace = js_sys::Object::new();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("x"),
            &JsValue::from_serde(&range_labels).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("y"),
            &JsValue::from_serde(&score_ranges).unwrap(),
        )
        .unwrap();

        js_sys::Reflect::set(
            &trace,
            &JsValue::from_str("type"),
            &JsValue::from_str("bar"),
        )
        .unwrap();

        js_sys::Reflect::set(&trace, &JsValue::from_str("marker"), &{
            let marker = js_sys::Object::new();
            let colors = js_sys::Array::new();
            colors.push(&JsValue::from_str(color_low())); // Red-orange for 0-20
            colors.push(&JsValue::from_str(color_medium())); // Medium orange for 21-40
            colors.push(&JsValue::from_str(color_medium())); // Medium orange for 41-60
            colors.push(&JsValue::from_str(color_medium())); // Medium orange for 61-80
            colors.push(&JsValue::from_str(color_high())); // Orange for 81-100

            js_sys::Reflect::set(&marker, &JsValue::from_str("color"), &colors).unwrap();
            js_sys::Reflect::set(
                &marker,
                &JsValue::from_str("opacity"),
                &JsValue::from_f64(0.9),
            )
            .unwrap();

            marker.into()
        })
        .unwrap();

        plot_data.push(&trace);

        // Create layout
        let layout = js_sys::Object::new();

        // Add title with subtle styling
        js_sys::Reflect::set(&layout, &JsValue::from_str("title"), &{
            let title = js_sys::Object::new();
            js_sys::Reflect::set(
                &title,
                &JsValue::from_str("text"),
                &JsValue::from_str("Score Distribution"),
            )
            .unwrap();
            js_sys::Reflect::set(&title, &JsValue::from_str("font"), &{
                let font = js_sys::Object::new();
                js_sys::Reflect::set(&font, &JsValue::from_str("size"), &JsValue::from_f64(16.0))
                    .unwrap();
                js_sys::Reflect::set(
                    &font,
                    &JsValue::from_str("color"),
                    &JsValue::from_str(color_text()),
                )
                .unwrap();
                font.into()
            })
            .unwrap();
            title.into()
        })
        .unwrap();

        // Apply common layout settings
        apply_common_layout_settings(&layout);

        // Specific settings for this chart
        js_sys::Reflect::set(&layout, &JsValue::from_str("xaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Score Range"),
                )
                .unwrap();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("standoff"),
                    &JsValue::from_f64(10.0),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(&layout, &JsValue::from_str("yaxis"), &{
            let axis = js_sys::Object::new();
            js_sys::Reflect::set(&axis, &JsValue::from_str("title"), &{
                let title = js_sys::Object::new();
                js_sys::Reflect::set(
                    &title,
                    &JsValue::from_str("text"),
                    &JsValue::from_str("Number of Tests"),
                )
                .unwrap();
                title.into()
            })
            .unwrap();
            axis.into()
        })
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("height"),
            &JsValue::from_f64(350.0),
        )
        .unwrap();

        js_sys::Reflect::set(
            &layout,
            &JsValue::from_str("bargap"),
            &JsValue::from_f64(0.3),
        )
        .unwrap();

        // Get common config
        let config = get_common_config();

        // Call Plotly to create the chart
        newPlot(plot_div_id, &plot_data, &layout, &config);
    });

    view! {
        <div class="mb-6">
            <h3 class="font-semibold mb-2">"Score Distribution"</h3>
            <div id={plot_div_id} class="h-80 w-full border rounded p-4 bg-white" node_ref={plot_div_ref}></div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::data_processing::{
    AssessmentSummary, Progress, StudentResultsSummary, TestDetail,
};
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent, StudentMappingService,
};
use crate::app::components::test_item::GenericTestModal;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::student::Student;
use chrono::prelude::*;
use icondata::{
    BiXCircleRegular, HiUserCircleOutlineLg, RiArrowRightSArrowsLine, RiBookmarkBusinessLine,
    RiFilePaper2DocumentLine,
};
use leptos::prelude::*;
use leptos_icons::Icon;
use leptos_router::components::*;
use leptos_router::hooks::*;

#[derive(Clone, PartialEq)]
pub enum ScorePanelType {
    AssessmentScore(String),     // Assessment ID
    TestScore(String, i32, i32), // Test ID, Student ID
    None,
}

#[component]
pub fn StudentScorePanel(
    #[prop(into)] show: Signal<bool>,
    #[prop(into)] panel_type: Signal<ScorePanelType>,
    #[prop(into)] set_show: Callback<bool>,
    #[prop(into)] student: Signal<Option<Student>>,
    #[prop(into)] assessment_data: Signal<Option<AssessmentSummary>>,
    #[prop(into)] test_data: Signal<Option<TestDetail>>,
    #[prop(into)] next_test: Signal<Option<String>>, // Next test ID in sequence
) -> impl IntoView {
    // Get global settings and student mapping service for de-anonymization
    let (settings, _) = use_settings();
    let (student_mapping_service, _) = use_student_mapping_service();

    let anonymization_enabled = move || settings.get().student_protections;

    // Format date for display
    let format_date = |date: DateTime<Utc>| date.format("%B %d, %Y").to_string();

    // Generate progress color based on status
    let get_progress_color = |progress: &Progress| match progress {
        Progress::Completed => "bg-green-100 text-green-800",
        Progress::Ongoing => "bg-yellow-100 text-yellow-800",
        Progress::NotStarted => "bg-blue-100 text-blue-800",
    };

    // Calculate percentage for progress bars
    let calculate_percentage = move |score: i32, total: i32| -> i32 {
        if total == 0 {
            0
        } else {
            (score as f32 / total as f32 * 100.0) as i32
        }
    };

    // Helper function to get student display name with de-anonymization support
    let get_student_display_name = move |student: &Student| -> String {
        if anonymization_enabled() {
            if let Some(service) = student_mapping_service.get() {
                if let Some(mapping) = service.get_original_student_info(student.student_id) {
                    return format!("{} {}", mapping.firstname, mapping.lastname);
                }
            }
        }

        // Fallback to anonymized or regular display
        let firstname = student.firstname.as_deref().unwrap_or("Student");
        let lastname = student
            .lastname
            .as_deref()
            .map(|s| s.to_string())
            .unwrap_or_else(|| format!("#{}", student.student_id));
        format!("{} {}", firstname, lastname)
    };

    // Helper function to get student ID display with de-anonymization support
    let get_student_display_id = move |student: &Student| -> String {
        if anonymization_enabled() {
            if let Some(service) = student_mapping_service.get() {
                if let Some(mapping) = service.get_original_student_info(student.student_id) {
                    return mapping.original_student_id.to_string();
                }
            }
        }

        // Fallback to current student ID
        student.student_id.to_string()
    };

    // Close panel function
    let close_panel = move |_| {
        set_show.call(false);
    };

    view! {
        <div
            class="fixed right-0 top-16 h-screen w-96 bg-white shadow-lg transform transition-transform duration-300 z-50 border-l border-gray-200 flex flex-col"
            class=("translate-x-full", move || !show.get())
        >
            <div class="flex justify-between items-center p-4 border-b border-gray-200 bg-[#DADADA] flex-shrink-0">
                <h2 class="text-lg font-bold text-[#2E3A59]">
                    {move || {
                        match panel_type.get() {
                            ScorePanelType::AssessmentScore(_) => "Assessment Details",
                            ScorePanelType::TestScore(_, _, _) => "Test Score Details",
                            ScorePanelType::None => ""
                        }
                    }}
                </h2>
                <button
                    class="text-gray-500 hover:text-gray-700 focus:outline-none"
                    on:click=close_panel
                >
                    <Icon icon=BiXCircleRegular class="w-6 h-6" />
                </button>
            </div>

            <div class="p-4 overflow-y-auto flex-grow">
                {move || {
                    if !show.get() {
                        view! { <div></div> }.into_any()
                    } else {
                        // Student info section with de-anonymization support
                        let student_info = view! {
                            <div class="mb-6 bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                <div class="flex items-center mb-3">
                                    <Icon
                                        icon=HiUserCircleOutlineLg
                                        class="w-12 h-12 text-[#2E3A59] mr-3"
                                    />
                                    <div>
                                        <h3 class="text-lg font-semibold text-[#2E3A59]">
                                            {move || {
                                                student.get()
                                                    .map(|s| get_student_display_name(&s))
                                                    .unwrap_or_else(|| "Unknown Student".to_string())
                                            }}
                                        </h3>
                                        <div class="text-sm text-gray-600">
                                            <p>
                                                {move || {
                                                    if anonymization_enabled() && student_mapping_service.get().is_some() {
                                                        "Original ID: "
                                                    } else {
                                                        "ID: "
                                                    }
                                                }}
                                                {move || {
                                                    student.get()
                                                        .map(|s| get_student_display_id(&s))
                                                        .unwrap_or_else(|| "N/A".to_string())
                                                }}
                                            </p>
                                            // Show anonymization status if enabled
                                            {move || {
                                                if anonymization_enabled() {
                                                    if student_mapping_service.get().is_some() {
                                                        view! {
                                                            <p class="text-green-600 text-xs mt-1">
                                                                "âœ“ De-anonymized data"
                                                            </p>
                                                        }.into_any()
                                                    } else {
                                                        view! {
                                                            <p class="text-yellow-600 text-xs mt-1">
                                                                "âš  Anonymized data"
                                                            </p>
                                                        }.into_any()
                                                    }
                                                } else {
                                                    view! { <span></span> }.into_any()
                                                }
                                            }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        };

                        match panel_type.get() {
                            ScorePanelType::AssessmentScore(_) => {
                                let assessment = assessment_data.get();

                                if let Some(assessment) = assessment {
                                    view! {
                                        {student_info}

                                        // Assessment Details
                                        <div class="mb-6">
                                            <h3 class="text-md font-bold mb-2 flex items-center">
                                                <Icon icon=RiBookmarkBusinessLine class="w-5 h-5 mr-2" />
                                                {assessment.assessment_name}
                                            </h3>
                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Subject:"}</span>
                                                    <span class="font-medium">{assessment.subject}</span>
                                                </div>
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Grade Level:"}</span>
                                                    <span class="font-medium">{assessment.grade_level.unwrap_or_else(|| "Not specified".to_string())}</span>
                                                </div>
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Progress:"}</span>
                                                    <span class=format!("px-2 py-1 rounded text-xs font-bold {}", get_progress_color(&assessment.progress))>
                                                        {assessment.progress.to_string()}
                                                    </span>
                                                </div>
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Overall Rating:"}</span>
                                                    <span class="font-bold text-indigo-600">{assessment.assessment_rating}</span>
                                                </div>
                                            </div>
                                        </div>

                                        // Score Section
                                        <div class="mb-6">
                                            <h4 class="text-md font-bold mb-2">{"Score Progress"}</h4>
                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                                <div class="flex justify-between mb-1">
                                                    <span class="font-medium">{assessment.current_score}</span>
                                                    <span class="text-gray-500">{"out of "} {assessment.total_possible.unwrap_or(0)}</span>
                                                </div>
                                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                                    <div
                                                        class="bg-blue-600 h-2.5 rounded-full"
                                                        style=format!("width: {}%",
                                                            calculate_percentage(
                                                                assessment.current_score,
                                                                assessment.total_possible.unwrap_or(0)
                                                            )
                                                        )
                                                    ></div>
                                                </div>
                                            </div>
                                        </div>

                                        // Test Breakdown
                                        <div class="mb-6">
                                            <h4 class="text-md font-bold mb-2">{"Test Breakdown"}</h4>
                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                                <table class="min-w-full">
                                                    <thead>
                                                        <tr>
                                                            <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider pb-2">{"Test"}</th>
                                                            <th class="text-right text-xs font-medium text-gray-500 uppercase tracking-wider pb-2">{"Score"}</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {assessment.test_details.iter().map(|test| {
                                                            view! {
                                                                <tr class="border-t border-gray-200">
                                                                    <td class="py-2">
                                                                        <a
                                                                            href="#"
                                                                            class="text-indigo-600 hover:text-indigo-800 font-medium"
                                                                        >
                                                                            {&test.test_name}
                                                                        </a>
                                                                    </td>
                                                                    <td class="py-2 text-right">
                                                                        {format!("{}/{}", test.score, test.total_possible)}
                                                                    </td>
                                                                </tr>
                                                            }
                                                        }).collect_view()}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>

                                        // Next Steps
                                        <div class="mb-6">
                                            <h4 class="text-md font-bold mb-2">{"Next Steps"}</h4>
                                            {move || {
                                                if assessment.progress != Progress::Completed {
                                                    if let Some(next_test_id) = next_test.get() {
                                                        let next_test_name = assessment.test_details.iter()
                                                            .find(|t| t.test_id == next_test_id)
                                                            .map(|t| t.test_name.clone())
                                                            .unwrap_or_else(|| "Next Test".to_string());

                                                        view! {
                                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                                                <p class="mb-4 text-sm text-gray-700">
                                                                    {"Continue this assessment by taking the next test in the sequence:"}
                                                                </p>

                                                                <GenericTestModal test_id=next_test_id test_name=next_test_name.clone()>
                                                                    <div class="w-full bg-blue-600 text-white px-4 py-2 rounded flex items-center justify-center font-medium hover:bg-blue-700">
                                                                        <span>{next_test_name}</span>
                                                                        <Icon icon=RiArrowRightSArrowsLine class="w-5 h-5 ml-2" />
                                                                    </div>
                                                                </GenericTestModal>
                                                            </div>
                                                        }.into_any()
                                                    } else {
                                                        view! {
                                                            <div class="bg-gray-100 p-4 rounded-lg text-gray-700 text-sm">
                                                                {"No additional tests are available at this time."}
                                                            </div>
                                                        }.into_any()
                                                    }
                                                } else {
                                                    view! {
                                                        <div class="bg-green-50 p-4 rounded-lg text-green-700 text-sm border border-green-200">
                                                            {"All tests in this assessment have been completed."}
                                                        </div>
                                                    }.into_any()
                                                }
                                            }}
                                        </div>

                                        // Action Buttons - Use de-anonymized student ID for navigation
                                        <div class="flex space-x-2">
                                            <A
                                                href=format!("/studentview/{}/results",
                                                    student.get().unwrap().student_id
                                                )
                                                class="flex-1 bg-indigo-600 text-white px-4 py-2 rounded text-center font-medium hover:bg-indigo-700"
                                            >
                                                {"View Full Report"}
                                            </A>
                                            <button
                                                class="flex-1 bg-gray-200 text-gray-800 px-4 py-2 rounded font-medium hover:bg-gray-300"
                                                on:click=close_panel
                                            >
                                                {"Close"}
                                            </button>
                                        </div>
                                    }.into_any()
                                } else {
                                    view! {
                                        <div class="text-center py-8">
                                            <p class="text-gray-500">{"Assessment data not available"}</p>
                                        </div>
                                    }.into_any()
                                }
                            },
                            ScorePanelType::TestScore(_, _, _) => {
                                let test = test_data.get();

                                if let Some(test) = test {
                                    view! {
                                        {student_info}

                                        // Test Details
                                        <div class="mb-6">
                                            <h3 class="text-md font-bold mb-2 flex items-center">
                                                <Icon icon=RiFilePaper2DocumentLine class="w-5 h-5 mr-2" />
                                                {test.test_name}
                                            </h3>
                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm">
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Test Area:"}</span>
                                                    <span class="font-medium">{test.test_area}</span>
                                                </div>
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Date Administered:"}</span>
                                                    <span class="font-medium">{format_date(test.date_administered)}</span>
                                                </div>
                                                <div class="flex justify-between mb-2">
                                                    <span class="text-gray-700">{"Performance Rating:"}</span>
                                                    <span class="font-bold text-indigo-600">{test.performance_class}</span>
                                                </div>
                                            </div>
                                        </div>

                                        // Score Visual
                                        <div class="mb-6">
                                            <h4 class="text-md font-bold mb-2">{"Score"}</h4>
                                            <div class="bg-[#F9F9F8] p-4 rounded-lg shadow-sm text-center">
                                                <div class="inline-flex items-center justify-center w-32 h-32 rounded-full bg-indigo-100 mb-4">
                                                    <div class="text-center">
                                                        <div class="text-3xl font-bold text-indigo-600">{test.score}</div>
                                                        <div class="text-xs text-gray-500">{"out of"}</div>
                                                        <div class="text-lg font-medium">{test.total_possible}</div>
                                                    </div>
                                                </div>

                                                <div class="w-full bg-gray-200 rounded-full h-2.5 mb-4">
                                                    <div
                                                        class="bg-indigo-600 h-2.5 rounded-full"
                                                        style=format!("width: {}%",
                                                            calculate_percentage(test.score, test.total_possible)
                                                        )
                                                    ></div>
                                                </div>

                                                <div class="text-sm text-gray-700">
                                                    {format!("{}% Score", calculate_percentage(test.score, test.total_possible))}
                                                </div>
                                            </div>
                                        </div>

                                        // Action Buttons - Use appropriate student ID for navigation
                                        <div class="flex flex-col space-y-2">
                                            <A
                                                href=format!("/reviewtest/{}/{}/{}/{}",
                                                    test.test_id,
                                                    // Use the actual student ID (not de-anonymized) for internal navigation
                                                    student.get().map(|s| s.student_id.to_string()).unwrap_or_default(),
                                                    test.test_variant,
                                                    test.attempt,
                                                )
                                                class="w-full bg-indigo-600 text-white px-4 py-2 rounded text-center font-medium hover:bg-indigo-700"
                                            >
                                                {"Review Test Responses"}
                                            </A>
                                            <A
                                                href=format!("/studentview/{}/results",
                                                    // Use de-anonymized ID for student view navigation
                                                    student.get().map(|s| get_student_display_id(&s)).unwrap_or_default()
                                                )
                                                class="w-full bg-blue-600 text-white px-4 py-2 rounded text-center font-medium hover:bg-blue-700"
                                            >
                                                {"View Student"}
                                            </A>
                                            <button
                                                class="w-full bg-gray-200 text-gray-800 px-4 py-2 rounded font-medium hover:bg-gray-300"
                                                on:click=close_panel
                                            >
                                                {"Close"}
                                            </button>
                                        </div>
                                    }.into_any()
                                } else {
                                    view! {
                                        <div class="text-center py-8">
                                            <p class="text-gray-500">{"Test data not available"}</p>
                                        </div>
                                    }.into_any()
                                }
                            },
                            ScorePanelType::None => {
                                view! {
                                    <div class="text-center py-8">
                                        <p class="text-gray-500">{"Select a score to view details"}</p>
                                    </div>
                                }.into_any()
                            }
                        }
                    }
                }}
            </div>

            <div class="p-4 mb-2 flex-shrink-0">
                {move || {
                    match panel_type.get() {
                        ScorePanelType::AssessmentScore(_) => {
                            let assessment = assessment_data.get();

                            if let Some(assessment) = assessment {
                                view! {
                                    <div class="flex space-x-2">
                                        <A
                                            href=format!("/studentview/{}/results",
                                                // Use de-anonymized ID for student view navigation
                                                student.get().map(|s| get_student_display_id(&s)).unwrap_or_default()
                                            )
                                            class="flex-1 bg-indigo-600 text-white px-4 py-2 rounded text-center font-medium hover:bg-indigo-700"
                                        >
                                            {"View Student"}
                                        </A>
                                        <button
                                            class="flex-1 bg-gray-200 text-gray-800 px-4 py-2 rounded font-medium hover:bg-gray-300"
                                            on:click=close_panel
                                        >
                                            {"Close"}
                                        </button>
                                    </div>
                                }.into_any()
                            } else {
                                view! {
                                    <button
                                        class="w-full bg-gray-200 text-gray-800 px-4 py-2 rounded font-medium hover:bg-gray-300"
                                        on:click=close_panel
                                    >
                                        {"Close"}
                                    </button>
                                }.into_any()
                            }
                        },
                        _ => view! { <div></div> }.into_any(),
                    }
                }}
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::models::assessment::Assessment;
use crate::app::models::course::Course;
use crate::app::models::student::GradeEnum;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct SimpleGradebookFilters {
    // Primary filters - highest impact, always visible
    pub search_term: String,
    pub grade_level: Option<GradeEnum>,
    pub course: Option<String>,
    pub assessment: Option<String>,

    // Secondary filters - show/hide toggle
    pub teacher: Option<i32>,
    pub intervention: bool,
    pub incomplete_only: bool,

    // Sorting and pagination
    pub sort_by: SortBy,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SortBy {
    Name,
    Grade,
    LastActivity,
    Score,
}

impl Default for SimpleGradebookFilters {
    fn default() -> Self {
        Self {
            search_term: String::new(),
            grade_level: None,
            course: None,
            assessment: None,
            teacher: None,
            intervention: false,
            incomplete_only: false,
            sort_by: SortBy::Name,
        }
    }
}

impl SimpleGradebookFilters {
    pub fn has_active_filters(&self) -> bool {
        !self.search_term.is_empty()
            || self.grade_level.is_some()
            || self.course.is_some()
            || self.assessment.is_some()
            || self.teacher.is_some()
            || self.intervention
            || self.incomplete_only
    }

    pub fn clear_all(&mut self) {
        *self = Self::default();
    }
}

//Main component
#[component]
pub fn GradebookFilters(
    #[prop(into)] filters: Signal<GradebookFilters>,
    #[prop(into)] set_filters: Callback<SimpleGradebookFilters>,
    #[prop(into)] available_teachers: Signal<Vec<(i32, String)>>,
    #[prop(into)] available_assessments: Signal<Vec<Assessment>>,
    #[prop(into)] class_sections: Signal<Vec<String>>,
    #[prop(into)] student_count: Signal<usize>,
) -> impl IntoView {
    let (show_more_filters, set_show_more_filters) = signal(false);

    view! {
        <div class="bg-white border border-gray-200 rounded-md mb-4">
            // Main filter bar - always visible
            <div class="p-4 border-b border-gray-100">
                <div class="flex flex-wrap items-center gap-3">
                    // Search input
                    <div class="flex-1 min-w-64">
                        <div class="relative">
                            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <svg class="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                                </svg>
                            </div>
                            <input
                                type="text"
                                placeholder="Search students..."
                                class="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                prop:value=move || filters.get().search_term
                                on:input=move |ev| {
                                    let mut new_filters = filters.get();
                                    new_filters.search_term = event_target_value(&ev);
                                    set_filters.call(new_filters);
                                }
                            />
                        </div>
                    </div>

                    // Grade filter
                    <div class="min-w-32">
                        <select
                            class="block w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            on:change=move |ev| {
                                let mut new_filters = filters.get();
                                let value = event_target_value(&ev);
                                new_filters.grade_level = if value == "all" {
                                    None
                                } else {
                                    value.parse::<GradeEnum>().ok()
                                };
                                set_filters.call(new_filters);
                            }
                        >
                            <option value="all">"All Grades"</option>
                            <option value="Kindergarten">"Kindergarten"</option>
                            <option value="1st Grade">"1st Grade"</option>
                            <option value="2nd Grade">"2nd Grade"</option>
                            <option value="3rd Grade">"3rd Grade"</option>
                            <option value="4th Grade">"4th Grade"</option>
                            <option value="5th Grade">"5th Grade"</option>
                            <option value="6th Grade">"6th Grade"</option>
                            <option value="7th Grade">"7th Grade"</option>
                            <option value="8th Grade">"8th Grade"</option>
                            <option value="9th Grade">"9th Grade"</option>
                            <option value="10th Grade">"10th Grade"</option>
                            <option value="11th Grade">"11th Grade"</option>
                            <option value="12th Grade">"12th Grade"</option>
                        </select>
                    </div>

                    // Class/Section filter
                    <div class="min-w-40">
                        <select
                            class="block w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            on:change=move |ev| {
                                let mut new_filters = filters.get();
                                let value = event_target_value(&ev);
                                new_filters.course = if value == "all" { None } else { Some(value) };
                                set_filters.call(new_filters);
                            }
                        >
                            <option value="all">"All Classes"</option>
                            {move || {
                                class_sections.get().into_iter().map(|section| {
                                    view! {
                                        <option value={section.clone()}>{section}</option>
                                    }
                                }).collect_view()
                            }}
                        </select>
                    </div>

                    // Assessment filter
                    <div class="min-w-48">
                        <select
                            class="block w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            on:change=move |ev| {
                                let mut new_filters = filters.get();
                                let value = event_target_value(&ev);
                                new_filters.assessment_id = if value == "all" { None } else { Some(value) };
                                set_filters.call(new_filters);
                            }
                        >
                            <option value="all">"All Assessments"</option>
                            {move || {
                                available_assessments.get().into_iter().map(|assessment| {
                                    view! {
                                        <option value={assessment.id.to_string()}>{assessment.name}</option>
                                    }
                                }).collect_view()
                            }}
                        </select>
                    </div>

                    // More filters toggle
                    <button
                        type="button"
                        class="inline-flex items-center px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:ring-2 focus:ring-blue-500"
                        on:click=move |_| set_show_more_filters.update(|show| *show = !*show)
                    >
                        {move || if show_more_filters.get() { "Fewer filters" } else { "More filters" }}
                        <svg class=move || {
                            if show_more_filters.get() {
                                "ml-1 h-4 w-4 transform rotate-180"
                            } else {
                                "ml-1 h-4 w-4"
                            }
                        } fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </button>

                    // Clear all (only show if filters are active)
                    <Show when=move || filters.get().has_active_filters()>
                        <button
                            type="button"
                            class="inline-flex items-center px-3 py-2 text-sm font-medium text-gray-500 hover:text-gray-700"
                            on:click=move |_| {
                                let mut new_filters = filters.get();
                                new_filters.clear_all();
                                set_filters.call(new_filters);
                            }
                        >
                            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                            "Clear all"
                        </button>
                    </Show>
                </div>
            </div>

            // Additional filters (collapsible)
            <Show when=move || show_more_filters.get()>
                <div class="p-4 bg-gray-50 border-b border-gray-100">
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        // Teacher filter
                        <div>
                            <label class="block text-xs font-medium text-gray-700 mb-1">"Teacher"</label>
                            <select
                                class="block w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                on:change=move |ev| {
                                    let mut new_filters = filters.get();
                                    let value = event_target_value(&ev);
                                    new_filters.teacher_id = if value == "all" {
                                        None
                                    } else {
                                        value.parse::<i32>().ok()
                                    };
                                    set_filters.call(new_filters);
                                }
                            >
                                <option value="all">"All Teachers"</option>
                                {move || {
                                    available_teachers.get().into_iter().map(|(id, name)| {
                                        view! {
                                            <option value={id.to_string()}>{name}</option>
                                        }
                                    }).collect_view()
                                }}
                            </select>
                        </div>

                        // Simple checkbox filters
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input
                                    type="checkbox"
                                    class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                                    prop:checked=move || filters.get().special_needs
                                    on:change=move |ev| {
                                        let mut new_filters = filters.get();
                                        new_filters.special_needs = event_target_checked(&ev);
                                        set_filters.call(new_filters);
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"Special needs (IEP/504/ESL)"</span>
                            </label>

                            <label class="flex items-center">
                                <input
                                    type="checkbox"
                                    class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                                    prop:checked=move || filters.get().intervention
                                    on:change=move |ev| {
                                        let mut new_filters = filters.get();
                                        new_filters.intervention = event_target_checked(&ev);
                                        set_filters.call(new_filters);
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"Receiving intervention"</span>
                            </label>
                        </div>

                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input
                                    type="checkbox"
                                    class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                                    prop:checked=move || filters.get().incomplete_only
                                    on:change=move |ev| {
                                        let mut new_filters = filters.get();
                                        new_filters.incomplete_only = event_target_checked(&ev);
                                        set_filters.call(new_filters);
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"Incomplete only"</span>
                            </label>

                            <label class="flex items-center">
                                <input
                                    type="checkbox"
                                    class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                                    prop:checked=move || filters.get().at_risk_only
                                    on:change=move |ev| {
                                        let mut new_filters = filters.get();
                                        new_filters.at_risk_only = event_target_checked(&ev);
                                        set_filters.call(new_filters);
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"At risk only"</span>
                            </label>
                        </div>

                        // Sort options
                        <div>
                            <label class="block text-xs font-medium text-gray-700 mb-1">"Sort by"</label>
                            <select
                                class="block w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                on:change=move |ev| {
                                    let mut new_filters = filters.get();
                                    new_filters.sort_by = match event_target_value(&ev).as_str() {
                                        "grade" => SortBy::Grade,
                                        "activity" => SortBy::LastActivity,
                                        "score" => SortBy::Score,
                                        _ => SortBy::Name,
                                    };
                                    set_filters.call(new_filters);
                                }
                            >
                                <option value="name">"Student Name"</option>
                                <option value="grade">"Grade Level"</option>
                                <option value="activity">"Last Activity"</option>
                                <option value="score">"Average Score"</option>
                            </select>
                        </div>
                    </div>
                </div>
            </Show>

            // Results summary
            <div class="px-4 py-2 bg-gray-50 border-b border-gray-100 text-xs text-gray-600">
                {move || {
                    let count = student_count.get();
                    let filter_count = if filters.get().has_active_filters() {
                        format!(" (filtered)")
                    } else {
                        String::new()
                    };
                    format!("Showing {} students{}", count, filter_count)
                }}
            </div>
        </div>
    }
}

// ============================================================================
// Active Filters Summary - Shows applied filters as removable pills
// ============================================================================

#[component]
pub fn ActiveFilterSummary(
    #[prop(into)] filters: Signal<SimpleGradebookFilters>,
    #[prop(into)] set_filters: Callback<SimpleGradebookFilters>,
) -> impl IntoView {
    view! {
        <Show when=move || filters.get().has_active_filters()>
            <div class="flex flex-wrap gap-2 mb-3">
                // Search term
                <Show when=move || !filters.get().search_term.is_empty()>
                    <FilterPill
                        label=move || format!("Search: \"{}\"", filters.get().search_term)
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.search_term.clear();
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                // Grade level
                <Show when=move || filters.get().grade_level.is_some()>
                    <FilterPill
                        label=move || format!("Grade: {}", filters.get().grade_level.unwrap().to_string())
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.grade_level = None;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                // Class section
                <Show when=move || filters.get().class_section.is_some()>
                    <FilterPill
                        label=move || format!("Class: {}", filters.get().class_section.as_ref().unwrap())
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.class_section = None;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                // Boolean filters
                <Show when=move || filters.get().special_needs>
                    <FilterPill
                        label="Special Needs"
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.special_needs = false;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                <Show when=move || filters.get().intervention>
                    <FilterPill
                        label="Intervention"
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.intervention = false;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                <Show when=move || filters.get().incomplete_only>
                    <FilterPill
                        label="Incomplete Only"
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.incomplete_only = false;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>

                <Show when=move || filters.get().at_risk_only>
                    <FilterPill
                        label="At Risk Only"
                        on_remove=move || {
                            let mut new_filters = filters.get();
                            new_filters.at_risk_only = false;
                            set_filters.call(new_filters);
                        }
                    />
                </Show>
            </div>
        </Show>
    }
}

// ============================================================================
// Helper Components
// ============================================================================

#[component]
fn FilterPill(
    #[prop(into)] label: Signal<String>,
    #[prop(into)] on_remove: Callback<()>,
) -> impl IntoView {
    view! {
        <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
            {move || label.get()}
            <button
                type="button"
                class="ml-1 inline-flex items-center p-0.5 rounded-full text-blue-600 hover:bg-blue-200 hover:text-blue-800 focus:outline-none"
                on:click=move |_| on_remove.call(())
            >
                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
            </button>
        </span>
    }
}

// ============================================================================
// Filter Logic Functions (for server-side filtering)
// ============================================================================

impl SimpleGradebookFilters {
    /// Generate SQL WHERE clause based on active filters
    pub fn to_sql_conditions(&self) -> (String, Vec<String>) {
        let mut conditions = Vec::new();
        let mut params = Vec::new();

        if !self.search_term.is_empty() {
            conditions.push(
                "(firstname ILIKE $? OR lastname ILIKE $? OR student_id=:text ILIKE $?)"
                    .to_string(),
            );
            let search_param = format!("%{}%", self.search_term);
            params.push(search_param.clone());
            params.push(search_param.clone());
            params.push(search_param);
        }

        if let Some(grade) = &self.grade_level {
            conditions.push("grade_level = $?".to_string());
            params.push(grade.to_string());
        }

        if let Some(class) = &self.class_section {
            conditions.push("class_section = $?".to_string());
            params.push(class.clone());
        }

        if let Some(teacher_id) = self.teacher_id {
            conditions.push("teacher_id = $?".to_string());
            params.push(teacher_id.to_string());
        }

        if self.special_needs {
            conditions.push("(iep = true OR plan_504 = true OR esl = true)".to_string());
        }

        if self.intervention {
            conditions.push(
                "intervention_status IS NOT NULL AND intervention_status != 'None'".to_string(),
            );
        }

        if self.incomplete_only {
            conditions.push("assessment_progress < 100".to_string());
        }

        if self.at_risk_only {
            conditions.push("risk_level = 'High'".to_string());
        }

        let where_clause = if conditions.is_empty() {
            "1=1".to_string()
        } else {
            conditions.join(" AND ")
        };

        (where_clause, params)
    }

    /// Get ORDER BY clause based on sort option
    pub fn to_sql_order(&self) -> String {
        match self.sort_by {
            SortBy::Name => "lastname, firstname".to_string(),
            SortBy::Grade => "grade_level, lastname, firstname".to_string(),
            SortBy::LastActivity => {
                "last_assessment_date DESC NULLS LAST, lastname, firstname".to_string()
            }
            SortBy::Score => "average_score DESC NULLS LAST, lastname, firstname".to_string(),
        }
    }
}
use leptos::prelude::*;
pub mod search_bar;
pub mod time_frame_selector;
pub mod sort_selector;
pub mod overview_table;
pub mod overview_tab;

pub use search_bar::SearchBar;
pub use time_frame_selector::{TimeFrameSelector, TimeFrame};
pub use sort_selector::{SortSelector, SortOption};
pub use overview_table::OverviewTable;
pub use overview_tab::OverviewTab;
use leptos::prelude::*;
pub mod assessment_card;
pub mod compact_assessment_dot_chart;
pub mod expanded_test_list;
pub mod progress_overview_tab;
pub mod sequence_web;
pub mod test_card;

pub use assessment_card::AssessmentCard;
pub use compact_assessment_dot_chart::*;
pub use expanded_test_list::ExpandedTestList;
pub use progress_overview_tab::ProgressOverviewTab;
pub use sequence_web::*;
pub use test_card::TestCard;
use crate::app::components::dashboard::color_utils::ColorUtils;
use crate::app::components::data_processing::{AssessmentSummary, Progress, TestHistoryEntry};
use crate::app::components::student_report::assessments::compact_assessment_dot_chart::CompactProgressChart; // Fixed import path
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn AssessmentCard(
    assessment: AssessmentSummary,
    tests_resource: Resource<(), Option<Vec<Test>>>,
    on_expand: Callback<String>,
    #[prop(default = false)] is_expanded: bool,
    #[prop(optional)] test_history: Option<Vec<TestHistoryEntry>>,
    #[prop(default = 1)] student_id: i32,
) -> impl IntoView {
    let assessment_id = assessment.assessment_id.clone();
    let assessment_name = assessment.assessment_name.clone();
    let current_score = assessment.current_score;
    let total_possible = assessment.total_possible;
    let progress = assessment.progress.clone();
    let assessment_rating = assessment.assessment_rating.clone();
    let subject = assessment.subject.clone();
    let grade_level = assessment.grade_level.clone();

    // Calculate completion percentage
    let completion_percentage = if let Some(total) = total_possible {
        (current_score as f32 / total as f32 * 100.0).min(100.0)
    } else {
        0.0
    };

    // Get progress status styling
    let (progress_color, progress_bg, progress_text) = match progress {
        Progress::Completed => ("text-green-700", "bg-green-100", "Completed"),
        Progress::Ongoing => ("text-yellow-700", "bg-yellow-100", "In Progress"),
        Progress::NotStarted => ("text-gray-700", "bg-gray-100", "Not Started"),
    };

    // Get rating color styling
    let rating_color = if assessment_rating.contains("Above") || assessment_rating.contains("High")
    {
        "text-green-600"
    } else if assessment_rating.contains("Average") || assessment_rating.contains("On Track") {
        "text-blue-600"
    } else if assessment_rating.contains("Below") || assessment_rating.contains("Risk") {
        "text-red-600"
    } else {
        "text-gray-600"
    };

    view! {
        <div class="bg-white rounded-xl border border-gray-200 shadow-sm hover:shadow-md transition-shadow duration-200">
            // Header Section
            <div class="p-6 border-b border-gray-100">
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <h3 class="text-lg font-semibold text-gray-900 mb-2">
                            {assessment_name}
                        </h3>
                        <div class="flex items-center gap-4 text-sm text-gray-600">
                            <span class="flex items-center gap-1">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                                </svg>
                                {subject}
                            </span>
                            {grade_level.as_ref().map(|grade| view! {
                                <span class="flex items-center gap-1">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                                    </svg>
                                    {format!("Grade {}", grade)}
                                </span>
                            })}
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <span class={format!("px-3 py-1 rounded-full text-xs font-medium {} {}", progress_color, progress_bg)}>
                            {progress_text}
                        </span>
                        <button
                            class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-50 rounded-lg transition-colors"
                            on:click=move |_| on_expand.call(assessment_id.clone())
                        >
                            <svg
                                class={format!("w-5 h-5 transition-transform duration-200 {}", if is_expanded { "rotate-180" } else { "" })}
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>

            {if !is_expanded && !assessment.test_details.is_empty() {
                view! {
                    <div class="px-6 py-4 border-b border-gray-100">
                        <CompactProgressChart
                            assessment={assessment.clone()}
                            test_details={assessment.test_details.clone()}
                            tests_resource={tests_resource}
                        />
                    </div>
                }
            } else {
                view! { <div></div> }
            }}

            // Content Section
            <div class="p-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    // Score Section
                    <div class="space-y-3">
                        <h4 class="text-sm font-medium text-gray-700">Score Progress</h4>
                        <div class="flex items-end gap-2">
                            <span class="text-2xl font-bold text-gray-900">
                                {current_score}
                            </span>
                            {total_possible.map(|total| view! {
                                <span class="text-lg text-gray-500 mb-1">
                                    / {total}
                                </span>
                            })}
                        </div>
                        {total_possible.map(|_| view! {
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div
                                    class={
                                        if completion_percentage >= 80.0 {
                                            "bg-green-500 h-2 rounded-full transition-all duration-300"
                                        } else if completion_percentage >= 60.0 {
                                            "bg-yellow-500 h-2 rounded-full transition-all duration-300"
                                        } else {
                                            "bg-red-500 h-2 rounded-full transition-all duration-300"
                                        }
                                    }
                                    style=format!("width: {}%", completion_percentage)
                                ></div>
                            </div>
                        })}
                        <p class="text-xs text-gray-500">
                            {format!("{:.1}% Complete", completion_percentage)}
                        </p>
                    </div>

                    // Performance Rating Section
                    <div class="space-y-3">
                        <h4 class="text-sm font-medium text-gray-700">Performance Level</h4>
                        <div class={format!("text-xl font-semibold {}", rating_color)}>
                            {assessment_rating.clone()}
                        </div>
                        <div class="flex items-center gap-2">
                            {
                                if assessment_rating.contains("Above") || assessment_rating.contains("High") {
                                    view! {
                                        <div class="flex items-center gap-1 text-green-600">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                                            </svg>
                                            <span class="text-sm">Above Average</span>
                                        </div>
                                    }
                                } else if assessment_rating.contains("Below") || assessment_rating.contains("Risk") {
                                    view! {
                                        <div class="flex items-center gap-1 text-red-600">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M16.707 10.293a1 1 0 010 1.414l-6 6a1 1 0 01-1.414 0l-6-6a1 1 0 111.414-1.414L9 14.586V3a1 1 0 012 0v11.586l4.293-4.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                                            </svg>
                                            <span class="text-sm">Needs Support</span>
                                        </div>
                                    }
                                } else {
                                    view! {
                                        <div class="flex items-center gap-1 text-blue-600">
                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                                            </svg>
                                            <span class="text-sm">On Track</span>
                                        </div>
                                    }
                                }
                            }
                        </div>
                    </div>

                    // Test Count Section
                    <div class="space-y-3">
                        <h4 class="text-sm font-medium text-gray-700">Tests Completed</h4>
                        <div class="flex items-center gap-2">
                            <span class="text-2xl font-bold text-gray-900">
                                {assessment.test_details.len()}
                            </span>
                            <span class="text-sm text-gray-500">tests</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-gray-600">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span>
                                {
                                    let completed_count = assessment.test_details.iter()
                                        .filter(|test| test.score > 0)
                                        .count();
                                    format!("{} completed", completed_count)
                                }
                            </span>
                        </div>
                    </div>
                </div>

                // Expanded Details Section
                {if is_expanded {
                    view! {
                        <div class="mt-6 pt-6 border-t border-gray-100">
                            <h4 class="text-sm font-medium text-gray-700 mb-4">Test Details</h4>
                            <div class="space-y-3">
                                {assessment.test_details.iter().map(|test| {
                                    let score_percentage = if test.total_possible > 0 {
                                        (test.score as f32 / test.total_possible as f32) * 100.0
                                    } else {
                                        0.0
                                    };

                                    let (status_color, status_bg) = if test.score > 0 {
                                        if score_percentage >= 80.0 {
                                            ("text-green-700", "bg-green-100")
                                        } else if score_percentage >= 60.0 {
                                            ("text-yellow-700", "bg-yellow-100")
                                        } else {
                                            ("text-red-700", "bg-red-100")
                                        }
                                    } else {
                                        ("text-gray-700", "bg-gray-100")
                                    };

                                    view! {
                                        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                                            <div class="flex-1">
                                                <div class="flex items-center gap-3">
                                                    <div class="flex-1">
                                                        <h5 class="font-medium text-gray-900">{test.test_name.clone()}</h5>
                                                        <p class="text-sm text-gray-500">{test.test_area.clone()}</p>
                                                    </div>
                                                    <div class="text-right">
                                                        <div class="text-lg font-semibold text-gray-900">
                                                            {test.score} / {test.total_possible}
                                                        </div>
                                                        <div class={format!("text-sm font-medium {}", status_color)}>
                                                            {if test.score > 0 {
                                                                format!("{:.0}%", score_percentage)
                                                            } else {
                                                                "Not taken".to_string()
                                                            }}
                                                        </div>
                                                    </div>
                                                    <span class={format!("px-2 py-1 rounded-full text-xs font-medium {} {}", status_color, status_bg)}>
                                                        {test.performance_class.clone()}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    }
                                }).collect::<Vec<_>>()}
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }}
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::dashboard::color_utils::ColorUtils;
use crate::app::components::dashboard::scores_ledger::ScoreUtils;
use crate::app::components::data_processing::TestDetail;
use crate::app::models::test::Test;
use leptos::prelude::*;

#[component]
pub fn TestCard(
    test_detail: TestDetail,
    tests_resource: Resource<(), Option<Vec<Test>>>,
    #[prop(default = false)] show_detailed_info: bool,
) -> impl IntoView {
    let test_name = test_detail.test_name.clone();
    let score = test_detail.score;
    let total_possible = test_detail.total_possible;
    let test_area = test_detail.test_area.clone();
    let date_administered = test_detail.date_administered;
    let test_id = test_detail.test_id;

    // Calculate percentage
    let percentage = (score as f32 / total_possible as f32 * 100.0).min(100.0);

    // Get benchmark-based styling
    let get_styling = move || {
        let test_data_result = tests_resource
            .get()
            .and_then(|result| result)
            .and_then(|tests| tests.iter().find(|t| t.test_id == test_id).cloned());

        let benchmark_categories = test_data_result
            .as_ref()
            .and_then(|t| t.benchmark_categories.as_ref());

        let badge_classes =
            ColorUtils::get_badge_classes_for_score(score, total_possible, benchmark_categories);
        let score_text_color =
            ColorUtils::get_score_text_color_for_score(score, total_possible, benchmark_categories);
        let progress_bar_color = ColorUtils::get_progress_bar_color_for_score(
            score,
            total_possible,
            benchmark_categories,
        );
        let benchmark_label =
            ScoreUtils::get_benchmark_label(score, total_possible, benchmark_categories);

        (
            badge_classes,
            score_text_color,
            progress_bar_color,
            benchmark_label,
        )
    };

    view! {
        <div class="bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition-all duration-200 hover:border-blue-200">
            <div class="p-5">
                // Header Section
                <div class="flex items-start justify-between mb-4">
                    <div class="flex-1">
                        <h4 class="text-base font-semibold text-gray-900 mb-1">
                            {test_name}
                        </h4>
                        <div class="flex items-center gap-3 text-sm text-gray-600">
                            <span class="flex items-center gap-1">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                                </svg>
                                {test_area}
                            </span>
                            <span class="flex items-center gap-1">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                </svg>
                                {date_administered.format("%b %d, %Y").to_string()}
                            </span>
                        </div>
                    </div>
                    // Performance Badge
                    <div class={format!("px-2.5 py-1 rounded-full text-xs font-medium {}", get_styling().0)}>
                        {get_styling().3}
                    </div>
                </div>

                // Score Section
                <div class="mb-4">
                    <div class="flex items-end gap-2 mb-2">
                        <span class={format!("text-2xl font-bold {}", get_styling().1)}>
                            {score}
                        </span>
                        <span class="text-lg text-gray-500 mb-1">
                            / {total_possible}
                        </span>
                        <span class="text-sm text-gray-500 mb-1">
                            ({format!("{:.1}%", percentage)})
                        </span>
                    </div>

                    // Progress Bar
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div
                            class={format!("{} h-2 rounded-full transition-all duration-300", get_styling().2)}
                            style=format!("width: {}%", percentage)
                        ></div>
                    </div>
                </div>

                // Detailed Information (conditional)
                {if show_detailed_info {
                    view! {
                        <div class="border-t border-gray-100 pt-4 space-y-3">
                            // Performance Indicators
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>
                                    <span class="text-gray-600">Score Range:</span>
                                    <div class="font-medium text-gray-900">
                                        {
                                            if percentage >= 90.0 {
                                                "Excellent (90-100%)"
                                            } else if percentage >= 80.0 {
                                                "Good (80-89%)"
                                            } else if percentage >= 70.0 {
                                                "Satisfactory (70-79%)"
                                            } else if percentage >= 60.0 {
                                                "Needs Improvement (60-69%)"
                                            } else {
                                                "Below Standards (<60%)"
                                            }
                                        }
                                    </div>
                                </div>
                                <div>
                                    <span class="text-gray-600">Status:</span>
                                    <div class={
                                        if percentage >= 70.0 {
                                            "font-medium text-green-600"
                                        } else if percentage >= 60.0 {
                                            "font-medium text-yellow-600"
                                        } else {
                                            "font-medium text-red-600"
                                        }
                                    }>
                                        {
                                            if percentage >= 70.0 {
                                                "Passing"
                                            } else if percentage >= 60.0 {
                                                "Marginal"
                                            } else {
                                                "Needs Support"
                                            }
                                        }
                                    </div>
                                </div>
                            </div>

                            // Additional Actions
                            <div class="flex items-center gap-2 pt-2">
                                <button class="text-xs text-blue-600 hover:text-blue-700 hover:underline transition-colors">
                                    View Details
                                </button>
                                <span class="text-gray-300">|</span>
                                <button class="text-xs text-gray-600 hover:text-gray-700 hover:underline transition-colors">
                                    Compare Scores
                                </button>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }}
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::data_processing::{AssessmentSummary, TestDetail};
use crate::app::models::test::Test;
use crate::app::server_functions::assessments::get_test_sequence;
use leptos::prelude::*;
use std::collections::HashMap;

#[component]
pub fn CompactProgressChart(
    assessment: AssessmentSummary,
    test_details: Vec<TestDetail>,
    tests_resource: Resource<(), Option<Vec<Test>>>,
) -> impl IntoView {
    // Get the complete test sequence for this assessment
    let test_sequence_resource = Resource::new(
        move || assessment.assessment_id.clone(),
        |assessment_id| async move {
            match get_test_sequence(assessment_id).await {
                Ok(sequence) => {
                    log::info!(
                        "Successfully loaded test sequence with {} tests",
                        sequence.len()
                    );
                    Some(sequence)
                }
                Err(e) => {
                    log::error!("Failed to get test sequence: {}", e);
                    None
                }
            }
        },
    );

    // Group test details by test_id and sort by attempt
    let grouped_tests = Memo::new(move |_| {
        let mut groups: HashMap<String, Vec<TestDetail>> = HashMap::new();

        for test in test_details.clone() {
            groups.entry(test.test_id.clone()).or_default().push(test);
        }

        // Sort each group by attempt number
        for attempts in groups.values_mut() {
            attempts.sort_by_key(|t| t.attempt);
        }

        groups
    });

    // Create the ordered test sequence including untaken tests
    let chart_data = Memo::new(move |_| {
        let groups = grouped_tests.get();
        let test_sequence = test_sequence_resource.get().unwrap_or(None);
        let all_tests = tests_resource.get().unwrap_or(None);

        log::info!(
            "Building chart data - test_sequence loaded: {}, attempted tests: {}",
            test_sequence.is_some(),
            groups.len()
        );

        // Get the ordered test sequence
        let ordered_test_ids = if let Some(sequence) = test_sequence {
            log::info!("Using database test sequence with {} tests", sequence.len());
            // Use the sequence from the database (test_id, test_name)
            sequence
                .into_iter()
                .map(|(test_id, _test_name)| test_id)
                .collect()
        } else {
            log::warn!("No test sequence available, falling back to attempted tests");

            // Fallback to just the attempted tests from test_details
            log::info!("Using test_details as fallback");
            let mut attempted: Vec<String> = groups.keys().cloned().collect();
            attempted.sort();
            attempted
        };

        log::info!(
            "Final ordered test sequence has {} tests",
            ordered_test_ids.len()
        );

        let max_attempts = groups
            .values()
            .map(|attempts| attempts.len())
            .max()
            .unwrap_or(1);

        let total_tests = ordered_test_ids.len();

        // Calculate completion stats (tests that have at least one attempt with score > 0)
        let completed_tests = groups
            .values()
            .filter(|attempts| attempts.iter().any(|t| t.score > 0))
            .count();

        // Create a map of test_id to test_name for untaken tests
        let test_names: HashMap<String, String> = if let Some(tests) = all_tests {
            tests
                .iter()
                .map(|t| (t.test_id.clone(), t.name.clone()))
                .collect()
        } else {
            HashMap::new()
        };

        (
            groups,
            ordered_test_ids,
            max_attempts,
            total_tests,
            completed_tests,
            test_names,
        )
    });

    // Helper function to get benchmark-based color
    let get_dot_color = move |test: &TestDetail| -> (String, String, String) {
        // Get benchmark categories from tests_resource
        let benchmark_categories = tests_resource
            .get()
            .unwrap_or(None)
            .and_then(|tests| tests.iter().find(|t| t.test_id == test.test_id).cloned())
            .and_then(|t| t.benchmark_categories);

        let percentage = if test.total_possible > 0 {
            (test.score as f32 / test.total_possible as f32) * 100.0
        } else {
            0.0
        };

        if test.score == 0 {
            return (
                "bg-gray-200".to_string(),
                "ring-gray-400".to_string(),
                "opacity-40".to_string(),
            );
        }

        // Use benchmark categories if available
        if let Some(categories) = benchmark_categories {
            for category in &categories {
                if category.contains(test.score) {
                    let color = category.get_color();
                    // Convert hex color to Tailwind classes
                    let bg_class = hex_to_tailwind_bg(&color);
                    let ring_class = bg_class
                        .replace("bg-", "ring-")
                        .replace("-500", "-600")
                        .replace("-400", "-500");
                    return (bg_class, ring_class, "".to_string());
                }
            }
        }

        // Fallback to percentage-based colors (GitHub-style)
        let (bg_class, ring_class) = if percentage >= 90.0 {
            ("bg-emerald-500", "ring-emerald-600")
        } else if percentage >= 80.0 {
            ("bg-emerald-400", "ring-emerald-500")
        } else if percentage >= 70.0 {
            ("bg-yellow-400", "ring-yellow-500")
        } else if percentage >= 60.0 {
            ("bg-orange-400", "ring-orange-500")
        } else {
            ("bg-red-400", "ring-red-500")
        };

        (bg_class.to_string(), ring_class.to_string(), "".to_string())
    };

    view! {
        <div class="w-full">
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                    <span class="text-sm font-medium text-gray-700">"Test Progress"</span>
                </div>
                <span class="text-xs text-gray-500">
                    {move || {
                        let (_, ordered_test_ids, _, _, _, _) = chart_data.get();
                        format!("{} tests", ordered_test_ids.len())
                    }}
                </span>
            </div>

            <div class="relative bg-gradient-to-br from-gray-50 to-gray-100 border border-gray-200 rounded-lg p-4">
                <Suspense fallback=move || view! {
                    <div class="text-center py-4 text-gray-500 text-xs">
                        "Loading test sequence..."
                    </div>
                }>
                    {move || {
                        let (groups, ordered_test_ids, max_attempts, total_tests, completed_tests, test_names) = chart_data.get();

                        if total_tests == 0 {
                            return view! {
                                <div class="text-center py-8 text-gray-500">
                                    <div class="w-12 h-12 mx-auto mb-3 bg-gray-200 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                                        </svg>
                                    </div>
                                    <div class="text-sm font-medium text-gray-600 mb-1">"No Test Sequence"</div>
                                    <div class="text-xs text-gray-500">"No tests found for this assessment"</div>
                                </div>
                            }.into_any();
                        }

                        // Responsive sizing based on number of tests - ensure no overlap
                        let (dot_size, gap_size, show_y_axis) = if total_tests <= 6 {
                            (16, 6, max_attempts > 1)
                        } else if total_tests <= 12 {
                            (14, 4, max_attempts > 1)
                        } else if total_tests <= 20 {
                            (12, 3, false)
                        } else {
                            (10, 2, false)
                        };

                        view! {
                            <div class="space-y-4">
                                // Chart grid
                                <div class="flex items-end">
                                    // Y-axis (attempts) - only show if multiple attempts and space allows
                                    {if show_y_axis {
                                        view! {
                                            <div class="w-8 mr-3 flex flex-col justify-end" style=format!("margin-bottom: {}px", dot_size / 2)>
                                                // Attempts label at the top
                                                <div class="text-xs font-medium text-gray-500 mb-2 text-center">"Attempts"</div>
                                                // Numbers from max down to 1 (so 1 appears at bottom)
                                                <div class="space-y-1 flex flex-col">
                                                    {(1..=max_attempts).rev().map(|attempt| {
                                                        view! {
                                                            <div
                                                                class="text-xs text-gray-400 text-right leading-none font-mono"
                                                                style=format!("height: {}px; display: flex; align-items: center; justify-content: flex-end", dot_size + gap_size)
                                                            >
                                                                {attempt.to_string()}
                                                            </div>
                                                        }
                                                    }).collect::<Vec<_>>()}
                                                </div>
                                            </div>
                                        }.into_any()
                                    } else {
                                        view! { <div class="w-0"></div> }.into_any()
                                    }}

                                    // Chart dots container
                                    <div class="flex-1 overflow-x-auto">
                                        <div class="flex items-end" style=format!("gap: {}px", gap_size)>
                                            {ordered_test_ids.iter().enumerate().map(|(index, test_id)| {
                                                let test_attempts = groups.get(test_id).cloned().unwrap_or_default();

                                                // Get test name - prioritize from attempts, then from test_names map, then fallback
                                                let test_name = test_attempts.first()
                                                    .map(|t| t.test_name.clone())
                                                    .or_else(|| test_names.get(test_id).cloned())
                                                    .or_else(|| {
                                                        // Try to get test name from tests_resource as final fallback
                                                        tests_resource.get()
                                                            .unwrap_or(None)
                                                            .and_then(|tests| {
                                                                tests.iter()
                                                                    .find(|t| &t.test_id == test_id)
                                                                    .map(|t| t.name.clone())
                                                            })
                                                    })
                                                    .unwrap_or_else(|| format!("Test {}", index + 1));

                                                // Determine if this test has been attempted at all
                                                let has_attempts = !test_attempts.is_empty();

                                                view! {
                                                    <div
                                                        class="flex flex-col hover:bg-white hover:bg-opacity-60 rounded-md p-1 transition-all duration-200"
                                                        style=format!("gap: {}px", gap_size / 2)
                                                        title=format!("{}{}", test_name, if !has_attempts { " (Not yet attempted)" } else { "" })
                                                    >
                                                        {(1..=max_attempts).rev().map(|attempt| {
                                                            let attempt_i32 = attempt as i32;
                                                            let dot_info = test_attempts.iter()
                                                                .find(|t| t.attempt == attempt_i32)
                                                                .map(|test| {
                                                                    let percentage = if test.total_possible > 0 {
                                                                        (test.score as f32 / test.total_possible as f32) * 100.0
                                                                    } else {
                                                                        0.0
                                                                    };

                                                                    let (bg_class, ring_class, opacity) = get_dot_color(test);

                                                                    let tooltip = format!("{}\nAttempt {}: {}/{} ({}%)\nDate: {}",
                                                                        test.test_name,
                                                                        attempt_i32,
                                                                        test.score,
                                                                        test.total_possible,
                                                                        percentage as i32,
                                                                        test.date_administered.format("%m/%d/%Y")
                                                                    );

                                                                    (bg_class, ring_class, opacity, tooltip)
                                                                });

                                                            match dot_info {
                                                                Some((bg_class, ring_class, opacity, tooltip)) => view! {
                                                                    <div
                                                                        class=format!("rounded-sm cursor-pointer hover:ring-2 hover:{} hover:scale-110 transition-all duration-200 shadow-sm {} {}", ring_class, bg_class, opacity)
                                                                        style=format!("width: {}px; height: {}px", dot_size, dot_size)
                                                                        title=tooltip
                                                                    ></div>
                                                                },
                                                                None => {
                                                                    // Show different styles based on whether test has been attempted
                                                                    if !has_attempts && attempt == 1 {
                                                                        // Untaken test in sequence - show dotted outline with better visibility
                                                                        view! {
                                                                            <div
                                                                                class="rounded-sm border-2 border-dashed border-blue-300 bg-blue-50 hover:bg-blue-100 hover:border-blue-400 transition-all duration-200"
                                                                                style=format!("width: {}px; height: {}px", dot_size, dot_size)
                                                                                title=format!("{}\nNext in sequence - Not yet attempted", test_name)
                                                                            ></div>
                                                                        }
                                                                    } else if has_attempts && attempt > test_attempts.len() {
                                                                        // Additional attempt slots for attempted tests - light gray
                                                                        view! {
                                                                            <div
                                                                                class="bg-gray-100 rounded-sm opacity-30 border border-gray-200"
                                                                                style=format!("width: {}px; height: {}px", dot_size, dot_size)
                                                                                title=format!("{}\nAttempt {} - Available", test_name, attempt_i32)
                                                                            ></div>
                                                                        }
                                                                    } else {
                                                                        // Empty space for higher attempts of untaken tests
                                                                        view! {
                                                                            <div
                                                                                style=format!("width: {}px; height: {}px", dot_size, dot_size)
                                                                            ></div>
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }).collect::<Vec<_>>()}
                                                    </div>
                                                }
                                            }).collect::<Vec<_>>()}
                                        </div>
                                    </div>
                                </div>

                                // Summary stats and legend
                                <div class="bg-white bg-opacity-70 rounded-md p-2 border border-gray-200">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center space-x-4">
                                            // Completion indicator
                                            <div class="flex items-center space-x-2">
                                                <div class="flex items-center space-x-1">
                                                    <div class="w-2 h-2 bg-emerald-500 rounded-full"></div>
                                                    <span class="text-sm font-medium text-gray-700">
                                                        {format!("{}/{}", completed_tests, total_tests)}
                                                    </span>
                                                </div>
                                                <span class="text-xs text-gray-500">"completed"</span>
                                            </div>

                                            // Progress percentage
                                            <div class="text-xs text-gray-600 bg-gray-100 px-2 py-1 rounded-full">
                                                {format!("{}%",
                                                    if total_tests > 0 { (completed_tests * 100) / total_tests } else { 0 }
                                                )}
                                            </div>

                                            // Pending tests indicator - updated styling
                                            <div class="flex items-center space-x-1">
                                                <div class="w-2 h-2 border-2 border-dashed border-blue-300 bg-blue-50 rounded-sm"></div>
                                                <span class="text-xs text-gray-500">
                                                    {format!("{} pending", total_tests - completed_tests)}
                                                </span>
                                            </div>
                                        </div>

                                        // Mini legend
                                        <div class="flex items-center space-x-2">
                                            <span class="text-xs text-gray-500">"Performance:"</span>
                                            <div class="flex space-x-1">
                                                <div class="w-2 h-2 bg-red-400 rounded-sm border border-red-500" title="Below 60%"></div>
                                                <div class="w-2 h-2 bg-orange-400 rounded-sm border border-orange-500" title="60-69%"></div>
                                                <div class="w-2 h-2 bg-yellow-400 rounded-sm border border-yellow-500" title="70-79%"></div>
                                                <div class="w-2 h-2 bg-emerald-400 rounded-sm border border-emerald-500" title="80-89%"></div>
                                                <div class="w-2 h-2 bg-emerald-500 rounded-sm border border-emerald-600" title="90%+"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }.into_any()
                    }}
                </Suspense>
            </div>
        </div>
    }
}

// Helper function to convert hex colors to Tailwind classes
fn hex_to_tailwind_bg(hex: &str) -> String {
    match hex.to_lowercase().as_str() {
        "#22c55e" | "#16a34a" | "#15803d" => "bg-green-500",
        "#eab308" | "#ca8a04" | "#a16207" => "bg-yellow-500",
        "#f97316" | "#ea580c" | "#c2410c" => "bg-orange-500",
        "#ef4444" | "#dc2626" | "#b91c1c" => "bg-red-500",
        "#3b82f6" | "#2563eb" | "#1d4ed8" => "bg-blue-500",
        "#8b5cf6" | "#7c3aed" | "#6d28d9" => "bg-purple-500",
        "#06b6d4" | "#0891b2" | "#0e7490" => "bg-cyan-500",
        "#10b981" | "#059669" | "#047857" => "bg-emerald-500",
        _ => "bg-gray-500", // fallback
    }
    .to_string()
}
use crate::app::components::data_processing::{AssessmentSummary, Progress, TestDetail};
use leptos::prelude::*;
use leptos::prelude::*;
use std::collections::HashMap;

#[component]
pub fn AssessmentProgressChart(
    assessment: AssessmentSummary,
    test_details: Vec<TestDetail>,
    #[prop(default = 200)] height: u32,
    #[prop(default = false)] show_legend: bool,
) -> impl IntoView {
    // Group tests by test name to handle multiple attempts
    let test_groups = Memo::new(move |_| {
        let mut groups: HashMap<String, Vec<TestDetail>> = HashMap::new();

        for test in test_details.iter() {
            groups
                .entry(test.test_name.clone())
                .or_insert_with(Vec::new)
                .push(test.clone());
        }

        // Sort groups by date and attempts
        let mut sorted_groups: Vec<(String, Vec<TestDetail>)> = groups.into_iter().collect();
        sorted_groups.sort_by_key(|(_, tests)| {
            tests
                .iter()
                .map(|t| t.date_administered)
                .min()
                .unwrap_or_default()
        });

        for (_, tests) in sorted_groups.iter_mut() {
            tests.sort_by_key(|t| (t.date_administered, t.attempt));
        }

        sorted_groups
    });

    // Calculate chart data points
    let chart_data = Memo::new(move |_| {
        let groups = test_groups.get();
        let mut data_points = Vec::new();
        let mut cumulative_score = 0;
        let mut cumulative_possible = 0;
        let mut x_position = 0;

        for (test_name, attempts) in groups.iter() {
            for (attempt_index, attempt) in attempts.iter().enumerate() {
                if attempt.score > 0 {
                    cumulative_score += attempt.score;
                    cumulative_possible += attempt.total_possible;

                    let percentage = if cumulative_possible > 0 {
                        (cumulative_score as f32 / cumulative_possible as f32) * 100.0
                    } else {
                        0.0
                    };

                    let attempt_percentage = if attempt.total_possible > 0 {
                        (attempt.score as f32 / attempt.total_possible as f32) * 100.0
                    } else {
                        0.0
                    };

                    data_points.push(ChartPoint {
                        x: x_position,
                        y: percentage,
                        test_name: test_name.clone(),
                        attempt_number: attempt.attempt,
                        score: attempt.score,
                        total_possible: attempt.total_possible,
                        attempt_percentage,
                        date: attempt.date_administered.date_naive(),
                        is_retry: attempt_index > 0,
                    });

                    x_position += 1;
                }
            }
        }

        data_points
    });

    // Calculate chart dimensions and scales
    let chart_bounds = Memo::new(move |_| {
        let data = chart_data.get();
        let max_x = data.len().max(1);
        let max_y = 100.0; // Always 0-100%

        ChartBounds {
            width: 400.0,
            height: height as f32,
            padding: 40.0,
            max_x: max_x as f32,
            max_y,
        }
    });

    view! {
        <div class="assessment-progress-chart bg-white rounded-lg border border-gray-200 p-4">
            {if show_legend {
                view! {
                    <div class="mb-4">
                        <h4 class="text-sm font-medium text-gray-700 mb-2">Assessment Progress Over Time</h4>
                        <div class="flex items-center gap-4 text-xs text-gray-600">
                            <div class="flex items-center gap-1">
                                <div class="w-3 h-0.5 bg-blue-500"></div>
                                <span>Cumulative Score</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                                <span>Test Attempt</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <div class="w-2 h-2 bg-amber-500 rounded-full"></div>
                                <span>Retry</span>
                            </div>
                        </div>
                    </div>
                }
            } else {
                view! { <div></div> }
            }}

            <div class="relative">
                <svg
                    width={move || chart_bounds.get().width + chart_bounds.get().padding * 2.0}
                    height={move || chart_bounds.get().height + chart_bounds.get().padding * 2.0}
                    class="overflow-visible"
                >
                    // Background grid
                    <g class="grid" stroke="#f3f4f6" stroke-width="1" opacity="0.5">
                        // Horizontal grid lines
                        {move || {
                            let bounds = chart_bounds.get();
                            (0..=4).map(|i| {
                                let y = bounds.padding + (i as f32 * bounds.height / 4.0);
                                view! {
                                    <line
                                        x1={bounds.padding}
                                        y1={y}
                                        x2={bounds.padding + bounds.width}
                                        y2={y}
                                    />
                                }
                            }).collect::<Vec<_>>()
                        }}

                        // Vertical grid lines
                        {move || {
                            let bounds = chart_bounds.get();
                            let data = chart_data.get();
                            if data.is_empty() { return vec![]; }

                            (0..=data.len()).map(|i| {
                                let x = bounds.padding + (i as f32 * bounds.width / data.len().max(1) as f32);
                                view! {
                                    <line
                                        x1={x}
                                        y1={bounds.padding}
                                        x2={x}
                                        y2={bounds.padding + bounds.height}
                                    />
                                }
                            }).collect::<Vec<_>>()
                        }}
                    </g>

                    // Y-axis labels
                    <g class="y-axis-labels" fill="#6b7280" font-size="10" text-anchor="end">
                        {move || {
                            let bounds = chart_bounds.get();
                            (0..=4).map(|i| {
                                let y = bounds.padding + (i as f32 * bounds.height / 4.0) + 3.0;
                                let value = 100.0 - (i as f32 * 25.0);
                                view! {
                                    <text x={bounds.padding - 5.0} y={y}>
                                        {format!("{}%", value as i32)}
                                    </text>
                                }
                            }).collect::<Vec<_>>()
                        }}
                    </g>

                    // Progress line
                    {move || {
                        let data = chart_data.get();
                        let bounds = chart_bounds.get();

                        if data.len() < 2 {
                            return view! { <g></g> };
                        }

                        let path_data = data.iter().enumerate().map(|(i, point)| {
                            let x = bounds.padding + (i as f32 * bounds.width / (data.len() - 1).max(1) as f32);
                            let y = bounds.padding + bounds.height - (point.y / 100.0 * bounds.height);

                            if i == 0 {
                                format!("M {} {}", x, y)
                            } else {
                                format!(" L {} {}", x, y)
                            }
                        }).collect::<String>();

                        view! {
                            <g>
                                <path
                                    d={path_data}
                                    stroke="#3b82f6"
                                    stroke-width="2"
                                    fill="none"
                                    class="transition-all duration-300"
                                />
                            </g>
                        }
                    }}

                    // Data points
                    {move || {
                        let data = chart_data.get();
                        let bounds = chart_bounds.get();

                        data.iter().enumerate().map(|(i, point)| {
                            let x = bounds.padding + (i as f32 * bounds.width / data.len().max(1) as f32);
                            let y = bounds.padding + bounds.height - (point.y / 100.0 * bounds.height);

                            let (fill_color, stroke_color) = if point.is_retry {
                                ("#f59e0b", "#d97706") // Amber for retries
                            } else {
                                ("#3b82f6", "#2563eb") // Blue for first attempts
                            };

                            view! {
                                <g class="data-point group cursor-pointer">
                                    <circle
                                        cx={x}
                                        cy={y}
                                        r="4"
                                        fill={fill_color}
                                        stroke={stroke_color}
                                        stroke-width="2"
                                        class="transition-all duration-200 group-hover:r-6 group-hover:stroke-width-3"
                                    />

                                    // Tooltip (hidden by default, shown on hover)
                                    <g class="tooltip opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none">
                                        <rect
                                            x={x - 40.0}
                                            y={y - 35.0}
                                            width="80"
                                            height="25"
                                            fill="#1f2937"
                                            rx="4"
                                            class="drop-shadow-lg"
                                        />
                                        <text
                                            x={x}
                                            y={y - 22.0}
                                            text-anchor="middle"
                                            fill="white"
                                            font-size="10"
                                            font-weight="600"
                                        >
                                            {point.test_name.chars().take(8).collect::<String>()}
                                            {if point.test_name.len() > 8 { "..." } else { "" }}
                                        </text>
                                        <text
                                            x={x}
                                            y={y - 12.0}
                                            text-anchor="middle"
                                            fill="white"
                                            font-size="9"
                                        >
                                            {format!("{}% ({}/{})", point.attempt_percentage as i32, point.score, point.total_possible)}
                                        </text>
                                    </g>
                                </g>
                            }
                        }).collect::<Vec<_>>()
                    }}

                    // X-axis
                    <line
                        x1={move || chart_bounds.get().padding}
                        y1={move || chart_bounds.get().padding + chart_bounds.get().height}
                        x2={move || chart_bounds.get().padding + chart_bounds.get().width}
                        y2={move || chart_bounds.get().padding + chart_bounds.get().height}
                        stroke="#6b7280"
                        stroke-width="1"
                    />

                    // Y-axis
                    <line
                        x1={move || chart_bounds.get().padding}
                        y1={move || chart_bounds.get().padding}
                        x2={move || chart_bounds.get().padding}
                        y2={move || chart_bounds.get().padding + chart_bounds.get().height}
                        stroke="#6b7280"
                        stroke-width="1"
                    />
                </svg>

                // Progress statistics overlay
                <div class="absolute top-2 right-2 bg-white/90 backdrop-blur-sm rounded-lg px-3 py-2 text-xs">
                    <div class="space-y-1">
                        <div class="flex justify-between gap-4">
                            <span class="text-gray-600">Tests:</span>
                            <span class="font-medium">{move || test_groups.get().len()}</span>
                        </div>
                        <div class="flex justify-between gap-4">
                            <span class="text-gray-600">Attempts:</span>
                            <span class="font-medium">{move || chart_data.get().len()}</span>
                        </div>
                        <div class="flex justify-between gap-4">
                            <span class="text-gray-600">Avg Score:</span>
                            <span class="font-medium text-blue-600">
                                {move || {
                                    let data = chart_data.get();
                                    if data.is_empty() {
                                        "0%".to_string()
                                    } else {
                                        let avg = data.iter().map(|p| p.attempt_percentage).sum::<f32>() / data.len() as f32;
                                        format!("{}%", avg as i32)
                                    }
                                }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
}

#[derive(Clone, Debug, PartialEq)]
struct ChartPoint {
    x: usize,
    y: f32, // Cumulative percentage
    test_name: String,
    attempt_number: i32,
    score: i32,
    total_possible: i32,
    attempt_percentage: f32,
    date: chrono::NaiveDate,
    is_retry: bool,
}

#[derive(Clone, Debug, PartialEq)]
struct ChartBounds {
    width: f32,
    height: f32,
    padding: f32,
    max_x: f32,
    max_y: f32,
}

// Compact version for embedding in assessment cards
#[component]
pub fn CompactProgressChart(
    assessment: AssessmentSummary,
    test_details: Vec<TestDetail>,
) -> impl IntoView {
    view! {
        <AssessmentProgressChart
            assessment={assessment}
            test_details={test_details}
            height={120}
            show_legend={false}
        />
    }
}

// Enhanced version with more details
#[component]
pub fn DetailedProgressChart(
    assessment: AssessmentSummary,
    test_details: Vec<TestDetail>,
) -> impl IntoView {
    view! {
        <AssessmentProgressChart
            assessment={assessment}
            test_details={test_details}
            height={300}
            show_legend={true}
        />
    }
}

// Legacy component aliases for backward compatibility with existing code
#[component]
pub fn SequenceWeb(assessment: AssessmentSummary, test_details: Vec<TestDetail>) -> impl IntoView {
    view! {
        <DetailedProgressChart
            assessment={assessment}
            test_details={test_details}
        />
    }
}

#[component]
pub fn EnhancedNodalSequence(
    assessment_name: String,
    test_details: Vec<TestDetail>,
    show_actions: bool,
) -> impl IntoView {
    // Convert to new format for compatibility
    let assessment = AssessmentSummary {
        assessment_id: "legacy".to_string(),
        assessment_name: assessment_name.clone(),
        subject: "Unknown".to_string(),
        grade_level: None,
        current_score: test_details.iter().map(|t| t.score).sum(),
        total_possible: Some(test_details.iter().map(|t| t.total_possible).sum()),
        progress: if test_details.iter().all(|t| t.score > 0) {
            Progress::Completed
        } else if test_details.iter().any(|t| t.score > 0) {
            Progress::Ongoing
        } else {
            Progress::NotStarted
        },
        assessment_rating: "Unknown".to_string(),
        test_details: test_details.clone(),
        distribution_data: Vec::new(),
    };

    view! {
        <DetailedProgressChart
            assessment={assessment}
            test_details={test_details}
        />
    }
}

#[component]
pub fn CompactNodalSequence(
    assessment_name: String,
    test_details: Vec<TestDetail>,
) -> impl IntoView {
    // Convert to new format for compatibility
    let assessment = AssessmentSummary {
        assessment_id: "legacy".to_string(),
        assessment_name: assessment_name.clone(),
        subject: "Unknown".to_string(),
        grade_level: None,
        current_score: test_details.iter().map(|t| t.score).sum(),
        total_possible: Some(test_details.iter().map(|t| t.total_possible).sum()),
        progress: if test_details.iter().all(|t| t.score > 0) {
            Progress::Completed
        } else if test_details.iter().any(|t| t.score > 0) {
            Progress::Ongoing
        } else {
            Progress::NotStarted
        },
        assessment_rating: "Unknown".to_string(),
        test_details: test_details.clone(),
        distribution_data: Vec::new(),
    };

    view! {
        <CompactProgressChart
            assessment={assessment}
            test_details={test_details}
        />
    }
}

#[component]
pub fn CompactSequenceWeb(
    assessment_name: String,
    test_details: Vec<TestDetail>,
    show_actions: bool,
) -> impl IntoView {
    // Convert to new format for compatibility
    let assessment = AssessmentSummary {
        assessment_id: "legacy".to_string(),
        assessment_name: assessment_name.clone(),
        subject: "Unknown".to_string(),
        grade_level: None,
        current_score: test_details.iter().map(|t| t.score).sum(),
        total_possible: Some(test_details.iter().map(|t| t.total_possible).sum()),
        progress: if test_details.iter().all(|t| t.score > 0) {
            Progress::Completed
        } else if test_details.iter().any(|t| t.score > 0) {
            Progress::Ongoing
        } else {
            Progress::NotStarted
        },
        assessment_rating: "Unknown".to_string(),
        test_details: test_details.clone(),
        distribution_data: Vec::new(),
    };

    view! {
        <CompactProgressChart
            assessment={assessment}
            test_details={test_details}
        />
    }
}
use leptos::prelude::*;
use crate::app::components::data_processing::{AssessmentSummary, TestDetail};
use crate::app::components::student_report::assessments::test_card::TestCard;
use crate::app::models::test::Test;
use leptos::prelude::*;

#[component]
pub fn ExpandedTestList(
    assessment: AssessmentSummary,
    tests_resource: Resource<(), Option<Vec<Test>>>,
    #[prop(default = false)] show_detailed_test_info: bool,
) -> impl IntoView {
    let test_details = assessment.test_details.clone();
    let assessment_name = assessment.assessment_name.clone();

    // Sort tests by date (most recent first)
    let sorted_tests = {
        let mut tests = test_details;
        tests.sort_by(|a, b| b.date_administered.cmp(&a.date_administered));
        tests
    };

    view! {
        <div class="mt-4 bg-gray-50 rounded-lg border border-gray-200 p-4">
            <div class="flex items-center justify-between mb-4">
                <h4 class="text-lg font-semibold text-gray-900">
                    {format!("{} - Test Details", assessment_name)}
                </h4>
                <div class="flex items-center gap-2 text-sm text-gray-600">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <span>{sorted_tests.len()} {if sorted_tests.len() == 1 { "test" } else { "tests" }}</span>
                </div>
            </div>

            {if sorted_tests.is_empty() {
                view! {
                    <div class="text-center py-8">
                        <div class="w-12 h-12 mx-auto mb-4 bg-gray-200 rounded-full flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                        </div>
                        <h3 class="text-lg font-medium text-gray-900 mb-1">No tests completed</h3>
                        <p class="text-gray-500">Tests for this assessment will appear here once completed.</p>
                    </div>
                }
            } else {
                view! {
                    <div class="space-y-3">
                        // Summary Stats
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4 p-4 bg-white rounded-lg border border-gray-200">
                            <div class="text-center">
                                <div class="text-2xl font-bold text-gray-900">
                                    {
                                        let total_score: i32 = sorted_tests.iter().map(|t| t.score).sum();
                                        total_score
                                    }
                                </div>
                                <div class="text-sm text-gray-600">Total Points</div>
                            </div>
                            <div class="text-center">
                                <div class="text-2xl font-bold text-gray-900">
                                    {
                                        let avg_percentage = if !sorted_tests.is_empty() {
                                            sorted_tests.iter()
                                                .map(|t| (t.score as f32 / t.total_possible as f32 * 100.0))
                                                .sum::<f32>() / sorted_tests.len() as f32
                                        } else {
                                            0.0
                                        };
                                        format!("{:.1}%", avg_percentage)
                                    }
                                </div>
                                <div class="text-sm text-gray-600">Average Score</div>
                            </div>
                            <div class="text-center">
                                <div class="text-2xl font-bold text-gray-900">
                                    {
                                        if let Some(latest_test) = sorted_tests.first() {
                                            latest_test.date_administered.format("%m/%d").to_string()
                                        } else {
                                            "N/A".to_string()
                                        }
                                    }
                                </div>
                                <div class="text-sm text-gray-600">Latest Test</div>
                            </div>
                        </div>

                        // Test Cards Grid
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {sorted_tests.clone().into_iter().map(|test| {
                                view! {
                                    <TestCard
                                        test_detail=test
                                        tests_resource=tests_resource
                                        show_detailed_info=show_detailed_test_info
                                    />
                                }
                            }).collect::<Vec<_>>()}
                        </div>

                        // Performance Insights
                        <div class="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                            <h5 class="font-medium text-blue-900 mb-2 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                Performance Insights
                            </h5>
                            <div class="text-sm text-blue-800">
                                {
                                    let test_count = sorted_tests.len();
                                    let high_scores = sorted_tests.iter()
                                        .filter(|t| (t.score as f32 / t.total_possible as f32) >= 0.8)
                                        .count();
                                    let low_scores = sorted_tests.iter()
                                        .filter(|t| (t.score as f32 / t.total_possible as f32) < 0.6)
                                        .count();

                                    if high_scores > test_count / 2 {
                                        "Strong performance across most tests. Consider advancing to more challenging material."
                                    } else if low_scores > test_count / 2 {
                                        "Several tests show room for improvement. Consider reviewing foundational concepts."
                                    } else {
                                        "Mixed performance indicates good progress with some areas needing attention."
                                    }
                                }
                            </div>
                        </div>
                    </div>
                }
            }}
        </div>
    }
}
use crate::app::components::data_processing::{AssessmentSummary, Progress};
use crate::app::components::student_report::assessments::assessment_card::AssessmentCard;
use crate::app::components::student_report::assessments::expanded_test_list::ExpandedTestList;
use crate::app::models::test::Test;
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn ProgressOverviewTab(
    assessments: Vec<AssessmentSummary>,
    tests_resource: Resource<(), Option<Vec<Test>>>,
) -> impl IntoView {
    // State for expanded assessment
    let (expanded_assessment, set_expanded_assessment) = create_signal::<Option<String>>(None);

    // State for filtering
    let (filter_progress, set_filter_progress) = create_signal::<Option<Progress>>(None);
    let (filter_subject, set_filter_subject) = create_signal::<Option<String>>(None);
    let (sort_option, set_sort_option) = create_signal::<String>("name".to_string());

    // Callback for expanding/collapsing assessments
    let on_expand = Callback::new(move |assessment_id: String| {
        if expanded_assessment.get() == Some(assessment_id.clone()) {
            set_expanded_assessment(None);
        } else {
            set_expanded_assessment(Some(assessment_id));
        }
    });

    // Clone assessments for use in multiple closures
    let assessments_clone = assessments.clone();
    let assessments_for_subjects = assessments.clone();

    // Filter and sort assessments
    let filtered_and_sorted_assessments = Memo::new(move |_| {
        let mut filtered_assessments = assessments_clone.clone();

        // Apply progress filter
        if let Some(progress_filter) = filter_progress.get() {
            filtered_assessments = filtered_assessments
                .into_iter()
                .filter(|assessment| assessment.progress == progress_filter)
                .collect();
        }

        // Apply subject filter
        if let Some(subject_filter) = filter_subject.get() {
            if !subject_filter.is_empty() {
                filtered_assessments = filtered_assessments
                    .into_iter()
                    .filter(|assessment| assessment.subject == subject_filter)
                    .collect();
            }
        }

        // Sort assessments
        match sort_option.get().as_str() {
            "name" => {
                filtered_assessments.sort_by(|a, b| a.assessment_name.cmp(&b.assessment_name))
            }
            "progress" => filtered_assessments.sort_by(|a, b| {
                let a_score = if let Some(total) = a.total_possible {
                    a.current_score as f32 / total as f32
                } else {
                    0.0
                };
                let b_score = if let Some(total) = b.total_possible {
                    b.current_score as f32 / total as f32
                } else {
                    0.0
                };
                b_score
                    .partial_cmp(&a_score)
                    .unwrap_or(std::cmp::Ordering::Equal)
            }),
            "subject" => filtered_assessments.sort_by(|a, b| a.subject.cmp(&b.subject)),
            "test_count" => {
                filtered_assessments.sort_by(|a, b| b.test_details.len().cmp(&a.test_details.len()))
            }
            _ => {}
        }

        filtered_assessments
    });

    // Get unique subjects for filter dropdown
    let unique_subjects = Memo::new(move |_| {
        let mut subjects: Vec<String> = assessments_for_subjects
            .iter()
            .map(|assessment| assessment.subject.clone())
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();
        subjects.sort();
        subjects
    });

    // Calculate summary statistics
    let summary_stats = Memo::new(move |_| {
        let filtered = filtered_and_sorted_assessments.get();
        let total_assessments = filtered.len();
        let completed = filtered
            .iter()
            .filter(|a| a.progress == Progress::Completed)
            .count();
        let in_progress = filtered
            .iter()
            .filter(|a| a.progress == Progress::Ongoing)
            .count();
        let not_started = filtered
            .iter()
            .filter(|a| a.progress == Progress::NotStarted)
            .count();

        let total_tests: usize = filtered.iter().map(|a| a.test_details.len()).sum();

        (
            total_assessments,
            completed,
            in_progress,
            not_started,
            total_tests,
        )
    });

    view! {
        <div class="space-y-6">
            // Header Section
            <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:justify-between sm:space-y-0">
                <div>
                    <h2 class="text-2xl font-semibold text-gray-900">Assessment Progress Overview</h2>
                    <p class="mt-1 text-sm text-gray-600">
                        "Track student performance across all assessments"
                    </p>
                </div>
            </div>

            // Summary Statistics Cards
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4">
                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex items-center">
                        <div class="p-2 bg-blue-100 rounded-lg">
                            <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                        </div>
                        <div class="ml-4">
                            <p class="text-sm text-gray-600">Total Assessments</p>
                            <p class="text-2xl font-semibold text-gray-900">{move || summary_stats.get().0}</p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex items-center">
                        <div class="p-2 bg-green-100 rounded-lg">
                            <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </div>
                        <div class="ml-4">
                            <p class="text-sm text-gray-600">Completed</p>
                            <p class="text-2xl font-semibold text-green-600">{move || summary_stats.get().1}</p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex items-center">
                        <div class="p-2 bg-yellow-100 rounded-lg">
                            <svg class="w-6 h-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </div>
                        <div class="ml-4">
                            <p class="text-sm text-gray-600">In Progress</p>
                            <p class="text-2xl font-semibold text-yellow-600">{move || summary_stats.get().2}</p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex items-center">
                        <div class="p-2 bg-gray-100 rounded-lg">
                            <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </div>
                        <div class="ml-4">
                            <p class="text-sm text-gray-600">Not Started</p>
                            <p class="text-2xl font-semibold text-gray-600">{move || summary_stats.get().3}</p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg border border-gray-200 p-4">
                    <div class="flex items-center">
                        <div class="p-2 bg-purple-100 rounded-lg">
                            <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                            </svg>
                        </div>
                        <div class="ml-4">
                            <p class="text-sm text-gray-600">Total Tests</p>
                            <p class="text-2xl font-semibold text-purple-600">{move || summary_stats.get().4}</p>
                        </div>
                    </div>
                </div>
            </div>

            // Filters and Controls
            <div class="bg-white rounded-lg border border-gray-200 p-4">
                <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:space-y-0 sm:space-x-4">
                    // Progress Filter
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Progress:</label>
                        <select
                            class="border border-gray-300 rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            on:change=move |ev| {
                                let value = event_target_value(&ev);
                                match value.as_str() {
                                    "completed" => set_filter_progress(Some(Progress::Completed)),
                                    "ongoing" => set_filter_progress(Some(Progress::Ongoing)),
                                    "not_started" => set_filter_progress(Some(Progress::NotStarted)),
                                    _ => set_filter_progress(None),
                                }
                            }
                        >
                            <option value="">"All Progress"</option>
                            <option value="completed">"Completed"</option>
                            <option value="ongoing">"In Progress"</option>
                            <option value="not_started">"Not Started"</option>
                        </select>
                    </div>

                    // Subject Filter
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Subject:</label>
                        <select
                            class="border border-gray-300 rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            on:change=move |ev| {
                                let value = event_target_value(&ev);
                                if value.is_empty() {
                                    set_filter_subject(None);
                                } else {
                                    set_filter_subject(Some(value));
                                }
                            }
                        >
                            <option value="">"All Subjects"</option>
                            {move || unique_subjects.get().into_iter().map(|subject| {
                                view! {
                                    <option value={subject.clone()}>{subject}</option>
                                }
                            }).collect::<Vec<_>>()}
                        </select>
                    </div>

                    // Sort Options
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Sort by:</label>
                        <select
                            class="border border-gray-300 rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            on:change=move |ev| {
                                let value = event_target_value(&ev);
                                set_sort_option(value);
                            }
                        >
                            <option value="name">"Assessment Name"</option>
                            <option value="progress">"Progress"</option>
                            <option value="subject">"Subject"</option>
                            <option value="test_count">"Test Count"</option>
                        </select>
                    </div>

                    // Clear Filters Button
                    <button
                        class="px-3 py-1 text-sm text-gray-600 hover:text-gray-800 hover:bg-gray-50 rounded-md transition-colors"
                        on:click=move |_| {
                            set_filter_progress(None);
                            set_filter_subject(None);
                            set_sort_option("name".to_string());
                        }
                    >
                        "Clear Filters"
                    </button>
                </div>
            </div>

            // Assessment Cards
            <div class="space-y-4">
                {move || {
                    let filtered_assessments = filtered_and_sorted_assessments.get();

                    if filtered_assessments.is_empty() {
                        view! {
                            <div class="text-center py-12 bg-white rounded-lg border border-gray-200">
                                <div class="w-12 h-12 mx-auto mb-4 bg-gray-100 rounded-full flex items-center justify-center">
                                    <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                </div>
                                <h3 class="text-lg font-medium text-gray-900 mb-1">"No assessments found"</h3>
                                <p class="text-gray-500">"Try adjusting your filters or check back later for new assessments."</p>
                            </div>
                        }
                    } else {
                        view! {
                            <div class="space-y-6">
                                {filtered_assessments.into_iter().map(|assessment| {
                                    let assessment_id = assessment.assessment_id.clone();
                                    let is_expanded = move || expanded_assessment.get() == Some(assessment_id.clone());

                                    view! {
                                        <div>
                                            <AssessmentCard
                                                assessment=assessment.clone()
                                                tests_resource=tests_resource
                                                on_expand=on_expand
                                                is_expanded=is_expanded()
                                            />

                                            // Expanded Test List
                                            {move || {
                                                if is_expanded() {
                                                    view! {
                                                        <div>
                                                            <ExpandedTestList
                                                                assessment=assessment.clone()
                                                                tests_resource=tests_resource
                                                                show_detailed_test_info=true
                                                            />
                                                        </div>
                                                    }
                                                } else {
                                                    view! { <div></div> }
                                                }
                                            }}
                                        </div>
                                    }
                                }).collect::<Vec<_>>()}
                            </div>
                        }
                    }
                }}
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::data_processing::{AssessmentSummary, Progress, TestDetail};
use leptos::prelude::*;

#[component]
pub fn StripeProgressBar(
    assessment: AssessmentSummary,
    test_details: Vec<TestDetail>,
) -> impl IntoView {
    let total_tests = test_details.len();
    let completed_tests = test_details.iter().filter(|t| t.score > 0).count();
    let progress_percentage = if total_tests > 0 {
        (completed_tests as f32 / total_tests as f32) * 100.0
    } else {
        0.0
    };

    // Calculate average score for color determination
    let avg_score = if !test_details.is_empty() {
        let total_score: i32 = test_details.iter().map(|t| t.score).sum();
        let total_possible: i32 = test_details.iter().map(|t| t.total_possible).sum();
        if total_possible > 0 {
            (total_score as f32 / total_possible as f32) * 100.0
        } else {
            0.0
        }
    } else {
        0.0
    };

    view! {
        <div class="relative">
            // Main progress container with Stripe-inspired design
            <div class="bg-gradient-to-r from-slate-50 to-slate-100 rounded-2xl p-6 border border-slate-200 shadow-lg">
                // Header with assessment info
                <div class="flex items-center justify-between mb-6">
                    <div class="flex items-center space-x-3">
                        <div class=move || {
                            match assessment.progress {
                                Progress::Completed => "w-3 h-3 bg-emerald-500 rounded-full animate-pulse",
                                Progress::Ongoing => "w-3 h-3 bg-amber-500 rounded-full animate-pulse",
                                Progress::NotStarted => "w-3 h-3 bg-slate-400 rounded-full",
                            }
                        }></div>
                        <h3 class="text-xl font-semibold text-slate-800">{assessment.assessment_name.clone()}</h3>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-slate-600">
                            {completed_tests} "/" {total_tests} " completed"
                        </span>
                        <div class=move || {
                            if avg_score >= 80.0 {
                                "px-3 py-1 bg-emerald-100 text-emerald-800 rounded-full text-sm font-medium"
                            } else if avg_score >= 60.0 {
                                "px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-sm font-medium"
                            } else {
                                "px-3 py-1 bg-rose-100 text-rose-800 rounded-full text-sm font-medium"
                            }
                        }>
                            {format!("{:.1}%", avg_score)}
                        </div>
                    </div>
                </div>

                // Stripe-style progress track
                <div class="relative mb-6">
                    // Background track
                    <div class="h-2 bg-slate-200 rounded-full overflow-hidden">
                        // Animated gradient progress bar
                        <div
                            class=move || {
                                if avg_score >= 80.0 {
                                    "h-full bg-gradient-to-r from-emerald-400 to-emerald-600 rounded-full transition-all duration-1000 ease-out relative overflow-hidden"
                                } else if avg_score >= 60.0 {
                                    "h-full bg-gradient-to-r from-amber-400 to-amber-600 rounded-full transition-all duration-1000 ease-out relative overflow-hidden"
                                } else {
                                    "h-full bg-gradient-to-r from-rose-400 to-rose-600 rounded-full transition-all duration-1000 ease-out relative overflow-hidden"
                                }
                            }
                            style=format!("width: {}%", progress_percentage)
                        >
                            // Stripe-style shine effect
                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent skew-x-12 animate-shine"></div>
                        </div>
                    </div>

                    // Progress percentage indicator
                    <div
                        class="absolute top-0 transform -translate-y-8 transition-all duration-500"
                        style=format!("left: {}%", progress_percentage.min(95.0))
                    >
                        <div class="relative">
                            <div class=move || {
                                if avg_score >= 80.0 {
                                    "bg-emerald-600 text-white px-2 py-1 rounded-md text-xs font-medium shadow-lg"
                                } else if avg_score >= 60.0 {
                                    "bg-amber-600 text-white px-2 py-1 rounded-md text-xs font-medium shadow-lg"
                                } else {
                                    "bg-rose-600 text-white px-2 py-1 rounded-md text-xs font-medium shadow-lg"
                                }
                            }>
                                {format!("{:.0}%", progress_percentage)}
                            </div>
                            // Arrow pointing down
                            <div class=move || {
                                if avg_score >= 80.0 {
                                    "absolute left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-emerald-600"
                                } else if avg_score >= 60.0 {
                                    "absolute left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-amber-600"
                                } else {
                                    "absolute left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-rose-600"
                                }
                            }></div>
                        </div>
                    </div>
                </div>

                // Test sequence visualization
                <div class="space-y-3">
                    <h4 class="text-sm font-medium text-slate-700 mb-3">"Test Sequence Progress"</h4>
                    <div class="flex flex-wrap gap-2">
                        {test_details.iter().enumerate().map(|(index, test)| {
                            let test_score_percent = (test.score as f32 / test.total_possible as f32) * 100.0;
                            let is_completed = test.score > 0;
                            let test_name = test.test_name.clone();
                            let test_area = test.test_area.clone();
                            let performance_class = test.performance_class.clone();

                            view! {
                                <div class="group relative">
                                    // Test node
                                    <div class=move || {
                                        let base_classes = "w-10 h-10 rounded-lg flex items-center justify-center text-sm font-bold transition-all duration-300 cursor-pointer border-2";
                                        if is_completed {
                                            if test_score_percent >= 80.0 {
                                                format!("{} bg-emerald-500 border-emerald-600 text-white shadow-lg group-hover:shadow-emerald-500/50 group-hover:scale-110", base_classes)
                                            } else if test_score_percent >= 60.0 {
                                                format!("{} bg-amber-500 border-amber-600 text-white shadow-lg group-hover:shadow-amber-500/50 group-hover:scale-110", base_classes)
                                            } else {
                                                format!("{} bg-rose-500 border-rose-600 text-white shadow-lg group-hover:shadow-rose-500/50 group-hover:scale-110", base_classes)
                                            }
                                        } else {
                                            format!("{} bg-slate-200 border-slate-300 text-slate-500 group-hover:bg-slate-300", base_classes)
                                        }
                                    }>
                                        {index + 1}
                                    </div>

                                    // Connecting line to next test
                                    {if index < test_details.len() - 1 {
                                        view! {
                                            <div class="absolute top-1/2 left-10 w-6 h-0.5 bg-slate-300 transform -translate-y-1/2 z-0"></div>
                                        }
                                    } else {
                                        view! { <div></div> }
                                    }}

                                    // Tooltip on hover
                                    <div class="absolute bottom-12 left-1/2 transform -translate-x-1/2 bg-slate-900 text-white px-3 py-2 rounded-lg text-xs font-medium opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10">
                                        <div class="text-center">
                                            <div class="font-semibold">{test_name.clone()}</div>
                                            <div class="text-slate-300">{test_area.clone()}</div>
                                            {if is_completed {
                                                view! {
                                                    <div class="mt-1">
                                                        <div>{test.score} "/" {test.total_possible}</div>
                                                        <div class="text-xs">{performance_class.clone()}</div>
                                                    </div>
                                                }
                                            } else {
                                                view! { <div class="text-slate-300">"Not started"</div> }
                                            }}
                                        </div>
                                        // Tooltip arrow
                                        <div class="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-slate-900"></div>
                                    </div>
                                </div>
                            }
                        }).collect::<Vec<_>>()}
                    </div>
                </div>

                // Performance stats grid
                <div class="grid grid-cols-3 gap-4 mt-6 pt-6 border-t border-slate-200">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-slate-800">{assessment.current_score}</div>
                        <div class="text-sm text-slate-600">"Current Score"</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-slate-800">
                            {assessment.total_possible.map(|t| t.to_string()).unwrap_or_else(|| "N/A".to_string())}
                        </div>
                        <div class="text-sm text-slate-600">"Total Possible"</div>
                    </div>
                    <div class="text-center">
                        <div class=move || {
                            if avg_score >= 80.0 {
                                "text-2xl font-bold text-emerald-600"
                            } else if avg_score >= 60.0 {
                                "text-2xl font-bold text-amber-600"
                            } else {
                                "text-2xl font-bold text-rose-600"
                            }
                        }>
                            {assessment.assessment_rating.clone()}
                        </div>
                        <div class="text-sm text-slate-600">"Overall Rating"</div>
                    </div>
                </div>
            </div>
        </div>
    }
}

#[component]
pub fn CompactStripeProgress(
    assessment_name: String,
    current_score: i32,
    total_possible: Option<i32>,
    test_details: Vec<TestDetail>,
) -> impl IntoView {
    let completed_tests = test_details.iter().filter(|t| t.score > 0).count();
    let total_tests = test_details.len();
    let progress_percentage = if total_tests > 0 {
        (completed_tests as f32 / total_tests as f32) * 100.0
    } else {
        0.0
    };

    view! {
        <div class="bg-white rounded-lg border border-slate-200 p-4 shadow-sm">
            <div class="flex items-center justify-between mb-3">
                <h4 class="font-semibold text-slate-800">{assessment_name}</h4>
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-slate-600">
                        {completed_tests} "/" {total_tests}
                    </span>
                    <div class="text-sm font-medium text-slate-800">
                        {current_score}
                        {total_possible.map(|t| format!("/{}", t)).unwrap_or_else(|| String::new())}
                    </div>
                </div>
            </div>

            <div class="h-2 bg-slate-200 rounded-full overflow-hidden mb-2">
                <div
                    class="h-full bg-gradient-to-r from-blue-400 to-blue-600 rounded-full transition-all duration-1000 ease-out relative overflow-hidden"
                    style=format!("width: {}%", progress_percentage)
                >
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent skew-x-12 animate-shine"></div>
                </div>
            </div>

            <div class="flex space-x-1">
                {test_details.iter().enumerate().map(|(index, test)| {
                    let is_completed = test.score > 0;
                    let test_score_percent = if test.total_possible > 0 {
                        (test.score as f32 / test.total_possible as f32) * 100.0
                    } else {
                        0.0
                    };

                    view! {
                        <div class=move || {
                            let base_classes = "w-3 h-3 rounded-sm transition-all duration-300";
                            if is_completed {
                                if test_score_percent >= 80.0 {
                                    format!("{} bg-emerald-500", base_classes)
                                } else if test_score_percent >= 60.0 {
                                    format!("{} bg-amber-500", base_classes)
                                } else {
                                    format!("{} bg-rose-500", base_classes)
                                }
                            } else {
                                format!("{} bg-slate-200", base_classes)
                            }
                        }
                        title=format!("{}: {}/{}", test.test_name, test.score, test.total_possible)
                        ></div>
                    }
                }).collect::<Vec<_>>()}
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::dashboard::color_utils::ColorUtils;
use crate::app::components::dashboard::scores_ledger::ScoreUtils;
use crate::app::components::data_processing::TestHistoryEntry;
use crate::app::components::overview::sort_selector::SortOption;
use crate::app::components::overview::time_frame_selector::TimeFrame;
use crate::app::models::test::Test;
use crate::app::server_functions::tests::get_tests;
use chrono::{DateTime, NaiveDate, Utc};
use leptos::prelude::*;

#[component]
pub fn OverviewTable(
    test_history: Vec<TestHistoryEntry>,
    #[prop(into)] search_query: ReadSignal<String>,
    #[prop(into)] selected_timeframe: ReadSignal<TimeFrame>,
    #[prop(into)] selected_sort: ReadSignal<SortOption>,
) -> impl IntoView {
    // Add resource to fetch test data for benchmark categories
    let tests_resource = LocalResource::new(
        || (),
        |_| async {
            match get_tests().await {
                Ok(tests) => Some(tests),
                Err(e) => {
                    log::error!("Failed to load tests: {}", e);
                    None
                }
            }
        },
    );

    let filtered_and_sorted_tests = Memo::new(move |_| {
        let mut tests = test_history.clone();
        let query = search_query.get().to_lowercase();
        let timeframe = selected_timeframe.get();
        let sort = selected_sort.get();

        // Filter by search query
        if !query.is_empty() {
            tests = tests
                .into_iter()
                .filter(|test| {
                    test.test_name.to_lowercase().contains(&query)
                        || test.performance_class.to_lowercase().contains(&query)
                        || test.evaluator.to_lowercase().contains(&query)
                })
                .collect();
        }

        // Filter by timeframe
        if timeframe != TimeFrame::AllTime {
            let days_back = match timeframe {
                TimeFrame::LastWeek => 7,
                TimeFrame::LastMonth => 30,
                TimeFrame::Last3Months => 90,
                TimeFrame::LastYear => 365,
                TimeFrame::AllTime => unreachable!(),
            };

            let cutoff_date = chrono::Utc::now() - chrono::Duration::days(days_back);
            tests = tests
                .into_iter()
                .filter(|test| test.date_administered >= cutoff_date)
                .collect();
        }

        // Sort
        match sort {
            SortOption::DateDesc => {
                tests.sort_by(|a, b| b.date_administered.cmp(&a.date_administered))
            }
            SortOption::DateAsc => {
                tests.sort_by(|a, b| a.date_administered.cmp(&b.date_administered))
            }
            SortOption::ScoreDesc => tests.sort_by(|a, b| {
                let a_percent = (a.score as f32 / a.total_possible as f32) * 100.0;
                let b_percent = (b.score as f32 / b.total_possible as f32) * 100.0;
                b_percent
                    .partial_cmp(&a_percent)
                    .unwrap_or(std::cmp::Ordering::Equal)
            }),
            SortOption::ScoreAsc => tests.sort_by(|a, b| {
                let a_percent = (a.score as f32 / a.total_possible as f32) * 100.0;
                let b_percent = (b.score as f32 / b.total_possible as f32) * 100.0;
                a_percent
                    .partial_cmp(&b_percent)
                    .unwrap_or(std::cmp::Ordering::Equal)
            }),
            SortOption::TestNameAsc => tests.sort_by(|a, b| a.test_name.cmp(&b.test_name)),
            SortOption::TestNameDesc => tests.sort_by(|a, b| b.test_name.cmp(&a.test_name)),
        }

        tests
    });

    view! {
        <div class="bg-white rounded-xl border border-gray-200 shadow-sm flex flex-col" style="height: 400px; min-height: 400px;">
            {move || {
                let tests = filtered_and_sorted_tests.get();
                let test_count = tests.len();

                if tests.is_empty() {
                    view! {
                        <div class="flex-1 flex items-center justify-center p-12">
                            <div class="text-center">
                                <div class="w-12 h-12 mx-auto mb-4 bg-gray-100 rounded-full flex items-center justify-center">
                                    <svg class="w-6 h-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                </div>
                                <h3 class="text-lg font-medium text-gray-900 mb-1">"No tests found"</h3>
                                <p class="text-gray-500 text-sm">"Try adjusting your search or time frame filters."</p>
                            </div>
                        </div>
                    }
                } else {
                    view! {
                        <div>
                            // Header with test count - fixed at top
                            <div class="flex-shrink-0 px-6 py-3 bg-gray-50 border-b border-gray-200 rounded-t-xl">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">
                                        {format!("{} test{} found", test_count, if test_count == 1 { "" } else { "s" })}
                                    </span>
                                </div>
                            </div>

                            // Scrollable table content
                            <div class="flex-1 overflow-auto">
                                <div class="overflow-x-auto h-full">
                                    <table class="min-w-full divide-y divide-gray-200">
                                        <thead class="bg-gray-50 sticky top-0 z-10">
                                            <tr>
                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                    "Test"
                                                </th>
                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                    "Score"
                                                </th>
                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                    "Performance"
                                                </th>
                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                    "Evaluator"
                                                </th>
                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                    "Date"
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody class="bg-white divide-y divide-gray-200">
                                            {tests.into_iter().map(|test| {
                                                let score_percentage = (test.score as f32 / test.total_possible as f32) * 100.0;
                                                let evaluator_name = test.evaluator.clone();

                                                // Get test data for benchmark categories using test_id for accurate matching
                                                let test_data = tests_resource.get()
                                                    .and_then(|result| result)
                                                    .and_then(|tests| tests.iter().find(|t| t.test_id == test.test_id).cloned());

                                                let benchmark_categories = test_data.as_ref().and_then(|t| t.benchmark_categories.as_ref());

                                                // Get benchmark-based colors using ColorUtils
                                                let badge_classes = ColorUtils::get_badge_classes_for_score(
                                                    test.score,
                                                    test.total_possible,
                                                    benchmark_categories
                                                );
                                                let benchmark_label = ScoreUtils::get_benchmark_label(
                                                    test.score,
                                                    test.total_possible,
                                                    benchmark_categories
                                                );
                                                let score_text_color = ColorUtils::get_score_text_color_for_score(
                                                    test.score,
                                                    test.total_possible,
                                                    benchmark_categories
                                                );
                                                let progress_bar_color = ColorUtils::get_progress_bar_color_for_score(
                                                    test.score,
                                                    test.total_possible,
                                                    benchmark_categories
                                                );

                                                view! {
                                                    <tr class="hover:bg-gray-50 transition-colors duration-150">
                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                            <div class="text-sm font-medium text-gray-900">
                                                                {test.test_name}
                                                            </div>
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                            <div class="flex items-center space-x-3">
                                                                <div class="flex-shrink-0">
                                                                    <span class={score_text_color}>
                                                                        {test.score}
                                                                    </span>
                                                                    <span class="text-sm text-gray-400 ml-1">
                                                                        "/" {test.total_possible}
                                                                    </span>
                                                                </div>
                                                                <div class="flex-1 min-w-0">
                                                                    <div class="w-16 bg-gray-200 rounded-full h-1.5">
                                                                        <div
                                                                            class={progress_bar_color}
                                                                            style=format!("width: {}%", score_percentage.min(100.0))
                                                                        ></div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                            <span class={format!("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium {}", badge_classes)}>
                                                                {benchmark_label}
                                                            </span>
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                            <div class="text-sm text-gray-900 font-medium">
                                                                {if evaluator_name.is_empty() {
                                                                    "Not specified".to_string()
                                                                } else {
                                                                    evaluator_name
                                                                }}
                                                            </div>
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                            {format!("{}", test.date_administered.format("%b %d, %Y"))}
                                                        </td>
                                                    </tr>
                                                }
                                            }).collect::<Vec<_>>()}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    }
                }
            }}
        </div>
    }
}
use leptos::prelude::*;
use leptos::prelude::*;

#[derive(Clone, Debug, PartialEq, Copy)]
pub enum SortOption {
    DateDesc,
    DateAsc,
    ScoreDesc,
    ScoreAsc,
    TestNameAsc,
    TestNameDesc,
}

impl SortOption {
    pub fn as_str(&self) -> &'static str {
        match self {
            SortOption::DateDesc => "Newest first",
            SortOption::DateAsc => "Oldest first",
            SortOption::ScoreDesc => "Highest score",
            SortOption::ScoreAsc => "Lowest score",
            SortOption::TestNameAsc => "Test name A-Z",
            SortOption::TestNameDesc => "Test name Z-A",
        }
    }

    pub fn as_value(&self) -> &'static str {
        match self {
            SortOption::DateDesc => "date_desc",
            SortOption::DateAsc => "date_asc",
            SortOption::ScoreDesc => "score_desc",
            SortOption::ScoreAsc => "score_asc",
            SortOption::TestNameAsc => "name_asc",
            SortOption::TestNameDesc => "name_desc",
        }
    }

    pub fn from_value(value: &str) -> Self {
        match value {
            "date_asc" => SortOption::DateAsc,
            "score_desc" => SortOption::ScoreDesc,
            "score_asc" => SortOption::ScoreAsc,
            "name_asc" => SortOption::TestNameAsc,
            "name_desc" => SortOption::TestNameDesc,
            _ => SortOption::DateDesc,
        }
    }

    pub fn all_options() -> Vec<SortOption> {
        vec![
            SortOption::DateDesc,
            SortOption::DateAsc,
            SortOption::ScoreDesc,
            SortOption::ScoreAsc,
            SortOption::TestNameAsc,
            SortOption::TestNameDesc,
        ]
    }
}

#[component]
pub fn SortSelector(
    #[prop(into)] selected_sort: ReadSignal<SortOption>,
    #[prop(into)] set_selected_sort: WriteSignal<SortOption>,
) -> impl IntoView {
    view! {
        <div class="relative">
            <select
                class="appearance-none bg-white border border-gray-200 rounded-lg px-4 py-2.5 pr-8 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 cursor-pointer"
                on:change=move |ev| {
                    let value = event_target_value(&ev);
                    set_selected_sort(SortOption::from_value(&value));
                }
            >
                {SortOption::all_options().into_iter().map(|option| {
                    let is_selected = move || selected_sort.get() == option;
                    view! {
                        <option
                            value={option.as_value()}
                            selected=is_selected
                        >
                            {option.as_str()}
                        </option>
                    }
                }).collect::<Vec<_>>()}
            </select>
            <div class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none">
                <svg class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use leptos::prelude::*;

#[derive(Clone, Debug, PartialEq, Copy)]
pub enum TimeFrame {
    LastWeek,
    LastMonth,
    Last3Months,
    LastYear,
    AllTime,
}

impl TimeFrame {
    pub fn as_str(&self) -> &'static str {
        match self {
            TimeFrame::LastWeek => "Last 7 days",
            TimeFrame::LastMonth => "Last 30 days",
            TimeFrame::Last3Months => "Last 90 days",
            TimeFrame::LastYear => "Last year",
            TimeFrame::AllTime => "All time",
        }
    }

    pub fn as_value(&self) -> &'static str {
        match self {
            TimeFrame::LastWeek => "7",
            TimeFrame::LastMonth => "30",
            TimeFrame::Last3Months => "90",
            TimeFrame::LastYear => "365",
            TimeFrame::AllTime => "all",
        }
    }

    pub fn from_value(value: &str) -> Self {
        match value {
            "7" => TimeFrame::LastWeek,
            "30" => TimeFrame::LastMonth,
            "90" => TimeFrame::Last3Months,
            "365" => TimeFrame::LastYear,
            _ => TimeFrame::AllTime,
        }
    }

    pub fn all_options() -> Vec<TimeFrame> {
        vec![
            TimeFrame::LastWeek,
            TimeFrame::LastMonth,
            TimeFrame::Last3Months,
            TimeFrame::LastYear,
            TimeFrame::AllTime,
        ]
    }
}

#[component]
pub fn TimeFrameSelector(
    #[prop(into)] selected_timeframe: ReadSignal<TimeFrame>,
    #[prop(into)] set_selected_timeframe: WriteSignal<TimeFrame>,
) -> impl IntoView {
    view! {
        <div class="relative">
            <select
                class="appearance-none bg-white border border-gray-200 rounded-lg px-4 py-2.5 pr-8 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 cursor-pointer"
                on:change=move |ev| {
                    let value = event_target_value(&ev);
                    set_selected_timeframe(TimeFrame::from_value(&value));
                }
            >
                {TimeFrame::all_options().into_iter().map(|option| {
                    let is_selected = move || selected_timeframe.get() == option;
                    view! {
                        <option
                            value={option.as_value()}
                            selected=is_selected
                        >
                            {option.as_str()}
                        </option>
                    }
                }).collect::<Vec<_>>()}
            </select>
            <div class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none">
                <svg class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::data_processing::TestHistoryEntry;
use crate::app::components::overview::overview_table::OverviewTable;
use crate::app::components::overview::search_bar::SearchBar;
use crate::app::components::overview::sort_selector::{SortOption, SortSelector};
use crate::app::components::overview::time_frame_selector::{TimeFrame, TimeFrameSelector};
use leptos::prelude::*;

#[component]
pub fn OverviewTab(test_history: Vec<TestHistoryEntry>) -> impl IntoView {
    let (search_query, set_search_query) = signal(String::new());
    let (selected_timeframe, set_selected_timeframe) = signal(TimeFrame::AllTime);
    let (selected_sort, set_selected_sort) = signal(SortOption::DateDesc);

    view! {
        <div class="space-y-6">
            // Header section
            <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:justify-between sm:space-y-0">
                <div>
                    <h2 class="text-2xl font-semibold text-gray-900">"Recent Tests"</h2>
                    <p class="mt-1 text-sm text-gray-600">
                        "Track test performance and progress over time"
                    </p>
                </div>
            </div>

            // Controls section
            <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:space-y-0 sm:space-x-4">
                <div class="flex-1 max-w-md">
                    <SearchBar
                        search_query=search_query
                        set_search_query=set_search_query
                    />
                </div>
                <div class="flex space-x-3">
                    <TimeFrameSelector
                        selected_timeframe=selected_timeframe
                        set_selected_timeframe=set_selected_timeframe
                    />
                    <SortSelector
                        selected_sort=selected_sort
                        set_selected_sort=set_selected_sort
                    />
                </div>
            </div>

            // Table section
            <OverviewTable
                test_history=test_history
                search_query=search_query
                selected_timeframe=selected_timeframe
                selected_sort=selected_sort
            />
        </div>
    }
}
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn SearchBar(
    #[prop(into)] search_query: ReadSignal<String>,
    #[prop(into)] set_search_query: WriteSignal<String>,
) -> impl IntoView {
    view! {
        <div class="relative">
            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <svg 
                    class="h-4 w-4 text-gray-400" 
                    fill="none" 
                    viewBox="0 0 24 24" 
                    stroke="currentColor"
                >
                    <path 
                        stroke-linecap="round" 
                        stroke-linejoin="round" 
                        stroke-width="2" 
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" 
                    />
                </svg>
            </div>
            <input
                type="text"
                placeholder="Search tests..."
                class="block w-full pl-10 pr-3 py-2.5 border border-gray-200 rounded-lg text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 bg-white"
                prop:value=search_query
                on:input=move |ev| {
                    set_search_query(event_target_value(&ev));
                }
            />
        </div>
    }
}
use leptos::prelude::*;
pub mod gradebook_side_panel;
pub use gradebook_side_panel::*;

//pub mod gradebook_filtering;
//pub use gradebook_filtering::*;
use leptos::prelude::*;
use crate::app::server_functions::bulk_enrollment::upload_bulk_enrollment;
use crate::app::server_functions::bulk_students::upload_students_bulk;
use leptos::ev::{Event, MouseEvent};
use leptos::prelude::*;

#[cfg(feature = "hydrate")]
use js_sys::Array;
#[cfg(feature = "hydrate")]
use std::sync::mpsc;
#[cfg(feature = "hydrate")]
use wasm_bindgen::{closure::Closure, JsCast};
#[cfg(feature = "hydrate")]
use web_sys::{FileList, HtmlInputElement};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ImportType {
    Students,
    Enrollments,
}

impl ImportType {
    pub fn display_name(&self) -> &'static str {
        match self {
            ImportType::Students => "Students",
            ImportType::Enrollments => "Enrollments",
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            ImportType::Students => {
                "Import student records with basic information (teacher names as text)"
            }
            ImportType::Enrollments => {
                "Import enrollment records with academic year and teacher IDs"
            }
        }
    }

    pub fn template_filename(&self) -> &'static str {
        match self {
            ImportType::Students => "student_template.csv",
            ImportType::Enrollments => "enrollment_template.csv",
        }
    }

    pub fn template_content(&self) -> &'static str {
        match self {
            ImportType::Students => include_str!("student_csv_template.csv"),
            ImportType::Enrollments => include_str!("enrollment_csv_template.csv"),
        }
    }
}

#[component]
pub fn BulkUploadModal(
    set_show_modal: WriteSignal<bool>,
    set_refresh_trigger: WriteSignal<i32>,
) -> impl IntoView {
    let (upload_status, set_upload_status) = signal(String::new());
    let (is_uploading, set_is_uploading) = signal(false);
    let (imported_count, set_imported_count) = signal(0);
    let (import_type, set_import_type) = signal(ImportType::Students);

    #[cfg(feature = "hydrate")]
    let (file, set_file) = create_signal::<Option<web_sys::File>>(None);

    let on_file_change = move |ev: Event| {
        #[cfg(feature = "hydrate")]
        {
            let target = ev.target();
            let input_element = target.and_then(|t| t.dyn_into::<HtmlInputElement>().ok());

            if let Some(input) = input_element {
                let files = input.files();
                if let Some(files) = files {
                    if files.length() > 0 {
                        if let Some(first_file) = files.item(0) {
                            set_file(Some(first_file));
                        }
                    }
                }
            }
        }
    };

    #[cfg(feature = "hydrate")]
    let handle_upload = move |ev: MouseEvent| {
        set_is_uploading(true);
        set_upload_status(String::new());
        set_imported_count(0);

        #[cfg(feature = "hydrate")]
        {
            if let Some(selected_file) = file() {
                let current_import_type = import_type();
                spawn_local(async move {
                    match upload_file(selected_file, current_import_type).await {
                        Ok(count) => {
                            set_upload_status(format!(
                                "Successfully imported {} {}",
                                count,
                                if count == 1 {
                                    current_import_type.display_name().trim_end_matches('s')
                                } else {
                                    current_import_type.display_name()
                                }
                            ));
                            set_imported_count(count);
                            set_refresh_trigger.update(|count| *count += 1);
                            set_is_uploading(false);

                            // Auto-close modal after successful upload
                            leptos::set_timeout(
                                move || set_show_modal(false),
                                std::time::Duration::from_millis(2000),
                            );
                        }
                        Err(e) => {
                            set_upload_status(format!("Upload failed: {}", e));
                            set_is_uploading(false);
                        }
                    }
                });
            } else {
                set_upload_status("Please select a file first".to_string());
                set_is_uploading(false);
            }
        }
    };

    let download_template = move |_| {
        #[cfg(feature = "hydrate")]
        {
            let current_type = import_type();
            let template_content = current_type.template_content();
            let filename = current_type.template_filename();

            let blob = web_sys::Blob::new_with_str_sequence(&Array::of1(&template_content.into()))
                .unwrap_or_else(|_| web_sys::Blob::new().unwrap());

            let url = web_sys::Url::create_object_url_with_blob(&blob).unwrap_or_default();

            if let Some(window) = web_sys::window() {
                if let Some(document) = window.document() {
                    if let Ok(a) = document.create_element("a") {
                        let _ = a.set_attribute("href", &url);
                        let _ = a.set_attribute("download", filename);

                        if let Some(html_element) = a.dyn_ref::<web_sys::HtmlElement>() {
                            html_element.click();
                        }
                    }
                }
            }
        }
    };

    // Reset file when import type changes
    Effect::new(move |_| {
        import_type();
        #[cfg(feature = "hydrate")]
        set_file(None);
        set_upload_status(String::new());
    });

    view! {
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-[#F9F9F8] p-6 rounded-lg shadow-xl max-w-lg w-full">
                <h3 class="text-xl font-bold mb-4">"Bulk Data Upload"</h3>

                // Import type selection
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        "Import Type"
                    </label>
                    <select
                        class="w-full p-2 border rounded"
                        on:change=move |ev| {
                            let value = event_target_value(&ev);
                            match value.as_str() {
                                "students" => set_import_type(ImportType::Students),
                                "enrollments" => set_import_type(ImportType::Enrollments),
                                _ => {}
                            }
                        }
                    >
                        <option value="students" selected=move || import_type() == ImportType::Students>
                            "Students"
                        </option>
                        <option value="enrollments" selected=move || import_type() == ImportType::Enrollments>
                            "Enrollments"
                        </option>
                    </select>
                </div>

                // Description
                <div class="mb-4 p-3 bg-blue-50 rounded border-l-4 border-blue-400">
                    <p class="text-sm text-blue-800">
                        {move || import_type().description()}
                    </p>
                </div>

                // File input
                <input
                    type="file"
                    accept=".csv"
                    on:change=on_file_change
                    class="w-full p-2 border rounded mb-4"
                />

                // Template download section
                <div class="text-sm text-gray-600 mb-4 flex justify-between items-center">
                    <span>
                        {move || format!("Expected CSV format for {} import", import_type().display_name().to_lowercase())}
                    </span>
                    <button
                        class="text-blue-500 hover:underline"
                        on:click=download_template
                    >
                        "Download Template"
                    </button>
                </div>

                // Important notes based on import type
                <div class="mb-4 text-xs text-gray-600 bg-gray-50 p-2 rounded">
                    {move || match import_type() {
                        ImportType::Students => view! {
                            <div>
                                <strong>"Student Import Notes:"</strong>
                                <ul class="list-disc list-inside mt-1">
                                    <li>"Teacher field uses teacher names (text)"</li>
                                    <li>"All boolean fields: true/false"</li>
                                    <li>"Date format: YYYY-MM-DD"</li>
                                    <li>"Intervention: None, Literacy, Math, or 'Literacy and Math'"</li>
                                </ul>
                            </div>
                        },
                        ImportType::Enrollments => view! {
                            <div>
                                <strong>"Enrollment Import Notes:"</strong>
                                <ul class="list-disc list-inside mt-1">
                                    <li>"teacher_id field uses numeric IDs from employees table"</li>
                                    <li>"student_id must exist in students table"</li>
                                    <li>"Academic year format: 2024-2025"</li>
                                    <li>"Status/dates are auto-set (Active, current date)"</li>
                                </ul>
                            </div>
                        }
                    }}
                </div>

                // Status message
                {move || {
                    if !upload_status().is_empty() {
                        let status_class = if upload_status().contains("failed") || upload_status().contains("error") {
                            "text-red-500"
                        } else {
                            "text-green-500"
                        };

                        Some(view! {
                            <div class={format!("mt-2 {}", status_class)}>
                                {upload_status()}
                                {move || if imported_count() > 0 {
                                    format!(" ({} records)", imported_count())
                                } else {
                                    "".to_string()
                                }}
                            </div>
                        })
                    } else {
                        None
                    }
                }}

                // Action buttons
                <div class="flex justify-end gap-2 mt-4">
                    <button
                        type="button"
                        class="px-4 py-2 text-white bg-[#F44336] rounded hover:bg-[#D32F2F]"
                        on:click=move |_| set_show_modal(false)
                    >
                        "Cancel"
                    </button>

                    {
                        #[cfg(feature = "hydrate")]
                        {
                            view! {
                                <button
                                    type="button"
                                    class="px-4 py-2 bg-[#4CAF50] text-white rounded hover:bg-[#388E3C] disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled=move || file().is_none() || is_uploading()
                                    on:click=handle_upload
                                >
                                    {move || if is_uploading() {
                                        format!("Uploading {}...", import_type().display_name())
                                    } else {
                                        format!("Upload {}", import_type().display_name())
                                    }}
                                </button>
                            }
                        }
                    }
                </div>
            </div>
        </div>
    }
}

#[cfg(feature = "hydrate")]
async fn upload_file(file: web_sys::File, import_type: ImportType) -> Result<usize, String> {
    // Create a future that resolves when the file is read
    let file_content_future =
        wasm_bindgen_futures::JsFuture::from(js_sys::Promise::new(&mut |resolve, reject| {
            let reader = web_sys::FileReader::new().unwrap();
            let reader_clone = reader.clone();

            let onload_callback = Closure::once(move |_event: web_sys::ProgressEvent| {
                if let Ok(result) = reader_clone.result() {
                    if let Some(text) = result.as_string() {
                        resolve
                            .call1(&wasm_bindgen::JsValue::NULL, &text.into())
                            .unwrap();
                    } else {
                        reject
                            .call1(
                                &wasm_bindgen::JsValue::NULL,
                                &"Failed to get file content as string".into(),
                            )
                            .unwrap();
                    }
                } else {
                    reject
                        .call1(
                            &wasm_bindgen::JsValue::NULL,
                            &"Failed to get file content".into(),
                        )
                        .unwrap();
                }
            });

            reader.set_onload(Some(onload_callback.as_ref().unchecked_ref()));
            let _ = reader.read_as_text(&file);
            onload_callback.forget();
        }))
        .await
        .map_err(|e| format!("Error reading file: {:?}", e))?;

    // Extract the file content as a string
    let file_contents = file_content_future
        .as_string()
        .ok_or_else(|| "Failed to convert file content to string".to_string())?;

    // Call the appropriate server function based on import type
    match import_type {
        ImportType::Students => {
            crate::app::server_functions::bulk_students::upload_students_bulk(file_contents)
                .await
                .map_err(|e| e.to_string())
        }
        ImportType::Enrollments => {
            crate::app::server_functions::bulk_enrollment::upload_bulk_enrollment(file_contents)
                .await
                .map_err(|e| e.to_string())
        }
    }
}
use crate::app::models::student::{DeleteStudentRequest, Student};
use crate::app::server_functions::students::delete_student;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use leptos::task::spawn_local;
use std::rc::Rc;

#[component]
pub fn DeleteStudentConfirmation(
    #[prop(into)] student: Signal<Option<Rc<Student>>>,
    #[prop(into)] show: Signal<bool>,
    #[prop(into)] set_show: Callback<bool>,
    #[prop(into)] on_delete_success: Callback<()>,
) -> impl IntoView {
    let (confirm_id, set_confirm_id) = signal(String::new());

    let handle_delete_student = move |ev: SubmitEvent| {
        ev.prevent_default();

        if let Some(student_to_be_deleted) = student() {
            let validated_confirm_id = confirm_id()
                .parse::<i32>()
                .expect("Delete confirmation ID was processed correctly");

            if validated_confirm_id == student_to_be_deleted.student_id {
                let delete_student_request = DeleteStudentRequest::new(
                    student_to_be_deleted.firstname.clone().unwrap(),
                    student_to_be_deleted.lastname.clone().unwrap(),
                    validated_confirm_id,
                );

                spawn_local(async move {
                    let delete_result = delete_student(delete_student_request).await;

                    match delete_result {
                        Ok(_deleted_student) => {
                            set_show.call(false);
                            on_delete_success.call(());
                        }
                        Err(e) => {
                            println!("Error deleting = {:?}", e);
                            set_show.call(false);
                        }
                    };
                });
            } else {
                set_show.call(false);
                log::info!("Delete was cancelled");
            }
        }
    };

    view! {
        <Show when=move || show() && student().is_some()>
            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full">
                    <h3 class="text-xl font-bold mb-4">"Confirm Delete"</h3>
                    <p class="mb-4">
                        "To confirm deletion, please enter the student ID number: "
                        {move || student().map(|s| s.student_id.to_string())}
                    </p>
                    <form on:submit=handle_delete_student>
                        <input
                            type="text"
                            class="w-full p-2 border rounded mb-4"
                            placeholder="Enter student ID"
                            on:input=move |ev| set_confirm_id(event_target_value(&ev))
                            required
                        />
                        <div class="flex justify-end gap-2">
                            <button
                                type="button"
                                class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                                on:click=move |_| set_show.call(false)
                            >
                                "Cancel"
                            </button>
                            <button
                                type="submit"
                                class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                "Delete"
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </Show>
    }
}
use leptos::prelude::*;
use crate::app::models::student::Student;
use crate::app::middleware::global_settings::use_settings;
use crate::app::components::auth::enhanced_login_form::{use_student_mapping_service, DeAnonymizedStudent};
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use std::rc::Rc;

// Updated color scheme to match the palette
const THEME_PRIMARY: &str = "#2E3A59"; // Navy blue
const THEME_SECONDARY: &str = "#DADADA"; // Light gray
const THEME_BG: &str = "#F9F9F8"; // Off-white

// Improved consistent styling with better naming and responsive design
const CARD_CONTAINER: &str = "h-[95%] bg-[#F9F9F8] p-3 sm:p-6 border-t-8 border-[#2E3A59] shadow-md rounded-lg flex flex-col";
const SECTION_CONTAINER: &str = "bg-white p-3 sm:p-5 rounded-lg border border-[#DADADA] shadow-sm";
const SECTION_TITLE: &str =
    "text-xs sm:text-sm font-semibold text-[#2E3A59] mb-2 sm:mb-3 pb-2 border-b border-[#DADADA]";
const INFO_TITLE: &str = "text-xs text-[#2E3A59] text-opacity-70 font-medium";
const INFO_VALUE: &str = "text-xs sm:text-sm text-[#2E3A59] mt-1";
const INFO_GROUP: &str = "mb-3 sm:mb-4";
const BUTTON_CONTAINER: &str =
    "mt-4 sm:mt-6 pt-3 sm:pt-4 flex flex-wrap sm:flex-nowrap gap-2 sm:gap-3 justify-end sticky bottom-0 bg-[#F9F9F8] border-t border-[#DADADA]";
const BUTTON_PRIMARY: &str = 
    "w-full sm:w-auto px-3 sm:px-4 py-2 bg-[#2E3A59] rounded-md text-xs sm:text-sm font-medium text-[#F9F9F8] hover:bg-opacity-80 transition-colors";
const BUTTON_SECONDARY: &str = 
    "w-full sm:w-auto px-3 sm:px-4 py-2 bg-[#F9F9F8] rounded-md text-xs sm:text-sm font-medium text-[#2E3A59] hover:bg-opacity-80 transition-colors border border-[#DADADA]";
const BUTTON_ACCENT: &str = 
    "w-full sm:w-auto px-3 sm:px-4 py-2 bg-[#F9F9F8] rounded-md text-xs sm:text-sm font-medium text-[#2E3A59] hover:bg-[#DADADA] hover:bg-opacity-30 transition-colors border border-[#DADADA]";

#[component]
pub fn StudentDetails(
    #[prop()] student: Rc<Student>,
    #[prop(optional)] on_edit_student: Option<Callback<()>>,
) -> impl IntoView {
    // Get global settings
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;
    
    // Get the mapping service
    let (student_mapping_service, _) = use_student_mapping_service();
    
    // Clone the student Rc for use in closures
    let student_for_deanonymization = student.clone();
    let student_for_memo = student.clone();
    
    // Create a memo for the de-anonymized student info
    let de_anonymized_student = Memo::new(move |_| {
        let mapping_service = student_mapping_service.get();
        DeAnonymizedStudent::from_student_with_mapping(
            &student_for_deanonymization.as_ref(), 
            mapping_service.as_ref()
        )
    });
    
    // Create a memo for the student to ensure stable references
    let student_memo = Memo::new(move |_| student_for_memo.clone());

    // Function to get display name based on anonymization settings
    let get_display_name = move || {
        if anonymization_enabled() {
            de_anonymized_student.get().display_name
        } else {
            format!(
                "{} {}", 
                student_memo().firstname.as_ref().unwrap_or(&"Unknown".to_string()), 
                student_memo().lastname.as_ref().unwrap_or(&"Unknown".to_string())
            )
        }
    };

    // Function to get display ID based on anonymization settings
    let get_display_id = move || {
        if anonymization_enabled() {
            de_anonymized_student.get().display_id
        } else {
            student_memo().student_id.to_string()
        }
    };

    // Function to get student PIN with proper de-anonymization
    let get_student_pin = move || {
        if anonymization_enabled() {
            if let Some(mapping_service) = student_mapping_service.get() {
                if let Some(mapping) = mapping_service.get_original_student_info(student_memo().student_id) {
                    return mapping.pin.clone();
                }
            }
            // Fallback to anonymized display
            "****".to_string()
        } else {
            student_memo().pin.unwrap_or(0).to_string()
        }
    };

    // Function to create support services view that doesn't borrow student directly
    let support_services_view = move || {
        let student = student_memo();
        let mut services = Vec::new();

        // Function to create consistent service status item
        let create_service_item = |title: &'static str, active: bool| {
            view! {
                <div class=INFO_GROUP>
                    <div class=INFO_TITLE>{title}</div>
                    <div class=INFO_VALUE>
                        {if active {
                            view! {
                                <div class="flex items-center">
                                    <div class="h-3 w-3 sm:h-4 sm:w-4 rounded-full bg-green-600 mr-1 sm:mr-2"></div>
                                    <span class="text-xs sm:text-sm text-green-700 font-medium">"Active"</span>
                                </div>
                            }
                        } else {
                            view! { <div><span class="text-xs sm:text-sm text-[#2E3A59] text-opacity-50 font-medium">"Inactive"</span></div> }
                        }}
                    </div>
                </div>
            }
        };

        if student.iep {
            services.push(create_service_item("IEP Status", true));
        }

        if student.bip {
            services.push(create_service_item("BEH Status", true));
        }

        if student.student_504 {
            services.push(create_service_item("504 Status", true));
        }

        if student.gt {
            services.push(create_service_item("GT Status", true));
        }

        if student.readplan {
            services.push(create_service_item("Readplan", true));
        }

        if student.intervention.is_some() {
            services.push(view! {
                <div class=INFO_GROUP>
                    <div class=INFO_TITLE>"Intervention Status"</div>
                    <div class=INFO_VALUE>
                        {match &student.intervention {
                            Some(intervention) => {
                                view! {
                                    <span class="px-1 sm:px-2 py-0.5 sm:py-1 bg-[#2E3A59] bg-opacity-10 text-[#2E3A59] rounded-md text-xs font-medium">
                                        {intervention.to_string()}
                                    </span>
                                }
                            },
                            None => {
                                view! {
                                    <span class="text-xs sm:text-sm text-[#2E3A59] text-opacity-50 font-medium">"None"</span>
                                }
                            }
                        }}
                </div>
                </div>
            });
        }

        if student.eye_glasses {
            services.push(create_service_item("Glasses", true));
        }

        if student.esl.to_string() != "Not Applicable" {
            services.push(view! {
                <div class=INFO_GROUP>
                    <div class=INFO_TITLE>"ESL Status"</div>
                    <div class=INFO_VALUE>
                        <span class="px-1 sm:px-2 py-0.5 sm:py-1 bg-[#2E3A59] bg-opacity-10 text-[#2E3A59] rounded-md text-xs font-medium">
                            {student.esl.to_string()}
                        </span>
                    </div>
                </div>
            });
        }

        services
    };

    view! {
        <div class=CARD_CONTAINER>
            <div class="flex items-center justify-between mb-3 sm:mb-6">
                <h2 class="text-lg sm:text-xl font-bold text-[#2E3A59]">
                    {get_display_name}
                </h2>
                <div class="px-2 sm:px-3 py-0.5 sm:py-1 rounded-full bg-[#2E3A59] text-white text-xs font-medium">
                    {move || student_memo().current_grade_level.to_string()}
                </div>
            </div>

            // Show anonymization status indicator
            {move || {
                if anonymization_enabled() {
                    let has_mapping = student_mapping_service.get()
                        .map(|service| service.has_mapping_for_app_id(student_memo().student_id))
                        .unwrap_or(false);
                    
                    view! {
                        <div class="mb-4 p-2 rounded-md border text-xs">
                            {if has_mapping {
                                view! {
                                    <div class="flex items-center text-green-700 bg-green-50 border-green-200">
                                        <div class="h-2 w-2 rounded-full bg-green-600 mr-2"></div>
                                        "Student identity available - showing real information"
                                    </div>
                                }.into_any()
                            } else {
                                view! {
                                    <div class="flex items-center text-amber-700 bg-amber-50 border-amber-200">
                                        <div class="h-2 w-2 rounded-full bg-amber-600 mr-2"></div>
                                        "Student identity protected - showing anonymized information"
                                    </div>
                                }.into_any()
                            }}
                        </div>
                    }.into_any()
                } else {
                    view! { <div></div> }.into_any()
                }
            }}

            <div class="flex-grow overflow-y-auto space-y-4 sm:space-y-6">
                // Basic Information Section
                <div>
                    <h3 class=SECTION_TITLE>"Basic Information"</h3>
                    <div class=SECTION_CONTAINER>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-6">
                            <div class=INFO_GROUP>
                                <div class=INFO_TITLE>"Preferred Name"</div>
                                <div class=INFO_VALUE>{move || student_memo().preferred.clone()}</div>
                            </div>

                            <div class=INFO_GROUP>
                                <div class=INFO_TITLE>
                                    {move || if anonymization_enabled() { "Student ID" } else { "Student ID" }}
                                </div>
                                <div class=INFO_VALUE>
                                    {move || format!("#{}", get_display_id())}
                                </div>
                            </div>

                            <div class=INFO_GROUP>
                                <div class=INFO_TITLE>"Teacher"</div>
                                <div class=INFO_VALUE>{move || student_memo().teacher.clone()}</div>
                            </div>

                            <div class=INFO_GROUP>
                                <div class=INFO_TITLE>"Date of Birth"</div>
                                <div class=INFO_VALUE>
                                    {move || {
                                        if anonymization_enabled() {
                                            let has_mapping = student_mapping_service.get()
                                                .map(|service| service.has_mapping_for_app_id(student_memo().student_id))
                                                .unwrap_or(false);
                                            if has_mapping {
                                                format!("{}", student_memo().date_of_birth.format("%m-%d-%Y"))
                                            } else {
                                                "Protected".to_string()
                                            }
                                        } else {
                                            format!("{}", student_memo().date_of_birth.format("%m-%d-%Y"))
                                        }
                                    }}
                                </div>
                            </div>
                            
                            <div class=INFO_GROUP>
                                <div class=INFO_TITLE>"Student Pin"</div>
                                <div class=INFO_VALUE>{get_student_pin}</div>
                            </div>
                        </div>
                    </div>
                </div>

                // Support Services Section
                <div>
                    <h3 class=SECTION_TITLE>"Support Services"</h3>
                    <div class=SECTION_CONTAINER>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-6">
                            {support_services_view}
                        </div>
                    </div>
                </div>

                // Additional Information Section
                <div>
                    <h3 class=SECTION_TITLE>"Additional Information"</h3>
                    <div class=SECTION_CONTAINER>
                        <div class=INFO_GROUP>
                            <div class=INFO_TITLE>"Student Notes"</div>
                            <div class="mt-2 whitespace-pre-wrap text-[#2E3A59] bg-white p-2 sm:p-3 rounded border border-[#DADADA] min-h-10 sm:min-h-12 text-xs sm:text-sm">
                                {move || {
                                    let notes = student_memo().notes.clone();
                                    if notes.is_empty() {
                                        view! { <span class="text-[#2E3A59] text-opacity-40 italic">"No notes available"</span> }
                                    } else {
                                        view! { <span>{notes}</span> }
                                    }
                                }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            // Button container at the bottom - stacked on mobile
            <div class=BUTTON_CONTAINER>
                <button class=BUTTON_ACCENT
                    on:click=move |_| {
                        if let Some(callback) = on_edit_student {
                            callback.call(());
                        }
                    }
                >
                    "Edit Student"
                </button>
                <button class=BUTTON_PRIMARY>
                    <a href=format!("/studentview/{}/results", &student_memo().student_id)>
                        "Test Results"
                    </a>
                </button>
            </div>
        </div>
    }
}
use leptos::prelude::*;
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent,
};
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::student::ESLEnum;
use crate::app::models::student::Student;
use leptos::prelude::*;
use std::rc::Rc;

// Base colors
const COLOR_PRIMARY: &str = "#2E3A59"; // Navy blue
const COLOR_NEAR_BLACK: &str = "#0D0D0D";
const COLOR_LIGHT_GRAY: &str = "#DADADA"; // Light gray
const COLOR_OFF_WHITE: &str = "#F9F9F8"; // Off-white

// Accent/Functional colors
const COLOR_ERROR: &str = "#D64045";
const COLOR_WARNING: &str = "#E9B872";
const COLOR_SUCCESS: &str = "#5B8C5A";
const COLOR_ACCENT_BLUE: &str = "#3E92CC";
const COLOR_ACCENT_TERRACOTTA: &str = "#D3A588";

// Table styles - Updated for better responsiveness
const TABLE_CONTAINER_STYLE: &str =
    "bg-[#F9F9F8] rounded-lg shadow-sm border border-[#DADADA] overflow-hidden flex flex-col h-full";
const TABLE_HEADER_STYLE: &str =
    "py-3 md:py-5 px-4 md:px-6 flex justify-between items-center bg-[#2E3A59] border-b border-[#2E3A59] flex-shrink-0";
const TABLE_WRAPPER_STYLE: &str = "overflow-auto flex-1 min-h-0 scroll-smooth";
const TABLE_STYLE: &str = "w-full min-w-[800px] divide-y divide-[#DADADA]";
const HEADER_CELL_STYLE: &str =
    "px-2 md:px-6 py-2 md:py-3 text-left text-sm font-medium text-[#2E3A59] uppercase tracking-wider whitespace-nowrap";
const CELL_STYLE: &str =
    "px-2 md:px-6 py-2 md:py-4 whitespace-nowrap text-sm md:text-md bg-[#F9F9F8]";
const SELECTED_ROW_STYLE: &str =
    "bg-[#DADADA] border-l-4 border-t-2 border-b-2 border-r-2 border-[#2E3A59]";

#[component]
pub fn StudentTable(
    #[prop(into)] students: Resource<i32, Option<Vec<Student>>>,
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] grade_filter: Signal<String>,
    #[prop(into)] teacher_filter: Signal<String>,
    #[prop(into)] iep_filter: Signal<bool>,
    #[prop(into)] esl_filter: Signal<bool>,
    #[prop(into)] intervention_filter: Signal<String>,
    #[prop(into)] student_504_filter: Signal<bool>,
    #[prop(into)] readplan_filter: Signal<bool>,
    #[prop(into)] gt_filter: Signal<bool>,
    #[prop(into)] bip_filter: Signal<bool>,
    #[prop(into)] is_panel_expanded: Signal<bool>,
    #[prop(into)] selected_student: Signal<Option<Rc<Student>>>,
    #[prop(into)] set_selected_student: WriteSignal<Option<Rc<Student>>>,
) -> impl IntoView {
    //get settings
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    // Get mapping service for de-anonymization
    let (mapping_service, _) = use_student_mapping_service();

    // Create enhanced student data with de-anonymization info
    let enhanced_students = Memo::new(move |_| {
        let students_data = students.get().unwrap_or(None).unwrap_or_default();

        if anonymization_enabled() {
            students_data
                .into_iter()
                .map(|student| {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &student,
                        mapping_service.get().as_ref(),
                    );
                    (student, Some(de_anon))
                })
                .collect::<Vec<_>>()
        } else {
            students_data
                .into_iter()
                .map(|student| (student, None))
                .collect::<Vec<_>>()
        }
    });

    let filtered_students = Memo::new(move |_| {
        let search = search_term().trim().to_lowercase();
        let current_grade_level = grade_filter();
        let teacher = teacher_filter();
        let show_iep = iep_filter();
        let show_esl = esl_filter();
        let intervention = intervention_filter();
        let show_504 = student_504_filter();
        let show_readplan = readplan_filter();
        let show_gt = gt_filter();
        let show_bip = bip_filter();

        enhanced_students()
            .into_iter()
            .filter(|(student, de_anon_opt)| {
                // Use de-anonymized data for search if available
                let (search_firstname, search_lastname, search_id) = if let Some(de_anon) =
                    de_anon_opt
                {
                    // Extract first and last name from display_name
                    let name_parts: Vec<&str> = de_anon.display_name.split_whitespace().collect();
                    let first = name_parts.get(0).unwrap_or(&"").to_string();
                    let last = name_parts.get(1).unwrap_or(&"").to_string();
                    (first, last, de_anon.display_id.clone())
                } else {
                    (
                        student
                            .firstname
                            .as_ref()
                            .unwrap_or(&"Unknown".to_string())
                            .clone(),
                        student
                            .lastname
                            .as_ref()
                            .unwrap_or(&"Unknown".to_string())
                            .clone(),
                        student.student_id.to_string(),
                    )
                };

                // Filter by search term (now using de-anonymized data when available)
                let matches_search = search.is_empty()
                    || search_firstname.to_lowercase().contains(&search)
                    || search_lastname.to_lowercase().contains(&search)
                    || search_id.to_lowercase().contains(&search);

                // Filter by grade
                let matches_grade = current_grade_level.is_empty()
                    || student
                        .current_grade_level
                        .to_string()
                        .contains(&current_grade_level);

                // Filter by teacher
                let matches_teacher = teacher == "all" || student.teacher.to_string() == teacher;

                // Filter by IEP
                let matches_iep = !show_iep || student.iep;

                // Filter by ESL - fixed for Option<ESLEnum>
                let matches_esl = !show_esl || student.esl != ESLEnum::NotApplicable;

                // Filter by intervention
                let matches_intervention = intervention.is_empty()
                    || intervention == "all"
                    || (intervention == "None" && student.intervention.is_none())
                    || student
                        .intervention
                        .as_ref()
                        .map(|i| i.to_string().contains(&intervention))
                        .unwrap_or(false);

                // New filters - assuming these fields exist on Student
                let matches_504 = !show_504 || student.student_504;
                let matches_readplan = !show_readplan || student.readplan;
                let matches_gt = !show_gt || student.gt;
                let matches_bip = !show_bip || student.bip;

                matches_search
                    && matches_grade
                    && matches_teacher
                    && matches_iep
                    && matches_esl
                    && matches_intervention
                    && matches_504
                    && matches_readplan
                    && matches_gt
                    && matches_bip
            })
            .collect::<Vec<_>>()
    });

    view! {
        <div class=TABLE_CONTAINER_STYLE>
            <div class=TABLE_HEADER_STYLE>
                <h2 class="text-lg md:text-xl font-medium text-[#F9F9F8]">
                    "Students"
                </h2>
                <span class="text-xs md:text-sm text-[#F9F9F8]">
                    {move || {
                        let count = filtered_students().len();
                        format!("{} {}", count, if count == 1 { "student" } else { "students" })
                    }}
                </span>
            </div>
            <div class=TABLE_WRAPPER_STYLE>
                <table class=TABLE_STYLE>
                    <thead class="bg-[#DADADA] sticky top-0 z-10">
                        <tr>
                            <th class=HEADER_CELL_STYLE>"First"</th>
                            <th class=HEADER_CELL_STYLE>"Last"</th>
                            <th class=HEADER_CELL_STYLE>"ID"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"Grade"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"Teacher"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"IEP"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"ESL"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"Intervention"</th>

                            // Additional columns that appear regardless of panel state
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"504 Plan"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"Read Plan"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"GT"</th>
                            <th class=format!("{} {}", HEADER_CELL_STYLE, "whitespace-nowrap")>"BEH"</th>
                        </tr>
                    </thead>
                    <Suspense fallback=move || view! {
                        <tr>
                            <td colspan="12" class="text-center p-8">
                                <div class="inline-block h-6 w-6 animate-spin rounded-full border-2 border-[#DADADA] border-t-[#2E3A59]"></div>
                            </td>
                        </tr>
                    }>
                        <tbody class="bg-[#F9F9F8]">
                            {move || {
                                let students = filtered_students();
                                if students.is_empty() {
                                    view! {
                                        <tr>
                                            <td colspan="12" class="px-6 py-12 text-center text-sm text-[#2E3A59] text-opacity-70">
                                                "No students match your search criteria"
                                            </td>
                                        </tr>
                                    }.into_any()
                                } else {
                                    students.into_iter().map(|(student, de_anon_opt)| {
                                        let student_rc = Rc::new(student.clone());
                                        let student_cmp = Rc::new(student.clone());
                                        let is_selected = move || selected_student() == Some(student_cmp.clone());

                                        // Determine display values based on anonymization status
                                        let (display_first, display_last, display_id) = if let Some(de_anon) = &de_anon_opt {
                                            // Split the display_name for first and last name
                                            let name_parts: Vec<&str> = de_anon.display_name.split_whitespace().collect();
                                            let first = name_parts.get(0).unwrap_or(&"Unknown").to_string();
                                            let last = if name_parts.len() > 1 {
                                                name_parts[1..].join(" ")
                                            } else {
                                                "Unknown".to_string()
                                            };
                                            (first, last, de_anon.display_id.clone())
                                        } else {
                                            (
                                                student.firstname.as_ref().unwrap_or(&"Unknown".to_string()).clone(),
                                                student.lastname.as_ref().unwrap_or(&"Unknown".to_string()).clone(),
                                                student.student_id.to_string()
                                            )
                                        };

                                        view! {
                                            <tr
                                                class=move || if is_selected() {
                                                    format!("{} {}", SELECTED_ROW_STYLE, "cursor-pointer")
                                                } else {
                                                    "hover:bg-[#DADADA] hover:bg-opacity-20 cursor-pointer border-b border-[#DADADA]".to_string()
                                                }
                                                on:click=move |_| set_selected_student(Some(student_rc.clone()))
                                            >
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{display_first}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "font-medium text-[#2E3A59]")>{display_last}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] text-opacity-70")>{display_id}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] text-opacity-70")>{&student.current_grade_level.to_string()}</td>
                                                <td class=format!("{} {}", CELL_STYLE, "text-[#2E3A59] text-opacity-70")>{&student.teacher.to_string()}</td>

                                                // IEP Column
                                                <td class=CELL_STYLE>
                                                    { if student.iep {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                "IEP"
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                // ESL Column
                                                <td class=CELL_STYLE>
                                                    { if student.esl != ESLEnum::NotApplicable {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                {student.esl.to_string()}
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full  bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                // Intervention Column
                                                <td class=CELL_STYLE>
                                                    { if let Some(intervention) = &student.intervention {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                {intervention.to_string()}
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                // 504 Plan Column
                                                <td class=CELL_STYLE>
                                                    { if student.student_504 {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                "504"
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                // Read Plan Column
                                                <td class=CELL_STYLE>
                                                    { if student.readplan {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                "Read Plan"
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                // GT Column
                                                <td class=CELL_STYLE>
                                                    { if student.gt {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                "GT"
                                                            </span>
                                                        }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>

                                                //BEH/BIP column
                                                <td class=CELL_STYLE>
                                                    { if student.bip {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-[#4CAF50] bg-opacity-40 text-[#2E3A59]">
                                                                "BEH"
                                                            </span>
                                                      }
                                                    } else {
                                                        view! {
                                                            <span class="px-2 py-1 text-sm font-medium rounded-full bg-opacity-40 text-[#2E3A59]">
                                                                "-"
                                                            </span>
                                                        }
                                                    }}
                                                </td>
                                            </tr>
                                        }
                                    }).collect_view()
                                }
                            }}
                        </tbody>
                    </Suspense>
                </table>
            </div>
        </div>
    }
}
use crate::app::models::student::{ESLEnum, GenderEnum, GradeEnum, InterventionEnum, Student};
use crate::app::models::UpdateStudentRequest;
use crate::app::server_functions::students::edit_student;
use leptos::prelude::*;
use leptos::tasks::spawn_local;
use std::rc::Rc;
use std::str::FromStr;
use strum::IntoEnumIterator;

// Styles - matching add form for consistency
const INFO_CONTAINER_STYLE: &str =
    "h-full p-6 border-t-8 border-[#00356B] shadow-lg rounded-lg flex flex-col";
const INFO_CONTENT_STYLE: &str = "flex-grow overflow-y-auto";
const INFO_TITLE_STYLE: &str = "text-stone-400 text-xs";
const INFO_GROUP_STYLE: &str = "mb-2";
const BUTTON_CONTAINER_STYLE: &str =
    "mt-4 pt-4 flex border-t gap-2 justify-end sticky bottom-0 bg-[#F9F9F8]";

#[component]
pub fn UpdateStudent(
    #[prop()] student: Rc<Student>,
    #[prop(optional)] on_cancel: Option<Callback<()>>,
    #[prop(optional)] on_update_success: Option<Callback<Student>>,
) -> impl IntoView {
    // Create signals for each field - FIXED: Handle None values safely
    let (firstname, set_firstname) =
        signal(student.firstname.clone().unwrap_or_else(|| "".to_string()));
    let (lastname, set_lastname) =
        signal(student.lastname.clone().unwrap_or_else(|| "".to_string()));
    let (preferred, set_preferred) = signal(student.preferred.clone());
    let (gender, set_gender) = signal(student.gender.clone().to_string());
    let (date_of_birth, set_date_of_birth) = signal(student.date_of_birth);
    let (student_id, set_student_id) = signal(student.student_id.clone().to_string());
    let (current_grade_level, set_current_grade_level) =
        signal(student.current_grade_level.clone().to_string());
    let (teacher, set_teacher) = signal(student.teacher.clone());
    let (yes_no_esl, set_yes_no_esl) = if student.esl.to_string() == "Not Applicable" {
        signal(false)
    } else {
        signal(true)
    };

    let (esl, set_esl) = signal(student.esl.to_string());

    let (iep, set_iep) = signal(student.iep);
    let (bip, set_bip) = signal(student.bip);
    let (student_504, set_student_504) = signal(student.student_504);
    let (readplan, set_readplan) = signal(student.readplan);
    let (gt, set_gt) = signal(student.gt);
    let (intervention_selection, set_intervention_selection) =
        signal(match &student.intervention {
            Some(intervention) => intervention.to_string(),
            None => "None".to_string(),
        });

    // Additional information - FIXED: Handle None pin value safely
    let (eye_glasses, set_eye_glasses) = signal(student.eye_glasses);
    let (notes, set_notes) = signal(student.notes.clone());
    let (pin, set_pin) = signal(student.pin.unwrap_or(0).to_string());

    // For handling form submission
    let (is_submitting, set_is_submitting) = signal(false);
    let (error_message, set_error_message) = signal(String::new());
    let (if_error, set_if_error) = signal(false);

    // Create a resource to fetch teachers (similar to add form)
    let teachers = Resource::new(
        || (),
        |_| async move {
            match crate::app::server_functions::get_teachers().await {
                Ok(teachers) => Some(teachers),
                Err(e) => {
                    log::error!("Failed to fetch teachers: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    // Create a derived signal for filtered teachers based on selected grade
    let filtered_teachers = Memo::new(move |_| {
        let grade_str = current_grade_level();
        if grade_str.is_empty() {
            return Vec::new(); // Return empty if no grade selected yet
        }

        // Convert the selected grade string to GradeEnum
        let selected_grade = match GradeEnum::from_str(&grade_str) {
            Ok(grade) => grade,
            Err(_) => return Vec::new(), // Return empty on error
        };

        // Filter teachers to only include those matching the selected grade
        teachers
            .get()
            .unwrap_or(Some(Vec::new()))
            .unwrap_or_default()
            .into_iter()
            .filter(|teacher| {
                // Check if teacher has EmployeeRole::Teacher{grade} matching selected_grade
                match &teacher.role {
                    crate::app::models::EmployeeRole::Teacher { grade } => {
                        *grade == Some(selected_grade.clone())
                    }
                    _ => false,
                }
            })
            .collect::<Vec<_>>()
    });

    // Handle form submission
    let on_submit = move |ev: leptos::ev::SubmitEvent| {
        ev.prevent_default();
        set_is_submitting(true);
        set_error_message(String::new());
        set_if_error(false);

        // Validate required fields - FIXED: Check for empty strings
        if firstname().trim().is_empty() {
            set_if_error(true);
            set_error_message(String::from("First name is required"));
            set_is_submitting(false);
            return;
        }

        if lastname().trim().is_empty() {
            set_if_error(true);
            set_error_message(String::from("Last name is required"));
            set_is_submitting(false);
            return;
        }

        // Parse and validate student ID
        let validated_student_id = match student_id().parse::<i32>() {
            Ok(id) => id,
            Err(_) => {
                set_if_error(true);
                set_error_message(String::from("Invalid student ID"));
                set_is_submitting(false);
                return;
            }
        };

        let validated_pin = match pin().parse::<i32>() {
            Ok(pin) => pin,
            Err(_) => {
                set_if_error(true);
                set_error_message(String::from("Invalid pin"));
                set_is_submitting(false);
                return;
            }
        };

        // Convert gender string to enum
        let convert_gender_to_enum = match GenderEnum::from_str(&gender()) {
            Ok(gender_enum) => gender_enum,
            Err(_) => {
                log::error!("Invalid gender value submitted for update");
                set_if_error(true);
                set_error_message(String::from("Invalid gender selection"));
                set_is_submitting(false);
                return;
            }
        };

        // Convert grade string to enum
        let convert_grade_to_enum = match GradeEnum::from_str(&current_grade_level()) {
            Ok(grade_enum) => grade_enum,
            Err(_) => {
                log::error!("Invalid grade value submitted for update");
                set_if_error(true);
                set_error_message(String::from("Invalid grade selection"));
                set_is_submitting(false);
                return;
            }
        };

        // Convert ELL string to enum
        let convert_esl_to_enum = match ESLEnum::from_str(&esl()) {
            Ok(esl_enum) => esl_enum,
            Err(_) => {
                log::error!("Invalid ELL value submitted for update");
                set_if_error(true);
                set_error_message(String::from("Invalid ELL selection"));
                set_is_submitting(false);
                return;
            }
        };

        // Convert selection_intervention into enum
        let convert_intervention = if intervention_selection() == "None" {
            None
        } else {
            match InterventionEnum::from_str(&intervention_selection()) {
                Ok(intervention_enum) => Some(intervention_enum),
                Err(_) => {
                    log::error!("Invalid intervention value submitted for update");
                    set_if_error(true);
                    set_error_message(String::from("Invalid intervention selection"));
                    set_is_submitting(false);
                    return;
                }
            }
        };

        let update_data = UpdateStudentRequest {
            firstname: firstname(),
            lastname: lastname(),
            preferred: preferred(),
            gender: convert_gender_to_enum,
            date_of_birth: date_of_birth(),
            student_id: validated_student_id,
            esl: convert_esl_to_enum,
            current_grade_level: convert_grade_to_enum,
            teacher: teacher(),
            iep: iep(),
            bip: bip(),
            student_504: student_504(),
            readplan: readplan(),
            gt: gt(),
            intervention: convert_intervention,
            eye_glasses: eye_glasses(),
            notes: notes(),
            pin: validated_pin,
        };

        spawn_local(async move {
            match edit_student(update_data).await {
                Ok(updated_student) => {
                    set_is_submitting(false);
                    if let Some(callback) = on_update_success {
                        callback.call(updated_student);
                    }
                }
                Err(e) => {
                    set_is_submitting(false);
                    set_if_error(true);
                    set_error_message(format!("Failed to update student: {}", e));
                }
            }
        });
    };

    let handle_cancel = move |_| {
        if let Some(callback) = on_cancel {
            callback.call(());
        }
    };

    view! {
        <div class=INFO_CONTAINER_STYLE>
            <Show when=move || if_error()>
                <p class="text-red-500 font-semibold">"There was an error with one or more of the entered fields"</p>
                <p class="text-red-500 rounded w-full h-12 px-5 -y-3">{error_message()}</p>
            </Show>
            <h2 class="text-xl font-bold mb-4">
                "Edit Student: " {move || firstname()} " " {move || lastname()}
            </h2>
            <form on:submit=on_submit class=INFO_CONTENT_STYLE>
                <div class="grid grid-cols-2 gap-4">
                    // Basic Information Section
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Basic Information"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="firstname">"First Name"</label>
                                <input
                                    id="firstname"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={firstname}
                                    on:input=move |ev| set_firstname(event_target_value(&ev))
                                    required
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="lastname">"Last Name"</label>
                                <input
                                    id="lastname"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={lastname}
                                    on:input=move |ev| set_lastname(event_target_value(&ev))
                                    required
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="preferred">"Preferred Name"</label>
                                <input
                                    id="preferred"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={preferred}
                                    on:input=move |ev| set_preferred(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="student-id">"Student ID"</label>
                                <input
                                    required
                                    id="student-id"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={student_id}
                                    on:input=move |ev| set_student_id(event_target_value(&ev))
                                    readonly
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="gender">"Gender"</label>
                                <select
                                    required
                                    id="gender"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_gender(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {GenderEnum::iter().map(|g| view! {
                                        <option value=format!("{}", g) selected=g.to_string() == gender()>
                                            {format!("{}", g)}
                                        </option>
                                    }).collect::<Vec<_>>()}
                                </select>
                            </div>

                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="grade">"Grade"</label>
                                <select
                                    required
                                    id="grade"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_current_grade_level(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {GradeEnum::iter().map(|g| view! {
                                        <option value=format!("{}", g) selected=g.to_string() == current_grade_level()>
                                            {format!("{}", g)}
                                        </option>
                                    }).collect::<Vec<_>>()}
                                </select>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="birthdate">"Birthdate"</label>
                                <input
                                    type="date"
                                    required
                                    id="birthdate"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={move || date_of_birth().format("%Y-%m-%d").to_string()}
                                    on:change=move |ev| {
                                        let date_str = event_target_value(&ev);
                                        match chrono::NaiveDate::parse_from_str(&date_str, "%Y-%m-%d") {
                                            Ok(parsed_date) => set_date_of_birth(parsed_date),
                                            Err(e) => {
                                                log::error!("Error parsing date: {}", e);
                                                // Keep the original date on error
                                            }
                                        }
                                    }
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="pin">"Pin"</label>
                                <input
                                    type="number"
                                    id="pin"
                                    class="mt-1 w-full rounded-md border p-2"
                                    value={pin}
                                    on:input=move |ev| set_pin(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="teacher">"Teacher"</label>
                                <select
                                    required
                                    id="teacher"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_teacher(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {move || {
                                        if current_grade_level().is_empty() {
                                            vec![view! { <option disabled>"First select a grade"</option> }].into_iter().collect_view()
                                        } else {
                                            let filtered = filtered_teachers();
                                            if filtered.is_empty() {
                                                vec![view! { <option disabled>"No teachers available for this grade"</option> }].into_iter().collect_view()
                                            } else {
                                                let current_teacher = teacher();
                                                filtered.iter().map(|t| view! {
                                                    <option value=t.lastname.clone() selected=t.lastname == current_teacher>
                                                        {t.lastname.clone()}
                                                    </option>
                                                }).collect_view()
                                            }
                                        }
                                    }}
                                </select>
                            </div>
                        </div>
                    </div>

                    // Support Services Section
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Support Services"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || iep()}
                                        on:change=move |ev| set_iep(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"IEP"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || bip()}
                                        on:change=move |ev| set_bip(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"BIP"</span>
                                </label>
                            </div>

                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || student_504()}
                                        on:change=move |ev| set_student_504(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"504"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || yes_no_esl()}
                                        on:change=move |ev| set_yes_no_esl(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"ESL"</span>
                                </label>
                                <Show when=move || yes_no_esl()>
                                    <select class="p-3 rounded-lg mt-2 w-full"
                                        required
                                        on:change=move |event| {
                                            set_esl(event_target_value(&event))
                                        }
                                    >
                                        <option value="">"Please Select"</option>
                                        {ESLEnum::iter().map(|lang| view! {
                                            <option value=format!("{}", lang) selected=lang.to_string() == esl()>
                                                {format!("{}", lang)}
                                            </option>
                                        }).collect::<Vec<_>>()}
                                    </select>
                                </Show>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || readplan()}
                                        on:change=move |ev| set_readplan(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"Read Plan"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || gt()}
                                        on:change=move |ev| set_gt(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"GT Status"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <select
                                        required
                                        id="intervention"
                                        class="mt-1 w-full rounded-md p-2"
                                        on:change=move |ev| set_intervention_selection(event_target_value(&ev))
                                    >
                                        <option value="">"Please select a value"</option>
                                        <option value="None" selected={intervention_selection() == "None"}>"None"</option>
                                        {InterventionEnum::iter().map(|intervention| view! {
                                            <option value=format!("{}", intervention) selected=intervention.to_string() == intervention_selection()>
                                                {format!("{}", intervention)}
                                            </option>
                                        }).collect::<Vec<_>>()}
                                    </select>
                                    <span class=INFO_TITLE_STYLE>"Intervention"</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    //Additional Services
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Additional Services"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        checked={move || eye_glasses()}
                                        on:change=move |ev| set_eye_glasses(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"Glasses"</span>
                                </label>
                            </div>
                        </div>

                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Student Notes"</h3>
                        <div class="grid grid-cols-1 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="notes">"Notes"</label>
                                <textarea
                                    id="notes"
                                    class="mt-1 w-full rounded-md border p-2 h-32"
                                    prop:value={move || notes()}
                                    on:input=move |ev| set_notes(event_target_value(&ev))
                                    placeholder="Enter any additional notes about the student..."
                                />
                            </div>
                        </div>
                    </div>
                </div>
                <div class=BUTTON_CONTAINER_STYLE>
                    <button
                        type="button"
                        class="px-4 py-2 bg-gray-200 rounded-lg font-md hover:bg-gray-300"
                        on:click=handle_cancel
                        disabled=move || is_submitting()
                    >
                        "Cancel"
                    </button>
                    <button
                        type="submit"
                        class="px-4 py-2 bg-green-500 text-white font-md rounded-lg hover:bg-[#A8DCAB]"
                        disabled=move || is_submitting()
                    >
                        {move || if is_submitting() { "Updating..." } else { "Update Student" }}
                    </button>
                </div>
            </form>
        </div>
    }
}
use crate::app::models::student::InterventionEnum;
use crate::app::models::student::{AddStudentRequest, ESLEnum, GenderEnum, GradeEnum};
use crate::app::models::EmployeeRole;
use chrono::NaiveDate;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use leptos::task::spawn_local;
use std::str::FromStr;
use strum::IntoEnumIterator;
use validator::Validate;

// Styles
const INFO_CONTAINER_STYLE: &str =
    "h-full p-6 border-t-8 border-[#00356B] shadow-lg rounded-lg flex flex-col";
const INFO_CONTENT_STYLE: &str = "flex-grow overflow-y-auto";
const INFO_TITLE_STYLE: &str = "text-stone-400 text-xs";
const INFO_GROUP_STYLE: &str = "mb-2";
const BUTTON_CONTAINER_STYLE: &str =
    "mt-4 pt-4 flex border-t gap-2 justify-end sticky bottom-0 bg-[#F9F9F8]";

#[component]
pub fn AddStudentForm(
    #[prop(into)] set_adding_student: Callback<bool>,
    #[prop(into)] set_refresh_trigger: WriteSignal<i32>,
) -> impl IntoView {
    //Signals for error messaging
    let (error_message, set_error_message) = signal(String::new());
    let (if_error, set_if_error) = signal(false);

    //Signals for getting a new student
    let (new_firstname, set_new_firstname) = signal(String::new());
    let (new_lastname, set_new_lastname) = signal(String::new());
    let (new_preferred, set_new_preferred) = signal(String::new());
    let (new_student_gender, set_student_gender) = signal(String::new());
    let (new_student_dob, set_student_dob) = signal(String::new());
    let (new_student_id, set_new_student_id) = signal(String::new());
    let (new_grade, set_new_grade) = signal(String::new());
    let (new_teacher, set_new_teacher) = signal(String::new());
    let (new_iep, set_new_iep) = signal(false);
    let (new_bip, set_new_bip) = signal(false);
    let (new_504, set_new_504) = signal(false);
    let (yes_no_esl, set_yes_no_esl) = signal(false);
    let (new_esl, set_new_esl) = signal(String::from("Not Applicable"));
    let (new_gt, set_new_gt) = signal(false);
    let (new_readplan, set_new_readplan) = signal(false);
    let (new_intervention, set_new_intervention) = signal(String::new());
    let (new_eye_glasses, set_new_eye_glasses) = signal(false);
    let (new_notes, set_new_notes) = signal(String::new());
    let (new_pin, set_new_pin) = signal(String::new());

    // Create a resource to fetch teachers
    let teachers = Resource::new(
        || (),
        |_| async move {
            match crate::app::server_functions::get_teachers().await {
                Ok(teachers) => Some(teachers),
                Err(e) => {
                    log::error!("Failed to fetch teachers: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    // Create a derived signal for filtered teachers based on selected grade
    let filtered_teachers = Memo::new(move |_| {
        let grade_str = new_grade();
        if grade_str.is_empty() {
            return Vec::new(); // Return empty if no grade selected yet
        }

        // Convert the selected grade string to GradeEnum
        let selected_grade = match GradeEnum::from_str(&grade_str) {
            Ok(grade) => grade,
            Err(_) => return Vec::new(), // Return empty on error
        };

        // Filter teachers to only include those matching the selected grade
        teachers
            .get()
            .unwrap_or(Some(Vec::new()))
            .unwrap_or_default()
            .into_iter()
            .filter(|teacher| {
                // Check if teacher has EmployeeRole::Teacher{grade} matching selected_grade
                match &teacher.role {
                    EmployeeRole::Teacher { grade } => *grade == Some(selected_grade.clone()),
                    _ => false,
                }
            })
            .collect::<Vec<_>>()
    });

    let handle_submit_new_student = move |ev: SubmitEvent| {
        ev.prevent_default();

        let validated_student_id = new_student_id().parse::<i32>();
        let validated_dob = match NaiveDate::parse_from_str(&new_student_dob(), "%Y-%m-%d") {
            Ok(date) => date,
            Err(e) => {
                log::error!("Error parsing date: {}", e);
                set_if_error(true);
                set_error_message(String::from("Invalid date format"));
                return;
            }
        };

        let validated_pin = match new_pin().parse::<i32>() {
            Ok(pin) => pin,
            Err(_) => {
                set_if_error(true);
                set_error_message(String::from("Invalid pin"));
                return;
            }
        };

        let convert_gender_to_enum = match GenderEnum::from_str(&new_student_gender()) {
            Ok(gender_enum) => gender_enum,
            Err(_) => {
                log::error!("Invalid gender value submitted for new student");
                set_if_error(true);
                set_error_message(String::from("Invalid gender selection"));
                return;
            }
        };

        let convert_grade_to_enum = match GradeEnum::from_str(&new_grade()) {
            Ok(grade_enum) => grade_enum,
            Err(_) => {
                log::error!("Invalid grade value submitted for new student");
                set_if_error(true);
                set_error_message(String::from("Invalid grade selection"));
                return;
            }
        };

        let convert_esl_to_enum = match ESLEnum::from_str(&new_esl()) {
            Ok(esl_enum) => esl_enum,
            Err(_) => {
                log::error!("Invalid ESL value submitted for new student");
                set_if_error(true);
                set_error_message(String::from("Invalid ESL selection"));
                return;
            }
        };

        let convert_intervention_to_enum = if new_intervention() == "None" {
            None
        } else {
            match InterventionEnum::from_str(&new_intervention()) {
                Ok(intervention_enum) => Some(intervention_enum),
                Err(_) => {
                    log::error!("Invalid intervention value for new student");
                    set_if_error(true);
                    set_error_message(String::from("Invalid intervention selection"));
                    return;
                }
            }
        };

        let add_student_request = AddStudentRequest {
            firstname: new_firstname(),
            lastname: new_lastname(),
            preferred: new_preferred(),
            gender: convert_gender_to_enum,
            date_of_birth: validated_dob,
            student_id: match validated_student_id {
                Ok(id) => id,
                Err(_) => {
                    set_if_error(true);
                    set_error_message(String::from("Invalid student ID"));
                    return;
                }
            },
            esl: convert_esl_to_enum,
            current_grade_level: convert_grade_to_enum,
            teacher: new_teacher(),
            iep: new_iep(),
            bip: new_bip(),
            student_504: new_504(),
            readplan: new_readplan(),
            gt: new_gt(),
            intervention: convert_intervention_to_enum,
            eye_glasses: new_eye_glasses(),
            notes: new_notes(),
            pin: validated_pin,
        };

        let is_valid = add_student_request.validate();

        match is_valid {
            Ok(_) => {
                spawn_local(async move {
                    let add_result =
                        crate::app::server_functions::students::add_student(add_student_request)
                            .await;

                    //we get the result back and do something with it
                    match add_result {
                        Ok(_added_result) => {
                            set_adding_student(false);
                            set_refresh_trigger.update(|count| *count += 1);
                            log::info!("Student added successfully");
                        }
                        Err(e) => {
                            log::error!("Error adding student: {:?}", e);
                            set_if_error(true);
                            set_error_message(format!("Error adding student: {}", e));
                        }
                    };
                });
            }
            Err(e) => {
                set_if_error(true);
                set_error_message(format!("Validation error: {:?}", e));
            }
        }
    };

    view! {
        <div class=INFO_CONTAINER_STYLE>
            <Show when=move || if_error()>
                <p class="text-red-500 font-semibold">"There was an error with one or more of the entered fields"</p>
                <p class="text-red-500 rounded w-full h-12 px-5 -y-3">{error_message()}</p>
            </Show>
            <h2 class="text-xl font-bold mb-4">"Add New Student"</h2>
            <form on:submit=handle_submit_new_student class=INFO_CONTENT_STYLE>
                <div class="grid grid-cols-2 gap-4">
                    // Basic Information Section
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Basic Information"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="firstname">"First Name"</label>
                                <input
                                    id="firstname"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:input=move |ev| set_new_firstname(event_target_value(&ev))
                                    required
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="lastname">"Last Name"</label>
                                <input
                                    id="lastname"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:input=move |ev| set_new_lastname(event_target_value(&ev))
                                    required
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="preferred">"Preferred Name"</label>
                                <input
                                    id="preferred"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:input=move |ev| set_new_preferred(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="student-id">"Student ID"</label>
                                <input
                                    required
                                    id="student-id"
                                    type="text"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:input=move |ev| set_new_student_id(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="gender">"Gender"</label>
                                <select
                                    required
                                    id="gender"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_student_gender(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {GenderEnum::iter().map(|gender| view! {
                                        <option value=format!("{}", gender)>
                                            {format!("{}", gender)}
                                        </option>
                                    }).collect::<Vec<_>>()}
                                </select>
                            </div>

                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="grade">"Grade"</label>
                                <select
                                    required
                                    id="grade"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_new_grade(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {GradeEnum::iter().map(|grade| view! {
                                        <option value=format!("{}", grade)>
                                            {format!("{}", grade)}
                                        </option>
                                    }).collect::<Vec<_>>()}
                                </select>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="birthdate">"Birthdate"</label>
                                <input
                                    type="date"
                                    required
                                    id="birthdate"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_student_dob(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="pin">"Pin"</label>
                                <input
                                    type="number"
                                    id="pin"
                                    min="0"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:input=move |ev| set_new_pin(event_target_value(&ev))
                                />
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="teacher">"Teacher"</label>
                                <select
                                    required
                                    id="teacher"
                                    class="mt-1 w-full rounded-md border p-2"
                                    on:change=move |ev| set_new_teacher(event_target_value(&ev))
                                >
                                    <option value="">"Please select a value"</option>
                                    {move || {
                                        if new_grade().is_empty() {
                                            vec![view! { <option disabled>"First select a grade"</option> }].into_iter().collect_view()
                                        } else {
                                            let filtered = filtered_teachers();
                                            if filtered.is_empty() {
                                                vec![view! { <option disabled>"No teachers available for this grade"</option> }].into_iter().collect_view()
                                            } else {
                                                filtered.iter().map(|teacher| view! {
                                                    <option value=teacher.lastname.clone()>{teacher.lastname.clone()}</option>
                                                }).collect_view()
                                            }
                                        }
                                    }}
                                </select>
                            </div>
                        </div>
                    </div>

                    // Support Services Section
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Support Services"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_iep(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"IEP"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_bip(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"BIP"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_504(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"504"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_yes_no_esl(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"ESL"</span>
                                </label>
                                <Show when=move || yes_no_esl()>
                                    <select class="p-3 rounded-lg mt-2 w-full"
                                        required
                                        value=new_esl
                                        on:change=move |event| {
                                            set_new_esl(event_target_value(&event))
                                        }
                                    >
                                        <option value="">"Please Select"</option>
                                        {ESLEnum::iter().map(|lang| view! {
                                            <option value=format!("{}", lang)>
                                                {format!("{}", lang)}
                                            </option>
                                        }).collect::<Vec<_>>()}
                                    </select>
                                </Show>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_readplan(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"Read Plan"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_gt(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"GT Status"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <select
                                        class="mt-1 w-full rounded-md border p-2"
                                        required
                                        id="intervention"
                                        on:change=move |event| set_new_intervention(event_target_value(&event))
                                    >
                                        <option value="">"Please Select"</option>
                                        <option value="None">"None"</option>
                                        {InterventionEnum::iter().map(|int| view! {
                                            <option value=format!("{}", int)>
                                                {format!("{}", int)}
                                            </option>
                                        }).collect::<Vec<_>>()}
                                    </select>
                                    <span class=INFO_TITLE_STYLE>"Intervention"</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    //Additional Services
                    <div class="col-span-2">
                        <h3 class="text-sm font-semibold text-gray-600 mb-2">"Additional Services"</h3>
                        <div class="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-lg">
                            <div class=INFO_GROUP_STYLE>
                                <label class="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        class="form-checkbox h-5 w-5"
                                        on:change=move |ev| set_new_eye_glasses(event_target_checked(&ev))
                                    />
                                    <span class=INFO_TITLE_STYLE>"Glasses"</span>
                                </label>
                            </div>
                            <div class=INFO_GROUP_STYLE>
                                <label class=INFO_TITLE_STYLE for="notes">"Notes"</label>
                                <textarea
                                    id="notes"
                                    class="mt-1 w-full rounded-md border p-2 h-32"
                                    on:input=move |ev| set_new_notes(event_target_value(&ev))
                                    placeholder="Enter any additional notes about the student..."
                                />
                            </div>
                        </div>
                    </div>
                </div>
                <div class=BUTTON_CONTAINER_STYLE>
                    <button
                        type="button"
                        class="px-4 py-2 bg-gray-200 rounded-lg font-bold hover:bg-gray-300"
                        on:click=move |_| set_adding_student(false)
                    >
                        "Cancel"
                    </button>
                    <button
                        type="submit"
                        class="px-4 py-2 bg-green-500 text-white font-bold rounded-lg hover:bg-[#A8DCAB]"
                    >
                        "Save Student"
                    </button>
                </div>
            </form>
        </div>
    }
}
use leptos::html;
use leptos::prelude::*;

// More responsive container style with padding adjustments for small screens
const SEARCH_CONTAINER_STYLE: &str =
    "md:mt-16 mt-14 mb-4 flex flex-grow gap-2 items-center w-full justify-between";
// Improved input style with better handling for small screens
const INPUT_STYLE: &str = "focus:ring-indigo-500 focus:border-indigo-500 block w-full pl-3 pr-3 text-xs sm:text-sm border-gray-300 rounded-md h-8 sm:h-10 border";
// Responsive select style
const SELECT_STYLE: &str = "mt-1 block w-full pl-2 pr-6 sm:pl-3 sm:pr-10 py-1 sm:py-2 text-xs sm:text-sm bg-white shadow-sm border-gray-200 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 rounded-md h-8 sm:h-10 border transition-all";
const CHECKBOX_STYLE: &str =
    "form-checkbox mr-1 sm:mr-2 h-3 w-3 sm:h-4 sm:w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded";
const LABEL_STYLE: &str = "block text-xs sm:text-sm font-medium text-gray-700 mb-1";
const CHECKBOX_CONTAINER_STYLE: &str = "flex items-center mt-3 sm:mt-6";

// Extra filters container for expanded view
const EXPANDED_FILTERS_STYLE: &str = "w-full flex flex-wrap gap-2 sm:gap-4 mt-2 pb-2";

#[derive(Clone)]
pub struct FilterState {
    pub search_term: String,
    pub grade_filter: String,
    pub iep_filter: bool,
    pub esl_filter: bool,
    pub teacher_filter: String,
    pub intervention_filter: String,
    pub student_504_filter: bool,
    pub readplan_filter: bool,
    pub gt_filter: bool,
    pub bip_filter: bool,
}

#[component]
pub fn SearchFilter(
    #[prop(into)] set_search_term: Callback<String>,
    #[prop(into)] set_grade_filter: Callback<String>,
    #[prop(into)] set_teacher_filter: Callback<String>,
    #[prop(into)] set_iep_filter: Callback<bool>,
    #[prop(into)] set_esl_filter: Callback<bool>,
    #[prop(into)] set_intervention_filter: Callback<String>,
    #[prop(into)] set_student_504_filter: Callback<bool>,
    #[prop(into)] set_readplan_filter: Callback<bool>,
    #[prop(into)] set_gt_filter: Callback<bool>,
    #[prop(into)] set_bip_filter: Callback<bool>,
    #[prop(into)] teachers: Signal<Vec<String>>,
    #[prop(into)] search_term: Signal<String>,
    #[prop(into)] on_clear_filters: Callback<()>,
    #[prop(into)] is_panel_expanded: Signal<bool>,
) -> impl IntoView {
    let iep_checkbox_ref = create_node_ref::<html::Input>();
    let esl_checkbox_ref = create_node_ref::<html::Input>();
    let student_504_checkbox_ref = create_node_ref::<html::Input>();
    let readplan_checkbox_ref = create_node_ref::<html::Input>();
    let gt_checkbox_ref = create_node_ref::<html::Input>();
    let bip_checkbox_ref = create_node_ref::<html::Input>();
    let intervention_filter_ref = create_node_ref::<html::Select>();
    let grade_filter_ref = create_node_ref::<html::Select>();
    let teacher_filter_ref = create_node_ref::<html::Select>();

    view! {
        <div class=SEARCH_CONTAINER_STYLE>
            // Search input - adjusted to be less wide
            <div class="flex-grow sm:w-72 md:w-72">
                <label for="search" class=LABEL_STYLE>"Search Students"</label>
                <div class="relative rounded-md shadow-sm">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <span class="text-gray-500 sm:text-sm">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </div>
                    <input
                        type="text"
                        name="search"
                        id="search"
                        class="focus:ring-indigo-500 focus:border-indigo-500 block w-full pl-10 pr-10 text-xs sm:text-sm border-gray-300 rounded-md h-8 sm:h-10 border"
                        placeholder="Search students..."
                        prop:value={move || search_term.get()}
                        on:input=move |ev| set_search_term(event_target_value(&ev))
                    />
                </div>
            </div>

            // Grade filter dropdown - optimized width
            <div class="flex-grow sm:w-36 md:w-36">
                <label for="grade-filter" class=LABEL_STYLE>"Grade"</label>
                <select
                    id="grade-filter"
                    class=SELECT_STYLE
                    on:change=move |ev| set_grade_filter(event_target_value(&ev))
                    node_ref=grade_filter_ref
                >
                    <option value="all">"All Grades"</option>
                    <option value="Kindergarten">"K"</option>
                    <option value="1st Grade">"1st"</option>
                    <option value="2nd Grade">"2nd"</option>
                    <option value="3rd Grade">"3rd"</option>
                    <option value="4th Grade">"4th"</option>
                    <option value="5th Grade">"5th"</option>
                    <option value="6th Grade">"6th"</option>
                    <option value="7th Grade">"7th"</option>
                    <option value="8th Grade">"8th"</option>
                    <option value="9th Grade">"9th"</option>
                    <option value="10th Grade">"10th"</option>
                    <option value="11th Grade">"11th"</option>
                    <option value="12th Grade">"12th"</option>
                </select>
            </div>

            // Teacher filter dropdown - optimized width
            <div class="flex-grow sm:w-36 md:w-36">
                <label for="teacher-filter" class=LABEL_STYLE>"Teacher"</label>
                <select
                    id="teacher-filter"
                    class=SELECT_STYLE
                    on:change=move |ev| set_teacher_filter(event_target_value(&ev))
                    node_ref=teacher_filter_ref
                >
                    <option value="all">"All Teachers"</option>
                    {move || {
                        let teacher_list = teachers.get();
                        log::info!("Rendering teacher dropdown with {} teachers", teacher_list.len());

                        teacher_list.into_iter().map(|teacher| {
                            view! {
                                <option value={teacher.clone()}>{teacher}</option>
                            }
                        }).collect_view()
                    }}
                </select>
            </div>

            // Intervention filter - optimized width
            <div class="flex-grow sm:w-36 md:w-36">
                <label for="intervention-filter" class=LABEL_STYLE>"Intervention"</label>
                <select
                    id="intervention-filter"
                    class=SELECT_STYLE
                    on:change=move |ev| set_intervention_filter(event_target_value(&ev))
                    node_ref=intervention_filter_ref
                >
                    <option value="all">""</option>
                    <option value="Literacy">"Literacy"</option>
                    <option value="Math">"Math"</option>
                    <option value="Literacy and Math">"Literacy and Math"</option>
                    <option value="None">"Exclude Intervention"</option>
                </select>
            </div>

            // Always render all checkboxes but use CSS to control visibility
            <div class="flex flex-grow items-center gap-3 mt-4 ml-2">
                // IEP filter checkbox
                <div class="flex items-center mr-2">
                    <input
                        type="checkbox"
                        id="iep-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_iep_filter(event_target_checked(&ev))
                        node_ref=iep_checkbox_ref
                    />
                    <label for="iep-filter" class="text-xs sm:text-sm text-gray-700">"IEP"</label>
                </div>

                // ESL filter checkbox
                <div class="flex items-center mr-2">
                    <input
                        type="checkbox"
                        id="esl-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_esl_filter(event_target_checked(&ev))
                        node_ref=esl_checkbox_ref
                    />
                    <label for="esl-filter" class="text-xs sm:text-sm text-gray-700">"ESL"</label>
                </div>

                // 504 Plan filter - moved to main row
                <div class="flex items-center mr-2">
                    <input
                        type="checkbox"
                        id="504-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_student_504_filter(event_target_checked(&ev))
                        node_ref=student_504_checkbox_ref
                    />
                    <label for="504-filter" class="text-xs sm:text-sm text-gray-700">"504"</label>
                </div>

                // Always render these but use conditional styling instead of conditional rendering
                <div class=move || {
                    if is_panel_expanded.get() {
                        "hidden".to_string()
                    } else {
                        "flex items-center mr-2".to_string()
                    }
                }>
                    <input
                        type="checkbox"
                        id="readplan-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_readplan_filter(event_target_checked(&ev))
                        node_ref=readplan_checkbox_ref
                    />
                    <label for="readplan-filter" class="text-xs sm:text-sm text-gray-700">"Read Plan"</label>
                </div>

                <div class=move || {
                    if is_panel_expanded.get() {
                        "hidden".to_string()
                    } else {
                        "flex items-center mr-2".to_string()
                    }
                }>
                    <input
                        type="checkbox"
                        id="gt-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_gt_filter(event_target_checked(&ev))
                        node_ref=gt_checkbox_ref
                    />
                    <label for="gt-filter" class="text-xs sm:text-sm text-gray-700">"GT"</label>
                </div>

                <div class=move || {
                    if is_panel_expanded.get() {
                        "hidden".to_string()
                    } else {
                        "flex items-center mr-2".to_string()
                    }
                }>
                    <input
                        type="checkbox"
                        id="bip-filter"
                        class=CHECKBOX_STYLE
                        on:change=move |ev| set_bip_filter(event_target_checked(&ev))
                        node_ref=bip_checkbox_ref
                    />
                    <label for="bip-filter" class="text-xs sm:text-sm text-gray-700">"BEH"</label>
                </div>
            </div>

            // Clear filters button
            <div class="flex items-center mt-3 flex-shrink-0">
                <button
                    type="button"
                    class="inline-flex justify-center items-center px-3 sm:px-4 py-1 sm:py-2 border border-gray-300 rounded-md shadow-sm text-xs sm:text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 h-8 sm:h-10 transition-none whitespace-nowrap"
                    on:click=move |_| {
                        if let Some(input) = iep_checkbox_ref.get() {
                            input.set_checked(false);
                        }
                        if let Some(input) = esl_checkbox_ref.get() {
                            input.set_checked(false);
                        }
                        if let Some(input) = intervention_filter_ref.get() {
                            input.set_value("all");
                        }
                        if let Some(select) = grade_filter_ref.get() {
                            select.set_value("all");
                        }
                        if let Some(select) = teacher_filter_ref.get() {
                            select.set_value("all");
                        }
                        // Clear the new checkbox filters too
                        if let Some(input) = student_504_checkbox_ref.get() {
                            input.set_checked(false);
                        }
                        if let Some(input) = readplan_checkbox_ref.get() {
                            input.set_checked(false);
                        }
                        if let Some(input) = gt_checkbox_ref.get() {
                            input.set_checked(false);
                        }
                        if let Some(input) = bip_checkbox_ref.get() {
                            input.set_checked(false);
                        }

                        on_clear_filters.call(());
                    }
                >
                    "Clear Filters"
                </button>
            </div>
        </div>
    }
}
use crate::app::components::auth::authorization_components::perform_post_login_redirect;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::auth::login;
use leptos::prelude::*;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[cfg(feature = "hydrate")]
use wasm_bindgen::{closure::Closure, JsCast};

#[derive(Debug, Clone)]
pub struct StudentMappingService {
    app_id_to_original: HashMap<i32, StudentMapping>,
    original_to_app_id: HashMap<i32, StudentMapping>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StudentMapping {
    pub app_id: i32,
    pub original_student_id: i32,
    pub firstname: String,
    pub lastname: String,
    pub pin: String,
    pub created_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StudentMappingData {
    pub mappings: Vec<StudentMapping>,
}

impl StudentMappingService {
    pub fn new(mappings: Vec<StudentMapping>) -> Self {
        let mut app_id_to_original = HashMap::new();
        let mut original_to_app_id = HashMap::new();

        for mapping in mappings {
            app_id_to_original.insert(mapping.app_id, mapping.clone());
            original_to_app_id.insert(mapping.original_student_id, mapping);
        }

        Self {
            app_id_to_original,
            original_to_app_id,
        }
    }

    // Fix: Add missing method
    pub fn get_mapping_count(&self) -> usize {
        self.app_id_to_original.len()
    }

    // De-anonymize: Convert app_id back to original student info
    pub fn de_anonymize_student_id(&self, app_id: i32) -> Option<i32> {
        self.app_id_to_original
            .get(&app_id)
            .map(|m| m.original_student_id)
    }

    // Get full student info for de-anonymization
    pub fn get_original_student_info(&self, app_id: i32) -> Option<&StudentMapping> {
        self.app_id_to_original.get(&app_id)
    }

    // Anonymize: Convert original student_id to app_id (if needed)
    pub fn anonymize_student_id(&self, original_student_id: i32) -> Option<i32> {
        self.original_to_app_id
            .get(&original_student_id)
            .map(|m| m.app_id)
    }

    pub fn get_app_id_info(&self, original_student_id: i32) -> Option<&StudentMapping> {
        self.original_to_app_id.get(&original_student_id)
    }

    pub fn has_mapping_for_app_id(&self, app_id: i32) -> bool {
        self.app_id_to_original.contains_key(&app_id)
    }

    // Batch de-anonymization for performance
    pub fn de_anonymize_batch(&self, app_ids: &[i32]) -> HashMap<i32, StudentMapping> {
        app_ids
            .iter()
            .filter_map(|&app_id| {
                self.app_id_to_original
                    .get(&app_id)
                    .map(|mapping| (app_id, mapping.clone()))
            })
            .collect()
    }
}

// Add a context provider for the mapping service
pub fn provide_student_mapping_service() -> (
    ReadSignal<Option<StudentMappingService>>,
    WriteSignal<Option<StudentMappingService>>,
) {
    signal(None)
}

// Hook to use the mapping service
pub fn use_student_mapping_service() -> (
    ReadSignal<Option<StudentMappingService>>,
    WriteSignal<Option<StudentMappingService>>,
) {
    expect_context::<(
        ReadSignal<Option<StudentMappingService>>,
        WriteSignal<Option<StudentMappingService>>,
    )>()
    .expect("StudentMappingService context not found. Make sure to provide it in your app.")
}

// Enhanced Student struct with de-anonymization support
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DeAnonymizedStudent {
    pub app_id: i32,
    pub original_student_id: Option<i32>,
    pub display_name: String,
    pub display_id: String,
}

impl DeAnonymizedStudent {
    pub fn from_student_with_mapping(
        student: &crate::app::models::student::Student,
        mapping_service: Option<&StudentMappingService>,
    ) -> Self {
        if let Some(service) = mapping_service {
            if let Some(mapping) = service.get_original_student_info(student.student_id) {
                return Self {
                    app_id: student.student_id,
                    original_student_id: Some(mapping.original_student_id),
                    display_name: format!("{} {}", mapping.firstname, mapping.lastname),
                    display_id: mapping.original_student_id.to_string(),
                };
            }
        }

        // Fallback to anonymized display
        Self {
            app_id: student.student_id,
            original_student_id: None,
            display_name: format!(
                "{} {}",
                student.firstname.as_deref().unwrap_or("Student"),
                student
                    .lastname
                    .as_deref()
                    .unwrap_or(&format!("#{}", student.student_id))
            ),
            display_id: student.student_id.to_string(),
        }
    }
}

// Updated login form component
#[component]
pub fn EnhancedLoginForm() -> impl IntoView {
    let (username, set_username) = signal("".to_string());
    let (password, set_password) = signal("".to_string());
    let (error, set_error) = create_signal::<Option<String>>(None);
    let (student_mapping_file, set_student_mapping_file) = create_signal::<Option<String>>(None);
    let (file_upload_status, set_file_upload_status) = create_signal::<Option<String>>(None);
    let (is_submitting, set_is_submitting) = signal(false);

    let set_current_user = expect_context::<WriteSignal<Option<SessionUser>>>().unwrap();
    let redirect_after_login = perform_post_login_redirect();

    // Get the mapping service context
    let (_, set_student_mapping_service) = use_student_mapping_service();

    // Get settings to check if anonymization is enabled
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    let parse_csv_content = move |content: String| -> Result<StudentMappingData, String> {
        let lines: Vec<&str> = content.lines().collect();

        if lines.is_empty() {
            return Err("Empty file".to_string());
        }

        if lines.len() < 2 {
            return Err("File must contain header and at least one data row".to_string());
        }

        let header = lines[0];
        let expected_headers = [
            "app_id",
            "original_student_id",
            "firstname",
            "lastname",
            "pin",
            "created_at",
        ];
        let actual_headers: Vec<&str> = header.split(',').map(|h| h.trim()).collect();

        if actual_headers.len() != expected_headers.len() {
            return Err(format!(
                "Invalid header format: expected {} columns, found {}",
                expected_headers.len(),
                actual_headers.len()
            ));
        }

        // Validate header names
        for (i, expected) in expected_headers.iter().enumerate() {
            if actual_headers.get(i).map(|h| h.to_lowercase()) != Some(expected.to_string()) {
                return Err(format!(
                    "Invalid header at position {}: expected '{}', found '{}'",
                    i + 1,
                    expected,
                    actual_headers.get(i).unwrap_or(&"missing")
                ));
            }
        }

        let data_lines = &lines[1..];
        let mut mappings = Vec::new();

        for (line_num, line) in data_lines.iter().enumerate() {
            if line.trim().is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split(',').collect();
            if parts.len() != 6 {
                return Err(format!(
                    "Invalid CSV format at line {}: expected 6 columns, found {}",
                    line_num + 2,
                    parts.len()
                ));
            }

            let app_id = parts[0]
                .trim()
                .parse::<i32>()
                .map_err(|_| format!("Invalid app_id at line {}: '{}'", line_num + 2, parts[0]))?;

            let original_student_id = parts[1].trim().parse::<i32>().map_err(|_| {
                format!(
                    "Invalid original_student_id at line {}: '{}'",
                    line_num + 2,
                    parts[1]
                )
            })?;

            // Validate that IDs are positive
            if app_id <= 0 || original_student_id <= 0 {
                return Err(format!(
                    "Invalid ID values at line {}: IDs must be positive integers",
                    line_num + 2
                ));
            }

            mappings.push(StudentMapping {
                app_id,
                original_student_id,
                firstname: parts[2].trim().to_string(),
                lastname: parts[3].trim().to_string(),
                pin: parts[4].trim().to_string(),
                created_at: parts[5].trim().to_string(),
            });
        }

        if mappings.is_empty() {
            return Err("No valid data rows found in CSV file".to_string());
        }

        // Check for duplicate app_ids or original_student_ids
        let mut seen_app_ids = std::collections::HashSet::new();
        let mut seen_original_ids = std::collections::HashSet::new();

        for mapping in &mappings {
            if !seen_app_ids.insert(mapping.app_id) {
                return Err(format!("Duplicate app_id found: {}", mapping.app_id));
            }
            if !seen_original_ids.insert(mapping.original_student_id) {
                return Err(format!(
                    "Duplicate original_student_id found: {}",
                    mapping.original_student_id
                ));
            }
        }

        Ok(StudentMappingData { mappings })
    };

    #[cfg(feature = "hydrate")]
    let handle_file_upload = move |ev: web_sys::Event| {
        let input = ev
            .target()
            .unwrap()
            .dyn_into::<web_sys::HtmlInputElement>()
            .unwrap();

        if let Some(files) = input.files() {
            if files.length() > 0 {
                let file = files.get(0).unwrap();

                // Validate file type
                if !file.name().ends_with(".csv") {
                    set_error.set(Some("Please select a CSV file".to_string()));
                    set_file_upload_status.set(Some("Invalid file type".to_string()));
                    return;
                }

                // Validate file size (e.g., max 10MB)
                if file.size() > 10_000_000.0 {
                    set_error.set(Some("File too large. Maximum size is 10MB".to_string()));
                    set_file_upload_status.set(Some("File too large".to_string()));
                    return;
                }

                let file_reader = web_sys::FileReader::new().unwrap();
                set_file_upload_status.set(Some("Loading file...".to_string()));
                set_error.set(None);

                let onload = Closure::wrap(Box::new({
                    let set_student_mapping_file = set_student_mapping_file.clone();
                    let set_error = set_error.clone();
                    let set_file_upload_status = set_file_upload_status.clone();
                    let parse_csv_content = parse_csv_content.clone();

                    move |event: web_sys::Event| {
                        let file_reader = event
                            .target()
                            .unwrap()
                            .dyn_into::<web_sys::FileReader>()
                            .unwrap();

                        if let Ok(result) = file_reader.result() {
                            if let Some(content) = result.as_string() {
                                match parse_csv_content(content.clone()) {
                                    Ok(mapping_data) => {
                                        set_student_mapping_file.set(Some(content));
                                        set_error.set(None);
                                        set_file_upload_status.set(Some(format!(
                                            "File loaded successfully ({} mappings)",
                                            mapping_data.mappings.len()
                                        )));
                                        log::info!(
                                            "Student mapping file loaded with {} mappings",
                                            mapping_data.mappings.len()
                                        );
                                    }
                                    Err(e) => {
                                        set_error.set(Some(format!("Invalid CSV format: {}", e)));
                                        set_file_upload_status
                                            .set(Some("Failed to load file".to_string()));
                                        set_student_mapping_file.set(None);
                                        log::info!("Invalid CSV in student mapping file: {}", e);
                                    }
                                }
                            }
                        } else {
                            set_error.set(Some("Failed to read file".to_string()));
                            set_file_upload_status.set(Some("Failed to read file".to_string()));
                        }
                    }
                }) as Box<dyn Fn(web_sys::Event)>);

                file_reader.set_onload(Some(onload.as_ref().unchecked_ref()));
                onload.forget();

                let _ = file_reader.read_as_text(&file);
            }
        } else {
            set_student_mapping_file.set(None);
            set_file_upload_status.set(None);
        }
    };
    #[cfg(not(feature = "hydrate"))]
    let handle_file_upload = move |_| {
        set_error.set(Some(
            "File upload is not supported in this environment".to_string(),
        ));
        set_file_upload_status.set(None);
    };

    let handle_submit = Action::new(move |_: &()| {
        let username = username.get();
        let password = password.get();
        let mapping_data_content = student_mapping_file.get();

        async move {
            set_is_submitting.set(true);

            if username.trim().is_empty() || password.trim().is_empty() {
                set_error.set(Some("Username and password are required".to_string()));
                set_is_submitting.set(false);
                return;
            }

            log::info!("Attempting login with username: {}", username);

            match login(username, password).await {
                Ok(response) => {
                    if response.success {
                        log::info!("Login successful, setting user");
                        set_current_user.set(response.user.clone());

                        // Set up mapping service only if a mapping file was provided
                        if let Some(data_content) = mapping_data_content {
                            match parse_csv_content(data_content) {
                                Ok(mapping_data) => {
                                    let mapping_service =
                                        StudentMappingService::new(mapping_data.mappings);
                                    let mapping_count = mapping_service.get_mapping_count();
                                    set_student_mapping_service.set(Some(mapping_service));
                                    log::info!(
                                        "Student mapping service initialized with {} mappings",
                                        mapping_count
                                    );
                                }
                                Err(e) => {
                                    log::info!("Failed to parse student mapping data: {}", e);
                                    set_error.set(Some(format!(
                                        "Failed to initialize mapping service: {}",
                                        e
                                    )));
                                    set_is_submitting.set(false);
                                    return;
                                }
                            }
                        } else {
                            set_student_mapping_service.set(None);
                            log::info!(
                                "No student mapping file provided - de-anonymization disabled"
                            );
                        }

                        set_error.set(None);

                        // Use the redirect function from AuthProvider
                        perform_post_login_redirect();
                    } else {
                        log::info!("Login failed: {}", response.message);
                        set_error.set(Some(response.message));
                    }
                }
                Err(err) => {
                    log::info!("Login error: {:?}", err);
                    set_error.set(Some(
                        "Login failed. Please check your credentials and try again.".to_string(),
                    ));
                }
            }

            set_is_submitting.set(false);
        }
    });

    view! {
        <div class="p-6 bg-white rounded-lg shadow-md max-w-md mx-auto">
            <h2 class="text-2xl font-bold mb-6 text-center text-gray-800">"Login"</h2>

            {move || {
                error.get().map(|err| {
                    view! {
                        <div class="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-md">
                            <div class="flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                                </svg>
                                {err}
                            </div>
                        </div>
                    }
                })
            }}

            <form on:submit=move |ev| {
                ev.prevent_default();
                if !is_submitting.get() {
                    handle_submit.dispatch(());
                }
            }>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-medium mb-2" for="username">
                        "Username"
                    </label>
                    <input
                        id="username"
                        type="text"
                        class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        prop:value=move || username.get()
                        on:input=move |ev| set_username.set(event_target_value(&ev))
                        prop:disabled=move || is_submitting.get()
                        placeholder="Enter your username"
                    />
                </div>

                <div class="mb-6">
                    <label class="block text-gray-700 text-sm font-medium mb-2" for="password">
                        "Password"
                    </label>
                    <input
                        id="password"
                        type="password"
                        class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        prop:value=move || password.get()
                        on:input=move |ev| set_password.set(event_target_value(&ev))
                        prop:disabled=move || is_submitting.get()
                        placeholder="Enter your password"
                    />
                </div>

                {move || {
                    if anonymization_enabled() {
                        view! {
                            <div class="mb-6">
                                <label class="block text-gray-700 text-sm font-medium mb-2" for="student-mapping">
                                    "Student ID Mapping File"
                                    <span class="text-sm text-gray-500 font-normal">" (Optional)"</span>
                                </label>
                                <input
                                    id="student-mapping"
                                    type="file"
                                    accept=".csv"
                                    class="w-full p-2 border border-gray-300 rounded-md file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                    on:change=handle_file_upload
                                    prop:disabled=move || is_submitting.get()
                                />
                                <p class="text-sm text-gray-600 mt-2">
                                    "Upload a CSV file containing student ID mappings for de-anonymization."
                                </p>
                                {move || {
                                    if let Some(status) = file_upload_status.get() {
                                        if status.contains("successfully") {
                                            view! {
                                                <div class="flex items-center mt-2 text-sm text-green-600">
                                                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                                                    </svg>
                                                    {status}" - De-anonymization enabled"
                                                </div>
                                            }.into_any()
                                        } else {
                                            view! {
                                                <p class="text-sm text-blue-600 mt-2">{status}</p>
                                            }.into_any()
                                        }
                                    } else {
                                        view! { <span></span> }.into_any()
                                    }
                                }}
                            </div>
                        }.into_any()
                    } else {
                        view! { <span></span> }.into_any()
                    }
                }}

                <button
                    type="submit"
                    class="w-full p-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors duration-200"
                    prop:disabled=move || is_submitting.get()
                >
                    {move || {
                        if is_submitting.get() {
                            view! {
                                <div class="flex items-center justify-center">
                                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    "Logging in..."
                                </div>
                            }.into_any()
                        } else {
                            view! { "Login" }.into_any()
                        }
                    }}
                </button>
            </form>

            {move || {
                if anonymization_enabled() {
                    view! {
                        <div class="mt-6 p-4 bg-gray-50 rounded-md">
                            <h3 class="text-sm font-semibold text-gray-700 mb-2">
                                "CSV Format Requirements:"
                            </h3>
                            <p class="text-xs text-gray-600 mb-2">
                                "For de-anonymization, upload a CSV file with this exact format:"
                            </p>
                            <div class="bg-gray-800 text-gray-100 p-3 rounded text-xs font-mono overflow-x-auto">
                                <pre>{"app_id,original_student_id,firstname,lastname,pin,created_at\n100000,12345,John,Doe,1234,2025-06-09 19:52:19.862183\n100001,52884,Thien,Le,1234,2025-06-09 19:52:19.862183"}</pre>
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                "Without this file, students will be displayed with anonymized IDs."
                            </p>
                        </div>
                    }.into_any()
                } else {
                    view! { <span></span> }.into_any()
                }
            }}
        </div>
    }
}
use crate::app::models::user::SessionUser;
use crate::app::server_functions::auth::get_current_user;
use leptos::prelude::*;
use leptos_router::hooks::{use_location, use_navigate};
use log::debug;

#[component]
pub fn AuthProvider(children: Children) -> impl IntoView {
    let (current_user, set_current_user) = signal::<Option<SessionUser>>(None);
    let (loading, set_loading) = signal(true);
    let (initialized, set_initialized) = signal(false);
    let (redirect_after_auth, set_redirect_after_auth) = signal::<Option<String>>(None);

    // Use LocalResource for client-side resource loading
    let user_resource = LocalResource::new(
        move || initialized.get(),
        move |_| async move {
            if initialized.get() {
                debug!("AuthProvider: Loading user");
                get_current_user().await
            } else {
                Ok(None)
            }
        },
    );

    // Initialize auth on client side only
    Effect::new(move |_| {
        if !initialized.get_untracked() {
            set_initialized.set(true);

            // Store current path for post-login redirect
            let location = use_location();
            let current_path = location.pathname.get_untracked();
            if !is_auth_page(&current_path) {
                set_redirect_after_auth.set(Some(current_path));
            }
        }
    });

    // Track resource state
    Effect::new(move |_| {
        match user_resource.get() {
            Some(Ok(user)) => {
                debug!("AuthProvider: User loaded: {:?}", user.is_some());
                set_current_user.set(user);
                set_loading.set(false);
            }
            Some(Err(err)) => {
                debug!("AuthProvider: Error loading user: {:?}", err);
                set_current_user.set(None);
                set_loading.set(false);
            }
            None => {
                // Still loading
                if initialized.get() {
                    set_loading.set(true);
                }
            }
        }
    });

    // Provide context
    provide_context(current_user);
    provide_context(set_current_user);
    provide_context(loading);
    provide_context(redirect_after_auth);
    provide_context(set_redirect_after_auth);

    children()
}

#[component]
pub fn RequireAuth(children: Children) -> impl IntoView {
    let current_user = expect_context::<ReadSignal<Option<SessionUser>>>();
    let loading = expect_context::<ReadSignal<bool>>();
    let set_redirect_after_auth = expect_context::<WriteSignal<Option<String>>>();

    let navigate = use_navigate();
    let location = use_location();
    let rendered_children = store_value(children());

    // Handle redirect when not authenticated
    Effect::new(move |_| {
        let is_loading = loading.get();
        let user = current_user.get();

        debug!(
            "RequireAuth: loading={}, user={:?}",
            is_loading,
            user.is_some()
        );

        if !is_loading && user.is_none() {
            let current_path = location.pathname.get_untracked();
            if !is_auth_page(&current_path) {
                set_redirect_after_auth.set(Some(current_path));
            }
            debug!("RequireAuth: No user found, redirecting to login");
            navigate("/login", Default::default());
        }
    });

    // Use Suspense to handle loading states properly
    view! {
        <Suspense fallback=move || loading_view()>
            {move || {
                let is_loading = loading.get();
                let user = current_user.get();

                if is_loading {
                    debug!("RequireAuth: Showing loading view");
                    loading_view().into_any()
                } else if user.is_some() {
                    debug!("RequireAuth: User authenticated, showing content");
                    rendered_children.get_value().into_any()
                } else {
                    debug!("RequireAuth: No user, showing redirect view");
                    redirect_view().into_any()
                }
            }}
        </Suspense>
    }
}

#[component]
pub fn RequireRole(
    #[prop(default = "user".to_string())] role: String,
    children: Children,
) -> impl IntoView {
    let current_user = expect_context::<ReadSignal<Option<SessionUser>>>();
    let loading = expect_context::<ReadSignal<bool>>();
    let set_redirect_after_auth = expect_context::<WriteSignal<Option<String>>>();

    let navigate = use_navigate();
    let location = use_location();
    let rendered_children = store_value(children());
    let role_stored = store_value(role);

    Effect::new(move |_| {
        let is_loading = loading.get();
        let user = current_user.get();
        let role = role_stored.get_value();

        debug!(
            "RequireRole: loading={}, user={:?}, required_role={}",
            is_loading,
            user.is_some(),
            role
        );

        if !is_loading {
            match user {
                Some(user) => {
                    if !user_has_role(&user, &role) {
                        debug!("RequireRole: User lacks required role: {}", role);
                        navigate("/", Default::default());
                    }
                }
                None => {
                    let current_path = location.pathname.get_untracked();
                    if !is_auth_page(&current_path) {
                        set_redirect_after_auth.set(Some(current_path));
                    }
                    debug!("RequireRole: No user found, redirecting to login");
                    navigate("/login", Default::default());
                }
            }
        }
    });

    view! {
        <Suspense fallback=move || loading_view()>
            {move || {
                let is_loading = loading.get();
                let user = current_user.get();
                let role = role_stored.get_value();

                if is_loading {
                    debug!("RequireRole: Showing loading view");
                    loading_view().into_any()
                } else if let Some(user) = user {
                    if user_has_role(&user, &role) {
                        debug!("RequireRole: User has required role, showing content");
                        rendered_children.get_value().into_any()
                    } else {
                        debug!("RequireRole: User lacks required role, showing unauthorized view");
                        unauthorized_view().into_any()
                    }
                } else {
                    debug!("RequireRole: No user, showing redirect view");
                    redirect_view().into_any()
                }
            }}
        </Suspense>
    }
}

#[component]
pub fn RequireAnyRole(roles: Vec<String>, children: Children) -> impl IntoView {
    let current_user = expect_context::<ReadSignal<Option<SessionUser>>>();
    let loading = expect_context::<ReadSignal<bool>>();
    let set_redirect_after_auth = expect_context::<WriteSignal<Option<String>>>();

    let navigate = use_navigate();
    let location = use_location();
    let rendered_children = store_value(children());
    let roles_stored = store_value(roles);

    Effect::new(move |_| {
        let is_loading = loading.get();
        let user = current_user.get();
        let roles = roles_stored.get_value();

        if !is_loading {
            match user {
                Some(user) => {
                    if !user_has_any_role(&user, &roles) {
                        debug!("RequireAnyRole: User lacks required roles: {:?}", roles);
                        navigate("/", Default::default());
                    }
                }
                None => {
                    let current_path = location.pathname.get_untracked();
                    if !is_auth_page(&current_path) {
                        set_redirect_after_auth.set(Some(current_path));
                    }
                    debug!("RequireAnyRole: No user found, redirecting to login");
                    navigate("/login", Default::default());
                }
            }
        }
    });

    view! {
        <Suspense fallback=move || loading_view()>
            {move || {
                let is_loading = loading.get();
                let user = current_user.get();
                let roles = roles_stored.get_value();

                if is_loading {
                    loading_view().into_any()
                } else if let Some(user) = user {
                    if user_has_any_role(&user, &roles) {
                        rendered_children.get_value().into_any()
                    } else {
                        unauthorized_view().into_any()
                    }
                } else {
                    redirect_view().into_any()
                }
            }}
        </Suspense>
    }
}

#[component]
pub fn RequireAdminOrTeacher(children: Children) -> impl IntoView {
    view! {
        <RequireAnyRole roles=vec!["admin".to_string(), "teacher".to_string()]>
            {children()}
        </RequireAnyRole>
    }
}

// Utility functions
fn is_auth_page(path: &str) -> bool {
    path.starts_with("/login")
        || path.starts_with("/register")
        || path.starts_with("/forgot-password")
        || path.starts_with("/reset-password")
}

fn user_has_role(user: &SessionUser, required_role: &str) -> bool {
    match required_role {
        "admin" => user.is_admin(),
        "teacher" => user.is_teacher(),
        "user" => user.is_user(),
        "guest" => user.is_guest(),
        _ => true,
    }
}

fn user_has_any_role(user: &SessionUser, required_roles: &[String]) -> bool {
    required_roles.iter().any(|role| user_has_role(user, role))
}

// Reusable view components
fn loading_view() -> impl IntoView {
    view! {
        <div class="flex items-center justify-center min-h-screen">
            <div class="flex items-center space-x-2">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                <span class="text-lg text-gray-600">Loading...</span>
            </div>
        </div>
    }
}

fn redirect_view() -> impl IntoView {
    view! {
        <div class="flex items-center justify-center min-h-screen">
            <div class="text-lg text-gray-600">Redirecting to login...</div>
        </div>
    }
}

fn unauthorized_view() -> impl IntoView {
    view! {
        <div class="flex items-center justify-center min-h-screen">
            <div class="text-center">
                <h1 class="text-2xl font-bold text-red-600 mb-2">Unauthorized</h1>
                <p class="text-gray-600">"You don't have permission to access this page."</p>
                <a href="/" class="mt-4 inline-block text-blue-600 hover:underline">
                    Return to Dashboard
                </a>
            </div>
        </div>
    }
}

// Post-login redirect function
pub fn perform_post_login_redirect() {
    let redirect_after_auth = expect_context::<ReadSignal<Option<String>>>();
    let set_redirect_after_auth = expect_context::<WriteSignal<Option<String>>>();
    let navigate = use_navigate();

    if let Some(redirect_path) = redirect_after_auth.get_untracked() {
        set_redirect_after_auth.set(None);
        navigate(&redirect_path, Default::default());
    } else {
        navigate("/dashboard", Default::default());
    }
}

// Auth hooks for components that need user data
pub fn use_current_user() -> ReadSignal<Option<SessionUser>> {
    expect_context::<ReadSignal<Option<SessionUser>>>()
}

pub fn use_auth_loading() -> ReadSignal<bool> {
    expect_context::<ReadSignal<bool>>()
}

pub fn use_set_current_user() -> WriteSignal<Option<SessionUser>> {
    expect_context::<WriteSignal<Option<SessionUser>>>()
}
use leptos::prelude::*;
use crate::app::server_functions::auth::{get_current_user, login, logout, register};
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;
use log::{debug, error, log};
use serde::Serialize;
#[cfg(feature = "ssr")]
use {
    lettre::transport::smtp::authentication::Credentials,
    lettre::{message::Message, SmtpTransport, Transport},
};

#[derive(Serialize)]
struct EmailContext {
    reset_link: String,
    // Add more fields as needed for your template
}

#[cfg(feature = "ssr")]
pub async fn send_reset_email(email: &str, reset_token: &str) -> Result<(), String> {
    use reqwest::Client;
    use serde_json::{json, Value};

    // Configuration - in production these should come from environment variables
    let sendgrid_api_key = std::env::var("SENDGRID_API_KEY")
        .map_err(|_| "SENDGRID_API_KEY environment variable not set".to_string())?;
    let app_url = std::env::var("APP_URL").unwrap_or_else(|_| "https://yourapp.com".to_string());
    let from_email =
        std::env::var("FROM_EMAIL").unwrap_or_else(|_| "noreply@yourapp.com".to_string());

    // Determine whether to use sandbox mode based on environment
    let is_development =
        std::env::var("APP_ENV").unwrap_or_else(|_| "development".to_string()) != "production";

    // Create the reset link
    let reset_link = format!("{}/reset-password/{}", app_url, reset_token);

    // Build the SendGrid API request payload
    let mut payload = json!({
        "personalizations": [{
            "to": [{ "email": email }]
        }],
        "from": { "email": from_email },
        "subject": "Password Reset Instructions",
        "content": [{
            "type": "text/plain",
            "value": format!(
                "Click the link below to reset your password:\n\n{}\n\nThis link will expire in 24 hours.",
                reset_link
            )
        }]
    });

    // Only enable sandbox mode for development environment
    if is_development {
        // Add sandbox mode setting for development
        if let Some(payload_obj) = payload.as_object_mut() {
            payload_obj.insert(
                "mail_settings".to_string(),
                json!({
                    "sandbox_mode": {
                        "enable": true
                    }
                }),
            );
            log::info!("Sending password reset email to {} (sandbox mode)", email);
        }
    } else {
        log::info!(
            "Sending password reset email to {} (production mode)",
            email
        );
    }

    // Send the request to SendGrid API
    let client = Client::new();
    let res = client
        .post("https://api.sendgrid.com/v3/mail/send")
        .header("Authorization", format!("Bearer {}", sendgrid_api_key))
        .header("Content-Type", "application/json")
        .json(&payload)
        .send()
        .await
        .map_err(|e| format!("Failed to send request to SendGrid= {}", e))?;

    // Check the response
    if res.status().is_success() {
        if is_development {
            log::info!(
                "Password reset email sent successfully to {} (sandbox mode)",
                email
            );
        } else {
            log::info!("Password reset email sent successfully to {}", email);
        }
        Ok(())
    } else {
        let status = res.status();
        let body = res
            .text()
            .await
            .unwrap_or_else(|_| "No response body".to_string());
        error!("Failed to send email. Status: {}, Body: {}", status, body);
        Err(format!("Failed to send email. Status: {}", status))
    }
}
use crate::app::server_functions::authorization::{check_page_authorization, AuthorizationCheck};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::hooks::{use_location, use_navigate};
use log::debug;

#[component]
pub fn ServerAuthGuard(#[prop(into)] page_path: String, children: Children) -> impl IntoView {
    let navigate = use_navigate();
    let location = use_location();

    // Store children to avoid FnOnce issue
    let stored_children = store_value(children());

    // Create resource that checks authorization on the server
    let auth_check = Resource::new(
        move || page_path.clone(),
        move |path| async move {
            debug!("ServerAuthGuard: Checking authorization for path: {}", path);
            check_page_authorization(path).await
        },
    );

    // Handle authorization result
    Effect::new(move |_| {
        if let Some(Ok(auth_result)) = auth_check.get() {
            debug!("ServerAuthGuard: Auth result: {:?}", auth_result.authorized);

            if !auth_result.authorized {
                if let Some(redirect_url) = auth_result.redirect_url {
                    debug!("ServerAuthGuard: Redirecting to: {}", redirect_url);
                    navigate(&redirect_url, Default::default());
                }
            }
        }
    });

    view! {
        <Suspense fallback=move || view! {
            <div class="flex items-center justify-center min-h-screen">
                <div class="flex items-center space-x-2">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                    <span class="text-lg text-gray-600">Verifying permissions...</span>
                </div>
            </div>
        }>
            {move || {
                match auth_check.get() {
                    Some(Ok(auth_result)) => {
                        if auth_result.authorized {
                            debug!("ServerAuthGuard: User authorized, showing content");
                            stored_children.get_value().into_any()
                        } else {
                            debug!("ServerAuthGuard: User not authorized, showing unauthorized");
                            view! {
                                <div class="flex items-center justify-center min-h-screen">
                                    <div class="text-center">
                                        <h1 class="text-2xl font-bold text-red-600 mb-2">Unauthorized</h1>
                                        <p class="text-gray-600">"You don't have permission to access this page."</p>
                                        <a href="/" class="mt-4 inline-block text-blue-600 hover:underline">
                                            Return to Home
                                        </a>
                                    </div>
                                </div>
                            }.into_any()
                        }
                    }
                    Some(Err(_)) => {
                        view! {
                            <div class="flex items-center justify-center min-h-screen">
                                <div class="text-center">
                                    <h1 class="text-2xl font-bold text-red-600 mb-2">Error</h1>
                                    <p class="text-gray-600">"Unable to verify permissions. Please try again."</p>
                                    <a href="/login" class="mt-4 inline-block text-blue-600 hover:underline">
                                        Go to Login
                                    </a>
                                </div>
                            </div>
                        }.into_any()
                    }
                    None => {
                        // Still loading, handled by Suspense fallback
                        view! { <div></div> }.into_any()
                    }
                }
            }}
        </Suspense>
    }
}

#[component]
pub fn RequireServerAuth(
    #[prop(into, optional)] required_role: Option<String>,
    #[prop(into, optional)] required_roles: Option<Vec<String>>,
    children: Children,
) -> impl IntoView {
    let navigate = use_navigate();

    // Store children to avoid FnOnce issue
    let stored_children = store_value(children());

    // Create resource that checks specific role requirements
    let auth_check = Resource::new(
        move || (required_role.clone(), required_roles.clone()),
        move |(role, roles)| async move {
            use crate::app::server_functions::authorization::check_authorization;
            debug!("RequireServerAuth: Checking role requirements");
            check_authorization(role, roles).await
        },
    );

    // Handle authorization result
    Effect::new(move |_| {
        if let Some(Ok(auth_result)) = auth_check.get() {
            if !auth_result.authorized {
                if let Some(redirect_url) = auth_result.redirect_url {
                    debug!("RequireServerAuth: Redirecting to: {}", redirect_url);
                    navigate(&redirect_url, Default::default());
                }
            }
        }
    });

    view! {
        <Suspense fallback=move || view! {
            <div class="flex items-center justify-center min-h-screen">
                <div class="flex items-center space-x-2">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                    <span class="text-lg text-gray-600">Verifying permissions...</span>
                </div>
            </div>
        }>
            {move || {
                match auth_check.get() {
                    Some(Ok(auth_result)) => {
                        if auth_result.authorized {
                            stored_children.get_value().into_any()
                        } else {
                            view! {
                                <div class="flex items-center justify-center min-h-screen">
                                    <div class="text-center">
                                        <h1 class="text-2xl font-bold text-red-600 mb-2">Unauthorized</h1>
                                        <p class="text-gray-600">"You don't have permission to access this page."</p>
                                        <a href="/" class="mt-4 inline-block text-blue-600 hover:underline">
                                            Return to Home
                                        </a>
                                    </div>
                                </div>
                            }.into_any()
                        }
                    }
                    Some(Err(_)) => {
                        view! {
                            <div class="flex items-center justify-center min-h-screen">
                                <div class="text-center">
                                    <h1 class="text-2xl font-bold text-red-600 mb-2">Error</h1>
                                    <p class="text-gray-600">"Unable to verify permissions."</p>
                                </div>
                            </div>
                        }.into_any()
                    }
                    None => view! { <div></div> }.into_any()
                }
            }}
        </Suspense>
    }
}
use crate::app::components::authorization_components::perform_post_login_redirect;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::auth::{get_current_user, login, logout, register};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;
use log::{debug, error, log};
use serde::Serialize;
#[cfg(feature = "ssr")]
use {
    lettre::transport::smtp::authentication::Credentials,
    lettre::{message::Message, SmtpTransport, Transport},
};

#[component]
pub fn LoginForm() -> impl IntoView {
    let (username, set_username) = signal("".to_string());
    let (password, set_password) = signal("".to_string());
    let (error, set_error) = create_signal::<Option<String>>(None);
    let set_current_user = expect_context::<WriteSignal<Option<SessionUser>>>().unwrap();

    let handle_submit = Action::new(move |_: &()| {
        let username = username.get();
        let password = password.get();

        async move {
            // Client-side validation for empty fields
            if username.trim().is_empty() || password.trim().is_empty() {
                set_error.set(Some("Username and password are required".to_string()));
                return;
            }

            // Debug log
            log::info!("Attempting login with username: {}", username);

            match login(username, password).await {
                Ok(response) => {
                    // Debug log the response
                    log::info!(
                        "Login response: success={}, message={}, user={:?}",
                        response.success,
                        response.message,
                        response.user
                    );

                    if response.success {
                        log::info!("Login successful, setting user");
                        set_current_user.set(response.user);
                        set_error.set(None);

                        // Use the simple redirect function
                        perform_post_login_redirect();
                    } else {
                        log::info!("Login failed: {}", response.message);
                        set_error.set(Some(response.message));
                    }
                }
                Err(err) => {
                    log::info!("Login error: {:?}", err);
                    set_error.set(Some(
                        "Login failed. Please check your credentials and try again.".to_string(),
                    ));
                }
            }
        }
    });

    view! {
        <div class="p-4 bg-white rounded shadow-md">
            <h2 class="text-2xl font-bold mb-4">"Login"</h2>

            {move || {
                error.get().map(|err| {
                    view! {
                        <div class="mb-4 p-2 bg-red-100 text-red-700 rounded">{err}</div>
                    }
                })
            }}

            <form on:submit=move |ev| {
                ev.prevent_default();
                handle_submit.dispatch(());
            }>
                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="username">"Username"</label>
                    <input
                        id="username"
                        type="text"
                        class="w-full p-2 border rounded"
                        prop:value=move || username.get()
                        on:input=move |ev| {
                            set_username.set(event_target_value(&ev));
                        }
                    />
                </div>

                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="password">"Password"</label>
                    <input
                        id="password"
                        type="password"
                        class="w-full p-2 border rounded"
                        prop:value=move || password.get()
                        on:input=move |ev| {
                            set_password.set(event_target_value(&ev));
                        }
                    />
                </div>

                <button
                    type="submit"
                    class="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    prop:disabled=move || handle_submit.pending().get()
                >
                    {move || {
                        if handle_submit.pending().get() {
                            "Logging in..."
                        } else {
                            "Login"
                        }
                    }}
                </button>
            </form>
        </div>
    }
}

#[component]
pub fn RegisterForm() -> impl IntoView {
    let (username, set_username) = signal("".to_string());
    let (email, set_email) = signal("".to_string());
    let (password, set_password) = signal("".to_string());
    let (confirm_password, set_confirm_password) = signal("".to_string());
    let (error, set_error) = create_signal::<Option<String>>(None);
    let set_current_user = expect_context::<WriteSignal<Option<SessionUser>>>().unwrap();

    let handle_submit = Action::new(move |_: &()| {
        let username = username.get();
        let email = email.get();
        let password = password.get();
        let confirm_password = confirm_password.get();

        async move {
            // Check passwords match first
            if password != confirm_password {
                set_error.set(Some("Passwords do not match".to_string()));
                return;
            }

            // Then proceed with registration
            match register(username, email, password).await {
                Ok(response) => {
                    if response.success {
                        set_current_user.set(response.user);
                        set_error.set(None);

                        // Use the simple redirect function
                        perform_post_login_redirect();
                    } else {
                        set_error.set(Some(response.message));
                    }
                }
                Err(_) => {
                    set_error.set(Some("An error occurred".to_string()));
                }
            }
        }
    });

    view! {
        <div class="p-4 bg-white rounded shadow-md">
            <h2 class="text-2xl font-bold mb-4">"Register"</h2>

            {move || {
                error.get().map(|err| {
                    view! {
                        <div class="mb-4 p-2 bg-red-100 text-red-700 rounded">{err}</div>
                    }
                })
            }}

            <form on:submit=move |ev| {
                ev.prevent_default();
                handle_submit.dispatch(());
            }>
                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="username">"Username"</label>
                    <input
                        id="username"
                        type="text"
                        class="w-full p-2 border rounded"
                        prop:value=move || username.get()
                        on:input=move |ev| {
                            set_username.set(event_target_value(&ev));
                        }
                    />
                </div>

                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="email">"Email"</label>
                    <input
                        id="email"
                        type="email"
                        class="w-full p-2 border rounded"
                        prop:value=move || email.get()
                        on:input=move |ev| {
                            set_email.set(event_target_value(&ev));
                        }
                    />
                </div>

                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="password">"Password"</label>
                    <input
                        id="password"
                        type="password"
                        class="w-full p-2 border rounded"
                        prop:value=move || password.get()
                        on:input=move |ev| {
                            set_password.set(event_target_value(&ev));
                        }
                    />
                </div>

                <div class="mb-4">
                    <label class="block text-gray-700 mb-2" for="confirm-password">"Confirm Password"</label>
                    <input
                        id="confirm-password"
                        type="password"
                        class="w-full p-2 border rounded"
                        prop:value=move || confirm_password.get()
                        on:input=move |ev| {
                            set_confirm_password.set(event_target_value(&ev));
                        }
                    />
                </div>

                <button
                    type="submit"
                    class="w-full p-2 bg-green-500 text-white rounded hover:bg-green-600"
                    prop:disabled=move || handle_submit.pending().get()
                >
                    {move || {
                        if handle_submit.pending().get() {
                            "Registering..."
                        } else {
                            "Register"
                        }
                    }}
                </button>
            </form>
        </div>
    }
}

#[component]
pub fn LogoutButton() -> impl IntoView {
    let set_current_user = expect_context::<WriteSignal<Option<SessionUser>>>().unwrap();

    let handle_logout = Action::new(move |_: &()| {
        async move {
            match logout().await {
                Ok(_) => {
                    set_current_user.set(None);
                }
                Err(_) => {
                    // Handle error
                }
            }
        }
    });

    view! {
        <button
            class="p-2 bg-red-500 text-white rounded hover:bg-red-600"
            on:click=move |_| {
                handle_logout.dispatch(());
            }
            prop:disabled=move || handle_logout.pending().get()
        >
            {move || {
                if handle_logout.pending().get() {
                    "Logging out..."
                } else {
                    "Logout"
                }
            }}
        </button>
    }
}
use crate::app::models::user::{SessionUser, UserRole};
use crate::app::server_functions::saml_auth::{create_saml_config, get_saml_institutions};
use leptos::prelude::*;
use leptos::task::spawn_local;

#[component]
pub fn SamlTestButton() -> impl IntoView {
    let current_user = expect_context::<ReadSignal<Option<SessionUser>>>().unwrap();
    let (loading, set_loading) = signal(false);
    let (message, set_message) = create_signal::<Option<(String, bool)>>(None);
    let (show_test_form, set_show_test_form) = signal(false);
    let (test_step, set_test_step) = signal(0); // Track progress

    // Check if user has admin privileges
    let is_admin = move || {
        current_user
            .get()
            .map(|user| matches!(user.role, UserRole::Admin | UserRole::SuperAdmin))
            .unwrap_or(false)
    };

    let create_test_saml = Action::new(move |_: &()| {
        async move {
            set_loading.set(true);
            set_message.set(None);
            set_test_step.set(1);

            // Create a test SAML configuration using Mock SAML
            let test_config = create_saml_config(
                "Mock SAML Test".to_string(),
                "https://mocksaml.com/api/saml/metadata".to_string(),
                "https://mocksaml.com/api/saml/sso".to_string(),
                Some("https://mocksaml.com/api/saml/slo".to_string()),
                // Mock SAML's actual certificate
                "-----BEGIN CERTIFICATE-----
MIIC4jCCAcoCCQC33wnybT5QZDANBgkqhkiG9w0BAQsFADAyMQswCQYDVQQGEwJV
SzEPMA0GA1UECgwGQm94eUhRMRIwEAYDVQQDDAlNb2NrIFNBTUwwIBcNMjIwMjI4
MjE0NjM4WhgPMzAyMTA3MDEyMTQ2MzhaMDIxCzAJBgNVBAYTAlVLMQ8wDQYDVQQK
DAZCb3h5SFExEjAQBgNVBAMMCU1vY2sgU0FNTDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBALGfYettMsct1T6tVUwTudNJH5Pnb9GGnkXi9Zw/e6x45DD0
RuRONbFlJ2T4RjAE/uG+AjXxXQ8o2SZfb9+GgmCHuTJFNgHoZ1nFVXCmb/Hg8Hpd
4vOAGXndixaReOiq3EH5XvpMjMkJ3+8+9VYMzMZOjkgQtAqO36eAFFfNKX7dTj3V
pwLkvz6/KFCq8OAwY+AUi4eZm5J57D31GzjHwfjH9WTeX0MyndmnNB1qV75qQR3b
2/W5sGHRv+9AarggJkF+ptUkXoLtVA51wcfYm6hILptpde5FQC8RWY1YrswBWAEZ
NfyrR4JeSweElNHg4NVOs4TwGjOPwWGqzTfgTlECAwEAATANBgkqhkiG9w0BAQsF
AAOCAQEAAYRlYflSXAWoZpFfwNiCQVE5d9zZ0DPzNdWhAybXcTyMf0z5mDf6FWBW
5Gyoi9u3EMEDnzLcJNkwJAAc39Apa4I2/tml+Jy29dk8bTyX6m93ngmCgdLh5Za4
khuU3AM3L63g7VexCuO7kwkjh/+LqdcIXsVGO6XDfu2QOs1Xpe9zIzLpwm/RNYeX
UjbSj5ce/jekpAw7qyVVL4xOyh8AtUW1ek3wIw1MJvEgEPt0d16oshWJpoS1OT8L
r/22SvYEo3EmSGdTVGgk3x3s+A0qWAqTcyjr7Q4s/GKYRFfomGwz0TZ4Iw1ZN99M
m0eo2USlSRTVl7QHRTuiuSThHpLKQQ==
-----END CERTIFICATE-----"
                    .to_string(),
                Some("https://mocksaml.com/api/saml/metadata".to_string()),
            )
            .await;

            match test_config {
                Ok(response) => {
                    if response.success {
                        set_message.set(Some((
                            "âœ… Mock SAML configuration created successfully!".to_string(),
                            true,
                        )));
                        set_test_step.set(2);

                        // Now test if we can retrieve it
                        spawn_local(async move {
                            match get_saml_institutions().await {
                                Ok(institutions) => {
                                    let test_institution = institutions
                                        .iter()
                                        .find(|inst| inst.name == "Mock SAML Test");
                                    if test_institution.is_some() {
                                        set_message.set(Some(("ðŸŽ‰ SAML configuration test PASSED! Ready for login testing.".to_string(), true)));
                                        set_test_step.set(3);
                                    } else {
                                        set_message.set(Some((
                                            "âš ï¸ Configuration created but not found in retrieval."
                                                .to_string(),
                                            false,
                                        )));
                                    }
                                }
                                Err(e) => {
                                    set_message.set(Some((
                                        format!("âŒ Failed to retrieve institutions: {}", e),
                                        false,
                                    )));
                                }
                            }
                        });
                    } else {
                        set_message.set(Some((format!("âŒ {}", response.message), false)));
                    }
                }
                Err(e) => {
                    set_message.set(Some((
                        format!("âŒ Failed to create SAML config: {}", e),
                        false,
                    )));
                }
            }

            set_loading.set(false);
        }
    });

    view! {
        {move || {
            if is_admin() {
                view! {
                    <div class="flex flex-col items-end space-y-2">
                        <div class="flex space-x-2">
                            <button
                                class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed text-sm"
                                on:click=move |_| set_show_test_form.update(|show| *show = !*show)
                            >
                                "ðŸ§ª Test SAML End-to-End"
                            </button>
                        </div>

                        {move || {
                            if show_test_form.get() {
                                let base_url = std::env::var("BASE_URL").unwrap_or_else(|_| "http://localhost:8080".to_string());

                                view! {
                                    <div class="absolute top-16 right-0 z-10 bg-white border border-gray-300 rounded-lg shadow-lg p-4 w-96">
                                        <div class="flex justify-between items-center mb-3">
                                            <h3 class="text-lg font-medium text-gray-900">"SAML End-to-End Test"</h3>
                                            <button
                                                class="text-gray-400 hover:text-gray-600"
                                                on:click=move |_| {
                                                    set_show_test_form.set(false);
                                                    set_test_step.set(0);
                                                    set_message.set(None);
                                                }
                                            >
                                                "âœ•"
                                            </button>
                                        </div>

                                        {move || {
                                            message.get().map(|(msg, is_success)| {
                                                let bg_class = if is_success { "bg-green-50 border-green-200 text-green-800" } else { "bg-red-50 border-red-200 text-red-800" };
                                                view! {
                                                    <div class={format!("border px-3 py-2 rounded mb-3 text-sm {}", bg_class)}>
                                                        {msg}
                                                    </div>
                                                }
                                            })
                                        }}

                                        <div class="space-y-4">
                                            // Step 1: Create SAML Config
                                            <div class={format!("p-3 rounded border {}",
                                                if test_step.get() >= 1 { "bg-green-50 border-green-200" }
                                                else { "bg-gray-50 border-gray-200" }
                                            )}>
                                                <div class="flex items-center justify-between mb-2">
                                                    <h4 class="font-medium text-gray-900">"Step 1: Create SAML Config"</h4>
                                                    {move || if test_step.get() >= 2 {
                                                        view! { <span class="text-green-600">"âœ…"</span> }
                                                    } else {
                                                        view! { <span></span> }
                                                    }}
                                                </div>
                                                <button
                                                    class="w-full px-3 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 disabled:bg-gray-400"
                                                    on:click=move |_| {
                                                        if !loading.get() {
                                                            create_test_saml.dispatch(());
                                                        }
                                                    }
                                                    prop:disabled=move || loading.get() || (test_step.get() >= 2)
                                                >
                                                    {move || {
                                                        if loading.get() {
                                                            "Creating..."
                                                        } else if test_step.get() >= 2 {
                                                            "âœ… Config Created"
                                                        } else {
                                                            "Create Mock SAML Config"
                                                        }
                                                    }}
                                                </button>
                                            </div>

                                            // Step 2: Configure Mock SAML
                                            <div class={format!("p-3 rounded border {}",
                                                if test_step.get() >= 2 { "bg-blue-50 border-blue-200" }
                                                else { "bg-gray-50 border-gray-200" }
                                            )}>
                                                <h4 class="font-medium text-gray-900 mb-2">"Step 2: Configure Mock SAML"</h4>
                                                <p class="text-sm text-gray-600 mb-3">
                                                    "Configure Mock SAML to point back to your service:"
                                                </p>

                                                <div class="space-y-2 text-xs bg-white p-3 rounded border">
                                                    <div>
                                                        <strong>"1. Visit: "</strong>
                                                        <a href="https://mocksaml.com/" target="_blank" class="text-blue-600 hover:underline">
                                                            "https://mocksaml.com/"
                                                        </a>
                                                    </div>
                                                    <div>
                                                        <strong>"2. Enter your SP Metadata URL:"</strong>
                                                        <div class="mt-1 p-2 bg-gray-100 rounded font-mono break-all">
                                                            {format!("{}/saml/metadata", base_url)}
                                                        </div>
                                                    </div>
                                                    <div>
                                                        <strong>"3. Or manually configure:"</strong>
                                                        <div class="ml-2 space-y-1">
                                                            <div>
                                                                "ACS URL: "
                                                                <code class="bg-gray-100 px-1 rounded text-xs">
                                                                    {format!("{}/saml/acs", base_url)}
                                                                </code>
                                                            </div>
                                                            <div>
                                                                "Entity ID: "
                                                                <code class="bg-gray-100 px-1 rounded text-xs">
                                                                    {format!("{}/saml/metadata", base_url)}
                                                                </code>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>

                                            // Step 3: Test Login
                                            <div class={format!("p-3 rounded border {}",
                                                if test_step.get() >= 3 { "bg-green-50 border-green-200" }
                                                else { "bg-gray-50 border-gray-200" }
                                            )}>
                                                <h4 class="font-medium text-gray-900 mb-2">"Step 3: Test SAML Login"</h4>

                                                {move || if test_step.get() >= 3 {
                                                    // Use the correct institution name format (URL-safe)
                                                    let login_url = format!("{}/saml/login?institution=mock-saml-test", base_url);
                                                    view! {
                                                        <div class="space-y-2">
                                                            <p class="text-sm text-gray-600">
                                                                "After configuring Mock SAML, test the login flow:"
                                                            </p>
                                                            <a
                                                                href=login_url
                                                                target="_blank"
                                                                rel="noopener noreferrer"
                                                                class="inline-block w-full px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700 transition-colors text-center"
                                                            >
                                                                "ðŸ”— Test SAML Login Flow"
                                                            </a>
                                                            <p class="text-xs text-gray-500">
                                                                "This will redirect to Mock SAML, then back to your app"
                                                            </p>
                                                        </div>
                                                    }.into_any()
                                                } else {
                                                    view! {
                                                        <p class="text-sm text-gray-500">
                                                            "Complete steps 1 and 2 first"
                                                        </p>
                                                    }.into_any()
                                                }}
                                            </div>

                                            // Additional helpful info
                                            <div class="p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                <h4 class="font-medium text-yellow-800 mb-1">"ðŸ’¡ Troubleshooting"</h4>
                                                <ul class="text-xs text-yellow-700 space-y-1">
                                                    <li>"â€¢ Check browser console for errors"</li>
                                                    <li>"â€¢ Verify your BASE_URL environment variable"</li>
                                                    <li>"â€¢ Make sure your app is accessible from the internet for Mock SAML"</li>
                                                    <li>
                                                        "â€¢ Check SAML response at: "
                                                        <code class="bg-yellow-100 px-1 rounded">"/saml/health"</code>
                                                    </li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                }.into_any()
                            } else {
                                view! { <div></div> }.into_any()
                            }
                        }}
                    </div>
                }.into_any()
            } else {
                view! { <div></div> }.into_any()
            }
        }}
    }
}
use crate::app::components::auth::authorization_components::perform_post_login_redirect;
use crate::app::models::user::SessionUser;
use crate::app::server_functions::auth::{get_current_user, login};
use crate::app::server_functions::saml_auth::{
    get_saml_institutions, initiate_saml_login, SamlInstitution,
};
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::hooks::use_navigate;

#[component]
pub fn SamlLoginForm() -> impl IntoView {
    let (username, set_username) = signal("".to_string());
    let (password, set_password) = signal("".to_string());
    let (error, set_error) = create_signal::<Option<String>>(None);
    let (login_mode, set_login_mode) = signal("local"); // "local" or "saml"
    let (selected_institution, set_selected_institution) = create_signal::<Option<String>>(None);
    let (saml_institutions, set_saml_institutions) =
        create_signal::<Vec<SamlInstitution>>(Vec::new());
    let (loading, set_loading) = signal(false);

    let set_current_user = expect_context::<WriteSignal<Option<SessionUser>>>().unwrap();
    let navigate = use_navigate();

    // Load SAML institutions on component mount
    Effect::new(move |_| {
        spawn_local(async move {
            match get_saml_institutions().await {
                Ok(institutions) => {
                    set_saml_institutions.set(institutions);
                }
                Err(e) => {
                    log::info!("Failed to load SAML institutions: {:?}", e);
                }
            }
        });
    });

    // Handle local login
    let handle_local_login = Action::new(move |_: &()| {
        let username = username.get();
        let password = password.get();

        async move {
            set_loading.set(true);
            set_error.set(None);

            if username.trim().is_empty() || password.trim().is_empty() {
                set_error.set(Some("Username and password are required".to_string()));
                set_loading.set(false);
                return;
            }

            match login(username, password).await {
                Ok(response) => {
                    if response.success {
                        set_current_user.set(response.user);
                        perform_post_login_redirect();
                    } else {
                        set_error.set(Some(response.message));
                    }
                }
                Err(err) => {
                    set_error.set(Some(format!("Login failed: {}", err)));
                }
            }

            set_loading.set(false);
        }
    });

    view! {
        <div class="max-w-md mx-auto mt-8 p-6 bg-white rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">"Login to Teapot Testing"</h2>

            {move || {
                error.get().map(|err| {
                    view! {
                        <div class="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-md">
                            <div class="flex items-center">
                                <svg class="w-5 h-5 mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                                </svg>
                                <span class="text-sm">{err}</span>
                            </div>
                        </div>
                    }
                })
            }}

            // Login method selector
            <div class="mb-6">
                <div class="flex border rounded-lg overflow-hidden">
                    <button
                        class=move || {
                            let base = "flex-1 py-2 px-4 text-sm font-medium transition-colors";
                            if login_mode.get() == "local" {
                                format!("{} bg-blue-600 text-white", base)
                            } else {
                                format!("{} bg-gray-100 text-gray-700 hover:bg-gray-200", base)
                            }
                        }
                        on:click=move |_| set_login_mode.set("local")
                        disabled=move || loading.get()
                    >
                        "Username & Password"
                    </button>
                    <button
                        class=move || {
                            let base = "flex-1 py-2 px-4 text-sm font-medium transition-colors";
                            if login_mode.get() == "saml" {
                                format!("{} bg-blue-600 text-white", base)
                            } else {
                                format!("{} bg-gray-100 text-gray-700 hover:bg-gray-200", base)
                            }
                        }
                        on:click=move |_| set_login_mode.set("saml")
                        disabled=move || loading.get()
                    >
                        "Institution Login"
                    </button>
                </div>
            </div>

            {move || {
                if login_mode.get() == "local" {
                    view! {
                        <form on:submit=move |ev| {
                            ev.prevent_default();
                            if !loading.get() {
                                handle_local_login.dispatch(());
                            }
                        }>
                            <div class="mb-4">
                                <label class="block text-gray-700 text-sm font-medium mb-2" for="username">
                                    "Username"
                                </label>
                                <input
                                    id="username"
                                    type="text"
                                    class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    prop:value=move || username.get()
                                    on:input=move |ev| set_username.set(event_target_value(&ev))
                                    prop:disabled=move || loading.get()
                                    placeholder="Enter your username"
                                />
                            </div>

                            <div class="mb-6">
                                <label class="block text-gray-700 text-sm font-medium mb-2" for="password">
                                    "Password"
                                </label>
                                <input
                                    id="password"
                                    type="password"
                                    class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    prop:value=move || password.get()
                                    on:input=move |ev| set_password.set(event_target_value(&ev))
                                    prop:disabled=move || loading.get()
                                    placeholder="Enter your password"
                                />
                            </div>

                            <button
                                type="submit"
                                class="w-full p-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors duration-200"
                                prop:disabled=move || loading.get()
                            >
                                {move || {
                                    if loading.get() {
                                        view! {
                                            <div class="flex items-center justify-center">
                                                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                "Signing in..."
                                            </div>
                                        }.into_any()
                                    } else {
                                        view! {
                                            "Sign In"
                                        }.into_any()
                                    }
                                }}
                            </button>
                        </form>
                    }.into_any()
                } else {
                    // SAML Institution Login - Using button with JavaScript navigation
                    view! {
                        <div class="space-y-4">
                            {move || {
                                let institutions_list = saml_institutions.get();
                                if institutions_list.is_empty() {
                                    view! {
                                        <div class="p-4 bg-gray-100 rounded-md">
                                            <p class="text-sm text-gray-600 text-center">
                                                "No institutions configured for SAML login."
                                            </p>
                                        </div>
                                    }.into_any()
                                } else {
                                    view! {
                                        <div>
                                            <label class="block text-gray-700 text-sm font-medium mb-2">
                                                "Select Your Institution"
                                            </label>
                                            <select
                                                class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                                on:change=move |ev| {
                                                    let value = event_target_value(&ev);
                                                    if value.is_empty() {
                                                        set_selected_institution.set(None);
                                                    } else {
                                                        set_selected_institution.set(Some(value));
                                                    }
                                                }
                                                prop:disabled=move || loading.get()
                                            >
                                                <option value="">"-- Select Institution --"</option>
                                                {institutions_list.into_iter().map(|institution| {
                                                    let url_safe_name = institution.to_url_safe();
                                                    view! {
                                                        <option value={url_safe_name}>{institution.name}</option>
                                                    }
                                                }).collect::<Vec<_>>()}
                                            </select>

                                            // Use Leptos navigation for SPA routing with hydration guards
                                            {move || {
                                                if let Some(institution_id) = selected_institution.get() {
                                                    let login_url = format!("/saml/login?institution={}&relay_state=/dashboard", institution_id);

                                                    view! {
                                                        <a
                                                            href={login_url}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            class="block w-full mt-4 p-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 text-center transition-colors duration-200 no-underline"
                                                        >
                                                            <div class="flex items-center justify-center">
                                                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                                                                </svg>
                                                                "Login with Institution"
                                                            </div>
                                                        </a>
                                                    }.into_any()
                                                } else {
                                                    view! {
                                                        <button
                                                            class="w-full mt-4 p-3 bg-gray-400 text-white rounded-md cursor-not-allowed"
                                                            disabled=true
                                                        >
                                                            "Select an institution first"
                                                        </button>
                                                    }.into_any()
                                                }
                                            }}

                                            <div class="mt-4 p-3 bg-blue-50 rounded-md">
                                                <p class="text-sm text-blue-700">
                                                    <strong>"Institution Login:"</strong>
                                                    " Your institution's credentials will be used to sign you in securely."
                                                </p>
                                            </div>
                                        </div>
                                    }.into_any()
                                }
                            }}
                        </div>
                    }.into_any()
                }
            }}

            <div class="mt-6 pt-6 border-t border-gray-200">
                <p class="text-center text-sm text-gray-600">
                    "Need help? Contact your institution's IT support."
                </p>
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod home_page;
pub use home_page::HomePage;

pub mod student_view;
pub use student_view::StudentView;

pub mod admin_test;
pub use admin_test::AdministerTest;

pub mod teacher_view;
pub use teacher_view::Teachers;

pub mod my_account;
pub use my_account::MyAccount;

pub mod login_page;
pub use login_page::LoginPage;

pub mod test_builder;
pub use test_builder::TestBuilder;

pub mod dashboard;
pub use dashboard::Dashboard;

pub mod review_test;
pub use review_test::ReviewTest;

pub mod assessment_page;
pub use assessment_page::AssessmentPage;

pub mod student_results;
pub use student_results::TestResultsPage;

pub mod settings;
pub use settings::Settings;

pub mod gradebook;
pub use gradebook::Gradebook;

pub mod admin_dashboard;
pub use admin_dashboard::AdminDashboard;

pub mod test_page;
pub use test_page::UnifiedTestManager;
pub use test_page::*;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;
// Importing necessary components and pages
use crate::app::components::{
    live_testing::{test_session::RealtimeTestSession, AnonymousStudentTest},
    login_components::{RequestPasswordResetForm, ResetPasswordForm},
    saml_admin::SamlAdminPanel,
    test_components::test_variation_manager::TestVariationManager,
    test_templates::{FlashCardSet, GridTest},
};
use crate::app::pages::*;

#[component]
pub fn AppRoutes() -> impl IntoView {
    view! {
        <Routes fallback=NotFound>
            // Public routes
            <Route path=path!("/") view=HomePage/>
            <Route path=path!("/login") view=LoginPage/>
            <Route path=path!("/forgot-password") view=RequestPasswordResetForm/>
            <Route path=path!("/reset-password/:token") view=ResetPasswordForm/>

            // Dashboard routes
            <Route path=path!("/dashboard") view=Dashboard/>
            <Route path=path!("/admindashboard") view=AdminDashboard/>
            <Route path=path!("/studentview") view=StudentView/>

            // Test management routes
            <Route path=path!("/test-manager") view=UnifiedTestManager/>
            <Route path=path!("/testbuilder") view=TestBuilder/>
            <Route path=path!("/testbuilder/:test_id") view=TestBuilder/>
            <Route path=path!("/test-variations") view=TestVariationManager/>

            // Assessment routes
            <Route path=path!("/assessments") view=AssessmentPage/>
            <Route path=path!("/admintest") view=AdministerTest/>
            <Route path=path!("/gradebook") view=Gradebook/>

            // Test session routes
            <Route path=path!("/test-session/:test_id") view=RealtimeTestSession/>
            <Route path=path!("/student-test/:test_id/:session_id") view=AnonymousStudentTest/>
            <Route path=path!("/tests/:test_id/sessions/:session_id") view=RealtimeTestSession/>

            // Test template routes
            <Route path=path!("/flashcardset/:test_id") view=FlashCardSet/>
            <Route path=path!("/gridtest/:test_id") view=GridTest/>

            // Review and results routes
            <Route path=path!("/reviewtest/:test_id/:student_id/:test_variant/:attempt") view=ReviewTest/>
            <Route path=path!("/studentview/:student_id/results") view=TestResultsPage/>

            // Settings and admin routes
            <Route path=path!("/settings") view=Settings/>
            <Route path=path!("/myaccount") view=MyAccount/>
            <Route path=path!("/teachers") view=Teachers/>
            <Route path=path!("/admin/saml") view=SamlAdminPanel/>
        </Routes>
    }
}

#[component]
pub fn NotFound() -> impl IntoView {
    #[cfg(feature = "ssr")]
    {
        let resp = expect_context::<leptos_actix::ResponseOptions>();
        resp.set_status(actix_web::http::StatusCode::NOT_FOUND);
    }

    view! {
        <div class="min-h-screen flex items-center justify-center bg-gray-50">
            <div class="text-center">
                <h1 class="text-6xl font-bold text-gray-400">"404"</h1>
                <h2 class="text-2xl font-semibold text-gray-600 mt-4">"Page Not Found"</h2>
                <p class="text-gray-500 mt-2">"The page you're looking for doesn't exist."</p>
                <a href="/" class="mt-6 inline-block px-6 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                    "Go Home"
                </a>
            </div>
        </div>
    }
}
use leptos::prelude::*;
pub mod header;
pub use header::Header;

pub mod toast;
pub use toast::Toast;
pub use toast::ToastMessage;
pub use toast::ToastMessageType;

pub mod teacher_page;
pub use teacher_page::*;

pub mod student_page;
pub use student_page::*;

pub mod auth;
pub use auth::*;

pub mod dashboard;
pub use dashboard::*;

pub mod test_templates;
pub use test_templates::*;

pub mod live_testing;
pub use live_testing::*;

pub mod data_charts;
pub use data_charts::*;

pub mod data_processing;
pub use data_processing::*;

pub mod login_components;
pub use login_components::*;

pub mod update_user_modal;
pub use update_user_modal::*;

pub mod gradebook;
pub use gradebook::*;

pub mod settings;
pub use settings::*;

pub mod admin;
pub use admin::*;

pub mod student_report;
pub use student_report::*;

pub mod test_components;
pub use test_components::*;

pub mod assessment_page;
use leptos::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum QuestionError {
    #[error("question not found")]
    QuestionNotFound,
    #[error("failed to update question")]
    QuestionUpdateFailure,
    #[error("failed to create question")]
    QuestionCreationFailure,
    #[error("failed to delete question")]
    QuestionDeleteFailure,
}

pub type ErrorMessageQuestion = String;

pub trait ResponseErrorTraitQuestion {
    fn create(question_error: QuestionError) -> ErrorMessageQuestion;
}

impl ResponseErrorTraitQuestion for ErrorMessageQuestion {
    fn create(question_error: QuestionError) -> ErrorMessageQuestion {
        match question_error {
            QuestionError::QuestionNotFound => ErrorMessageQuestion::from("question not found"),
            QuestionError::QuestionUpdateFailure => {
                ErrorMessageQuestion::from("failed to update question")
            }
            QuestionError::QuestionDeleteFailure => {
                ErrorMessageQuestion::from("failed to delete question")
            }
            QuestionError::QuestionCreationFailure => {
                ErrorMessageQuestion::from("failed to create question")
            }
        }
    }
}
use leptos::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum TestError {
    #[error("student not found")]
    TestNotFound,
    #[error("failed to update student")]
    TestUpdateFailure,
    #[error("failed to create student")]
    TestCreationFailure,
    #[error("failed to delete student")]
    TestDeleteFailure,
}

pub type ErrorMessageTest = String;

pub trait ResponseErrorTraitTest {
    fn create(test_error: TestError) -> ErrorMessageTest;
}

impl ResponseErrorTraitTest for ErrorMessageTest {
    fn create(test_error: TestError) -> ErrorMessageTest {
        match test_error {
            TestError::TestNotFound => ErrorMessageTest::from("test not found"),
            TestError::TestUpdateFailure => ErrorMessageTest::from("failed to update test"),
            TestError::TestCreationFailure => ErrorMessageTest::from("failed to create test"),
            TestError::TestDeleteFailure => ErrorMessageTest::from("failed to delete test"),
        }
    }
}
use leptos::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum StudentError {
    #[error("student not found")]
    StudentNotFound,
    #[error("failed to update student")]
    StudentUpdateFailure,
    #[error("failed to create student")]
    StudentCreationFailure,
    #[error("failed to delete student")]
    StudentDeleteFailure,
}

pub type ErrorMessage = String;

pub trait ResponseErrorTrait {
    fn create(student_error: StudentError) -> ErrorMessage; 
}

impl ResponseErrorTrait for ErrorMessage {
    fn create(student_error: StudentError) -> ErrorMessage {
        match student_error {
            StudentError::StudentNotFound => ErrorMessage::from("student not found"),
            StudentError::StudentUpdateFailure => ErrorMessage::from("failed to update student"),
            StudentError::StudentCreationFailure => ErrorMessage::from("failed to create student"),
            StudentError::StudentDeleteFailure => ErrorMessage::from("failed to delete student"),
        }
    }
}
use leptos::prelude::*;
pub mod authentication;
pub mod global_settings;
use crate::app::models::student::GradeEnum;
use chrono::NaiveDate;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug, Display};
use std::str::FromStr;
use strum::IntoEnumIterator;
use strum_macros::EnumIter;
use validator::Validate;

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum EnrollmentStatus {
    Active,
    Inactive,
    Graduated,
    Transferred,
    Dropped,
}
impl FromStr for EnrollmentStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "active" => Ok(EnrollmentStatus::Active),
            "inactive" => Ok(EnrollmentStatus::Inactive),
            "graduated" => Ok(EnrollmentStatus::Graduated),
            "transferred" => Ok(EnrollmentStatus::Transferred),
            "dropped" => Ok(EnrollmentStatus::Dropped),
            _ => Err(format!("Invalid enrollment status: {}", s)),
        }
    }
}
impl fmt::Display for EnrollmentStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                EnrollmentStatus::Active => "active".to_string(),
                EnrollmentStatus::Inactive => "inactive".to_string(),
                EnrollmentStatus::Graduated => "graduated".to_string(),
                EnrollmentStatus::Transferred => "transferred".to_string(),
                EnrollmentStatus::Dropped => "dropped".to_string(),
            }
        )
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq, EnumIter, Hash)]
pub enum AcademicYear {
    Year2023_2024,
    Year2024_2025,
    Year2025_2026,
    Year2026_2027,
    Year2027_2028,
    Year2028_2029,
    Year2029_2030,
}
impl FromStr for AcademicYear {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "2023-2024" => Ok(AcademicYear::Year2023_2024),
            "2024-2025" => Ok(AcademicYear::Year2024_2025),
            "2025-2026" => Ok(AcademicYear::Year2025_2026),
            "2026-2027" => Ok(AcademicYear::Year2026_2027),
            "2027-2028" => Ok(AcademicYear::Year2027_2028),
            "2028-2029" => Ok(AcademicYear::Year2028_2029),
            "2029-2030" => Ok(AcademicYear::Year2029_2030),
            _ => Err(format!("Invalid academic year: {}", s)),
        }
    }
}
impl Display for AcademicYear {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                AcademicYear::Year2023_2024 => "2023-2024",
                AcademicYear::Year2024_2025 => "2024-2025",
                AcademicYear::Year2025_2026 => "2025-2026",
                AcademicYear::Year2026_2027 => "2026-2027",
                AcademicYear::Year2027_2028 => "2027-2028",
                AcademicYear::Year2028_2029 => "2028-2029",
                AcademicYear::Year2029_2030 => "2029-2030",
            }
        )
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Enrollment {
    pub student_id: i32,
    pub academic_year: AcademicYear,
    pub grade_level: GradeEnum,
    pub teacher_id: i32,
    pub status: EnrollmentStatus,
    pub enrollment_date: NaiveDate,
    pub status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate> to match database
    pub notes: Option<String>,
}

impl Enrollment {
    pub fn new(
        student_id: i32,
        academic_year: AcademicYear,
        grade_level: GradeEnum,
        teacher_id: i32,
        status: EnrollmentStatus,
        enrollment_date: NaiveDate,
        status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate>
        notes: Option<String>,
    ) -> Self {
        Enrollment {
            student_id,
            academic_year,
            grade_level,
            teacher_id,
            status,
            enrollment_date,
            status_change_date,
            notes,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct CreateEnrollmentRequest {
    pub student_id: i32,
    pub course_id: i32,
    pub academic_year: AcademicYear,
    pub grade_level: GradeEnum,
    pub teacher_id: i32,
    pub status: EnrollmentStatus,
    pub enrollment_date: NaiveDate,
    pub status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate>
    pub notes: Option<String>,
}
impl CreateEnrollmentRequest {
    pub fn new(
        student_id: i32,
        course_id: i32,
        academic_year: AcademicYear,
        grade_level: GradeEnum,
        teacher_id: i32,
        status: EnrollmentStatus,
        enrollment_date: NaiveDate,
        status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate>
        notes: Option<String>,
    ) -> Self {
        CreateEnrollmentRequest {
            student_id,
            course_id,
            academic_year,
            grade_level,
            teacher_id,
            status,
            enrollment_date,
            status_change_date,
            notes,
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct UpdateEnrollmentRequest {
    pub student_id: i32,
    pub course_id: i32,
    pub academic_year: AcademicYear,
    pub grade_level: GradeEnum,
    pub teacher_id: i32,
    pub status: EnrollmentStatus,
    pub enrollment_date: NaiveDate,
    pub status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate>
    pub notes: Option<String>,
}
impl UpdateEnrollmentRequest {
    pub fn new(
        student_id: i32,
        course_id: i32,
        academic_year: AcademicYear,
        grade_level: GradeEnum,
        teacher_id: i32,
        status: EnrollmentStatus,
        enrollment_date: NaiveDate,
        status_change_date: Option<NaiveDate>, // Changed to Option<NaiveDate>
        notes: Option<String>,
    ) -> Self {
        UpdateEnrollmentRequest {
            student_id,
            course_id,
            academic_year,
            grade_level,
            teacher_id,
            status,
            enrollment_date,
            status_change_date,
            notes,
        }
    }
}

//the following functions are all gated behind ssr but allow encoding and decoding of
//EnrollmentStatus and AcademicYear by sqlx
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::prelude::*;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for EnrollmentStatus {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, Postgres> for EnrollmentStatus {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                EnrollmentStatus::from_str(s).map_err(|_| format!("Invalid enrollment status: {:?}", s).into())
            }
        }
        impl Type<Postgres> for EnrollmentStatus {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("enrollment_status_enum")
            }
        }

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for AcademicYear {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, Postgres> for AcademicYear {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                AcademicYear::from_str(s).map_err(|_| format!("Invalid academic year: {:?}", s).into())
            }
        }
        impl Type<Postgres> for AcademicYear {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("school_year_enum")
            }
        }
    }
}
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Display};
use crate::app::models::test::Test;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum VariationType {
    Randomized,
    Distinct, 
    Practice,
}

impl VariationType {
    pub fn display_name(&self) -> &'static str {
        match self {
            VariationType::Randomized => "Randomized",
            VariationType::Distinct => "Distinct",
            VariationType::Practice => "Practice",
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            VariationType::Randomized => "Same questions with shuffled order and randomized answer choices",
            VariationType::Distinct => "Entirely different questions covering the same topics",
            VariationType::Practice => "Practice version for student preparation with new questions",
        }
    }

    pub fn detailed_description(&self) -> &'static str {
        match self {
            VariationType::Randomized => "Creates a test variation with the same questions but in randomized order with shuffled answer choices. Questions are automatically generated from the base test.",
            VariationType::Distinct => "Creates a blank test variation where you can add entirely new questions for a different version covering the same material.",
            VariationType::Practice => "Creates a blank practice version where you can add new questions for student practice and preparation.",
        }
    }

    pub fn variant_number_offset(&self) -> i32 {
        match self {
            VariationType::Randomized => 100,
            VariationType::Distinct => 200,
            VariationType::Practice => 300,
        }
    }

    pub fn badge_class(&self) -> &'static str {
        match self {
            VariationType::Randomized => "bg-blue-100 text-blue-800 border-blue-300",
            VariationType::Distinct => "bg-green-100 text-green-800 border-green-300",
            VariationType::Practice => "bg-purple-100 text-purple-800 border-purple-300",
        }
    }

    pub fn card_class(&self) -> &'static str {
        match self {
            VariationType::Randomized => "border-blue-200 bg-blue-50",
            VariationType::Distinct => "border-green-200 bg-green-50",
            VariationType::Practice => "border-purple-200 bg-purple-50",
        }
    }

    pub fn requires_manual_questions(&self) -> bool {
        match self {
            VariationType::Randomized => false,
            VariationType::Distinct => true,
            VariationType::Practice => true,
        }
    }

    pub fn from_test_name(test_name: &str) -> Option<Self> {
        let name_lower = test_name.to_lowercase();
        if name_lower.contains("randomized") {
            Some(VariationType::Randomized)
        } else if name_lower.contains("distinct") {
            Some(VariationType::Distinct)
        } else if name_lower.contains("practice") {
            Some(VariationType::Practice)
        } else {
            None
        }
    }

    pub fn from_comments(comments: &str) -> Option<Self> {
        let comments_lower = comments.to_lowercase();
        if comments_lower.contains("variation: randomized") {
            Some(VariationType::Randomized)
        } else if comments_lower.contains("variation: distinct") {
            Some(VariationType::Distinct)
        } else if comments_lower.contains("variation: practice") {
            Some(VariationType::Practice)
        } else {
            None
        }
    }
}

impl Display for VariationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.display_name())
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TestVariationInfo {
    pub base_test: Test,
    pub randomized_variations: Vec<Test>,
    pub distinct_variations: Vec<Test>,
    pub practice_variations: Vec<Test>,
}

impl TestVariationInfo {
    pub fn new(base_test: Test) -> Self {
        Self {
            base_test,
            randomized_variations: Vec::new(),
            distinct_variations: Vec::new(),
            practice_variations: Vec::new(),
        }
    }

    pub fn add_variation(&mut self, variation: Test) {
        if let Some(var_type) = VariationType::from_test_name(&variation.name) {
            match var_type {
                VariationType::Randomized => self.randomized_variations.push(variation),
                VariationType::Distinct => self.distinct_variations.push(variation),
                VariationType::Practice => self.practice_variations.push(variation),
            }
        } else if let Some(var_type) = VariationType::from_comments(&variation.comments) {
            match var_type {
                VariationType::Randomized => self.randomized_variations.push(variation),
                VariationType::Distinct => self.distinct_variations.push(variation),
                VariationType::Practice => self.practice_variations.push(variation),
            }
        }
    }

    pub fn total_variations(&self) -> usize {
        self.randomized_variations.len() + self.distinct_variations.len() + self.practice_variations.len()
    }

    pub fn get_variations_by_type(&self, var_type: &VariationType) -> &Vec<Test> {
        match var_type {
            VariationType::Randomized => &self.randomized_variations,
            VariationType::Distinct => &self.distinct_variations,
            VariationType::Practice => &self.practice_variations,
        }
    }

    pub fn has_variation_type(&self, var_type: &VariationType) -> bool {
        !self.get_variations_by_type(var_type).is_empty()
    }

    pub fn get_all_variations(&self) -> Vec<&Test> {
        let mut all = Vec::new();
        all.extend(self.randomized_variations.iter());
        all.extend(self.distinct_variations.iter());
        all.extend(self.practice_variations.iter());
        all
    }
}

// Utility functions for test variation detection
pub fn is_variation_test(test: &Test) -> bool {
    test.name.contains(" - ") && (
        VariationType::from_test_name(&test.name).is_some() ||
        VariationType::from_comments(&test.comments).is_some()
    )
}

pub fn get_base_test_name(test_name: &str) -> String {
    if test_name.contains(" - ") {
        test_name.split(" - ").next().unwrap_or(test_name).to_string()
    } else {
        test_name.to_string()
    }
}

pub fn get_variation_name_suffix(test_name: &str) -> Option<String> {
    if test_name.contains(" - ") {
        test_name.split(" - ").nth(1).map(|s| s.to_string())
    } else {
        None
    }
}

// Group tests into variation families
pub fn group_tests_by_base(tests: Vec<Test>) -> Vec<TestVariationInfo> {
    let mut groups: std::collections::HashMap<String, TestVariationInfo> = std::collections::HashMap::new();

    for test in tests {
        let base_name = get_base_test_name(&test.name);

        if is_variation_test(&test) {
            groups.entry(base_name.clone())
                .and_modify(|group| group.add_variation(test.clone()))
                .or_insert_with(|| {
                    let mut group = TestVariationInfo::new(test.clone());
                    // Clear the base test since we're adding a variation first
                    group.base_test = Test::new(
                        base_name.clone(),
                        0,
                        String::new(),
                        test.testarea.clone(),
                        test.school_year.clone(),
                        test.benchmark_categories.clone(),
                        0,
                        test.grade_level.clone(),
                        String::new(),
                        test.scope.clone(),
                        test.course_id.clone(),
                    );
                    group.add_variation(test.clone());
                    group
                });
        } else {
            groups.entry(base_name.clone())
                .and_modify(|group| {
                    // Replace placeholder base test if it exists
                    if group.base_test.test_id.is_empty() {
                        group.base_test = test.clone();
                    }
                })
                .or_insert_with(|| TestVariationInfo::new(test.clone()));
        }
    }

    // Filter out groups that only have placeholder base tests
    groups.into_values()
        .filter(|group| !group.base_test.test_id.is_empty())
        .collect()
}
use crate::app::models::test::BenchmarkCategory;
use chrono::prelude::*;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::Debug;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct Score {
    pub student_id: i32,
    pub date_administered: DateTime<Utc>,
    pub test_id: String,
    pub test_scores: Vec<i32>,
    pub comments: Vec<String>,
    pub test_variant: i32,
    pub evaluator: String,
    pub attempt: i32,
    //in theory it should be most efficient to use a hashmap whereby the key to the map is the
    //qnumber from the questions_table and links to the tuple: (points, comments)
}

impl Score {
    pub fn new(
        student_id: i32,
        date_administered: DateTime<Utc>,
        //I think i want this to be Local date offset on the front end but save to UTC on the back
        test_id: String,
        test_scores: Vec<i32>,
        comments: Vec<String>,
        test_variant: i32,
        evaluator: String,
        attempt: i32,
    ) -> Score {
        Score {
            student_id,
            date_administered,
            test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
            attempt,
        }
    }
    pub fn get_total(&self) -> i32 {
        self.test_scores.iter().sum()
    }
    pub fn find_benchmark_category(
        total_score: i32,
        benchmark_categories: &[BenchmarkCategory],
    ) -> Option<BenchmarkCategory> {
        benchmark_categories
            .iter()
            .find(|category| category.contains(total_score))
            .cloned()
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct CreateScoreRequest {
    pub student_id: i32,
    pub test_id: String,
    pub test_scores: Vec<i32>,
    pub comments: Vec<String>,
    pub test_variant: i32,
    pub evaluator: String,
}

impl CreateScoreRequest {
    pub fn new(
        student_id: i32,
        test_id: String,
        test_scores: Vec<i32>,
        comments: Vec<String>,
        test_variant: i32,
        evaluator: String,
    ) -> CreateScoreRequest {
        CreateScoreRequest {
            student_id,
            test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct UpdateScoreRequest {
    pub student_id: i32,
    pub date_administered: DateTime<Utc>,
    //I think i want this to be Local date offset on the front end but save to UTC on the back
    pub test_id: String,
    pub test_scores: Vec<i32>,
    pub comments: Vec<String>,
    pub test_variant: i32,
    pub evaluator: String,
    pub attempt: i32,
}

impl UpdateScoreRequest {
    pub fn new(
        student_id: i32,
        date_administered: DateTime<Utc>,
        test_id: String,
        test_scores: Vec<i32>,
        comments: Vec<String>,
        test_variant: i32,
        //I think i want this to be Local date offset on the front end but save to UTC on the back
        evaluator: String,
        attempt: i32,
    ) -> UpdateScoreRequest {
        UpdateScoreRequest {
            student_id,
            date_administered,
            test_id,
            test_scores,
            comments,
            test_variant,
            evaluator,
            attempt,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct DeleteScoreRequest {
    pub student_id: i32,
    //test_id refers to the key used to create the hashmap
    pub test_id: String,
    pub test_variant: i32,
    pub attempt: i32,
}

impl DeleteScoreRequest {
    pub fn new(
        student_id: i32,
        test_id: String,
        test_variant: i32,
        attempt: i32,
    ) -> DeleteScoreRequest {
        DeleteScoreRequest {
            student_id,
            test_id,
            test_variant,
            attempt,
        }
    }
}
use chrono::{DateTime, Utc};
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[cfg(feature = "ssr")]
use sqlx::Type;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(feature = "ssr", derive(Type))]
#[cfg_attr(feature = "ssr", sqlx(type_name = "session_status_enum"))]
pub enum SessionStatus {
    #[serde(rename = "active")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "active"))]
    Active,
    #[serde(rename = "inactive")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "inactive"))]
    Inactive,
    #[serde(rename = "expired")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "expired"))]
    Expired,
}

impl ToString for SessionStatus {
    fn to_string(&self) -> String {
        match self {
            SessionStatus::Active => "active".to_string(),
            SessionStatus::Inactive => "inactive".to_string(),
            SessionStatus::Expired => "expired".to_string(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(feature = "ssr", derive(Type))]
#[cfg_attr(feature = "ssr", sqlx(type_name = "session_type_enum"))]
pub enum SessionType {
    #[serde(rename = "chat")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "chat"))]
    Chat,
    #[serde(rename = "test")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "test"))]
    Test,
}

impl ToString for SessionType {
    fn to_string(&self) -> String {
        match self {
            SessionType::Chat => "chat".to_string(),
            SessionType::Test => "test".to_string(),
        }
    }
}

//this is the model used for a websocket chat session
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Session {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub last_active: DateTime<Utc>,
    pub owner_id: Option<Uuid>,
    pub status: SessionStatus,
    pub max_users: i32,
    pub current_users: i32,
    pub is_private: bool,
    pub password_required: bool,
    pub session_type: SessionType,
    pub test_id: Option<String>,
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    #[serde(skip_serializing)]
    pub metadata: Option<serde_json::Value>,
    pub teacher_id: Option<i32>,
}

impl Session {
    pub fn new(
        name: String,
        description: Option<String>,
        teacher_id: Option<i32>,
        session_type: SessionType,
        test_id: Option<String>,
    ) -> Self {
        Session {
            id: Uuid::new_v4(),
            name,
            description,
            created_at: Utc::now(),
            last_active: Utc::now(),
            owner_id: None,
            status: SessionStatus::Active,
            max_users: 0, // 0 means unlimited
            current_users: 0,
            is_private: false,
            password_required: false,
            session_type,
            test_id,
            start_time: None,
            end_time: None,
            metadata: None,
            teacher_id,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CreateSessionRequest {
    pub name: String,
    pub description: Option<String>,
    pub max_users: Option<i32>,
    pub is_private: Option<bool>,
    pub password: Option<String>,
    pub session_type: Option<SessionType>,
    pub test_id: Option<String>,
    pub metadata: Option<serde_json::Value>,
    pub teacher_id: Option<i32>,
}

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct SessionSummary {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub current_users: i32,
    pub created_at: DateTime<Utc>,
    pub last_active: DateTime<Utc>,
    pub is_private: bool,
    pub password_required: bool,
    pub session_type: SessionType,
    pub test_id: Option<String>,
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub teacher_id: Option<i32>,
}

impl From<Session> for SessionSummary {
    fn from(session: Session) -> Self {
        SessionSummary {
            id: session.id,
            name: session.name,
            description: session.description,
            current_users: session.current_users,
            created_at: session.created_at,
            last_active: session.last_active,
            is_private: session.is_private,
            password_required: session.password_required,
            session_type: session.session_type,
            test_id: session.test_id,
            start_time: session.start_time,
            end_time: session.end_time,
            teacher_id: session.teacher_id,
        }
    }
}
use leptos::prelude::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid=:Uuid;

#[cfg(feature = "ssr")]
use sqlx::Type;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(feature = "ssr", derive(Type))]
#[cfg_attr(feature = "ssr", sqlx(type_name = "session_status_enum"))]
pub enum SessionStatus {
    #[serde(rename = "active")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "active"))]
    Active,
    #[serde(rename = "inactive")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "inactive"))]
    Inactive,
    #[serde(rename = "expired")]
    #[cfg_attr(feature = "ssr", sqlx(rename = "expired"))]
    Expired,
}

impl ToString for SessionStatus {
    fn to_string(&self) -> String {
        match self {
            SessionStatus::Active => "active".to_string(),
            SessionStatus::Inactive => "inactive".to_string(),
            SessionStatus::Expired => "expired".to_string(),
        }
    }
}

//this is the model used for a websocket chat session
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Session {
    pub id= Uuid,
    pub name: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub last_active: DateTime<Utc>,
    pub owner_id= Option<Uuid>,
    pub status: SessionStatus,
    pub max_users: i32,
    pub current_users: i32,
    pub is_private: bool,
    pub password_required: bool,
    #[serde(skip_serializing)]
    pub metadata: Option<serde_json::Value>,
}

impl Session {
    pub fn new(name: String, description: Option<String>, owner_id= Option<Uuid>) -> Self {
        Session {
            id= Uuid=:new_v4(),
            name,
            description,
            created_at: Utc::now(),
            last_active: Utc::now(),
            owner_id,
            status: SessionStatus::Active,
            max_users: 0, // 0 means unlimited
            current_users: 0,
            is_private: false,
            password_required: false,
            metadata: None,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CreateSessionRequest {
    pub name: String,
    pub description: Option<String>,
    pub max_users: Option<i32>,
    pub is_private: Option<bool>,
    pub password: Option<String>,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SessionSummary {
    pub id= Uuid,
    pub name: String,
    pub description: Option<String>,
    pub current_users: i32,
    pub created_at: DateTime<Utc>,
    pub last_active: DateTime<Utc>,
    pub is_private: bool,
    pub password_required: bool,
}

impl From<Session> for SessionSummary {
    fn from(session: Session) -> Self {
        SessionSummary {
            id= session.id,
            name: session.name,
            description: session.description,
            current_users: session.current_users,
            created_at: session.created_at,
            last_active: session.last_active,
            is_private: session.is_private,
            password_required: session.password_required,
        }
    }
}
use crate::app::models::student::{ESLEnum, GenderEnum, GradeEnum, InterventionEnum, Student};
use chrono::NaiveDate;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct BulkStudentImportRequest {
    pub students: Vec<Student>,
}

#[derive(Debug, Deserialize)]
pub struct StudentCsvRow {
    pub firstname: String,
    pub lastname: String,
    pub preferred: String,
    //note that these are strings now but get converted to GenderEnum later
    pub gender: String,
    //same as above
    pub date_of_birth: String,
    pub student_id: i32,
    //same as above
    pub esl: String,
    //same as above
    pub current_grade_level: String,
    pub teacher: String,
    pub iep: bool,
    pub bip: bool,
    pub student_504: bool,
    pub readplan: bool,
    pub gt: bool,
    pub intervention: String,
    pub eye_glasses: bool,
    pub notes: String,
    pub pin: i32,
}

#[derive(Debug, Deserialize)]
pub struct StudentCsvRowAlternative {
    pub firstname: String,
    pub lastname: String,
    pub preferred: String,
    pub gender: String,
    pub date_of_birth: String,
    pub student_id: i32,
    pub esl: String,
    pub grade: String,
    pub teacher: String,
    pub iep: bool,
    pub bip: bool,
    pub student_504: bool,
    pub readplan: bool,
    pub gt: bool,
    pub intervention: String,
    pub eye_glasses: bool,
    pub notes: String,
    pub pin: i32,
}

impl From<StudentCsvRowAlternative> for StudentCsvRow {
    fn from(row: StudentCsvRowAlternative) -> Self {
        StudentCsvRow {
            firstname: row.firstname,
            lastname: row.lastname,
            preferred: row.preferred,
            gender: row.gender,
            date_of_birth: row.date_of_birth,
            student_id: row.student_id,
            esl: row.esl,
            current_grade_level: row.grade,
            teacher: row.teacher,
            iep: row.iep,
            bip: row.bip,
            student_504: row.student_504,
            readplan: row.readplan,
            gt: row.gt,
            intervention: row.intervention,
            eye_glasses: row.eye_glasses,
            notes: row.notes,
            pin: row.pin,
        }
    }
}
use crate::app::models::student::GradeEnum;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug};
use std::str::FromStr;
use strum_macros::EnumIter;
use validator::Validate;

//Defining the employee roles here
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, EnumIter)]
pub enum EmployeeRole {
    Teacher { grade: Option<GradeEnum> },
    AssistantPrincipal,
    Principal,
    Interventionist,
    IntegratedServices,
    Speech,
    OT,
    Psychologist,
    ParaProf,
    AssessmentCoordinator,
    Other,
}

impl fmt::Display for EmployeeRole {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                EmployeeRole::Teacher { grade: _ } => "Teacher".to_string(),
                EmployeeRole::AssistantPrincipal => "Assistant Principal".to_string(),
                EmployeeRole::Principal => "Principal".to_string(),
                EmployeeRole::Interventionist => "Interventionist".to_string(),
                EmployeeRole::IntegratedServices => "Integrated Services".to_string(),
                EmployeeRole::Speech => "Speech".to_string(),
                EmployeeRole::OT => "O/T".to_string(),
                EmployeeRole::Psychologist => "Psychologist".to_string(),
                EmployeeRole::ParaProf => "Para-Professional".to_string(),
                EmployeeRole::AssessmentCoordinator => "Assessment Coordinator".to_string(),
                EmployeeRole::Other => "Other".to_string(),
            }
        )
    }
}

impl FromStr for EmployeeRole {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Teacher" => Ok(EmployeeRole::Teacher { grade: None }),
            "Assistant Principal" => Ok(EmployeeRole::AssistantPrincipal),
            "Principal" => Ok(EmployeeRole::Principal),
            "Interventionist" => Ok(EmployeeRole::Interventionist),
            "Integrated Services" => Ok(EmployeeRole::IntegratedServices),
            "Speech" => Ok(EmployeeRole::Speech),
            "O/T" => Ok(EmployeeRole::OT),
            "Psychologist" => Ok(EmployeeRole::Psychologist),
            "Para-Professional" => Ok(EmployeeRole::ParaProf),
            "Assessment Coordinator" => Ok(EmployeeRole::AssessmentCoordinator),
            "Other" => Ok(EmployeeRole::Other),
            _ => Err(format!("Invalid status value: {}", s)),
        }
    }
}

//Defining the Status for an Employee here
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, EnumIter)]
pub enum StatusEnum {
    Active,
    OnLeave,
    PartTime,
    NotApplicable,
}

impl fmt::Display for StatusEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                StatusEnum::Active => "Active".to_string(),
                StatusEnum::OnLeave => "On Leave".to_string(),
                StatusEnum::PartTime => "Part-time".to_string(),
                StatusEnum::NotApplicable => "Not Applicable".to_string(),
            }
        )
    }
}

impl FromStr for StatusEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Active" => Ok(StatusEnum::Active),
            "On Leave" => Ok(StatusEnum::OnLeave),
            "Part-time" => Ok(StatusEnum::PartTime),
            "Not Applicable" => Ok(StatusEnum::NotApplicable),
            _ => Err(format!("Invalid status value: {}", s)),
        }
    }
}

//defining the employee here
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct Employee {
    pub id: i32,
    pub firstname: String,
    pub lastname: String,
    pub status: StatusEnum,
    pub role: EmployeeRole,
}

impl Employee {
    //generic constructor for all roles
    pub fn new(
        id: i32,
        firstname: String,
        lastname: String,
        status: StatusEnum,
        role: EmployeeRole,
    ) -> Self {
        Employee {
            id,
            firstname,
            lastname,
            status,
            role,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Validate, PartialEq, Eq, Clone)]
pub struct AddNewEmployeeRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub firstname: String,
    #[validate(length(min = 1, message = "lastname is required"))]
    pub lastname: String,
    pub status: StatusEnum,
    pub role: EmployeeRole,
    pub grade: Option<GradeEnum>,
}

impl AddNewEmployeeRequest {
    pub fn new(
        firstname: String,
        lastname: String,
        status: StatusEnum,
        role: EmployeeRole,
        grade: Option<GradeEnum>,
    ) -> AddNewEmployeeRequest {
        AddNewEmployeeRequest {
            firstname,
            lastname,
            status,
            role,
            grade,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Validate, PartialEq, Eq, Clone)]
pub struct UpdateEmployeeRequest {
    pub id: i32,
    #[validate(length(min = 1, message = "name is required"))]
    pub firstname: String,
    #[validate(length(min = 1, message = "lastname is required"))]
    pub lastname: String,
    pub status: StatusEnum,
    pub role: EmployeeRole,
    pub grade: Option<GradeEnum>,
}

impl UpdateEmployeeRequest {
    pub fn new(
        id: i32,
        firstname: String,
        lastname: String,
        status: StatusEnum,
        role: EmployeeRole,
        grade: Option<GradeEnum>,
    ) -> UpdateEmployeeRequest {
        UpdateEmployeeRequest {
            id,
            firstname,
            lastname,
            status,
            role,
            grade,
        }
    }
}

//these are ssr methods used to assist in the conversion/serialization/deserialization of
//StatusEnum from postgres
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")]{
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::prelude::*;

        impl<'q>sqlx::encode::Encode<'q, sqlx::Postgres> for StatusEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r>sqlx::decode::Decode<'r, sqlx::Postgres> for StatusEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                StatusEnum::from_str(s).map_err(|_| format!("Invalid StatusEnum: {:?}", s).into())
            }
        }
        impl Type<Postgres> for StatusEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("status_enum")
            }
        }
        impl<'q>sqlx::encode::Encode<'q, sqlx::Postgres> for EmployeeRole {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r>sqlx::decode::Decode<'r, sqlx::Postgres> for EmployeeRole {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                EmployeeRole::from_str(s).map_err(|_| format!("Invalid EmployeeRole: {:?}", s).into())
            }
        }
        impl Type<Postgres> for EmployeeRole {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("employee_role")
            }
        }

    }
}
use leptos::prelude::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Invitation {
    pub id= i64,
    pub code: String,
    pub school_name: String,
    pub invited_by_user_id= Option<i64>,
    pub role: String,
    pub max_uses: i32,
    pub current_uses: i32,
    pub expires_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateInvitationRequest {
    pub school_name: String,
    pub role: String,
    pub max_uses: i32,
    pub expires_in_days: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvitationInfo {
    pub code: String,
    pub school_name: String,
    pub role: String,
    pub expires_at: Option<DateTime<Utc>>,
    pub uses_remaining: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationCode {
    pub id= i64,
    pub user_id= i64,
    pub code: String,
    pub verification_type: VerificationType,
    pub expires_at: DateTime<Utc>,
    pub used_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VerificationType {
    Email,
    Phone,
}

impl VerificationType {
    pub fn as_str(&self) -> &'static str {
        match self {
            VerificationType::Email => "email",
            VerificationType::Phone => "phone",
        }
    }

    pub fn from_str(s: &str) -> Result<Self, String> {
        match s.to_lowercase().as_str() {
            "email" => Ok(VerificationType::Email),
            "phone" => Ok(VerificationType::Phone),
            _ => Err(format!("Invalid verification type: {}", s)),
        }
    }
}

impl Invitation {
    pub fn is_valid(&self) -> bool {
        // Check if invitation hasn't expired
        if let Some(expires_at) = self.expires_at {
            if Utc::now() > expires_at {
                return false;
            }
        }

        // Check if uses are available
        self.current_uses < self.max_uses
    }

    pub fn uses_remaining(&self) -> i32 {
        self.max_uses - self.current_uses
    }

    pub fn can_be_used(&self) -> bool {
        self.is_valid() && self.uses_remaining() > 0
    }
}

impl VerificationCode {
    pub fn is_valid(&self) -> bool {
        // Code hasn't been used and hasn't expired
        self.used_at.is_none() && Utc::now() < self.expires_at
    }

    pub fn is_expired(&self) -> bool {
        Utc::now() >= self.expires_at
    }
}

// Helper for generating secure invitation codes
pub fn generate_invitation_code() -> String {
    use rand::{distributions::Alphanumeric, Rng};
    
    rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(12)
        .map(char::from)
        .collect::<String>()
        .to_uppercase()
}

// Helper for generating verification codes
pub fn generate_verification_code() -> String {
    use rand::Rng;
    
    let mut rng = rand::thread_rng();
    format!("{:06}", rng.gen_range(100000..999999))
}

// Phone number validation and normalization
pub fn normalize_phone_number(phone: &str) -> Result<String, String> {
    // Remove all non-digits
    let digits_only: String = phone.chars().filter(|c| c.is_ascii_digit()).collect();
    
    // Handle US phone numbers
    match digits_only.len() {
        10 => {
            // 1234567890 -> +11234567890
            Ok(format!("+1{}", digits_only))
        }
        11 if digits_only.starts_with('1') => {
            // 11234567890 -> +11234567890
            Ok(format!("+{}", digits_only))
        }
        _ => Err("Phone number must be a valid US phone number (10 or 11 digits)".to_string()),
    }
}

pub fn format_phone_display(phone: &str) -> String {
    // Convert +11234567890 to (123) 456-7890
    if phone.starts_with("+1") && phone.len() == 12 {
        let digits = &phone[2..];
        format!("({}) {}-{}", 
            &digits[0..3], 
            &digits[3..6], 
            &digits[6..10]
        )
    } else {
        phone.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_phone_normalization() {
        assert_eq!(normalize_phone_number("1234567890").unwrap(), "+11234567890");
        assert_eq!(normalize_phone_number("(123) 456-7890").unwrap(), "+11234567890");
        assert_eq!(normalize_phone_number("11234567890").unwrap(), "+11234567890");
        assert_eq!(normalize_phone_number("+1 123 456 7890").unwrap(), "+11234567890");
        
        assert!(normalize_phone_number("123456789").is_err()); // Too short
        assert!(normalize_phone_number("123456789012").is_err()); // Too long
    }

    #[test]
    fn test_phone_display() {
        assert_eq!(format_phone_display("+11234567890"), "(123) 456-7890");
    }

    #[test]
    fn test_invitation_validity() {
        let mut invitation = Invitation {
            id= 1,
            code: "TEST123".to_string(),
            school_name: "Test School".to_string(),
            invited_by_user_id= Some(1),
            role: "user".to_string(),
            max_uses: 5,
            current_uses: 2,
            expires_at: Some(Utc::now() + chrono::Duration::days(7)),
            created_at: Utc::now(),
        };

        assert!(invitation.is_valid());
        assert_eq!(invitation.uses_remaining(), 3);
        assert!(invitation.can_be_used());

        // Test expired invitation
        invitation.expires_at = Some(Utc::now() - chrono::Duration::hours(1));
        assert!(!invitation.is_valid());
        assert!(!invitation.can_be_used());

        // Test exhausted uses
        invitation.expires_at = Some(Utc::now() + chrono::Duration::days(7));
        invitation.current_uses = 5;
        assert!(!invitation.can_be_used());
    }
}
use crate::app::models::enrollment::Enrollment;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct BulkEnrollmentImportRequest {
    pub enrollments: Vec<Enrollment>,
}

#[derive(Debug, Deserialize)]
pub struct EnrollmentCsvRow {
    pub student_id: i32,
    pub academic_year: String,
    pub grade_level: String,
    pub teacher_id: i32,
    #[serde(default)]
    pub status: String, //ignored - set to "Active" always for bulk update
    #[serde(default)]
    pub enrollment_date: String, //ignored - set in database as NOW()
    #[serde(default)]
    pub status_change_date: String, //ignored - set in database as NOW()
    #[serde(default)]
    pub notes: String,
}
use crate::app::models::enrollment::AcademicYear;
use crate::app::models::student::GradeEnum;
use chrono::{DateTime, Utc};
use leptos::prelude::*;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug, Display};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Course {
    pub id: i32,
    pub name: String,
    pub subject: String,
    pub course_code: String,
    pub course_level: GradeEnum,
    pub teacher_id: i32,
    pub academic_year: AcademicYear,
    pub semester_period: String,
    pub credits: Decimal,
    pub description: String,
    pub max_students: i32,
    pub room_number: Option<String>, // This should be Option<String> to match DB schema
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Course {
    pub fn new(
        id: i32,
        name: String,
        subject: String,
        course_code: String,
        course_level: GradeEnum,
        teacher_id: i32,
        academic_year: AcademicYear,
        semester_period: String,
        credits: Decimal,
        description: String,
        max_students: i32,
        room_number: Option<String>,
        created_at: DateTime<Utc>,
        updated_at: DateTime<Utc>,
    ) -> Self {
        Course {
            id,
            name,
            subject,
            course_code,
            course_level,
            teacher_id,
            academic_year,
            semester_period,
            credits,
            description,
            max_students,
            room_number,
            created_at,
            updated_at,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct CreateCourseRequest {
    pub name: String,
    pub subject: String,
    pub course_code: String,
    pub course_level: GradeEnum,
    pub teacher_id: i32,
    pub academic_year: AcademicYear,
    pub semester_period: String,
    pub credits: Decimal,
    pub description: String,
    pub max_students: i32,
    pub room_number: Option<String>, // Changed to Option<String> to match DB schema
}

impl CreateCourseRequest {
    pub fn new(
        name: String,
        subject: String,
        course_code: String,
        course_level: GradeEnum,
        teacher_id: i32,
        academic_year: AcademicYear,
        semester_period: String,
        credits: Decimal,
        description: String,
        max_students: i32,
        room_number: Option<String>, // Changed to Option<String>
    ) -> Self {
        CreateCourseRequest {
            name,
            subject,
            course_code,
            course_level,
            teacher_id,
            academic_year,
            semester_period,
            credits,
            description,
            max_students,
            room_number,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UpdateCourseRequest {
    pub name: Option<String>,
    pub subject: Option<String>,
    pub course_code: Option<String>,
    pub course_level: Option<GradeEnum>,
    pub teacher_id: Option<i32>,
    pub academic_year: Option<AcademicYear>,
    pub semester_period: Option<String>,
    pub credits: Option<Decimal>,
    pub description: Option<String>,
    pub max_students: Option<i32>,
    pub room_number: Option<Option<String>>, // This is Option<Option<String>> to allow setting to NULL
}

impl UpdateCourseRequest {
    pub fn new(
        name: Option<String>,
        subject: Option<String>,
        course_code: Option<String>,
        course_level: Option<GradeEnum>,
        teacher_id: Option<i32>,
        academic_year: Option<AcademicYear>,
        semester_period: Option<String>,
        credits: Option<Decimal>,
        description: Option<String>,
        max_students: Option<i32>,
        room_number: Option<Option<String>>, // Changed to Option<Option<String>>
    ) -> Self {
        UpdateCourseRequest {
            name,
            subject,
            course_code,
            course_level,
            teacher_id,
            academic_year,
            semester_period,
            credits,
            description,
            max_students,
            room_number,
        }
    }

    // Helper method to create a partial update
    pub fn partial_update() -> Self {
        UpdateCourseRequest {
            name: None,
            subject: None,
            course_code: None,
            course_level: None,
            teacher_id: None,
            academic_year: None,
            semester_period: None,
            credits: None,
            description: None,
            max_students: None,
            room_number: None,
        }
    }
}
use crate::app::models::assessment_sequences::{
    SequenceBehavior, TestSequenceItem, VariationLevel,
};
use crate::app::models::student::GradeEnum;
use crate::app::models::test::Test;
use itertools::Itertools;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug};
use std::str::FromStr;
use strum_macros::{EnumIter, EnumString};
use uuid::Uuid;
use validator::Validate;

#[derive(Debug, Clone)]
pub struct AssessmentProgressionStatus {
    pub total_main_tests: usize,
    pub completed_main_tests: usize,
    pub completion_percentage: f32,
    pub variation_attempts: usize,
    pub intervention_needed: Vec<Uuid>,
    pub is_complete: bool,
}

impl AssessmentProgressionStatus {
    pub fn legacy_mode() -> Self {
        AssessmentProgressionStatus {
            total_main_tests: 0,
            completed_main_tests: 0,
            completion_percentage: 0.0,
            variation_attempts: 0,
            intervention_needed: vec![],
            is_complete: false,
        }
    }
}

#[derive(Debug, Clone)]
pub enum RecommendedAction {
    TakeTest {
        test_id: Uuid,
        is_required: bool,
    },
    TakeVariation {
        main_test_id: Uuid,
        variation_test_id: Uuid,
        level: i32,
        description: String,
    },
    TakeOptionalTest {
        test_id: Uuid,
    },
    TakeDiagnostic {
        test_id: Uuid,
    },
    RetakeTest {
        test_id: Uuid,
        attempts_remaining: i32,
    },
    NeedsIntervention {
        test_id: Uuid,
        reason: String,
    },
    AssessmentComplete,
    LegacyMode,
}

#[derive(Debug, Clone)]
pub struct InterventionAlert {
    pub test_id: Uuid,
    pub alert_type: InterventionType,
    pub main_score: i32,
    pub variation_scores: Vec<(i32, i32)>, // (level, score) pairs
    pub message: String,
}

#[derive(Debug, Clone)]
pub enum InterventionType {
    AllVariationsFailed,
    ExcessiveAttempts,
    StuckOnVariation,
    LowProgressRate,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, EnumIter)]
pub enum ScopeEnum {
    #[strum(to_string = "course")]
    Course,
    #[strum(to_string = "grade_level")]
    GradeLevel,
    #[strum(to_string = "all-required")]
    AllRequired,
}
impl fmt::Display for ScopeEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ScopeEnum::Course => "course".to_string(),
                ScopeEnum::GradeLevel => "grade_level".to_string(),
                ScopeEnum::AllRequired => "all-required".to_string(),
            }
        )
    }
}
impl FromStr for ScopeEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "course" => Ok(ScopeEnum::Course),
            "grade_level" => Ok(ScopeEnum::GradeLevel),
            "all-required" => Ok(ScopeEnum::AllRequired),
            _ => Err(format!("Invalid scope value: {}", s)),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct RangeCategory {
    pub min: i32,
    pub max: i32,
    pub label: String,
}
impl RangeCategory {
    pub fn new(min: i32, max: i32, label: String) -> RangeCategory {
        RangeCategory { min, max, label }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter, Copy)]
pub enum SubjectEnum {
    Reading,
    Math,
    Literacy,
    Phonics,
    History,
    Science,
    SocialStudies,
    Other,
}
impl fmt::Display for SubjectEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                SubjectEnum::Reading => "Reading".to_string(),
                SubjectEnum::Math => "Math".to_string(),
                SubjectEnum::Literacy => "Literacy".to_string(),
                SubjectEnum::Phonics => "Phonics".to_string(),
                SubjectEnum::History => "History".to_string(),
                SubjectEnum::Science => "Science".to_string(),
                SubjectEnum::SocialStudies => "Social Studies".to_string(),
                SubjectEnum::Other => "Other".to_string(),
            }
        )
    }
}
impl FromStr for SubjectEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Reading" => Ok(SubjectEnum::Reading),
            "Math" => Ok(SubjectEnum::Math),
            "Literacy" => Ok(SubjectEnum::Literacy),
            "Phonics" => Ok(SubjectEnum::Phonics),
            "History" => Ok(SubjectEnum::History),
            "Science" => Ok(SubjectEnum::Science),
            "Social Studies" => Ok(SubjectEnum::SocialStudies),
            "Other" => Ok(SubjectEnum::Other),
            _ => Err(format!("Invalid subject value: {}", s)),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Assessment {
    pub name: String,
    pub frequency: Option<i32>,
    pub grade: Option<GradeEnum>,
    pub version: i32,
    pub id: Uuid,
    pub tests: Vec<Uuid>,
    pub composite_score: Option<i32>,
    pub risk_benchmarks: Option<Vec<RangeCategory>>,
    pub national_benchmarks: Option<Vec<RangeCategory>>,
    pub subject: Option<SubjectEnum>,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
    pub test_sequence: Option<Vec<TestSequenceItem>>,
}
impl Assessment {
    // Get the next test in sequence by order
    pub fn get_next_in_sequence(&self, current_order: i32) -> Option<Uuid> {
        let sequence = self.test_sequence.as_ref()?;

        sequence
            .iter()
            .find(|item| item.sequence_order == current_order + 1)
            .map(|item| item.test_id)
    }

    /// Get the next variation level for a failed test
    pub fn get_next_variation_level(
        &self,
        main_test_id: Uuid,
        student_history: &[(Uuid, i32)],
        main_item: &TestSequenceItem,
    ) -> Option<Uuid> {
        let variations = main_item.variation_levels.as_ref()?;

        let attempted_tests: std::collections::HashSet<Uuid> = student_history
            .iter()
            .map(|(test_id, _)| *test_id)
            .collect();

        for level in 1..=3 {
            if let Some(variation) = variations.iter().find(|v| v.level == level) {
                if !attempted_tests.contains(&variation.test_id) {
                    return Some(variation.test_id);
                }
            }
        }

        None
    }

    /// Legacy get_next_test method for backward compatibility
    pub fn get_next_test(&self, current_test_id: Uuid, score: Option<i32>) -> Option<Uuid> {
        let sequence = self.test_sequence.as_ref()?;
        let current_item = sequence
            .iter()
            .find(|item| item.test_id == current_test_id)?;

        match current_item.sequence_behavior {
            SequenceBehavior::Node => self.get_next_in_sequence(current_item.sequence_order),
            SequenceBehavior::Attainment => {
                let score = score?;
                let required_score = current_item.required_score.unwrap_or(70);

                if score >= required_score {
                    current_item
                        .next_on_pass
                        .or_else(|| self.get_next_in_sequence(current_item.sequence_order))
                } else {
                    current_item
                        .next_on_fail
                        .or_else(|| self.get_next_in_sequence(current_item.sequence_order))
                }
            }
            SequenceBehavior::Branching => {
                if let Some(score) = score {
                    if let Some(ranges) = &current_item.score_ranges {
                        for range in ranges {
                            if score >= range.min && score <= range.max {
                                return range.next_test;
                            }
                        }
                    }
                }
                self.get_next_in_sequence(current_item.sequence_order)
            }
            _ => self.get_next_in_sequence(current_item.sequence_order),
        }
    }

    /// Create a new Assessment with legacy test list (no sequences)
    pub fn new(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        id: Uuid,
        tests: Vec<Uuid>,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> Assessment {
        Assessment {
            name,
            frequency,
            grade,
            version,
            id,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: None,
        }
    }
    pub fn new_with_sequence(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        id: Uuid,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
        test_sequence: Vec<TestSequenceItem>,
    ) -> Assessment {
        // Extract ALL test IDs including variations for backward compatibility
        let mut tests = Vec::new();

        for item in &test_sequence {
            // Add main test ID
            tests.push(item.test_id);

            // Add variation test IDs if they exist
            if let Some(variations) = &item.variation_levels {
                for variation in variations {
                    tests.push(variation.test_id);
                }
            }
        }

        Assessment {
            name,
            frequency,
            grade,
            version,
            id,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: Some(test_sequence),
        }
    }

    /// Get the next test with comprehensive multi-level variation logic
    pub fn get_next_test_adaptive(
        &self,
        current_test_id: Uuid,
        score: Option<i32>,
        student_history: &[(Uuid, i32)],
        all_tests: &[Test],
    ) -> Option<Uuid> {
        let sequence = self.test_sequence.as_ref()?;

        // Check if current test is a variation test
        if let Some(main_test_id) = self.find_main_test_for_variation(current_test_id) {
            return self.handle_variation_completion(
                main_test_id,
                current_test_id,
                score?,
                student_history,
            );
        }

        // Handle main test completion
        let current_item = sequence
            .iter()
            .find(|item| item.test_id == current_test_id)?;

        match current_item.sequence_behavior {
            SequenceBehavior::Attainment => {
                let score = score?;
                let required_score = current_item.required_score?;

                if score >= required_score {
                    // Passed main test: continue to next in sequence
                    current_item
                        .next_on_pass
                        .or_else(|| self.get_next_in_sequence(current_item.sequence_order))
                } else {
                    // Failed main test: try variations
                    self.get_next_variation_level(current_test_id, student_history, current_item)
                        .or_else(|| {
                            // No more variations: use fallback or continue
                            current_item
                                .next_on_fail
                                .or_else(|| self.get_next_in_sequence(current_item.sequence_order))
                        })
                }
            }
            _ => {
                // Other behaviors use existing logic
                self.get_next_test(current_test_id, score)
            }
        }
    }

    /// Find the main test ID for a variation test
    fn find_main_test_for_variation(&self, variation_test_id: Uuid) -> Option<Uuid> {
        let sequence = self.test_sequence.as_ref()?;

        for item in sequence {
            if let Some(variations) = &item.variation_levels {
                if variations.iter().any(|v| v.test_id == variation_test_id) {
                    return Some(item.test_id);
                }
            }
        }
        None
    }

    /// Handle completion of a variation test
    fn handle_variation_completion(
        &self,
        main_test_id: Uuid,
        variation_test_id: Uuid,
        score: i32,
        student_history: &[(Uuid, i32)],
    ) -> Option<Uuid> {
        let sequence = self.test_sequence.as_ref()?;
        let main_item = sequence.iter().find(|item| item.test_id == main_test_id)?;
        let variations = main_item.variation_levels.as_ref()?;

        let current_variation = variations.iter().find(|v| v.test_id == variation_test_id)?;
        let required_score = current_variation.required_score.unwrap_or(60);

        if score >= required_score {
            // Passed variation: continue to next test in main sequence
            main_item
                .next_on_pass
                .or_else(|| self.get_next_in_sequence(main_item.sequence_order))
        } else {
            // Failed variation: try next level or end
            let next_level = current_variation.level + 1;

            if let Some(next_variation) = variations.iter().find(|v| v.level == next_level) {
                // Check if this level has already been attempted
                let attempted = student_history
                    .iter()
                    .any(|(id, _)| *id == next_variation.test_id);
                if !attempted {
                    return Some(next_variation.test_id);
                }
            }

            // No more variations available: continue or flag for intervention
            main_item
                .next_on_pass
                .or_else(|| self.get_next_in_sequence(main_item.sequence_order))
        }
    }

    /// Get detailed progression status for a student
    pub fn get_progression_status(
        &self,
        student_history: &[(Uuid, i32)],
        all_tests: &[Test],
    ) -> AssessmentProgressionStatus {
        let sequence = match self.test_sequence.as_ref() {
            Some(seq) => seq,
            None => return AssessmentProgressionStatus::legacy_mode(),
        };

        let mut completed_main_tests = 0;
        let mut total_main_tests = 0;
        let mut variation_attempts = 0;
        let mut intervention_needed = Vec::new();
        let completed_tests: std::collections::HashMap<Uuid, i32> =
            student_history.iter().cloned().collect();

        for item in sequence {
            match item.sequence_behavior {
                SequenceBehavior::Attainment | SequenceBehavior::Node => {
                    total_main_tests += 1;

                    if let Some(&score) = completed_tests.get(&item.test_id) {
                        if item.sequence_behavior == SequenceBehavior::Attainment {
                            let required = item.required_score.unwrap_or(70);
                            if score >= required {
                                completed_main_tests += 1;
                            } else {
                                // Check variation attempts
                                if let Some(variations) = &item.variation_levels {
                                    let mut attempted_all_variations = true;
                                    let mut passed_any_variation = false;

                                    for variation in variations {
                                        if let Some(&var_score) =
                                            completed_tests.get(&variation.test_id)
                                        {
                                            variation_attempts += 1;
                                            let var_required =
                                                variation.required_score.unwrap_or(60);
                                            if var_score >= var_required {
                                                passed_any_variation = true;
                                                completed_main_tests += 1;
                                                break;
                                            }
                                        } else {
                                            attempted_all_variations = false;
                                            break;
                                        }
                                    }

                                    if attempted_all_variations && !passed_any_variation {
                                        intervention_needed.push(item.test_id);
                                    }
                                }
                            }
                        } else {
                            completed_main_tests += 1;
                        }
                    }
                }
                _ => {} // Skip optional, diagnostic, etc. for main progress
            }
        }

        let completion_percentage = if total_main_tests > 0 {
            (completed_main_tests as f32 / total_main_tests as f32) * 100.0
        } else {
            0.0
        };

        AssessmentProgressionStatus {
            total_main_tests,
            completed_main_tests,
            completion_percentage,
            variation_attempts,
            intervention_needed,
            is_complete: completed_main_tests >= total_main_tests,
        }
    }

    /// Get recommended next action for a student
    pub fn get_recommended_action(
        &self,
        student_history: &[(Uuid, i32)],
        all_tests: &[Test],
    ) -> RecommendedAction {
        let sequence = match self.test_sequence.as_ref() {
            Some(seq) => seq,
            None => return RecommendedAction::LegacyMode,
        };

        let completed_tests: std::collections::HashMap<Uuid, i32> =
            student_history.iter().cloned().collect();

        // Find the first incomplete main test
        for item in sequence {
            match item.sequence_behavior {
                SequenceBehavior::Attainment | SequenceBehavior::Node => {
                    if let Some(&score) = completed_tests.get(&item.test_id) {
                        // Test attempted - check if passed
                        if item.sequence_behavior == SequenceBehavior::Attainment {
                            let required = item.required_score.unwrap_or(70);
                            if score < required {
                                // Failed main test - check variations
                                if let Some(variations) = &item.variation_levels {
                                    // Sort variations by level to ensure proper order
                                    let sorted_variations: Vec<&VariationLevel> =
                                        variations.iter().sorted_by_key(|v| v.level).collect();

                                    for variation in sorted_variations {
                                        if !completed_tests.contains_key(&variation.test_id) {
                                            return RecommendedAction::TakeVariation {
                                                main_test_id: item.test_id,
                                                variation_test_id: variation.test_id,
                                                level: variation.level,
                                                description: variation.description.clone(),
                                            };
                                        }
                                    }
                                    // All variations attempted and failed
                                    return RecommendedAction::NeedsIntervention {
                                        test_id: item.test_id,
                                        reason: "Failed main test and all variations".to_string(),
                                    };
                                } else {
                                    // No variations available
                                    return RecommendedAction::RetakeTest {
                                        test_id: item.test_id,
                                        attempts_remaining: item.max_attempts.unwrap_or(1) - 1,
                                    };
                                }
                            }
                        }
                        // Test passed, continue to next
                    } else {
                        // Test not attempted yet
                        return RecommendedAction::TakeTest {
                            test_id: item.test_id,
                            is_required: item.sequence_behavior == SequenceBehavior::Attainment,
                        };
                    }
                }
                SequenceBehavior::Optional => {
                    if !completed_tests.contains_key(&item.test_id) {
                        return RecommendedAction::TakeOptionalTest {
                            test_id: item.test_id,
                        };
                    }
                }
                SequenceBehavior::Diagnostic => {
                    if !completed_tests.contains_key(&item.test_id) {
                        return RecommendedAction::TakeDiagnostic {
                            test_id: item.test_id,
                        };
                    }
                }
                _ => {} // Skip other types for now
            }
        }

        RecommendedAction::AssessmentComplete
    }

    /// Check if a student needs teacher intervention
    pub fn needs_intervention(&self, student_history: &[(Uuid, i32)]) -> Vec<InterventionAlert> {
        let sequence = match self.test_sequence.as_ref() {
            Some(seq) => seq,
            None => return vec![],
        };

        let mut alerts = Vec::new();
        let completed_tests: std::collections::HashMap<Uuid, i32> =
            student_history.iter().cloned().collect();

        for item in sequence {
            if item.sequence_behavior == SequenceBehavior::Attainment {
                if let Some(&main_score) = completed_tests.get(&item.test_id) {
                    let required = item.required_score.unwrap_or(70);

                    if main_score < required {
                        // Check if all variations have been attempted and failed
                        if let Some(variations) = &item.variation_levels {
                            let mut all_variations_failed = true;
                            let mut attempted_variations = 0;

                            for variation in variations {
                                if let Some(&var_score) = completed_tests.get(&variation.test_id) {
                                    attempted_variations += 1;
                                    let var_required = variation.required_score.unwrap_or(60);
                                    if var_score >= var_required {
                                        all_variations_failed = false;
                                        break;
                                    }
                                } else {
                                    all_variations_failed = false;
                                    break;
                                }
                            }

                            if all_variations_failed && attempted_variations == variations.len() {
                                alerts.push(InterventionAlert {
                                    test_id: item.test_id,
                                    alert_type: InterventionType::AllVariationsFailed,
                                    main_score,
                                    variation_scores: variations.iter()
                                        .filter_map(|v| completed_tests.get(&v.test_id).map(|&score| (v.level, score)))
                                        .collect(),
                                    message: format!(
                                        "Student failed main test ({}%) and all {} variation levels. Needs teacher support.",
                                        main_score, variations.len()
                                    ),
                                });
                            }
                        }

                        // Check for excessive attempts on main test
                        let main_attempts = student_history
                            .iter()
                            .filter(|(id, _)| *id == item.test_id)
                            .count();

                        if main_attempts >= item.max_attempts.unwrap_or(3) as usize {
                            alerts.push(InterventionAlert {
                                test_id: item.test_id,
                                alert_type: InterventionType::ExcessiveAttempts,
                                main_score,
                                variation_scores: vec![],
                                message: format!(
                                    "Student has used all {} attempts on main test with best score of {}%",
                                    main_attempts, main_score
                                ),
                            });
                        }
                    }
                }
            }
        }

        alerts
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, Clone)]
pub struct CreateNewAssessmentRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub name: String,
    pub frequency: Option<i32>,
    pub grade: Option<GradeEnum>,
    pub version: i32,
    pub tests: Vec<Uuid>,
    pub composite_score: Option<i32>,
    pub risk_benchmarks: Option<Vec<RangeCategory>>,
    pub national_benchmarks: Option<Vec<RangeCategory>>,
    pub subject: Option<SubjectEnum>,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
    pub test_sequence: Option<Vec<TestSequenceItem>>,
}
impl CreateNewAssessmentRequest {
    pub fn new(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        tests: Vec<Uuid>,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> CreateNewAssessmentRequest {
        CreateNewAssessmentRequest {
            name,
            frequency,
            grade,
            version,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: None,
        }
    }
    pub fn new_with_sequence(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
        test_sequence: Vec<TestSequenceItem>,
    ) -> CreateNewAssessmentRequest {
        // Extract ALL test IDs including variations for backward compatibility
        let mut tests = Vec::new();

        for item in &test_sequence {
            tests.push(item.test_id);
            if let Some(variations) = &item.variation_levels {
                for variation in variations {
                    tests.push(variation.test_id);
                }
            }
        }

        CreateNewAssessmentRequest {
            name,
            frequency,
            grade,
            version,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: Some(test_sequence),
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, Clone)]
pub struct UpdateAssessmentRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub name: String,
    pub frequency: Option<i32>,
    pub grade: Option<GradeEnum>,
    pub version: i32,
    pub id: Uuid,
    pub tests: Vec<Uuid>,
    pub composite_score: Option<i32>,
    pub risk_benchmarks: Option<Vec<RangeCategory>>,
    pub national_benchmarks: Option<Vec<RangeCategory>>,
    pub subject: Option<SubjectEnum>,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
    pub test_sequence: Option<Vec<TestSequenceItem>>,
}
impl UpdateAssessmentRequest {
    pub fn new(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        id: Uuid,
        tests: Vec<Uuid>,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> UpdateAssessmentRequest {
        UpdateAssessmentRequest {
            name,
            frequency,
            grade,
            version,
            id,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: None,
        }
    }
    pub fn new_with_sequence(
        name: String,
        frequency: Option<i32>,
        grade: Option<GradeEnum>,
        version: i32,
        id: Uuid,
        composite_score: Option<i32>,
        risk_benchmarks: Option<Vec<RangeCategory>>,
        national_benchmarks: Option<Vec<RangeCategory>>,
        subject: Option<SubjectEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
        test_sequence: Vec<TestSequenceItem>,
    ) -> UpdateAssessmentRequest {
        // Extract ALL test IDs including variations for backward compatibility
        let mut tests = Vec::new();

        for item in &test_sequence {
            tests.push(item.test_id);
            if let Some(variations) = &item.variation_levels {
                for variation in variations {
                    tests.push(variation.test_id);
                }
            }
        }

        UpdateAssessmentRequest {
            name,
            frequency,
            grade,
            version,
            id,
            tests,
            composite_score,
            risk_benchmarks,
            national_benchmarks,
            subject,
            scope,
            course_id,
            test_sequence: Some(test_sequence),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct DeleteAssessmentRequest {
    pub version: i32,
    pub id: Uuid,
}
impl DeleteAssessmentRequest {
    pub fn new(version: i32, id: Uuid) -> DeleteAssessmentRequest {
        DeleteAssessmentRequest { version, id }
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer, PgHasArrayType}, encode::IsNull};
        use sqlx::prelude::*;
        use sqlx::types::Json;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for SubjectEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for SubjectEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                SubjectEnum::from_str(s).map_err(|_| format!("Invalid SubjectEnum: {}", s).into())
            }
        }
        impl Type<Postgres> for SubjectEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("subject_enum")
            }
        }

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for RangeCategory {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(self).encode_by_ref(buf)
            }
        }
        impl sqlx::Type<sqlx::Postgres> for RangeCategory {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("jsonb")
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for RangeCategory {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<RangeCategory> = sqlx::decode::Decode::decode(value)?;
                Ok(json.0)
            }
        }
        impl sqlx::postgres::PgHasArrayType for RangeCategory {
            fn array_type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("_jsonb")
            }
        }
        impl <'q> sqlx::encode::Encode<'q, sqlx::Postgres> for ScopeEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for ScopeEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                ScopeEnum::from_str(s).map_err(|_| format!("Invalid ScopeEnum: {}", s).into())
            }
        }
        impl sqlx::Type<sqlx::Postgres> for ScopeEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("assessment_scope_enum")
            }
        }

        ///Create wrapper for new type Vec<RangeCategory> to solve orphan rule issue in rust
        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
        pub struct RangeCategoriesWrapper(pub Vec<RangeCategory>);

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for RangeCategoriesWrapper {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(&self.0).encode_by_ref(buf)
            }
        }

        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for RangeCategoriesWrapper {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<Vec<RangeCategory>> = sqlx::decode::Decode::decode(value)?;
                Ok(RangeCategoriesWrapper(json.0))
            }
        }
    }
}
use crate::app::models::test::Test;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::str::FromStr;
use strum_macros::EnumIter;
use uuid::Uuid;

#[derive(Debug, Clone)]
pub enum TestStatus {
    NotAttempted,
    Completed(i32),
    Passed(i32),
    Failed(i32),
}

#[derive(Debug, Clone)]
pub struct VariationStatus {
    pub level: i32,
    pub test_name: String,
    pub test_id: Uuid,
    pub status: TestStatus,
    pub description: String,
}

#[derive(Debug, Clone)]
pub struct LearningPathItem {
    pub test_name: String,
    pub test_id: Uuid,
    pub behavior: SequenceBehavior,
    pub status: TestStatus,
    pub required_score: Option<i32>,
    pub variations: Vec<VariationStatus>,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct VariationLevel {
    pub level: i32, // 1, 2, or 3
    pub test_id: Uuid,
    pub required_score: Option<i32>, // Score needed to pass this variation
    pub max_attempts: Option<i32>,   // Attempts allowed at this level
    pub description: String,         // "Practice A", "Remedial", "Guided", etc.
}

impl VariationLevel {
    pub fn new(level: i32, test_id: Uuid, description: String) -> Self {
        VariationLevel {
            level,
            test_id,
            required_score: Some(60), // Default lower threshold for variations
            max_attempts: Some(2),
            description,
        }
    }

    pub fn new_with_score(
        level: i32,
        test_id: Uuid,
        description: String,
        required_score: i32,
    ) -> Self {
        VariationLevel {
            level,
            test_id,
            required_score: Some(required_score),
            max_attempts: Some(2),
            description,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, EnumIter)]
pub enum SequenceBehavior {
    #[strum(to_string = "attainment")]
    Attainment,
    #[strum(to_string = "node")]
    Node,
    #[strum(to_string = "optional")]
    Optional,
    #[strum(to_string = "diagnostic")]
    Diagnostic,
    #[strum(to_string = "remediation")]
    Remediation,
    #[strum(to_string = "branching")]
    Branching,
}

impl fmt::Display for SequenceBehavior {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                SequenceBehavior::Attainment => "attainment",
                SequenceBehavior::Node => "node",
                SequenceBehavior::Optional => "optional",
                SequenceBehavior::Diagnostic => "diagnostic",
                SequenceBehavior::Remediation => "remediation",
                SequenceBehavior::Branching => "branching",
            }
        )
    }
}

impl FromStr for SequenceBehavior {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "attainment" | "Attainment" => Ok(SequenceBehavior::Attainment),
            "node" | "Node" => Ok(SequenceBehavior::Node),
            "optional" | "Optional" => Ok(SequenceBehavior::Optional),
            "diagnostic" | "Diagnostic" => Ok(SequenceBehavior::Diagnostic),
            "remediation" | "Remediation" => Ok(SequenceBehavior::Remediation),
            "branching" | "Branching" => Ok(SequenceBehavior::Branching),
            _ => Err(format!("Invalid sequence behavior value: {}", s)),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct ScoreRange {
    pub min: i32,
    pub max: i32,
    pub next_test: Option<Uuid>,
}

impl ScoreRange {
    pub fn new(min: i32, max: i32, next_test: Option<Uuid>) -> Self {
        ScoreRange {
            min,
            max,
            next_test,
        }
    }
}

// Updated TestSequenceItem with multi-level variation support
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct TestSequenceItem {
    pub test_id: Uuid,
    pub sequence_behavior: SequenceBehavior,
    pub sequence_order: i32,
    pub required_score: Option<i32>,
    pub next_on_pass: Option<Uuid>,
    pub next_on_fail: Option<Uuid>,
    pub variation_levels: Option<Vec<VariationLevel>>,
    pub score_ranges: Option<Vec<ScoreRange>>,
    pub max_attempts: Option<i32>,
    pub time_limit_minutes: Option<i32>,
    pub prerequisite_tests: Option<Vec<Uuid>>,
    pub skip_conditions: Option<Vec<Uuid>>,
    pub show_feedback: bool,
    pub allow_review: bool,
    pub randomize_questions: bool,
    pub adaptive_difficulty: bool,
}

impl TestSequenceItem {
    pub fn new_node(test_id: Uuid, sequence_order: i32) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Node,
            sequence_order,
            required_score: None,
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: None,
            score_ranges: None,
            max_attempts: Some(1),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: true,
            allow_review: false,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    pub fn new_attainment(
        test_id: Uuid,
        sequence_order: i32,
        required_score: i32,
        next_on_pass: Option<Uuid>,
        next_on_fail: Option<Uuid>,
    ) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Attainment,
            sequence_order,
            required_score: Some(required_score),
            next_on_pass,
            next_on_fail,
            variation_levels: None,
            score_ranges: None,
            max_attempts: Some(3),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: true,
            allow_review: true,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    // NEW: Create attainment with multi-level variations
    pub fn new_attainment_with_variations(
        test_id: Uuid,
        sequence_order: i32,
        required_score: i32,
        variation_levels: Vec<VariationLevel>,
    ) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Attainment,
            sequence_order,
            required_score: Some(required_score),
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: Some(variation_levels),
            score_ranges: None,
            max_attempts: Some(3),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: true,
            allow_review: true,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    pub fn new_branching(
        test_id: Uuid,
        sequence_order: i32,
        score_ranges: Vec<ScoreRange>,
    ) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Branching,
            sequence_order,
            required_score: None,
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: None,
            score_ranges: Some(score_ranges),
            max_attempts: Some(1),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: true,
            allow_review: false,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    pub fn new_optional(test_id: Uuid, sequence_order: i32) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Optional,
            sequence_order,
            required_score: None,
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: None,
            score_ranges: None,
            max_attempts: Some(1),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: true,
            allow_review: true,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    pub fn new_diagnostic(test_id: Uuid, sequence_order: i32) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Diagnostic,
            sequence_order,
            required_score: None,
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: None,
            score_ranges: None,
            max_attempts: Some(1),
            time_limit_minutes: None,
            prerequisite_tests: None,
            skip_conditions: None,
            show_feedback: false,
            allow_review: false,
            randomize_questions: true,
            adaptive_difficulty: true,
        }
    }

    pub fn new_remediation(
        test_id: Uuid,
        sequence_order: i32,
        prerequisite_tests: Vec<Uuid>,
    ) -> Self {
        TestSequenceItem {
            test_id,
            sequence_behavior: SequenceBehavior::Remediation,
            sequence_order,
            required_score: None,
            next_on_pass: None,
            next_on_fail: None,
            variation_levels: None,
            score_ranges: None,
            max_attempts: Some(5),
            time_limit_minutes: None,
            prerequisite_tests: Some(prerequisite_tests),
            skip_conditions: None,
            show_feedback: true,
            allow_review: true,
            randomize_questions: false,
            adaptive_difficulty: false,
        }
    }

    // NEW: Helper methods for variation support
    pub fn has_variations(&self) -> bool {
        self.variation_levels
            .as_ref()
            .map(|v| !v.is_empty())
            .unwrap_or(false)
    }

    pub fn get_variation_count(&self) -> usize {
        self.variation_levels.as_ref().map(|v| v.len()).unwrap_or(0)
    }

    pub fn get_variation_by_level(&self, level: i32) -> Option<&VariationLevel> {
        self.variation_levels
            .as_ref()?
            .iter()
            .find(|v| v.level == level)
    }

    pub fn add_variation_level(&mut self, variation: VariationLevel) {
        if let Some(ref mut variations) = self.variation_levels {
            variations.push(variation);
            variations.sort_by_key(|v| v.level);
        } else {
            self.variation_levels = Some(vec![variation]);
        }
    }

    pub fn remove_variation_level(&mut self, level: i32) {
        if let Some(ref mut variations) = self.variation_levels {
            variations.retain(|v| v.level != level);
            if variations.is_empty() {
                self.variation_levels = None;
            }
        }
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::types::Json;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for SequenceBehavior {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for SequenceBehavior {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                SequenceBehavior::from_str(s).map_err(|_| format!("Invalid SequenceBehavior: {}", s).into())
            }
        }
        impl Type<Postgres> for SequenceBehavior {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("sequence_behavior_enum")
            }
        }

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for VariationLevel {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(self).encode_by_ref(buf)
            }
        }
        impl sqlx::Type<sqlx::Postgres> for VariationLevel {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("jsonb")
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for VariationLevel {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<VariationLevel> = sqlx::decode::Decode::decode(value)?;
                Ok(json.0)
            }
        }

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for TestSequenceItem {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(self).encode_by_ref(buf)
            }
        }
        impl sqlx::Type<sqlx::Postgres> for TestSequenceItem {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("jsonb")
            }
        }
        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for TestSequenceItem {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<TestSequenceItem> = sqlx::decode::Decode::decode(value)?;
                Ok(json.0)
            }
        }
    }
}
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
#[cfg(feature = "ssr")]
use sqlx::FromRow;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UserSettings {
    pub ui: UiSettings,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UiSettings {
    pub dark_mode: bool,
    pub pinned_sidebar: bool,
}
impl Default for UserSettings {
    fn default() -> Self {
        Self {
            ui: UiSettings::default(),
        }
    }
}
impl Default for UiSettings {
    fn default() -> Self {
        Self {
            dark_mode: false,
            pinned_sidebar: false,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserSettingsUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ui: Option<UiSettingsUpdate>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UiSettingsUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dark_mode: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pinned_sidebar: Option<bool>,
}
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalSetting {
    pub key_name: String,
    pub value: String,
    pub updated_by: i32,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SettingsCache {
    pub student_protections: bool,
    // Add other global settings here as needed
    pub maintenance_mode: bool,
    pub max_upload_size: i64,
    // etc.
}

impl SettingsCache {
    pub fn from_settings(settings: Vec<GlobalSetting>) -> Self {
        let mut cache = SettingsCache::default();

        for setting in settings {
            match setting.key_name.as_str() {
                "student_protections" => {
                    cache.student_protections = setting.value.parse().unwrap_or(false);
                }
                "maintenance_mode" => {
                    cache.maintenance_mode = setting.value.parse().unwrap_or(false);
                }
                "max_upload_size" => {
                    cache.max_upload_size = setting.value.parse().unwrap_or(10485760);
                    // 10MB default
                }
                _ => {} // Ignore unknown settings
            }
        }

        cache
    }
}
use crate::app::models::employee::{Employee, EmployeeRole, StatusEnum};
use crate::app::models::student::GradeEnum;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};

impl Employee {
    pub fn new_teacher(
        id: i32,
        firstname: String,
        lastname: String,
        status: StatusEnum,
        grade: Option<GradeEnum>,
    ) -> Self {
        Self::new(
            id,
            firstname,
            lastname,
            status,
            EmployeeRole::Teacher { grade },
        )
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct AddNewTeacherRequest {
    pub firstname: String,
    pub lastname: String,
}

impl AddNewTeacherRequest {
    pub fn new(firstname: String, lastname: String) -> AddNewTeacherRequest {
        AddNewTeacherRequest {
            firstname,
            lastname,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct DeleteTeacherRequest {
    pub id: i32,
}

impl DeleteTeacherRequest {
    pub fn new(id: i32) -> DeleteTeacherRequest {
        DeleteTeacherRequest { id }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct UpdateTeacherRequest {
    pub id: i32,
    pub firstname: String,
    pub lastname: String,
    pub status: StatusEnum,
    pub grade: Option<GradeEnum>,
}

impl UpdateTeacherRequest {
    pub fn new(
        id: i32,
        firstname: String,
        lastname: String,
        status: StatusEnum,
        grade: Option<GradeEnum>,
    ) -> UpdateTeacherRequest {
        UpdateTeacherRequest {
            id,
            firstname,
            lastname,
            status,
            grade,
        }
    }
}
use crate::app::models::user::UserRole;
use chrono::{DateTime, Utc};
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::str::FromStr;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuthProvider {
    Local,
    Saml(String), // Institution ID
    Google,
    Microsoft,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JwtClaims {
    pub sub: String, // User ID
    pub username: String,
    pub email: String,
    pub role: UserRole,
    pub auth_provider: AuthProvider,
    pub session_id: String,
    pub institution_id: Option<String>,
    pub iat: i64,    // Issued at
    pub exp: i64,    // Expiration
    pub iss: String, // Issuer
    pub aud: String, // Audience
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SamlConfig {
    pub id: Uuid,
    pub institution_name: String,
    pub entity_id: String,
    pub sso_url: String,
    pub slo_url: Option<String>,
    pub x509_cert: String,
    pub metadata_url: Option<String>,
    pub active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub attribute_mapping: HashMap<String, String>,
    pub role_mapping: HashMap<String, String>,
    pub auto_provision: bool,
    pub require_encrypted_assertions: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SamlResponse {
    pub name_id: String,
    pub email: Option<String>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub display_name: Option<String>,
    pub attributes: HashMap<String, Vec<String>>,
    pub session_index: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthSession {
    pub id: String,
    pub user_id: i64,
    pub auth_provider: AuthProvider,
    pub institution_id: Option<String>,
    pub expires_at: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AccountStatus {
    Pending,
    Active,
    Suspended,
    Deleted,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserJwt {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub role: UserRole,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub role: UserRole,
    pub account_status: AccountStatus,
    pub email_verified: bool,
    pub display_name: Option<String>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginCredentials {
    pub username: String,
    pub password: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthResponse {
    pub token: String,
    pub user: UserJwt,
}

// For registration
#[derive(Debug, Serialize, Deserialize)]
pub struct RegisterRequest {
    pub username: String,
    pub email: String,
    pub password: String,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
}
use chrono::NaiveDate;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug, Display};
use std::str::FromStr;
use strum::IntoEnumIterator;
use strum_macros::EnumIter;
use validator::Validate;

//this section instantiates all the enums and their corresponding formatting
#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum GenderEnum {
    Male,
    Female,
    Nonbinary,
}
impl fmt::Display for GenderEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                GenderEnum::Male => "Male".to_string(),
                GenderEnum::Female => "Female".to_string(),
                GenderEnum::Nonbinary => "Non-binary".to_string(),
            }
        )
    }
}
impl FromStr for GenderEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Male" => Ok(GenderEnum::Male),
            "Female" => Ok(GenderEnum::Female),
            "Non-binary" => Ok(GenderEnum::Nonbinary),
            _ => Err(format!("Invalid gender value: {}", s)),
        }
    }
}
#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum ESLEnum {
    NotApplicable,
    Spanish,
    Arabic,
    Mandarin,
    Cantonese,
    Vietnamese,
    Nepali,
    French,
    Russian,
    Somali,
    Amharic,
    Hindi,
    Telugu,
    Tamil,
    Other,
}
impl fmt::Display for ESLEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ESLEnum::NotApplicable => "Not Applicable".to_string(),
                ESLEnum::Spanish => "Spanish".to_string(),
                ESLEnum::Arabic => "Arabic".to_string(),
                ESLEnum::Mandarin => "Mandarin".to_string(),
                ESLEnum::Cantonese => "Cantonese".to_string(),
                ESLEnum::Vietnamese => "Vietnamese".to_string(),
                ESLEnum::Nepali => "Nepali".to_string(),
                ESLEnum::French => "French".to_string(),
                ESLEnum::Russian => "Russian".to_string(),
                ESLEnum::Somali => "Somali".to_string(),
                ESLEnum::Amharic => "Amharic".to_string(),
                ESLEnum::Hindi => "Hindi".to_string(),
                ESLEnum::Telugu => "Telugu".to_string(),
                ESLEnum::Tamil => "Tamil".to_string(),
                ESLEnum::Other => "Other".to_string(),
            }
        )
    }
}
impl FromStr for ESLEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Not Applicable" => Ok(ESLEnum::NotApplicable),
            "Spanish" => Ok(ESLEnum::Spanish),
            "Arabic" => Ok(ESLEnum::Arabic),
            "Mandarin" => Ok(ESLEnum::Mandarin),
            "Cantonese" => Ok(ESLEnum::Cantonese),
            "Vietnamese" => Ok(ESLEnum::Vietnamese),
            "Nepali" => Ok(ESLEnum::Nepali),
            "French" => Ok(ESLEnum::French),
            "Russian" => Ok(ESLEnum::Russian),
            "Somali" => Ok(ESLEnum::Somali),
            "Amharic" => Ok(ESLEnum::Amharic),
            "Hindi" => Ok(ESLEnum::Hindi),
            "Telugu" => Ok(ESLEnum::Telugu),
            "Tamil" => Ok(ESLEnum::Tamil),
            "Other" => Ok(ESLEnum::Other),
            _ => Err(format!("Invalid ESL value: {}", s)),
        }
    }
}
#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum GradeEnum {
    Kindergarten,
    First,
    Second,
    Third,
    Fourth,
    Fifth,
    Sixth,
    Seventh,
    Eighth,
    Ninth,
    Tenth,
    Eleventh,
    Twelfth,
}
impl fmt::Display for GradeEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                GradeEnum::Kindergarten => "Kindergarten".to_string(),
                GradeEnum::First => "1st Grade".to_string(),
                GradeEnum::Second => "2nd Grade".to_string(),
                GradeEnum::Third => "3rd Grade".to_string(),
                GradeEnum::Fourth => "4th Grade".to_string(),
                GradeEnum::Fifth => "5th Grade".to_string(),
                GradeEnum::Sixth => "6th Grade".to_string(),
                GradeEnum::Seventh => "7th Grade".to_string(),
                GradeEnum::Eighth => "8th Grade".to_string(),
                GradeEnum::Ninth => "9th Grade".to_string(),
                GradeEnum::Tenth => "10th Grade".to_string(),
                GradeEnum::Eleventh => "11th Grade".to_string(),
                GradeEnum::Twelfth => "12th Grade".to_string(),
            }
        )
    }
}
impl FromStr for GradeEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Kindergarten" => Ok(GradeEnum::Kindergarten),
            "1st Grade" => Ok(GradeEnum::First),
            "2nd Grade" => Ok(GradeEnum::Second),
            "3rd Grade" => Ok(GradeEnum::Third),
            "4th Grade" => Ok(GradeEnum::Fourth),
            "5th Grade" => Ok(GradeEnum::Fifth),
            "6th Grade" => Ok(GradeEnum::Sixth),
            "7th Grade" => Ok(GradeEnum::Seventh),
            "8th Grade" => Ok(GradeEnum::Eighth),
            "9th Grade" => Ok(GradeEnum::Ninth),
            "10th Grade" => Ok(GradeEnum::Tenth),
            "11th Grade" => Ok(GradeEnum::Eleventh),
            "12th Grade" => Ok(GradeEnum::Twelfth),
            _ => Err(format!("Invalid grade value: {}", s)),
        }
    }
}
#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum InterventionEnum {
    Literacy,
    Math,
    Both,
}
impl fmt::Display for InterventionEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                InterventionEnum::Literacy => "Literacy".to_string(),
                InterventionEnum::Math => "Math".to_string(),
                InterventionEnum::Both => "Literacy and Math".to_string(),
            }
        )
    }
}
impl FromStr for InterventionEnum {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Literacy" => Ok(InterventionEnum::Literacy),
            "Math" => Ok(InterventionEnum::Math),
            "Literacy and Math" => Ok(InterventionEnum::Both),
            _ => Err(format!("Invalid intervention enum value: {}", s)),
        }
    }
}
//this object instantiates a student on the client side for use in reading and writing data from
//the database
#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Student {
    pub firstname: Option<String>, //firstname, lastname, and pin are considered PII and need to
    //have Option<> wrapper so they can be nulled out
    pub lastname: Option<String>,
    pub preferred: String,
    pub gender: GenderEnum,
    pub date_of_birth: NaiveDate,
    #[validate(range(min = 0, max = 2000000000))]
    pub student_id: i32,
    pub esl: ESLEnum,
    pub current_grade_level: GradeEnum,
    pub teacher: String,
    pub iep: bool,
    pub bip: bool,
    pub student_504: bool,
    pub readplan: bool,
    pub gt: bool,
    pub intervention: Option<InterventionEnum>,
    pub eye_glasses: bool,
    pub notes: String,
    pub pin: Option<i32>,
}

impl Student {
    pub fn new(
        firstname: Option<String>,
        lastname: Option<String>,
        preferred: String,
        gender: GenderEnum,
        date_of_birth: NaiveDate,
        student_id: i32,
        esl: ESLEnum,
        current_grade_level: GradeEnum,
        teacher: String,
        iep: bool,
        bip: bool,
        student_504: bool,
        readplan: bool,
        gt: bool,
        intervention: Option<InterventionEnum>,
        eye_glasses: bool,
        notes: String,
        pin: Option<i32>,
    ) -> Student {
        Student {
            firstname,
            lastname,
            preferred,
            gender,
            date_of_birth,
            student_id,
            esl,
            current_grade_level,
            teacher,
            iep,
            bip,
            student_504,
            readplan,
            gt,
            intervention,
            eye_glasses,
            notes,
            pin,
        }
    }
}

//this function is the client-side initalization Writing a new Student into the database
#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct AddStudentRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub firstname: String,
    #[validate(length(min = 1, message = "name is required"))]
    pub lastname: String,
    pub preferred: String,
    pub gender: GenderEnum,
    pub date_of_birth: NaiveDate,
    #[validate(range(min = 0, max = 2000000000))]
    pub student_id: i32,
    pub esl: ESLEnum,
    pub current_grade_level: GradeEnum,
    pub teacher: String,
    pub iep: bool,
    pub bip: bool,
    pub student_504: bool,
    pub readplan: bool,
    pub gt: bool,
    pub intervention: Option<InterventionEnum>,
    pub eye_glasses: bool,
    pub notes: String,
    pub pin: i32,
}

impl AddStudentRequest {
    pub fn new(
        firstname: String,
        lastname: String,
        preferred: String,
        gender: GenderEnum,
        date_of_birth: NaiveDate,
        student_id: i32,
        esl: ESLEnum,
        current_grade_level: GradeEnum,
        teacher: String,
        iep: bool,
        bip: bool,
        student_504: bool,
        readplan: bool,
        gt: bool,
        intervention: Option<InterventionEnum>,
        eye_glasses: bool,
        notes: String,
        pin: i32,
    ) -> AddStudentRequest {
        AddStudentRequest {
            firstname,
            lastname,
            preferred,
            gender,
            date_of_birth,
            student_id,
            esl,
            current_grade_level,
            teacher,
            iep,
            bip,
            student_504,
            readplan,
            gt,
            intervention,
            eye_glasses,
            notes,
            pin,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct UpdateStudentRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub firstname: String,
    #[validate(length(min = 1, message = "name is required"))]
    pub lastname: String,
    pub preferred: String,
    pub gender: GenderEnum,
    pub date_of_birth: NaiveDate,
    #[validate(range(min = 0, max = 2000000000))]
    pub student_id: i32,
    pub esl: ESLEnum,
    pub current_grade_level: GradeEnum,
    pub teacher: String,
    pub iep: bool,
    pub bip: bool,
    pub student_504: bool,
    pub readplan: bool,
    pub gt: bool,
    pub intervention: Option<InterventionEnum>,
    pub eye_glasses: bool,
    pub notes: String,
    pub pin: i32,
}

impl UpdateStudentRequest {
    pub fn new(
        firstname: String,
        lastname: String,
        preferred: String,
        gender: GenderEnum,
        date_of_birth: NaiveDate,
        student_id: i32,
        esl: ESLEnum,
        current_grade_level: GradeEnum,
        teacher: String,
        iep: bool,
        bip: bool,
        student_504: bool,
        readplan: bool,
        gt: bool,
        intervention: Option<InterventionEnum>,
        eye_glasses: bool,
        notes: String,
        pin: i32,
    ) -> UpdateStudentRequest {
        UpdateStudentRequest {
            firstname,
            lastname,
            preferred,
            gender,
            date_of_birth,
            student_id,
            esl,
            current_grade_level,
            teacher,
            iep,
            bip,
            student_504,
            readplan,
            gt,
            intervention,
            eye_glasses,
            notes,
            pin,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct DeleteStudentRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub firstname: String,
    #[validate(length(min = 1, message = "name is required"))]
    pub lastname: String,
    pub student_id: i32,
}

impl DeleteStudentRequest {
    pub fn new(firstname: String, lastname: String, student_id: i32) -> DeleteStudentRequest {
        DeleteStudentRequest {
            firstname,
            lastname,
            student_id,
        }
    }
}

//the following functions are all gated behind the ssr feature but they allow for the encoding and decoding of the different enums inside of student
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::prelude::*;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for GenderEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, sqlx::Postgres> for GenderEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                GenderEnum::from_str(s).map_err(|_| format!("Invalid GenderEnum: {:?}", s).into())
            }
        }
        impl Type<Postgres> for GenderEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("gender_enum")
            }
        }
        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for ESLEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, sqlx::Postgres> for ESLEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                ESLEnum::from_str(s).map_err(|_| format!("Invalid ESLEnum: {:?}", s).into())
            }
        }
        impl Type<Postgres> for ESLEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("esl_enum")
            }
        }
        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for GradeEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, sqlx::Postgres> for GradeEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                GradeEnum::from_str(s).map_err(|_| format!("Invalid GradeEnum: {:?}", s).into())
            }
        }
        impl Type<Postgres> for GradeEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("grade_enum")
            }
        }
        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for InterventionEnum {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }
        impl <'r> sqlx::decode::Decode<'r, sqlx::Postgres> for InterventionEnum {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                InterventionEnum::from_str(s).map_err(|_| format!("Invalid InterventionEnum: {:?}", s).into())
            }
        }
        impl Type<Postgres> for InterventionEnum {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("intervention_enum")
            }
        }
    }
}
use crate::app::models::assessment::ScopeEnum;
use crate::app::models::student::GradeEnum;
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug};
use std::str::FromStr;
use strum_macros::EnumString;
use validator::Validate;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct BenchmarkCategory {
    pub min: i32,
    pub max: i32,
    pub label: String,
    pub color: Option<String>,
}

impl BenchmarkCategory {
    // Original constructor (now for ranges)
    pub fn new(min: i32, max: i32, label: String) -> BenchmarkCategory {
        BenchmarkCategory {
            min,
            max,
            label,
            color: None,
        }
    }
    // Constructor for range (alias for clarity)
    pub fn new_range(min: i32, max: i32, label: String) -> BenchmarkCategory {
        BenchmarkCategory {
            min,
            max,
            label,
            color: None,
        }
    }
    // Constructor for single value
    pub fn new_single(value: i32, label: String) -> BenchmarkCategory {
        BenchmarkCategory {
            min: value,
            max: value,
            label,
            color: None,
        }
    }
    // Helper method to check if this is a single value
    pub fn is_single_value(&self) -> bool {
        self.min == self.max
    }
    // Helper method to check if a score falls within this category
    pub fn contains(&self, score: i32) -> bool {
        score >= self.min && score <= self.max
    }
    // Helper method to get the display text for the range
    pub fn range_display(&self) -> String {
        if self.is_single_value() {
            self.min.to_string()
        } else {
            format!("{}-{}", self.min, self.max)
        }
    }
    // Helper method to get the value for single-value categories
    pub fn get_single_value(&self) -> Option<i32> {
        if self.is_single_value() {
            Some(self.min)
        } else {
            None
        }
    }
    //helper method to set color
    pub fn set_color(&mut self, color: String) {
        self.color = Some(color);
    }
    //helper method to get color if available
    pub fn get_color(&self) -> String {
        return self.color.clone().unwrap_or_else(|| "#6b7280".to_string());
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub enum TestType {
    Reading,
    Math,
    PhonemicAwareness,
    Spelling,
    Other,
}
impl fmt::Display for TestType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TestType::Reading => "Reading".to_string(),
                TestType::PhonemicAwareness => "PhonemicAwareness".to_string(),
                TestType::Spelling => "Spelling".to_string(),
                TestType::Math => "Math".to_string(),
                TestType::Other => "Other".to_string(),
            }
        )
    }
}
impl FromStr for TestType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Reading" => Ok(TestType::Reading),
            "Math" => Ok(TestType::Math),
            "PhonemicAwareness" | "Phonemic Awareness" => Ok(TestType::PhonemicAwareness),
            "Spelling" => Ok(TestType::Spelling),
            "Other" => Ok(TestType::Other),
            _ => Err(format!("Invalid TestType: {}", s)),
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Test {
    #[validate(length(min = 1, message = "name is required"))]
    pub name: String,
    #[validate(range(min = -20000, max = 99999, message = "score is required"))]
    pub score: i32,
    pub instructions: Option<String>,
    pub comments: String,
    pub testarea: TestType,
    pub school_year: Option<String>,
    pub benchmark_categories: Option<Vec<BenchmarkCategory>>,
    pub test_variant: i32,
    pub grade_level: Option<GradeEnum>,
    pub test_id: String,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
}

impl Test {
    pub fn new(
        name: String,
        score: i32,
        instructions: Option<String>,
        comments: String,
        testarea: TestType,
        school_year: Option<String>,
        benchmark_categories: Option<Vec<BenchmarkCategory>>,
        test_variant: i32,
        grade_level: Option<GradeEnum>,
        test_id: String,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> Test {
        Test {
            name,
            score,
            instructions,
            comments,
            testarea,
            school_year,
            benchmark_categories,
            test_variant,
            grade_level,
            test_id,
            scope,
            course_id,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct CreateNewTestRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub name: String,
    #[validate(range(min = 0, max = 99999, message = "a score is required"))]
    pub score: i32,
    pub instructions: Option<String>,
    pub comments: String,
    pub testarea: TestType,
    pub school_year: Option<String>,
    pub benchmark_categories: Option<Vec<BenchmarkCategory>>,
    pub test_variant: i32,
    pub grade_level: Option<GradeEnum>,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
}

impl CreateNewTestRequest {
    pub fn new(
        name: String,
        score: i32,
        instructions: Option<String>,
        comments: String,
        testarea: TestType,
        school_year: Option<String>,
        benchmark_categories: Option<Vec<BenchmarkCategory>>,
        test_variant: i32,
        grade_level: Option<GradeEnum>,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> CreateNewTestRequest {
        CreateNewTestRequest {
            name,
            score,
            instructions,
            comments,
            testarea,
            school_year,
            benchmark_categories,
            test_variant,
            grade_level,
            scope,
            course_id,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct UpdateTestRequest {
    #[validate(length(min = 1, message = "name is required"))]
    pub name: String,
    #[validate(range(min = -20000, max = 99999, message = "a score is required"))]
    pub score: i32,
    pub instructions: Option<String>,
    pub comments: String,
    pub testarea: TestType,
    pub school_year: Option<String>,
    pub benchmark_categories: Option<Vec<BenchmarkCategory>>,
    pub test_variant: i32,
    pub grade_level: Option<GradeEnum>,
    pub test_id: String,
    pub scope: Option<ScopeEnum>,
    pub course_id: Option<i32>,
}

impl UpdateTestRequest {
    pub fn new(
        name: String,
        score: i32,
        instructions: Option<String>,
        comments: String,
        testarea: TestType,
        school_year: Option<String>,
        benchmark_categories: Option<Vec<BenchmarkCategory>>,
        test_variant: i32,
        grade_level: Option<GradeEnum>,
        test_id: String,
        scope: Option<ScopeEnum>,
        course_id: Option<i32>,
    ) -> UpdateTestRequest {
        UpdateTestRequest {
            name,
            score,
            instructions,
            comments,
            testarea,
            school_year,
            benchmark_categories,
            test_variant,
            grade_level,
            test_id,
            scope,
            course_id,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct DeleteTestRequest {
    pub test_id: String,
}

impl DeleteTestRequest {
    pub fn new(test_id: String) -> DeleteTestRequest {
        DeleteTestRequest { test_id }
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer, PgHasArrayType}, encode::IsNull};
        use sqlx::prelude::*;
        use sqlx::types::Json;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for TestType {
           fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
               let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
           }
       }

        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for TestType {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                TestType::from_str(s).map_err(|_| format!("Invalid TestType: {}", s).into())
            }
        }

        impl Type<Postgres> for TestType {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("testarea_enum")
            }
        }

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for BenchmarkCategory {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(self).encode_by_ref(buf)
            }
        }

        impl sqlx::Type<sqlx::Postgres> for BenchmarkCategory {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("jsonb")
            }
        }

        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for BenchmarkCategory {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<BenchmarkCategory> = sqlx::decode::Decode::decode(value)?;
                Ok(json.0)
            }
        }

        impl sqlx::postgres::PgHasArrayType for BenchmarkCategory {
            fn array_type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("_jsonb")
            }
        }

        // Create a newtype wrapper for Vec<BenchmarkCategory> to solve the orphan rule issue
        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
        pub struct BenchmarkCategories(pub Vec<BenchmarkCategory>);

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for BenchmarkCategories {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                Json(&self.0).encode_by_ref(buf)
            }
        }

        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for BenchmarkCategories {
            fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let json: Json<Vec<BenchmarkCategory>> = sqlx::decode::Decode::decode(value)?;
                Ok(BenchmarkCategories(json.0))
            }
        }

    }
}
use leptos::prelude::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid=:Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct CreateSessionRequest {
    pub title: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SessionResponse {
    pub id= Uuid,
    pub session_code: String,
    pub title: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct JoinSessionRequest {
    pub session_code: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SessionJoinResponse {
    pub session_id= Uuid,
    pub message: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TeacherSession {
    pub id= Uuid,
    pub session_code: String,
    pub title: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
#[cfg(feature = "ssr")]
use sqlx::FromRow;
use std::fmt::{self, Display};
use std::str::FromStr;

#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum UserRole {
    Admin,
    Teacher,
    Guest,
    User,
    SuperAdmin,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum AccountStatus {
    Pending,
    Active,
    Suspended,
    Deleted,
}

impl FromStr for UserRole {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "admin" => Ok(UserRole::Admin),
            "teacher" => Ok(UserRole::Teacher),
            "guest" => Ok(UserRole::Guest),
            "user" => Ok(UserRole::User),
            "superadmin" => Ok(UserRole::SuperAdmin),
            _ => Err(()),
        }
    }
}

impl fmt::Display for UserRole {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let role_str = match self {
            UserRole::Admin => "admin",
            UserRole::Teacher => "teacher",
            UserRole::Guest => "guest",
            UserRole::User => "user",
            UserRole::SuperAdmin => "superadmin",
        };
        write!(f, "{}", role_str)
    }
}

impl AccountStatus {
    pub fn to_string(&self) -> String {
        match self {
            AccountStatus::Pending => "pending".to_string(),
            AccountStatus::Active => "active".to_string(),
            AccountStatus::Suspended => "suspended".to_string(),
            AccountStatus::Deleted => "deleted".to_string(),
        }
    }

    pub fn from_str(status: &str) -> Self {
        match status.to_lowercase().as_str() {
            "pending" => AccountStatus::Pending,
            "active" => AccountStatus::Active,
            "suspended" => AccountStatus::Suspended,
            "deleted" => AccountStatus::Deleted,
            _ => AccountStatus::Pending,
        }
    }
}

// Full User struct - contains ALL user data including sensitive information
// Used for: database operations, admin functions, complete user management
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct User {
    pub id: i64,
    pub username: String,
    pub email: String,
    #[serde(skip_serializing, default)]
    pub password_hash: String,
    pub role: UserRole,
    pub password_salt: Option<String>,
    pub account_status: AccountStatus,
    pub email_verified: bool,
    pub phone_number: Option<String>,
    pub phone_verified: bool,
    pub display_name: Option<String>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
}

impl User {
    pub fn new(
        id: i64,
        username: String,
        email: String,
        password_hash: String,
        role: UserRole,
    ) -> Self {
        User {
            id,
            username,
            email,
            password_hash,
            role,
            password_salt: None,
            account_status: AccountStatus::Active,
            email_verified: false,
            phone_number: None,
            phone_verified: false,
            display_name: None,
            first_name: None,
            last_name: None,
        }
    }

    pub fn is_user(&self) -> bool {
        matches!(
            self.role,
            UserRole::User | UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
        )
    }

    pub fn is_admin(&self) -> bool {
        matches!(self.role, UserRole::Admin | UserRole::SuperAdmin)
    }

    pub fn is_teacher(&self) -> bool {
        matches!(
            self.role,
            UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
        )
    }

    pub fn is_super_admin(&self) -> bool {
        self.role == UserRole::SuperAdmin
    }

    pub fn is_guest(&self) -> bool {
        self.role == UserRole::Guest
    }

    // Convert to session-safe version (without sensitive data)
    pub fn to_session_user(&self) -> SessionUser {
        SessionUser {
            id: self.id,
            username: self.username.clone(),
            email: self.email.clone(),
            role: self.role,
            display_name: self.display_name.clone(),
            first_name: self.first_name.clone(),
            last_name: self.last_name.clone(),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct SessionUser {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub role: UserRole,
    pub display_name: Option<String>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
}

impl SessionUser {
    pub fn is_user(&self) -> bool {
        matches!(
            self.role,
            UserRole::User | UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
        )
    }

    pub fn is_admin(&self) -> bool {
        matches!(self.role, UserRole::Admin | UserRole::SuperAdmin)
    }

    pub fn is_teacher(&self) -> bool {
        matches!(
            self.role,
            UserRole::Teacher | UserRole::Admin | UserRole::SuperAdmin
        )
    }

    pub fn is_super_admin(&self) -> bool {
        self.role == UserRole::SuperAdmin
    }

    pub fn is_guest(&self) -> bool {
        self.role == UserRole::Guest
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::prelude::*;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for UserRole {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, sqlx::error::BoxDynError> {
                let role_str = self.to_string();
                Encode::<Postgres>::encode_by_ref(&role_str, buf)
            }
        }

        impl <'r> sqlx::decode::Decode<'r, Postgres> for UserRole {
            fn decode(value: PgValueRef<'r>) -> Result<Self, sqlx::error::BoxDynError> {
                let role_str: String = Decode::<Postgres>::decode(value)?;
                role_str.parse().map_err(|_| {
                    sqlx::error::BoxDynError::from(format!("Invalid UserRole: {}", role_str))
                })
            }
        }

        impl Type<Postgres> for UserRole {
            fn type_info() -> PgTypeInfo {
                PgTypeInfo::with_name("user_role_enum")
            }
        }
    }
}
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug};
use std::str::FromStr;
use strum_macros::EnumIter;
use validator::Validate;

//these following enum is defined for use within the question struct
#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone, EnumIter)]
pub enum QuestionType {
    MultipleChoice,
    WeightedMultipleChoice,
    Written,
    Selection,
    TrueFalse,
}

impl fmt::Display for QuestionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                QuestionType::MultipleChoice => "Multiple choice".to_string(),
                QuestionType::WeightedMultipleChoice => "Weighted Multiple Choice".to_string(),
                QuestionType::Written => "Written".to_string(),
                QuestionType::Selection => "Selection".to_string(),
                QuestionType::TrueFalse => "True False".to_string(),
            }
        )
    }
}

impl FromStr for QuestionType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Multiple choice" => Ok(QuestionType::MultipleChoice),
            "Weighted Multiple Choice" => Ok(QuestionType::WeightedMultipleChoice),
            "Written" => Ok(QuestionType::Written),
            "Selection" => Ok(QuestionType::Selection),
            "True False" => Ok(QuestionType::TrueFalse),
            _ => Err(format!("Invalid QuestionType (enum) value: {}", s)),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct WeightedOption {
    pub text: String,
    pub points: i32,
    pub is_selectable: bool, // Whether this option can be selected for points
}

impl WeightedOption {
    pub fn new(text: String, points: i32, is_selectable: bool) -> Self {
        Self {
            text,
            points,
            is_selectable,
        }
    }
}

//the following Question object is for use on the client side when reading and writing data
#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Question {
    #[validate(length(min = 1, message = "please that a question is asked"))]
    pub word_problem: String,
    #[validate(range(min = -20000, max = 99999, message = "please ensure a score is associated with this question"))]
    pub point_value: i32,
    pub question_type: QuestionType,
    #[validate(length(min = 1, message = "please ensure that an answer is provided"))]
    pub options: Vec<String>,
    #[validate(length(min = 1, message = "please provide the correct answer"))]
    pub correct_answer: String,
    pub qnumber: i32,
    pub testlinker: String,
    pub weighted_options: Option<String>,
}

impl Question {
    pub fn new(
        word_problem: String,
        point_value: i32,
        question_type: QuestionType,
        options: Vec<String>,
        correct_answer: String,
        qnumber: i32,
        testlinker: String,
    ) -> Question {
        Question {
            word_problem,
            point_value,
            question_type,
            options,
            correct_answer,
            qnumber,
            testlinker,
            weighted_options: None, // Default to None, can be set later if needed
        }
    }
    //
    // Helper methods for weighted options
    pub fn get_weighted_options(&self) -> Vec<WeightedOption> {
        match &self.weighted_options {
            Some(json_str) => serde_json::from_str(json_str).unwrap_or_default(),
            None => Vec::new(),
        }
    }

    pub fn set_weighted_options(&mut self, options: Vec<WeightedOption>) {
        self.weighted_options = Some(serde_json::to_string(&options).unwrap_or_default());
    }

    // Calculate score for weighted multiple choice based on selected options
    pub fn calculate_weighted_score(&self, selected_options: &[String]) -> i32 {
        if self.question_type != QuestionType::WeightedMultipleChoice {
            return 0;
        }

        let weighted_opts = self.get_weighted_options();
        let mut total_score = 0;

        for selected in selected_options {
            if let Some(option) = weighted_opts
                .iter()
                .find(|opt| opt.text == *selected && opt.is_selectable)
            {
                total_score += option.points;
            }
        }

        // Cap the score at the question's point_value
        total_score.min(self.point_value)
    }
}

//the following Objects are for use in making requests to the database on the client-side
#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct CreateNewQuestionRequest {
    #[validate(length(min = 1, message = "please that a question is asked"))]
    pub word_problem: String,
    #[validate(range(min = -20000, max = 99999, message = "please ensure a score is associated with this question"))]
    pub point_value: i32,
    pub question_type: QuestionType,
    #[validate(length(min = 1, message = "please ensure that an answer is provided"))]
    pub options: Vec<String>,
    #[validate(length(min = 1, message = "please provide the correct answer"))]
    pub correct_answer: String,
    pub qnumber: i32,
    pub testlinker: String,
    pub weighted_options: Option<String>,
}

impl CreateNewQuestionRequest {
    pub fn new(
        word_problem: String,
        point_value: i32,
        question_type: QuestionType,
        options: Vec<String>,
        correct_answer: String,
        qnumber: i32,
        testlinker: String,
    ) -> CreateNewQuestionRequest {
        CreateNewQuestionRequest {
            word_problem,
            point_value,
            question_type,
            options,
            correct_answer,
            qnumber,
            testlinker,
            weighted_options: None,
        }
    }

    pub fn from_question(question: &Question) -> Self {
        Self {
            word_problem: question.word_problem.clone(),
            point_value: question.point_value,
            question_type: question.question_type.clone(),
            options: question.options.clone(),
            correct_answer: question.correct_answer.clone(),
            qnumber: question.qnumber,
            testlinker: question.testlinker.clone(),
            weighted_options: question.weighted_options.clone(),
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct UpdateQuestionRequest {
    #[validate(length(min = 1, message = "please that a question is asked"))]
    pub word_problem: String,
    #[validate(range(min = -20000, max = 99999, message = "please ensure a score is associated with this question"))]
    pub point_value: i32,
    pub question_type: QuestionType,
    #[validate(length(min = 1, message = "please ensure that an answer is provided"))]
    pub options: Vec<String>,
    #[validate(length(min = 1, message = "please provide the correct answer"))]
    pub correct_answer: String,
    pub qnumber: i32,
    pub testlinker: String,
    pub weighted_options: Option<String>,
}

impl UpdateQuestionRequest {
    pub fn new(
        word_problem: String,
        point_value: i32,
        question_type: QuestionType,
        options: Vec<String>,
        correct_answer: String,
        qnumber: i32,
        testlinker: String,
    ) -> UpdateQuestionRequest {
        UpdateQuestionRequest {
            word_problem,
            point_value,
            question_type,
            options,
            correct_answer,
            qnumber,
            testlinker,
            weighted_options: None,
        }
    }
}

#[derive(Debug, Validate, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct DeleteQuestionRequest {
    pub qnumber: i32,
    pub testlinker: String,
}

impl DeleteQuestionRequest {
    pub fn new(qnumber: i32, testlinker: String) -> DeleteQuestionRequest {
        DeleteQuestionRequest {
            qnumber,
            testlinker,
        }
    }
}

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Postgres, Encode, Decode, Type, postgres::{PgTypeInfo, PgValueRef, PgArgumentBuffer}, encode::IsNull};
        use sqlx::prelude::*;

        impl<'q> sqlx::encode::Encode<'q, sqlx::Postgres> for QuestionType {
            fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> Result<IsNull, Box<dyn std::error::Error + Send + Sync>> {
                let s = self.to_string();
                <&str as Encode<Postgres>>::encode(&s.as_str(), buf)
            }
        }

        impl<'r> sqlx::decode::Decode<'r, sqlx::Postgres> for QuestionType {
            fn decode(value: sqlx::postgres::PgValueRef<'r>)-> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
                let s: &str = Decode::<sqlx::Postgres>::decode(value)?;
                QuestionType::from_str(s).map_err(|_| format!("Invalid QuestionType: {}", s).into())
            }
        }

        impl Type<Postgres> for QuestionType {
            fn type_info() -> sqlx::postgres::PgTypeInfo {
                sqlx::postgres::PgTypeInfo::with_name("questiontype_enum")
            }
        }
    }
}
use leptos::prelude::*;
#[cfg(feature = "ssr")]
use {
    crate::app::websockets::lobby::{AnonymousStudentJoinMessage, Lobby},
    crate::app::websockets::messages::{
        ClientActorMessage, Connect, Disconnect, TestMessageType, TestSessionMessage,
        UserInfoMessage, WsMessage,
    },
    actix::{fut, ActorContext, ActorFuture, ContextFutureSpawner, WrapFuture},
    actix::{Actor, Addr, Running, StreamHandler},
    actix::{ActorFutureExt, AsyncContext, Handler},
    actix_web_actors::ws,
    serde_json::{from_str, json, Value},
};

use std::time::{Duration, Instant};
use uuid::Uuid;

const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);

#[cfg(feature = "ssr")]
pub struct WsConn {
    room: Uuid,
    lobby_addr: Addr<Lobby>,
    hb: Instant,
    id: Uuid,
}

#[cfg(feature = "ssr")]
impl WsConn {
    pub fn new(room: Uuid, lobby: Addr<Lobby>) -> WsConn {
        WsConn {
            id: Uuid::new_v4(),
            room,
            hb: Instant::now(),
            lobby_addr: lobby,
        }
    }
}

#[cfg(feature = "ssr")]
impl Actor for WsConn {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        self.hb(ctx);

        let addr = ctx.address();
        self.lobby_addr
            .send(Connect {
                addr: addr.recipient(),
                lobby_id: self.room,
                self_id: self.id,
                user_role: None,           //Role assigned later
                is_session_creator: false, //this is determined based on logic
            })
            .into_actor(self)
            .then(|res, _, ctx| {
                match res {
                    Ok(_res) => (),
                    _ => ctx.stop(),
                }
                fut::ready(())
            })
            .wait(ctx)
    }

    fn stopping(&mut self, _: &mut Self::Context) -> Running {
        self.lobby_addr.do_send(Disconnect {
            id: self.id,
            room_id: self.room,
        });
        Running::Stop
    }
}

#[cfg(feature = "ssr")]
impl WsConn {
    fn hb(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
            if Instant::now().duration_since(act.hb) > CLIENT_TIMEOUT {
                println!("Disconnecting failed heartbeat");
                ctx.stop();
                return;
            }

            ctx.ping(b"hi");
        });
    }
}

#[cfg(feature = "ssr")]
impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WsConn {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                self.hb = Instant::now();
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {
                self.hb = Instant::now();
            }
            Ok(ws::Message::Binary(bin)) => ctx.binary(bin),
            Ok(ws::Message::Close(reason)) => {
                ctx.close(reason);
                ctx.stop();
            }
            Ok(ws::Message::Continuation(_)) => {
                ctx.stop();
            }
            Ok(ws::Message::Nop) => (),
            Ok(ws::Message::Text(s)) => {
                log::info!("Received WebSocket message: {}", s);

                if let Ok(json_value) = from_str::<Value>(&s) {
                    if let Some(msg_type) = json_value.get("type").and_then(|t| t.as_str()) {
                        log::info!("Processing message type: {}", msg_type);

                        match msg_type {
                            "anonymous_student_join" => {
                                log::info!("Handling anonymous student join from user {}", self.id);
                                self.lobby_addr.do_send(AnonymousStudentJoinMessage {
                                    student_data: json_value,
                                    user_id: self.id,
                                    room_id: self.room,
                                });
                                return;
                            }
                            "user_info" => {
                                log::info!("Handling user_info from user {}", self.id);
                                // Send user info to lobby for role assignment
                                self.lobby_addr.do_send(UserInfoMessage {
                                    user_data: json_value,
                                    user_id: self.id,
                                    room_id: self.room,
                                });
                                return;
                            }
                            "request_participants" => {
                                log::info!("Handling request_participants from user {}", self.id);
                                self.lobby_addr.do_send(TestSessionMessage {
                                    message_type: TestMessageType::RequestParticipants,
                                    payload: json!({}),
                                    id: self.id,
                                    room_id: self.room,
                                });
                                return;
                            }
                            "test_message" => {
                                if let Some(test_msg_type_str) =
                                    json_value.get("test_message_type").and_then(|t| t.as_str())
                                {
                                    log::info!(
                                        "Processing test message type: {}",
                                        test_msg_type_str
                                    );

                                    let message_type = match test_msg_type_str {
                                        "start_test" => TestMessageType::StartTest,
                                        "submit_answer" => TestMessageType::SubmitAnswer,
                                        "teacher_comment" => TestMessageType::TeacherComment,
                                        "end_test" => TestMessageType::EndTest,
                                        "student_joined" => TestMessageType::StudentJoined,
                                        "student_left" => TestMessageType::StudentLeft,
                                        "question_focus" => TestMessageType::QuestionFocus,
                                        "time_update" => TestMessageType::TimeUpdate,
                                        unknown => {
                                            log::warn!("Unknown test message type: {}", unknown);
                                            return;
                                        }
                                    };

                                    let payload =
                                        json_value.get("payload").cloned().unwrap_or(Value::Null);

                                    self.lobby_addr.do_send(TestSessionMessage {
                                        message_type,
                                        payload,
                                        id: self.id,
                                        room_id: self.room,
                                    });
                                    return;
                                }
                            }
                            _ => {
                                log::info!("Unhandled message type: {}", msg_type);
                            }
                        }
                    } else {
                        log::warn!("Message missing 'type' field: {}", s);
                    }
                } else {
                    log::warn!("Failed to parse JSON message: {}", s);
                }

                // Fallback to regular chat message
                self.lobby_addr.do_send(ClientActorMessage {
                    id: self.id,
                    msg: s.to_string(),
                    room_id: self.room,
                });
            }
            Err(e) => {
                log::error!("WebSocket protocol error: {:?}", e);
                std::panic::panic_any(e)
            }
        }
    }
}

#[cfg(feature = "ssr")]
impl Handler<WsMessage> for WsConn {
    type Result = ();

    fn handle(&mut self, msg: WsMessage, ctx: &mut Self::Context) {
        ctx.text(msg.0);
    }
}
use leptos::prelude::*;
use uuid::Uuid;
#[cfg(feature = "ssr")]
use {
    crate::app::db::websocket_session_database,
    crate::app::models::websocket_session::{
        CreateSessionRequest, Session, SessionStatus, SessionType,
    },
    crate::app::websockets::lobby::Lobby,
    crate::app::websockets::ws::WsConn,
    actix::Addr,
    actix_web::{
        get, post, web::Data, web::Json, web::Path, web::Payload, Error, HttpRequest, HttpResponse,
    },
    actix_web_actors::ws,
    serde::{Deserialize, Serialize},
};

#[cfg(feature = "ssr")]
#[get("/{group_id}")]
pub async fn start_connection(
    req: HttpRequest,
    stream: Payload,
    path: Path<String>,
    srv: Data<Addr<Lobby>>,
    pool: Data<sqlx::PgPool>,
) -> Result<HttpResponse, Error> {
    let group_id_str = path.into_inner();
    let group_id = Uuid::parse_str(&group_id_str)
        .map_err(|_| actix_web::error::ErrorBadRequest("Invalid UUID format"))?;

    // Verify the session exists and is active
    match websocket_session_database::get_session(group_id, &pool).await {
        Ok(Some(session)) => {
            if session.status != SessionStatus::Active {
                return Err(actix_web::error::ErrorBadRequest("Session is not active").into());
            }

            // Check if session is full
            if session.max_users > 0 && session.current_users >= session.max_users {
                return Err(actix_web::error::ErrorBadRequest("Session is full").into());
            }

            // Create WebSocket connection
            let ws = WsConn::new(group_id, srv.get_ref().clone());
            let resp = ws::start(ws, &req, stream)?;
            Ok(resp)
        }
        Ok(None) => Err(actix_web::error::ErrorNotFound("Session not found").into()),
        Err(e) => {
            log::error!("Database error when verifying session: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Database error").into())
        }
    }
}

// Add a new endpoint to get information about active rooms
#[cfg(feature = "ssr")]
#[get("/rooms")]
pub async fn list_active_rooms(pool: Data<sqlx::PgPool>) -> Result<HttpResponse, Error> {
    match websocket_session_database::get_active_sessions(&pool).await {
        Ok(sessions) => {
            // Convert to a format suitable for client consumption
            let room_summaries = sessions
                .into_iter()
                .map(|session| crate::app::models::websocket_session::SessionSummary::from(session))
                .collect::<Vec<_>>();

            Ok(HttpResponse::Ok().json(room_summaries))
        }
        Err(e) => {
            log::error!("Error fetching active rooms: {}", e);
            Err(actix_web::error::ErrorInternalServerError("Database error").into())
        }
    }
}
use crate::app::models::Question;
use crate::app::server_functions::questions;
use leptos::prelude::*;
use std::collections::{HashMap, HashSet};
use uuid::Uuid;

#[cfg(feature = "ssr")]
use {
    crate::app::db::websocket_session_database,
    crate::app::models::question::QuestionType,
    crate::app::models::websocket_session::{Session, SessionType},
    crate::app::server_functions::questions::get_questions,
    crate::app::websockets::messages::{
        ClientActorMessage, Connect, Disconnect, TestMessageType, TestSessionMessage,
        UserInfoMessage, WsMessage,
    },
    actix::prelude::{Actor, Context, Handler, Message, Recipient},
    serde_json::{json, Value},
    sqlx::PgPool,
};

#[cfg(feature = "ssr")]
type Socket = Recipient<WsMessage>;

#[derive(Debug, Clone)]
pub struct AnonymousStudent {
    pub id: String,
    pub name: String,
    pub session_id: Uuid,
    pub test_id: String,
    pub joined_at: chrono::DateTime<chrono::Utc>,
}

#[cfg(feature = "ssr")]
pub struct Lobby {
    sessions: HashMap<Uuid, Socket>,
    rooms: HashMap<Uuid, HashSet<Uuid>>,
    room_roles: HashMap<(Uuid, Uuid), String>,
    active_tests: HashMap<Uuid, String>,
    test_questions: HashMap<String, Vec<Value>>,
    anonymous_students: HashMap<Uuid, AnonymousStudent>, // New field for anonymous students
    db_pool: Option<sqlx::PgPool>,
}

#[cfg(feature = "ssr")]
impl Default for Lobby {
    fn default() -> Lobby {
        Lobby {
            sessions: HashMap::new(),
            rooms: HashMap::new(),
            room_roles: HashMap::new(),
            active_tests: HashMap::new(),
            test_questions: HashMap::new(),
            anonymous_students: HashMap::new(),
            db_pool: None,
        }
    }
}

#[cfg(feature = "ssr")]
impl Lobby {
    pub fn new(pool: sqlx::PgPool) -> Self {
        Lobby {
            sessions: HashMap::new(),
            rooms: HashMap::new(),
            db_pool: Some(pool),
            room_roles: HashMap::new(),
            active_tests: HashMap::new(),
            test_questions: HashMap::new(),
            anonymous_students: HashMap::new(),
        }
    }

    fn handle_user_info_message(&mut self, msg: serde_json::Value, user_id: Uuid, room_id: Uuid) {
        if let (Some(role_str), Some(is_teacher), Some(is_admin)) = (
            msg.get("role").and_then(|r| r.as_str()),
            msg.get("is_teacher").and_then(|t| t.as_bool()),
            msg.get("is_admin").and_then(|a| a.as_bool()),
        ) {
            let assigned_role = if is_admin || is_teacher {
                "teacher"
            } else {
                "student"
            };

            log::info!("ðŸ”‘ Assigning role '{}' to user {} based on user_info (is_teacher: {}, is_admin: {})", 
                      assigned_role, user_id, is_teacher, is_admin);

            // Check if this is a teacher reconnecting/taking over
            if assigned_role == "teacher"
                && msg
                    .get("is_reconnecting")
                    .and_then(|r| r.as_bool())
                    .unwrap_or(false)
            {
                log::info!("Teacher {} taking over session {}", user_id, room_id);

                if let Some(room_users) = self.rooms.get(&room_id) {
                    let reset_msg = json!({
                        "type": "session_reset",
                        "message": "Teacher has reconnected. Session is being reset."
                    });

                    for other_user_id in room_users.iter() {
                        if other_user_id != &user_id {
                            self.send_message(&reset_msg.to_string(), other_user_id);
                        }
                    }
                }

                self.active_tests.remove(&room_id);
            }

            // FIXED: Assign the role based on user info, not room count
            self.room_roles
                .insert((room_id, user_id), assigned_role.to_string());

            let role_msg = json!({
                "type": "role_assigned",
                "role": assigned_role,
                "user_id": user_id.to_string(),
                "room_id": room_id.to_string(),
                "is_takeover": assigned_role == "teacher" && msg.get("is_reconnecting").and_then(|r| r.as_bool()).unwrap_or(false)
            });

            log::info!(
                "âœ… Sending role assignment: {} to user {}",
                assigned_role,
                user_id
            );
            self.send_message(&role_msg.to_string(), &user_id);

            // Now send participants list since role is assigned
            self.send_participants_list(&room_id, &user_id);

            // Broadcast user joined event
            self.broadcast_user_event(&room_id, &user_id, "user_joined", None);
        } else {
            log::error!(
                "âŒ Invalid user_info message format for user {}: missing role/is_teacher/is_admin",
                user_id
            );
        }
    }

    fn handle_anonymous_student_join(
        &mut self,
        msg: serde_json::Value,
        user_id: Uuid,
        room_id: Uuid,
    ) {
        if let (Some(name), Some(student_id), Some(test_id)) = (
            msg.get("student_name").and_then(|n| n.as_str()),
            msg.get("student_id").and_then(|s| s.as_str()),
            msg.get("test_id").and_then(|t| t.as_str()),
        ) {
            log::info!(
                "Anonymous student joining: {} (ID: {}) for test {}",
                name,
                student_id,
                test_id
            );

            // Store anonymous student info
            let anon_student = AnonymousStudent {
                id: student_id.to_string(),
                name: name.to_string(),
                session_id: room_id,
                test_id: test_id.to_string(),
                joined_at: chrono::Utc::now(),
            };

            self.anonymous_students
                .insert(user_id, anon_student.clone());

            // Assign student role automatically
            self.room_roles
                .insert((room_id, user_id), "student".to_string());

            // Send role confirmation with student info
            let role_msg = json!({
                "type": "role_assigned",
                "role": "student",
                "user_id": user_id.to_string(),
                "room_id": room_id.to_string(),
                "student_info": {
                    "name": name,
                    "student_id": student_id,
                    "is_anonymous": true
                }
            });

            log::info!("Assigning student role to anonymous user {}", user_id);
            self.send_message(&role_msg.to_string(), &user_id);

            // Broadcast student joined event with proper student data
            self.broadcast_user_event(
                &room_id,
                &user_id,
                "student_joined",
                Some(json!({
                    "name": name,
                    "student_id": student_id,
                    "is_anonymous": true,
                    "joined_at": anon_student.joined_at.to_rfc3339()
                })),
            );
        } else {
            log::warn!("Invalid anonymous student join message format");
        }
    }

    fn send_message(&self, message: &str, id_to: &Uuid) {
        if let Some(socket_recipient) = self.sessions.get(id_to) {
            let _ = socket_recipient.do_send(WsMessage(message.to_owned()));
        } else {
            println!("attempting to send message but couldn't find user id");
        }
    }

    // Helper method to update session counts in the database
    async fn update_db_session_count(&self, room_id: &Uuid, increment: bool) {
        if let Some(pool) = &self.db_pool {
            if let Err(e) =
                websocket_session_database::update_session_user_count(*room_id, increment, pool)
                    .await
            {
                log::error!("Failed to update session count: {}", e);
            }
        }
    }

    // ENHANCED: Send participants list with anonymous student info
    fn send_participants_list(&self, room_id: &Uuid, requesting_user_id: &Uuid) {
        if let Some(room_users) = self.rooms.get(room_id) {
            let participants: Vec<serde_json::Value> = room_users
                .iter()
                .map(|user_id| {
                    let role = self
                        .room_roles
                        .get(&(*room_id, *user_id))
                        .cloned()
                        .unwrap_or_else(|| "unknown".to_string());

                    // Check if this is an anonymous student
                    if let Some(anon_student) = self.anonymous_students.get(user_id) {
                        json!({
                            "id": anon_student.id,
                            "name": anon_student.name,
                            "type": "Student",
                            "status": "Connected",
                            "role": role,
                            "is_anonymous": true,
                            "joined_at": anon_student.joined_at.to_rfc3339()
                        })
                    } else {
                        // Regular logged-in user
                        json!({
                            "id": user_id.to_string(),
                            "name": format!("User {}", user_id.to_string()[..8].to_uppercase()),
                            "type": match role.as_str() {
                                "teacher" => "Teacher",
                                "student" => "Student",
                                _ => "User"
                            },
                            "status": "Connected",
                            "role": role,
                            "is_anonymous": false
                        })
                    }
                })
                .collect();

            let participants_msg = json!({
                "type": "participants_list",
                "participants": participants,
                "room_id": room_id.to_string(),
                "total_count": participants.len()
            });

            log::info!(
                "Sending participants list to {}: {} participants",
                requesting_user_id,
                participants.len()
            );
            self.send_message(&participants_msg.to_string(), requesting_user_id);
        } else {
            log::warn!("Room {} not found when requesting participants", room_id);
        }
    }

    // ENHANCED: Broadcast user event with anonymous student support
    fn broadcast_user_event(
        &self,
        room_id: &Uuid,
        user_id: &Uuid,
        event_type: &str,
        user_data: Option<serde_json::Value>,
    ) {
        if let Some(room_users) = self.rooms.get(room_id) {
            let role = self
                .room_roles
                .get(&(*room_id, *user_id))
                .cloned()
                .unwrap_or_else(|| "unknown".to_string());

            let event_msg = if let Some(provided_data) = user_data {
                // Use provided data (for anonymous students)
                json!({
                    "type": event_type,
                    "id": provided_data.get("student_id").unwrap_or(&json!(user_id.to_string())),
                    "user_data": provided_data,
                    "room_id": room_id.to_string(),
                    "timestamp": chrono::Utc::now().to_rfc3339()
                })
            } else {
                // Default data for regular users
                json!({
                    "type": event_type,
                    "id": user_id.to_string(),
                    "user_data": json!({
                        "name": format!("User {}", user_id.to_string()[..8].to_uppercase()),
                        "username": format!("User {}", user_id.to_string()[..8].to_uppercase()),
                        "role": role,
                        "is_anonymous": false
                    }),
                    "room_id": room_id.to_string(),
                    "timestamp": chrono::Utc::now().to_rfc3339()
                })
            };

            log::info!(
                "Broadcasting {} event for user {} in room {}",
                event_type,
                user_id,
                room_id
            );

            for other_user_id in room_users.iter() {
                if other_user_id != user_id {
                    self.send_message(&event_msg.to_string(), other_user_id);
                }
            }
        }
    }

    fn handle_test_message(&mut self, msg: TestSessionMessage) {
        log::info!("Handling test message: {:?}", msg.message_type);

        match msg.message_type {
            TestMessageType::RequestParticipants => {
                log::info!(
                    "Received request_participants from user {} in room {}",
                    msg.id,
                    msg.room_id
                );
                self.send_participants_list(&msg.room_id, &msg.id);
            }
            TestMessageType::StartTest => {
                if let Some(test_id) = msg.payload.get("test_id").and_then(|id| id.as_str()) {
                    self.active_tests.insert(msg.room_id, test_id.to_string());

                    if let Some(room_users) = self.rooms.get(&msg.room_id) {
                        let start_msg = json!({
                            "type": "test_started",
                            "test_id": test_id,
                        });

                        for user_id in room_users.iter() {
                            self.send_message(&start_msg.to_string(), user_id);
                        }
                    }
                }
            }
            TestMessageType::SubmitAnswer => {
                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    // Get student info for the answer
                    let student_info =
                        if let Some(anon_student) = self.anonymous_students.get(&msg.id) {
                            json!({
                                "student_id": anon_student.id,
                                "name": anon_student.name,
                                "is_anonymous": true
                            })
                        } else {
                            json!({
                                "student_id": msg.id.to_string(),
                                "name": format!("User {}", msg.id.to_string()[..8].to_uppercase()),
                                "is_anonymous": false
                            })
                        };

                    // Enhanced answer message to include answer type
                    let mut answer_data = msg.payload.clone();

                    // Ensure we preserve the answer_type if it exists
                    if !answer_data.as_object().unwrap().contains_key("answer_type") {
                        answer_data
                            .as_object_mut()
                            .unwrap()
                            .insert("answer_type".to_string(), json!("regular"));
                    }

                    let answer_msg = json!({
                        "type": "student_answer",
                        "student_id": msg.id.to_string(),
                        "student_info": student_info,
                        "answer_data": answer_data,
                    });

                    // Send to all teachers in the room
                    for user_id in room_users.iter() {
                        if let Some(role) = self.room_roles.get(&(msg.room_id, *user_id)) {
                            if role == "teacher" {
                                self.send_message(&answer_msg.to_string(), user_id);
                            }
                        }
                    }
                }
            }
            TestMessageType::TeacherComment => {
                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    let comment_msg = json!({
                        "type": "teacher_comment",
                        "comment": msg.payload,
                    });

                    // Send to all students in the room
                    for user_id in room_users.iter() {
                        if let Some(role) = self.room_roles.get(&(msg.room_id, *user_id)) {
                            if role == "student" {
                                self.send_message(&comment_msg.to_string(), user_id);
                            }
                        }
                    }
                }
            }
            TestMessageType::EndTest => {
                self.active_tests.remove(&msg.room_id);

                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    let end_msg = json!({
                        "type": "test_ended",
                    });

                    for user_id in room_users.iter() {
                        self.send_message(&end_msg.to_string(), user_id);
                    }
                }
            }
            TestMessageType::QuestionFocus => {
                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    let focus_msg = json!({
                        "type": "focus_question",
                        "question_data": msg.payload,
                    });

                    // Send to all students in the room
                    for user_id in room_users.iter() {
                        if let Some(role) = self.room_roles.get(&(msg.room_id, *user_id)) {
                            if role == "student" {
                                self.send_message(&focus_msg.to_string(), user_id);
                            }
                        }
                    }
                }
            }
            TestMessageType::TimeUpdate => {
                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    let time_msg = json!({
                        "type": "time_update",
                        "time_data": msg.payload,
                    });

                    for user_id in room_users.iter() {
                        self.send_message(&time_msg.to_string(), user_id);
                    }
                }
            }
            _ => {
                // Handle other message types
                if let Some(room_users) = self.rooms.get(&msg.room_id) {
                    let msg_json = json!({
                        "type": format!("{:?}", msg.message_type).to_lowercase(),
                        "from": msg.id.to_string(),
                        "data": msg.payload,
                    });

                    for user_id in room_users.iter() {
                        self.send_message(&msg_json.to_string(), user_id);
                    }
                }
            }
        }
    }
}

#[cfg(feature = "ssr")]
impl Actor for Lobby {
    type Context = Context<Self>;
}

#[cfg(feature = "ssr")]
impl Handler<Disconnect> for Lobby {
    type Result = ();

    fn handle(&mut self, msg: Disconnect, ctx: &mut Context<Self>) {
        log::info!("User {} disconnecting from room {}", msg.id, msg.room_id);

        if self.sessions.remove(&msg.id).is_some() {
            // ENHANCED: Handle anonymous student disconnect
            if let Some(anon_student) = self.anonymous_students.remove(&msg.id) {
                log::info!(
                    "Anonymous student {} ({}) disconnected from test session",
                    anon_student.name,
                    anon_student.id
                );

                // Broadcast student left event with student info
                self.broadcast_user_event(
                    &msg.room_id,
                    &msg.id,
                    "student_left",
                    Some(json!({
                        "name": anon_student.name,
                        "student_id": anon_student.id,
                        "is_anonymous": true
                    })),
                );
            } else {
                // Broadcast regular user left event
                self.broadcast_user_event(&msg.room_id, &msg.id, "user_left", None);
            }

            // Remove user from room
            if let Some(lobby) = self.rooms.get_mut(&msg.room_id) {
                lobby.remove(&msg.id);

                if lobby.is_empty() {
                    self.rooms.remove(&msg.room_id);
                    log::info!("Room {} is now empty and removed", msg.room_id);

                    // Mark session as inactive in database
                    let room_id = msg.room_id;
                    if let Some(pool) = self.db_pool.clone() {
                        actix::spawn(async move {
                            use crate::app::models::websocket_session::SessionStatus;
                            if let Err(e) = websocket_session_database::update_session_status(
                                room_id,
                                SessionStatus::Inactive,
                                &pool,
                            )
                            .await
                            {
                                log::error!("Failed to mark session as inactive: {}", e);
                            }
                        });
                    }
                } else {
                    log::info!("Room {} now has {} users", msg.room_id, lobby.len());
                }
            }

            // Remove role assignment
            self.room_roles.remove(&(msg.room_id, msg.id));

            // Update database session count
            let room_id = msg.room_id;
            if let Some(pool) = self.db_pool.clone() {
                actix::spawn(async move {
                    if let Err(e) =
                        websocket_session_database::update_session_user_count(room_id, false, &pool)
                            .await
                    {
                        log::error!("Failed to update session count: {}", e);
                    }
                });
            }
        }

        log::info!(
            "User {} successfully disconnected from room {}",
            msg.id,
            msg.room_id
        );
    }
}

#[cfg(feature = "ssr")]
impl Handler<Connect> for Lobby {
    type Result = ();

    fn handle(&mut self, msg: Connect, _: &mut Context<Self>) -> Self::Result {
        log::info!("User {} connecting to room {}", msg.self_id, msg.lobby_id);

        // Add user to the room
        self.rooms
            .entry(msg.lobby_id)
            .or_insert_with(HashSet::new)
            .insert(msg.self_id);

        // FIXED: Only assign role if we don't have one yet AND it's not from user_info
        if !self.room_roles.contains_key(&(msg.lobby_id, msg.self_id)) {
            let is_anonymous_student = self.anonymous_students.contains_key(&msg.self_id);

            if is_anonymous_student {
                self.room_roles
                    .insert((msg.lobby_id, msg.self_id), "student".to_string());
                log::info!("Assigned 'student' role to anonymous user {}", msg.self_id);
            } else {
                // FIXED: Don't assign role here - wait for user_info message
                log::info!(
                    "User {} connected - waiting for user_info to assign role",
                    msg.self_id
                );

                // Store the connection but don't assign role yet
                self.sessions.insert(msg.self_id, msg.addr);

                // Send welcome message but no role assignment yet
                let welcome_msg = json!({
                    "type": "welcome",
                    "user_id": msg.self_id.to_string(),
                    "room_id": msg.lobby_id.to_string(),
                    "message": format!("Welcome! Your ID is {}", msg.self_id)
                });
                self.send_message(&welcome_msg.to_string(), &msg.self_id);

                // Update database session count
                let room_id = msg.lobby_id;
                if let Some(pool) = self.db_pool.clone() {
                    actix::spawn(async move {
                        if let Err(e) = websocket_session_database::update_session_user_count(
                            room_id, true, &pool,
                        )
                        .await
                        {
                            log::error!("Failed to update session count: {}", e);
                        }
                    });
                }

                log::info!(
                    "User {} connected - awaiting user_info message",
                    msg.self_id
                );
                return; // Exit early - role will be assigned in handle_user_info_message
            }
        }

        // Store the connection (for anonymous students)
        self.sessions.insert(msg.self_id, msg.addr);

        // Send role assignment for anonymous students only
        if let Some(role) = self.room_roles.get(&(msg.lobby_id, msg.self_id)) {
            let role_msg = json!({
                "type": "role_assigned",
                "role": role,
                "user_id": msg.self_id.to_string(),
                "room_id": msg.lobby_id.to_string()
            });

            log::info!(
                "Sending role assignment to user {}: {} (message: {})",
                msg.self_id,
                role,
                role_msg.to_string()
            );
            self.send_message(&role_msg.to_string(), &msg.self_id);
        }

        // Broadcast user joined event to other participants
        self.broadcast_user_event(&msg.lobby_id, &msg.self_id, "user_joined", None);

        // Send welcome message
        let welcome_msg = json!({
            "type": "welcome",
            "user_id": msg.self_id.to_string(),
            "room_id": msg.lobby_id.to_string(),
            "message": format!("Welcome! Your ID is {}", msg.self_id)
        });
        self.send_message(&welcome_msg.to_string(), &msg.self_id);

        // Send current participants list to the new user
        self.send_participants_list(&msg.lobby_id, &msg.self_id);

        // If there's an active test, send test data
        if let Some(test_id) = self.active_tests.get(&msg.lobby_id) {
            if let Some(questions) = self.test_questions.get(test_id) {
                let role = self.room_roles.get(&(msg.lobby_id, msg.self_id)).unwrap();
                let filtered_questions = if role == "teacher" {
                    questions.clone()
                } else {
                    questions
                        .iter()
                        .map(|q| {
                            let mut q_copy = q.clone();
                            if let Some(obj) = q_copy.as_object_mut() {
                                obj.remove("correct_answer");
                            }
                            q_copy
                        })
                        .collect()
                };

                let test_data = json!({
                    "type": "test_data",
                    "test_id": test_id,
                    "questions": filtered_questions
                });

                self.send_message(&test_data.to_string(), &msg.self_id);
            }
        }

        // Update database session count
        let room_id = msg.lobby_id;
        if let Some(pool) = self.db_pool.clone() {
            actix::spawn(async move {
                if let Err(e) =
                    websocket_session_database::update_session_user_count(room_id, true, &pool)
                        .await
                {
                    log::error!("Failed to update session count: {}", e);
                }
            });
        }

        log::info!(
            "User {} successfully connected to room {}",
            msg.self_id,
            msg.lobby_id
        );
    }
}

#[cfg(feature = "ssr")]
impl Handler<ClientActorMessage> for Lobby {
    type Result = ();

    fn handle(&mut self, msg: ClientActorMessage, _ctx: &mut Context<Self>) -> Self::Result {
        // Handle private messages (whispers)
        if msg.msg.starts_with("\\w") {
            if let Some(id_to) = msg.msg.split(' ').collect::<Vec<&str>>().get(1) {
                self.send_message(&msg.msg, &Uuid::parse_str(id_to).unwrap());
            }
        } else {
            // Broadcast to all users in the room
            if let Some(room_users) = self.rooms.get(&msg.room_id) {
                for client in room_users.iter() {
                    self.send_message(&msg.msg, client);
                }
            }
        }
    }
}

#[cfg(feature = "ssr")]
impl Handler<TestSessionMessage> for Lobby {
    type Result = ();

    fn handle(&mut self, msg: TestSessionMessage, _ctx: &mut Context<Self>) -> Self::Result {
        self.handle_test_message(msg);
    }
}

#[cfg(feature = "ssr")]
impl Handler<UserInfoMessage> for Lobby {
    type Result = ();

    fn handle(&mut self, msg: UserInfoMessage, _ctx: &mut Context<Self>) -> Self::Result {
        self.handle_user_info_message(msg.user_data, msg.user_id, msg.room_id);
    }
}

// Handler for anonymous student joins
#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct AnonymousStudentJoinMessage {
    pub student_data: serde_json::Value,
    pub user_id: Uuid,
    pub room_id: Uuid,
}

#[cfg(feature = "ssr")]
impl Handler<AnonymousStudentJoinMessage> for Lobby {
    type Result = ();

    fn handle(
        &mut self,
        msg: AnonymousStudentJoinMessage,
        _ctx: &mut Context<Self>,
    ) -> Self::Result {
        self.handle_anonymous_student_join(msg.student_data, msg.user_id, msg.room_id);
    }
}
use crate::app::models::user::UserRole;
#[cfg(feature = "ssr")]
use actix::prelude::{Message, Recipient};
use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct WsMessage(pub String);

#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct Connect {
    pub addr: Recipient<WsMessage>,
    pub lobby_id: Uuid,
    pub self_id: Uuid,
    pub user_role: Option<UserRole>,
    pub is_session_creator: bool,
}

#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct UserInfoMessage {
    pub user_data: serde_json::Value,
    pub user_id: Uuid,
    pub room_id: Uuid,
}

#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct Disconnect {
    pub id: Uuid,
    pub room_id: Uuid,
}

#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct ClientActorMessage {
    pub id: Uuid,
    pub msg: String,
    pub room_id: Uuid,
}

#[cfg(feature = "ssr")]
#[derive(Message, Debug, Serialize, Deserialize)]
#[rtype(result = "()")]
pub struct TestSessionMessage {
    pub message_type: TestMessageType,
    pub payload: serde_json::Value,
    pub id: Uuid,
    pub room_id: Uuid,
}

// NEW: Anonymous student join message
#[cfg(feature = "ssr")]
#[derive(Message)]
#[rtype(result = "()")]
pub struct AnonymousStudentJoinMessage {
    pub student_data: serde_json::Value,
    pub user_id: Uuid,
    pub room_id: Uuid,
}

#[cfg(feature = "ssr")]
#[derive(Debug, Serialize, Deserialize)]
pub enum TestMessageType {
    StartTest,
    SubmitAnswer,
    TeacherComment,
    EndTest,
    StudentJoined,
    StudentLeft,
    UserJoined,
    UserLeft,
    QuestionFocus,
    TimeUpdate,
    RequestParticipants,
}
use leptos::prelude::*;
pub mod students;
pub use students::get_students;

pub mod tests;
pub use tests::get_tests;

pub mod questions;
pub use questions::get_questions;

pub mod scores;
pub use scores::get_score;
pub use scores::get_scores;

pub mod teachers;
pub use teachers::get_teachers;

pub mod employees;
pub use employees::get_employees;

pub mod auth;

pub mod bulk_students;
pub use bulk_students::upload_students_bulk;

pub mod bulk_enrollment;
pub use bulk_enrollment::upload_bulk_enrollment;

pub mod websocket_sessions;
pub use websocket_sessions::list_active_sessions;

pub mod assessments;
pub use assessments::get_assessments;

pub mod data_wrappers;
pub use data_wrappers::get_student_results_server;

pub mod users;
pub use users::get_users;

pub mod user_settings;
pub use user_settings::get_user_settings;

pub mod courses;
pub use courses::get_courses;

pub mod enrollments;
pub use enrollments::get_enrollments;

pub mod globals;
pub use globals::get_global_settings;

pub mod authorization;
pub use authorization::*;

pub mod saml_auth;
pub use saml_auth::*;
use leptos::prelude::*;
use crate::app::models::test::BenchmarkCategory;

//This file contains utilities for working with benchmark categories (primarily used in
//test_builder.rs)

/// Utilities for working with benchmark categories in both single value and range formats
pub struct BenchmarkUtils;

impl BenchmarkUtils {
    /// Creates benchmark categories from the UI tuple representation (id, min, max, label)
    /// Automatically detects single values when min == max
    pub fn from_tuples(tuples: Vec<(i32, i32, i32, String, String)>) -> Vec<BenchmarkCategory> {
        tuples
            .into_iter()
            .map(|(_, min, max, label, color)| {
                let mut category = if min == max {
                    BenchmarkCategory::new_single(min, label)
                } else {
                    BenchmarkCategory::new_range(min, max, label)
                };
                category.color = Some(color);
                category
            })
            .collect()
    }

    /// Converts benchmark categories to tuples for UI consumption
    /// Returns (index, min, max, label) tuples
    pub fn to_tuples(categories: Vec<BenchmarkCategory>) -> Vec<(i32, i32, i32, String, String)> {
        categories
            .into_iter()
            .enumerate()
            .map(|(idx, cat)| {
                let color = cat.get_color();
                (idx as i32, cat.min, cat.max, cat.label, color)
            })
            .collect()
    }

    /// Finds which benchmark category a score belongs to
    /// Returns the first matching category (categories should not overlap)
    pub fn find_category_for_score(
        score: i32,
        categories: &[BenchmarkCategory],
    ) -> Option<&BenchmarkCategory> {
        categories.iter().find(|cat| cat.contains(score))
    }

    /// Gets the grade/label for a given score
    /// Returns None if no category matches the score
    pub fn get_grade_for_score(score: i32, categories: &[BenchmarkCategory]) -> Option<String> {
        Self::find_category_for_score(score, categories).map(|cat| cat.label.clone())
    }

    /// Validates benchmark categories for overlapping ranges
    /// Returns an error if any categories have overlapping score ranges
    pub fn validate_no_overlaps(categories: &[BenchmarkCategory]) -> Result<(), String> {
        if categories.is_empty() {
            return Ok(());
        }

        for (i, cat1) in categories.iter().enumerate() {
            for (j, cat2) in categories.iter().enumerate() {
                if i != j {
                    let overlap = Self::categories_overlap(cat1, cat2);

                    if overlap {
                        return Err(format!(
                            "Categories '{}' ({}) and '{}' ({}) have overlapping score ranges",
                            cat1.label,
                            cat1.range_display(),
                            cat2.label,
                            cat2.range_display()
                        ));
                    }
                }
            }
        }

        Ok(())
    }

    /// Checks if two benchmark categories have overlapping score ranges
    fn categories_overlap(cat1: &BenchmarkCategory, cat2: &BenchmarkCategory) -> bool {
        if cat1.is_single_value() && cat2.is_single_value() {
            // Both single values - overlap if they're the same value
            cat1.min == cat2.min
        } else if cat1.is_single_value() {
            // cat1 is single value, cat2 is range - overlap if cat2 contains cat1's value
            cat2.contains(cat1.min)
        } else if cat2.is_single_value() {
            // cat2 is single value, cat1 is range - overlap if cat1 contains cat2's value
            cat1.contains(cat2.min)
        } else {
            // Both are ranges - overlap if ranges intersect
            !(cat1.max < cat2.min || cat2.max < cat1.min)
        }
    }

    /// Validates that all categories have valid ranges (min <= max) and non-empty labels
    pub fn validate_categories(categories: &[BenchmarkCategory]) -> Result<(), String> {
        for cat in categories {
            if cat.label.trim().is_empty() {
                return Err("All benchmark categories must have a label".to_string());
            }

            if cat.min > cat.max {
                return Err(format!(
                    "Category '{}' has invalid range: min ({}) cannot be greater than max ({})",
                    cat.label, cat.min, cat.max
                ));
            }

            if cat.min < 0 {
                return Err(format!(
                    "Category '{}' has invalid minimum score: {} (scores cannot be negative)",
                    cat.label, cat.min
                ));
            }
        }

        Ok(())
    }

    /// Comprehensive validation that checks both individual categories and overlaps
    pub fn validate_all(categories: &[BenchmarkCategory]) -> Result<(), String> {
        Self::validate_categories(categories)?;
        Self::validate_no_overlaps(categories)?;
        Ok(())
    }

    /// Formats benchmark categories for display in summaries
    /// Returns a human-readable string representation
    pub fn format_summary(categories: &[BenchmarkCategory]) -> String {
        if categories.is_empty() {
            return "No benchmark categories defined".to_string();
        }

        let formatted: Vec<String> = categories
            .iter()
            .map(|cat| format!("{}: {}", cat.label, cat.range_display()))
            .collect();

        formatted.join(", ")
    }

    /// Sorts categories by their minimum score (useful for display)
    pub fn sort_by_min_score(mut categories: Vec<BenchmarkCategory>) -> Vec<BenchmarkCategory> {
        categories.sort_by_key(|cat| cat.min);
        categories
    }

    /// Groups categories by type (single values vs ranges)
    pub fn group_by_type(
        categories: &[BenchmarkCategory],
    ) -> (Vec<&BenchmarkCategory>, Vec<&BenchmarkCategory>) {
        let mut single_values = Vec::new();
        let mut ranges = Vec::new();

        for cat in categories {
            if cat.is_single_value() {
                single_values.push(cat);
            } else {
                ranges.push(cat);
            }
        }

        (single_values, ranges)
    }

    /// Gets statistics about the benchmark categories
    pub fn get_stats(categories: &[BenchmarkCategory]) -> BenchmarkStats {
        let total_count = categories.len();
        let (single_values, ranges) = Self::group_by_type(categories);
        let single_count = single_values.len();
        let range_count = ranges.len();

        let min_score = categories.iter().map(|cat| cat.min).min();
        let max_score = categories.iter().map(|cat| cat.max).max();

        BenchmarkStats {
            total_count,
            single_count,
            range_count,
            min_score,
            max_score,
        }
    }
}

/// Statistics about a set of benchmark categories
#[derive(Debug, Clone)]
pub struct BenchmarkStats {
    pub total_count: usize,
    pub single_count: usize,
    pub range_count: usize,
    pub min_score: Option<i32>,
    pub max_score: Option<i32>,
}

impl BenchmarkStats {
    pub fn summary(&self) -> String {
        if self.total_count == 0 {
            return "No benchmark categories".to_string();
        }

        let mut parts = vec![format!("{} total", self.total_count)];

        if self.single_count > 0 {
            parts.push(format!(
                "{} single value{}",
                self.single_count,
                if self.single_count == 1 { "" } else { "s" }
            ));
        }

        if self.range_count > 0 {
            parts.push(format!(
                "{} range{}",
                self.range_count,
                if self.range_count == 1 { "" } else { "s" }
            ));
        }

        let type_info = parts.join(", ");

        match (self.min_score, self.max_score) {
            (Some(min), Some(max)) => {
                format!("{} (covering scores {}-{})", type_info, min, max)
            }
            _ => type_info,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_tuples() {
        let tuples = vec![
            (0, 90, 100, "A".to_string(), "#10b981".to_string()),
            (1, 85, 85, "Perfect".to_string(), "#ef4444".to_string()),
        ];

        let categories = BenchmarkUtils::from_tuples(tuples);

        assert_eq!(categories.len(), 2);
        assert!(!categories[0].is_single_value());
        assert!(categories[1].is_single_value());
        assert_eq!(categories[0].get_color(), "#10b981");
        assert_eq!(categories[1].get_color(), "#ef4444");
    }

    #[test]
    fn test_validate_overlapping_ranges() {
        let categories = vec![
            BenchmarkCategory::new_range(70, 80, "B".to_string()),
            BenchmarkCategory::new_range(75, 85, "A".to_string()), // Overlaps with B
        ];

        assert!(BenchmarkUtils::validate_no_overlaps(&categories).is_err());
    }

    #[test]
    fn test_validate_overlapping_single_values() {
        let categories = vec![
            BenchmarkCategory::new_single(85, "Good".to_string()),
            BenchmarkCategory::new_single(85, "Excellent".to_string()), // Same value
        ];

        assert!(BenchmarkUtils::validate_no_overlaps(&categories).is_err());
    }

    #[test]
    fn test_validate_non_overlapping() {
        let categories = vec![
            BenchmarkCategory::new_range(70, 79, "B".to_string()),
            BenchmarkCategory::new_range(80, 89, "A".to_string()),
            BenchmarkCategory::new_single(100, "Perfect".to_string()),
        ];

        assert!(BenchmarkUtils::validate_no_overlaps(&categories).is_ok());
    }
}
use leptos::prelude::*;
pub mod assessment_database;
pub mod course_database;
pub mod database;
pub mod enrollment_database;
pub mod global_database;
pub mod question_database;
pub mod saml_database;
pub mod score_database;
pub mod student_database;
pub mod teacher_database;
pub mod test_database;
pub mod user_database;
pub mod websocket_session_database;

pub use assessment_database::*;
pub use course_database::*;
pub use database::*;
pub use enrollment_database::*;
pub use global_database::*;
pub use question_database::*;
pub use saml_database::*;
pub use score_database::*;
pub use student_database::*;
pub use teacher_database::*;
pub use test_database::*;
pub use user_database::*;
pub use websocket_session_database::*;
use leptos::prelude::*;
pub mod student;
pub use student::AddStudentRequest;
pub use student::DeleteStudentRequest;
pub use student::Student;
pub use student::UpdateStudentRequest;

pub mod test;
pub use test::CreateNewTestRequest;
pub use test::DeleteTestRequest;
pub use test::UpdateTestRequest;
pub use test::{Test, TestType};

pub mod question;
pub use question::CreateNewQuestionRequest;
pub use question::DeleteQuestionRequest;
pub use question::UpdateQuestionRequest;
pub use question::{Question, QuestionType, WeightedOption};

pub mod score;
pub use score::CreateScoreRequest;
pub use score::DeleteScoreRequest;
pub use score::Score;
pub use score::UpdateScoreRequest;

pub mod teacher;
pub use teacher::AddNewTeacherRequest;
pub use teacher::DeleteTeacherRequest;
pub use teacher::UpdateTeacherRequest;

pub mod employee;
pub use employee::Employee;
pub use employee::EmployeeRole;
pub use employee::StatusEnum;

pub mod user;
pub use user::User;

pub mod bulk_student;
pub use bulk_student::BulkStudentImportRequest;
pub use bulk_student::StudentCsvRow;

pub mod bulk_enrollment;
pub use bulk_enrollment::BulkEnrollmentImportRequest;
pub use bulk_enrollment::EnrollmentCsvRow;

pub mod websocket_session;
pub use websocket_session::CreateSessionRequest;
pub use websocket_session::Session;
pub use websocket_session::SessionSummary;

pub mod assessment;
pub use assessment::Assessment;
pub use assessment::CreateNewAssessmentRequest;
pub use assessment::DeleteAssessmentRequest;
pub use assessment::UpdateAssessmentRequest;
pub use assessment::{RangeCategory, SubjectEnum};

pub mod enrollment;
pub use enrollment::Enrollment;

pub mod setting_data;
pub use setting_data::UserSettings;
pub use setting_data::UserSettingsUpdate;

pub mod course;
pub use course::Course;
pub use course::CreateCourseRequest;
pub use course::UpdateCourseRequest;

pub mod global;

pub mod auth;
pub use auth::*;

pub mod assessment_sequences;
pub use assessment_sequences::{SequenceBehavior, TestSequenceItem};
use leptos::prelude::*;
pub mod saml_routes;
pub use saml_routes::*;
use leptos::leptos::ServerFnError;
use leptos::prelude::*;
use uuid::Uuid;

use crate::app::{models::websocket_session::SessionType, server_functions::tests::update_test};

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")]{
        use crate::app::models::websocket_session::Session;
        use crate::app::models::websocket_session::SessionStatus;
        use log::{debug, error, info, warn};
        use chrono::{DateTime, Utc};
        use leptos::prelude::*;
        use sqlx::PgPool;
        use sqlx::prelude::*;
        use sqlx::types::JsonValue;

        /// Retrieves all active sessions from the database
        pub async fn get_active_sessions(pool: &PgPool) -> Result<Vec<Session>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, description, created_at, last_active, owner_id,
                status, max_users, current_users, is_private, password_required, metadata,
                session_type, test_id, start_time, end_time, teacher_id
                FROM websocket_sessions WHERE status = 'active' ORDER BY last_active DESC"
            )
            .fetch_all(pool)
            .await?;

            let sessions: Vec<Session> = rows
                .into_iter()
                .map(|row| {
                    let id: Uuid = row.get("id");
                    let name: String = row.get("name");
                    let description: Option<String> = row.get("description");
                    let created_at: DateTime<Utc> = row.get("created_at");
                    let last_active: DateTime<Utc> = row.get("last_active");
                    let owner_id: Option<Uuid> = row.get("owner_id");
                    let status: SessionStatus = row.get("status");
                    let max_users: i32 = row.get("max_users");
                    let current_users: i32 = row.get("current_users");
                    let is_private: bool = row.get("is_private");
                    let password_required: bool = row.get("password_required");
                    let metadata: Option<JsonValue> = row.get("metadata");
                    let session_type: SessionType = row.get("session_type");
                    let test_id: Option<String> = row.get("test_id");
                    let start_time: Option<DateTime<Utc>> = row.get("start_time");
                    let end_time: Option<DateTime<Utc>> = row.get("end_time");
                    let teacher_id: Option<i32> = row.get("teacher_id");

                    Session {
                        id,
                        name,
                        description,
                        created_at,
                        last_active,
                        owner_id,
                        status,
                        max_users,
                        current_users,
                        is_private,
                        password_required,
                        metadata,
                        session_type,
                        test_id,
                        start_time,
                        end_time,
                        teacher_id,
                    }
                })
                .collect();

            Ok(sessions)
        }

        ///Get all active test sessions
        pub async fn get_active_test_sessions(pool: &PgPool) -> Result<Vec<Session>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, description, created_at, last_active, owner_id,
                status, max_users, current_users, is_private, password_required, metadata, 
                session_type, test_id, start_time, end_time, teacher_id
                FROM websocket_sessions
                WHERE status = 'active' AND session_type = 'test'
                ORDER BY last_active DESC"
            )
            .fetch_all(pool)
            .await?;

            let sessions: Vec<Session> = rows
                .into_iter()
                .map(|row| {
                    let id: Uuid = row.get("id");
                    let name: String = row.get("name");
                    let description: Option<String> = row.get("description");
                    let created_at: DateTime<Utc> = row.get("created_at");
                    let last_active: DateTime<Utc> = row.get("last_active");
                    let owner_id: Option<Uuid> = row.get("owner_id");
                    let status: SessionStatus = row.get("status");
                    let max_users: i32 = row.get("max_users");
                    let current_users: i32 = row.get("current_users");
                    let is_private: bool = row.get("is_private");
                    let password_required: bool = row.get("password_required");
                    let metadata: Option<JsonValue> = row.get("metadata");
                    let session_type: SessionType = row.get("session_type");
                    let test_id: Option<String> = row.get("test_id");
                    let start_time: Option<DateTime<Utc>> = row.get("start_time");
                    let end_time: Option<DateTime<Utc>> = row.get("end_time");
                    let teacher_id: Option<i32> = row.get("teacher_id");

                    Session {
                        id,
                        name,
                        description,
                        created_at,
                        last_active,
                        owner_id,
                        status,
                        max_users,
                        current_users,
                        is_private,
                        password_required,
                        metadata,
                        session_type,
                        test_id,
                        start_time,
                        end_time,
                        teacher_id,
                    }
                })
                .collect();

            Ok(sessions)
        }

        /// Retrieves a specific session by ID
        pub async fn get_session(session_id: Uuid, pool: &PgPool) -> Result<Option<Session>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, name, description, created_at, last_active, owner_id,
                status, max_users, current_users, is_private, password_required, metadata,
                session_type, test_id, start_time, end_time, teacher_id
                FROM websocket_sessions WHERE id = $1"
            )
            .bind(session_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let session = Session {
                        id: row.get("id"),
                        name: row.get("name"),
                        description: row.get("description"),
                        created_at: row.get("created_at"),
                        last_active: row.get("last_active"),
                        owner_id: row.get("owner_id"),
                        status: row.get("status"),
                        max_users: row.get("max_users"),
                        current_users: row.get("current_users"),
                        is_private: row.get("is_private"),
                        password_required: row.get("password_required"),
                        metadata: row.get("metadata"),
                        session_type: row.get("session_type"),
                        test_id: row.get("test_id"),
                        start_time: row.get("start_time"),
                        end_time: row.get("end_time"),
                        teacher_id: row.get("teacher_id"),
                    };
                    Ok(Some(session))
                },
                None => Ok(None),
            }
        }

        ///Get sessions by test ID
        pub async fn get_sessions_by_test_id(test_id: &str, pool: &PgPool) -> Result<Vec<Session>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, description, created_at, last_active, owner_id,
                status, max_users, current_users, is_private, password_required, metadata,
                session_type, test_id, start_time, end_time, teacher_id
                FROM websocket_sessions
                WHERE test_id = $1 
                ORDER BY created_at DESC"
            )
            .bind(test_id)
            .fetch_all(pool)
            .await?;

            let sessions: Vec<Session> = rows
                .into_iter()
                .map(|row| {
                    let id: Uuid = row.get("id");
                    let name: String = row.get("name");
                    let description: Option<String> = row.get("description");
                    let created_at: DateTime<Utc> = row.get("created_at");
                    let last_active: DateTime<Utc> = row.get("last_active");
                    let owner_id: Option<Uuid> = row.get("owner_id");
                    let status: SessionStatus = row.get("status");
                    let max_users: i32 = row.get("max_users");
                    let current_users: i32 = row.get("current_users");
                    let is_private: bool = row.get("is_private");
                    let password_required: bool = row.get("password_required");
                    let metadata: Option<JsonValue> = row.get("metadata");
                    let session_type: SessionType = row.get("session_type");
                    let test_id: Option<String> = row.get("test_id");
                    let start_time: Option<DateTime<Utc>> = row.get("start_time");
                    let end_time: Option<DateTime<Utc>> = row.get("end_time");
                    let teacher_id: Option<i32> = row.get("teacher_id");

                    Session {
                        id,
                        name,
                        description,
                        created_at,
                        last_active,
                        owner_id,
                        status,
                        max_users,
                        current_users,
                        is_private,
                        password_required,
                        metadata,
                        session_type,
                        test_id,
                        start_time,
                        end_time,
                        teacher_id,
                    }
                })
                .collect();

            Ok(sessions)
        }

        /// Creates a new session
        pub async fn create_session(session: &Session, pool: &PgPool) -> Result<Session, leptos::ServerFnError> {
        let row = sqlx::query(
                "INSERT INTO websocket_sessions
                (id, name, description, owner_id, status, max_users, is_private, password_required, password_hash, metadata, session_type, test_id, start_time, end_time, teacher_id) 
                VALUES ($1, $2, $3, $4, $5::session_status_enum, $6, $7, $8, $9, $10, $11::session_type_enum, $12, $13, $14, $15) 
                RETURNING id, name, description, created_at, last_active, owner_id, 
                status, max_users, current_users, is_private, password_required, metadata, session_type, test_id, start_time, end_time, teacher_id"
            )
            .bind(session.id)
            .bind(&session.name)
            .bind(&session.description)
            .bind(session.owner_id)
            .bind(&session.status.to_string())
            .bind(session.max_users)
            .bind(session.is_private)
            .bind(session.password_required)
            .bind(None::<String>) // password_hash - would implement proper hashing in production
            .bind(&session.metadata)
            .bind(&session.session_type.to_string())
            .bind(&session.test_id)
            .bind(session.start_time)
            .bind(session.end_time)
            .bind(session.teacher_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let session = Session {
                id: row.get("id"),
                name: row.get("name"),
                description: row.get("description"),
                created_at: row.get("created_at"),
                last_active: row.get("last_active"),
                owner_id: row.get("owner_id"),
                status: row.get("status"),
                max_users: row.get("max_users"),
                current_users: row.get("current_users"),
                is_private: row.get("is_private"),
                password_required: row.get("password_required"),
                metadata: row.get("metadata"),
                session_type: row.get("session_type"),
                test_id: row.get("test_id"),
                start_time: row.get("start_time"),
                end_time: row.get("end_time"),
                teacher_id: row.get("teacher_id"),
            };

            Ok(session)
        }

        /// Updates session user count
        pub async fn update_session_user_count(session_id: Uuid, increment: bool, pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            let sql = if increment {
                "UPDATE websocket_sessions SET current_users = current_users + 1, last_active = NOW() WHERE id = $1"
            } else {
                "UPDATE websocket_sessions SET current_users = GREATEST(current_users - 1, 0), last_active = NOW() WHERE id = $1"
            };

            sqlx::query(sql)
                .bind(session_id)
                .execute(pool)
                .await?;

            Ok(())
        }

        /// Updates a session's status
        pub async fn update_session_status(session_id: Uuid, status: SessionStatus, pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            sqlx::query("UPDATE websocket_sessions SET status = $1::session_status_enum, last_active = NOW() WHERE id = $2")
                .bind(status)
                .bind(session_id)
                .execute(pool)
                .await?;

            Ok(())
        }

        ///Updates a test session's start and end times
        pub async fn update_test_session_times(
            session_id: Uuid,
            start_time: Option<DateTime<Utc>>,
            end_time: Option<DateTime<Utc>>,
            pool: &PgPool
        ) -> Result<Session, leptos::ServerFnError> {
            let update_result = sqlx::query(
                "UPDATE websocket_sessions
                SET start_time = $1, end_time = $2, last_active = NOW()
                WHERE id =  $3 
                RETURNING id, name, description, created_at, last_active, owner_id, 
                status, max_users, current_users, is_private, password_required, metadata,
                session_type, test_id, start_time, end_time, teacher_id"
            )
            .bind(start_time)
            .bind(end_time)
            .bind(session_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let session = Session {
                id: update_result.get("id"),
                name: update_result.get("name"),
                description: update_result.get("description"),
                created_at: update_result.get("created_at"),
                last_active: update_result.get("last_active"),
                owner_id: update_result.get("owner_id"),
                status: update_result.get("status"),
                max_users: update_result.get("max_users"),
                current_users: update_result.get("current_users"),
                is_private: update_result.get("is_private"),
                password_required: update_result.get("password_required"),
                metadata: update_result.get("metadata"),
                session_type: update_result.get("session_type"),
                test_id: update_result.get("test_id"),
                start_time: update_result.get("start_time"),
                end_time: update_result.get("end_time"),
                teacher_id: update_result.get("teacher_id"),
            };

            Ok(session)
        }

        /// Deletes a session
        pub async fn delete_session(session_id: Uuid, pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            sqlx::query("DELETE FROM websocket_sessions WHERE id = $1")
                .bind(session_id)
                .execute(pool)
                .await?;

            Ok(())
        }

        //Auto-expire test session that have passed their end times
        pub async fn expire_completed_test_sessions(pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE websocket_sessions
                SET status = 'expired'::session_status_enum
                WHERE status = 'active'::session_status_enum
                AND session_type = 'test'::session_type_enum
                AND end_time IS NOT NULL
                AND end_time < NOW()"
            )
            .execute(pool)
            .await?;

            Ok(())
        }

        //Cleanup expired or empty session (for test and chat session)
        pub async fn cleanup_inactive_sessions(pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            // 1. Clean up sessions where teacher has been inactive for 10 seconds
            sqlx::query(
                "UPDATE websocket_sessions
                 SET status = 'inactive'::session_status_enum,
                     teacher_id = NULL
                 WHERE status = 'active'::session_status_enum
                 AND teacher_id IS NOT NULL
                 AND last_active < NOW() - INTERVAL '10 seconds'"
            )
            .execute(pool)
            .await?;

            // 2. Clean up duplicate sessions for same teacher (keep most recent)
            sqlx::query(
                "UPDATE websocket_sessions s1
                 SET status = 'inactive'::session_status_enum,
                     teacher_id = NULL
                 WHERE s1.status = 'active'::session_status_enum
                 AND s1.teacher_id IS NOT NULL
                 AND EXISTS (
                     SELECT 1 FROM websocket_sessions s2
                     WHERE s2.teacher_id = s1.teacher_id
                     AND s2.id != s1.id
                     AND s2.status = 'active'::session_status_enum
                     AND s2.last_active > s1.last_active
                 )"
            )
            .execute(pool)
            .await?;
            // 3. Clean up sessions where teacher has been marked as disconnected (more aggressive timing)
            sqlx::query(
                "UPDATE websocket_sessions
                 SET status = 'inactive'::session_status_enum,
                     teacher_id = NULL
                 WHERE status = 'active'::session_status_enum
                 AND teacher_id IS NOT NULL
                 AND last_active < NOW() - INTERVAL '30 seconds'"  // REDUCED from 2 minutes
            )
            .execute(pool)
            .await?;

            // 4. Mark empty sessions as inactive after 5 minutes (unchanged)
            sqlx::query(
                "UPDATE websocket_sessions
                 SET status = 'inactive'::session_status_enum
                 WHERE status = 'active'::session_status_enum
                 AND current_users = 0
                 AND last_active < NOW() - INTERVAL '5 minutes'"
            )
            .execute(pool)
            .await?;

            // 5. Mark old sessions as expired after 2 hours (unchanged)
            sqlx::query(
                "UPDATE websocket_sessions
                 SET status = 'expired'::session_status_enum
                 WHERE status = 'active'::session_status_enum
                 AND last_active < NOW() - INTERVAL '2 hours'"
            )
            .execute(pool)
            .await?;

            // 6. Handle completed test sessions
            expire_completed_test_sessions(pool).await?;

            Ok(())
        }

        pub async fn assign_teacher_to_session(session_id: Uuid, teacher_id: i32, pool: &PgPool) -> Result<Session, leptos::ServerFnError> {
            let row = sqlx::query(
                "UPDATE websocket_sessions
                 SET teacher_id = $1, last_active = NOW() 
                 WHERE id = $2 
                 RETURNING id, name, description, created_at, last_active, owner_id,
                 status, max_users, current_users, is_private, password_required, metadata,
                 session_type, test_id, start_time, end_time, teacher_id"
            )
            .bind(teacher_id)
            .bind(session_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let session = Session {
                id: row.get("id"),
                name: row.get("name"),
                description: row.get("description"),
                created_at: row.get("created_at"),
                last_active: row.get("last_active"),
                owner_id: row.get("owner_id"),
                status: row.get("status"),
                max_users: row.get("max_users"),
                current_users: row.get("current_users"),
                is_private: row.get("is_private"),
                password_required: row.get("password_required"),
                metadata: row.get("metadata"),
                session_type: row.get("session_type"),
                test_id: row.get("test_id"),
                start_time: row.get("start_time"),
                end_time: row.get("end_time"),
                teacher_id: row.get("teacher_id"),
            };

            Ok(session)
        }

        /// Gets the active session for a specific teacher
        pub async fn get_teacher_active_session(teacher_id: i32, pool: &PgPool) -> Result<Option<Session>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, name, description, created_at, last_active, owner_id,
                 status, max_users, current_users, is_private, password_required, metadata,
                 session_type, test_id, start_time, end_time, teacher_id
                 FROM websocket_sessions 
                 WHERE teacher_id = $1 AND end_time IS NULL AND status = 'active'::session_status_enum"
            )
            .bind(teacher_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let session = Session {
                        id: row.get("id"),
                        name: row.get("name"),
                        description: row.get("description"),
                        created_at: row.get("created_at"),
                        last_active: row.get("last_active"),
                        owner_id: row.get("owner_id"),
                        status: row.get("status"),
                        max_users: row.get("max_users"),
                        current_users: row.get("current_users"),
                        is_private: row.get("is_private"),
                        password_required: row.get("password_required"),
                        metadata: row.get("metadata"),
                        session_type: row.get("session_type"),
                        test_id: row.get("test_id"),
                        start_time: row.get("start_time"),
                        end_time: row.get("end_time"),
                        teacher_id: row.get("teacher_id"),
                    };
                    Ok(Some(session))
                },
                None => Ok(None),
            }
        }

        /// Releases a teacher from a session (sets teacher_id to NULL)
        pub async fn release_teacher_from_session(session_id: Uuid, pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE websocket_sessions
                 SET teacher_id = NULL, last_active = NOW() 
                 WHERE id = $1"
            )
            .bind(session_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(())
        }

        /// Checks if a teacher can access a specific test (no other teacher is currently active)
        pub async fn check_teacher_test_access(test_id: &str, teacher_id: i32, pool: &PgPool) -> Result<bool, leptos::ServerFnError> {
            // FIRST: Clean up any stale sessions
            cleanup_inactive_sessions(pool).await?;

            // SECOND: Check for conflicting active sessions
            let conflicting_sessions = sqlx::query(
                "SELECT COUNT(*) as count
                 FROM websocket_sessions 
                 WHERE test_id = $1 
                 AND teacher_id IS NOT NULL 
                 AND teacher_id != $2 
                 AND end_time IS NULL 
                 AND status = 'active'::session_status_enum
                 AND last_active > NOW() - INTERVAL '1 minute'"  // Only consider recently active sessions
            )
            .bind(test_id)
            .bind(teacher_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let count: i64 = conflicting_sessions.get("count");
            Ok(count == 0)
        }

        /// Immediately cleanup a teacher's session when they disconnect
        pub async fn cleanup_teacher_session(teacher_id: i32, pool: &PgPool) -> Result<(), leptos::ServerFnError> {
            info!("Starting enhanced cleanup for teacher {}", teacher_id);

            // Get the teacher's active session first for logging
            if let Some(session) = get_teacher_active_session(teacher_id, pool).await? {
                info!("Found active session {} for teacher {}, cleaning up...", session.id, teacher_id);

                // Update session timestamp to current time to prevent race conditions
                sqlx::query(
                    "UPDATE websocket_sessions
                     SET last_active = NOW() 
                     WHERE id = $1"
                )
                .bind(session.id)
                .execute(pool)
                .await?;

                // Set session to inactive
                update_session_status(session.id, SessionStatus::Inactive, pool).await?;

                // Release teacher from session
                release_teacher_from_session(session.id, pool).await?;

                info!("Successfully cleaned up session {} for teacher {}", session.id, teacher_id);
            } else {
                info!("No active session found for teacher {} during cleanup", teacher_id);
            }

            // Also run general cleanup to catch any other stale sessions
            cleanup_inactive_sessions(pool).await?;

            Ok(())
        }
    }
}
use crate::app::models::assessment::RangeCategory;
use crate::app::models::assessment::ScopeEnum;
use crate::app::models::assessment_sequences::{SequenceBehavior, TestSequenceItem};
use crate::app::models::student::GradeEnum;
use leptos::prelude::*;
use uuid::Uuid;
cfg_if::cfg_if! {

    if #[cfg(feature = "ssr")]{
        use crate::app::models::assessment::{Assessment, SubjectEnum, RangeCategoriesWrapper};
        use sqlx::PgPool;
        use sqlx::types::Json;
        use leptos::prelude::*;
        use sqlx::prelude::*;

        pub async fn get_all_assessments(pool: &sqlx::PgPool) -> Result<Vec<Assessment>, ServerFnError> {
            let rows = sqlx::query("SELECT name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id FROM assessments ORDER BY name ASC")
                .fetch_all(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            let assessments: Vec<Assessment> = rows
                .into_iter()
                .map(|row| {
                    let name: String = row.get("name");
                    let frequency: Option<i32> = row.get("frequency");
                    let grade: Option<GradeEnum> = row.get("grade");
                    let version: i32 = row.get("version");
                    let id: Uuid = row.get("id");
                    let tests: Vec<Uuid> = row.get("tests");
                    let composite_score: Option<i32> = row.get("composite_score");

                    // ADD: Parse test_sequence
                    let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Option<Json<Vec<TestSequenceItem>>>, _>("test_sequence") {
                        Ok(Some(json)) => Some(json.0),
                        _ => None,
                    };

                    let risk_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("risk_benchmarks") {
                        Ok(Some(json)) => Some(json.0),
                        _ => None,
                    };
                    let national_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("national_benchmarks") {
                        Ok(Some(json)) => Some(json.0),
                        _ => None,
                    };
                    let subject: Option<SubjectEnum> = row.get("subject");
                    let scope: Option<ScopeEnum> = row.get("scope");
                    let course_id: Option<i32> = row.get("course_id");

                    Assessment {
                        name,
                        frequency,
                        grade,
                        version,
                        id,
                        tests,
                        composite_score,
                        risk_benchmarks,
                        national_benchmarks,
                        subject,
                        scope,
                        course_id,
                        test_sequence,
                    }
                })
                .collect();

            Ok(assessments)
        }

    pub async fn get_assessment(id: String, pool: &sqlx::PgPool) -> Result<Assessment, ServerFnError> {
        let uuid = Uuid::parse_str(&id)
            .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

        let row = sqlx::query("SELECT name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id FROM assessments WHERE id = $1")
            .bind(&uuid)
            .fetch_one(pool)
            .await
            .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

        // ADD: Parse test_sequence
        let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Option<Json<Vec<TestSequenceItem>>>, _>("test_sequence") {
            Ok(Some(json)) => Some(json.0),
            _ => None,
        };

        let risk_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("risk_benchmarks") {
            Ok(Some(json)) => Some(json.0),
            _ => None,
        };

        let national_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("national_benchmarks") {
            Ok(Some(json)) => Some(json.0),
            _ => None,
        };

        let assessment = Assessment {
            name: row.get("name"),
            frequency: row.get("frequency"),
            grade: row.get("grade"),
            version: row.get("version"),
            id: row.get("id"),
            tests: row.get("tests"),
            composite_score: row.get("composite_score"),
            risk_benchmarks,
            national_benchmarks,
            subject: row.get("subject"),
            scope: row.get("scope"),
            course_id: row.get("course_id"),
            test_sequence, // ADD THIS
        };

        Ok(assessment)
    }


        pub async fn add_assessment(new_assessment: &Assessment, pool: &PgPool) -> Result<Assessment, ServerFnError> {
            let risk_benchmarks = match &new_assessment.risk_benchmarks {
                Some(categories) if !categories.is_empty() => Json(categories.clone()),
                _ => Json(Vec::<RangeCategory>::new()),
            };
            let national_benchmarks = match &new_assessment.national_benchmarks {
                Some(categories) if !categories.is_empty() => Json(categories.clone()),
                _ => Json(Vec::<RangeCategory>::new()),
            };

            // ADD: Handle test_sequence
            let test_sequence = match &new_assessment.test_sequence {
                Some(sequence) if !sequence.is_empty() => Json(sequence.clone()),
                _ => Json(Vec::<TestSequenceItem>::new()),
            };

            let row = sqlx::query("INSERT INTO assessments (name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id")
                .bind(&new_assessment.name)
                .bind(&new_assessment.frequency)
                .bind(&new_assessment.grade)
                .bind(&new_assessment.version)
                .bind(&new_assessment.id)
                .bind(&new_assessment.tests)
                .bind(&test_sequence) // ADD THIS BIND
                .bind(&new_assessment.composite_score)
                .bind(&risk_benchmarks)
                .bind(&national_benchmarks)
                .bind(&new_assessment.subject)
                .bind(&new_assessment.scope)
                .bind(&new_assessment.course_id)
                .fetch_one(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            // Fixed parsing logic to handle empty arrays
            let risk_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Json<Vec<RangeCategory>>, _>("risk_benchmarks") {
                Ok(json) => {
                    if json.0.is_empty() {
                        None
                    } else {
                        Some(json.0)
                    }
                },
                Err(_) => None,
            };

            let national_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Json<Vec<RangeCategory>>, _>("national_benchmarks") {
                Ok(json) => {
                    if json.0.is_empty() {
                        None
                    } else {
                        Some(json.0)
                    }
                },
                Err(_) => None,
            };

            // ADD: Parse test_sequence from result
            let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Json<Vec<TestSequenceItem>>, _>("test_sequence") {
                Ok(json) => {
                    if json.0.is_empty() {
                        None
                    } else {
                        Some(json.0)
                    }
                },
                Err(_) => None,
            };

            let id: Uuid = row.get("id");

            let assessment = Assessment {
                name: row.get("name"),
                frequency: row.get("frequency"),
                grade: row.get("grade"),
                version: row.get("version"),
                id,
                tests: row.get("tests"),
                composite_score: row.get("composite_score"),
                risk_benchmarks,
                national_benchmarks,
                subject: row.get("subject"),
                scope: row.get("scope"),
                course_id: row.get("course_id"),
                test_sequence, // ADD THI
            };
            Ok(assessment)
        }

        pub async fn update_all_assessments_referencing_test(test_id: &String, pool: &sqlx::PgPool) -> Result<(), ServerFnError> {
            // Convert the string to a UUID
            let test_uuid = Uuid::parse_str(test_id)
                .map_err(|e| ServerFnError::new(format!("Invalid UUID format: {}", e)))?;

            // Find all assessments that reference this test
            let assessment_ids: Vec<Uuid> = sqlx::query_as::<_, (Uuid,)>("SELECT id FROM assessments WHERE $1 = ANY(tests)")
                .bind(test_uuid)
                .fetch_all(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?
                .into_iter()
                .map(|(id,)| id)
                .collect();

            // Update each assessment's composite score
            for assessment_id in assessment_ids {
                // Get the test IDs for this assessment
                let test_ids: Vec<Uuid> = sqlx::query_scalar::<_, Uuid>("SELECT unnest(tests) FROM assessments WHERE id = $1")
                    .bind(assessment_id)
                    .fetch_all(pool)
                    .await
                    .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

                // Get scores for all tests and calculate the sum
                let scores: Vec<i32> = sqlx::query_scalar::<_, i32>("SELECT score FROM tests WHERE test_id = ANY($1)")
                    .bind(&test_ids)
                    .fetch_all(pool)
                    .await
                    .map_err(|e| ServerFnError::new(format!("Issue retrieving score values for tests: {}", e)))?;

                let total: i32 = scores.iter().sum();

                // Update the assessment with the new composite score
                sqlx::query("UPDATE assessments SET composite_score = $1 WHERE id = $2")
                    .bind(total)
                    .bind(assessment_id)
                    .execute(pool)
                    .await
                    .map_err(|e| ServerFnError::new(format!("Database error updating assessment: {}", e)))?;
            }

            Ok(())
        }

        pub async fn update_assessment(assessment: &Assessment, pool: &sqlx::PgPool) -> Result<Assessment, ServerFnError> {
            let risk_benchmarks = match &assessment.risk_benchmarks {
                Some(categories) => Json(categories.clone()),
                None => Json(Vec::new()),
            };
            let national_benchmarks = match &assessment.national_benchmarks {
                Some(categories) => Json(categories.clone()),
                None => Json(Vec::new()),
            };

            // ADD: Handle test_sequence
            let test_sequence = match &assessment.test_sequence {
                Some(sequence) => Json(sequence.clone()),
                None => Json(Vec::new()),
            };

            let row = sqlx::query("UPDATE assessments SET name = $1, frequency = $2, grade = $3, version = $4, tests = $5, test_sequence = $6, composite_score = $7, risk_benchmarks = $8, national_benchmarks = $9, subject = $10, scope = $11, course_id = $12 WHERE id = $13 RETURNING name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id")
                .bind(&assessment.name)
                .bind(&assessment.frequency)
                .bind(&assessment.grade)
                .bind(&assessment.version)
                .bind(&assessment.tests)
                .bind(&test_sequence) // ADD THIS BIND
                .bind(&assessment.composite_score)
                .bind(&risk_benchmarks)
                .bind(&national_benchmarks)
                .bind(&assessment.subject)
                .bind(&assessment.scope)
                .bind(&assessment.course_id)
                .bind(&assessment.id)
                .fetch_one(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            let risk_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("risk_benchmarks") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };
            let national_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("national_benchmarks") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            // ADD: Parse test_sequence from result
            let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Option<Json<Vec<TestSequenceItem>>>, _>("test_sequence") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let id: Uuid = row.get("id");

            let assessment = Assessment {
                name: row.get("name"),
                frequency: row.get("frequency"),
                grade: row.get("grade"),
                version: row.get("version"),
                id,
                tests: row.get("tests"),
                composite_score: row.get("composite_score"),
                risk_benchmarks,
                national_benchmarks,
                subject: row.get("subject"),
                scope: row.get("scope"),
                course_id: row.get("course_id"),
                test_sequence, // ADD
            };

            Ok(assessment)
        }


        pub async fn delete_assessment(id: String, pool: &sqlx::PgPool) -> Result<Assessment, ServerFnError> {
            let uuid = Uuid::parse_str(&id)
                .map_err(|e| ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let row = sqlx::query("DELETE from assessments WHERE id = $1 RETURNING name, frequency, grade, version, id, tests, test_sequence, composite_score, risk_benchmarks, national_benchmarks, subject, scope, course_id")
                .bind(&uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            let risk_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("risk_benchmarks") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };
            let national_benchmarks: Option<Vec<RangeCategory>> = match row.try_get::<Option<Json<Vec<RangeCategory>>>, _>("national_benchmarks") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            // ADD: Parse test_sequence from result
            let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Option<Json<Vec<TestSequenceItem>>>, _>("test_sequence") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let id: Uuid = row.get("id");

            let assessment = Assessment {
                name: row.get("name"),
                frequency: row.get("frequency"),
                grade: row.get("grade"),
                version: row.get("version"),
                id,
                tests: row.get("tests"),
                composite_score: row.get("composite_score"),
                risk_benchmarks,
                national_benchmarks,
                subject: row.get("subject"),
                scope: row.get("scope"),
                course_id: row.get("course_id"),
                test_sequence,
            };

            Ok(assessment)
        }

        pub async fn get_test_sequence(assessment_id: &String, pool: &sqlx::PgPool) -> Result<Vec<(String, String)>, ServerFnError> {

            let uuid = Uuid::parse_str(assessment_id)
                .map_err(|e| {
                    log::error!("UUID parsing failed for '{}': {}", assessment_id, e);
                    ServerFnError::new(format!("Invalid UUID: {}", e))
                })?;

            let row = sqlx::query("SELECT test_sequence FROM assessments WHERE id = $1")
                .bind(&uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| {
                    log::error!("Database query failed for assessment {}: {}", uuid, e);
                    ServerFnError::new(format!("Database error: {}", e))
                })?;

            // Parse the test_sequence from the row
            let test_sequence: Option<Vec<TestSequenceItem>> = match row.try_get::<Option<Json<Vec<TestSequenceItem>>>, _>("test_sequence") {
                Ok(Some(json)) => {
                    log::info!("test_sequence JSON parsed successfully, {} items", json.0.len());
                    Some(json.0)
                },
                Ok(None) => {
                    log::warn!("test_sequence is NULL for assessment {}", uuid);
                    None
                },
                Err(e) => {
                    log::error!("Failed to parse test_sequence JSON for assessment {}: {}", uuid, e);
                    return Err(ServerFnError::new(format!("JSON parsing error: {}", e)));
                }
            };

            // Convert TestSequenceItem to (String, String) pairs
            let sequence_items = test_sequence.unwrap_or_default();

            if sequence_items.is_empty() {
                log::warn!("No test sequence items found for assessment {}", uuid);
                return Ok(vec![]);
            }

            // Get test names from the tests table for each test_id in the sequence
            let mut result = Vec::new();

            for (index, item) in sequence_items.iter().enumerate() {
                let test_name: Option<String> = sqlx::query_scalar("SELECT name FROM tests WHERE test_id = $1")
                    .bind(&item.test_id)  // Bind the UUID directly, not as string
                    .fetch_optional(pool)
                    .await
                    .map_err(|e| {
                        log::error!("Database error fetching test name for test_id {}: {}", item.test_id, e);
                        ServerFnError::new(format!("Database error fetching test name: {}", e))
                    })?;

                let name = test_name.unwrap_or_else(|| {
                    log::warn!("Test name not found for test_id {}, using fallback", item.test_id);
                    format!("Test {}", item.test_id)
                });

                // Return the UUID as string in the result tuple
                result.push((item.test_id.to_string(), name));
            }

            Ok(result)
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use crate::app::models::invitation::{
            generate_invitation_code, generate_verification_code, CreateInvitationRequest, Invitation,
            VerificationCode, VerificationType,
        };
        use chrono::{DateTime, Duration, Utc};
        use log::{debug, error, info};
        use sqlx::{PgPool, Row};

        pub async fn create_invitation(
            pool: &PgPool,
            request: CreateInvitationRequest,
            invited_by_user_id= Option<i64>,
        ) -> Result<Invitation, sqlx::Error> {
            let code = generate_invitation_code();
            let expires_at = if request.expires_in_days > 0 {
                Some(Utc::now() + Duration::days(request.expires_in_days as i64))
            } else {
                None
            };

            let row = sqlx::query(
                r#"
                INSERT INTO invitations (code, school_name, invited_by_user_id, role, max_uses, expires_at)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id, code, school_name, invited_by_user_id, role, max_uses, current_uses, expires_at, created_at
                "#,
            )
            .bind(&code)
            .bind(&request.school_name)
            .bind(invited_by_user_id)
            .bind(&request.role)
            .bind(request.max_uses)
            .bind(expires_at)
            .fetch_one(pool)
            .await?;

            Ok(Invitation {
                id= row.get("id"),
                code: row.get("code"),
                school_name: row.get("school_name"),
                invited_by_user_id= row.get("invited_by_user_id"),
                role: row.get("role"),
                max_uses: row.get("max_uses"),
                current_uses: row.get("current_uses"),
                expires_at: row.get("expires_at"),
                created_at: row.get("created_at"),
            })
        }

        pub async fn get_invitation_by_code(
            pool: &PgPool,
            code: &str,
        ) -> Result<Option<Invitation>, sqlx::Error> {
            let row = sqlx::query(
                "SELECT id, code, school_name, invited_by_user_id, role, max_uses, current_uses, expires_at, created_at FROM invitations WHERE code = $1"
            )
            .bind(code)
            .fetch_optional(pool)
            .await?;

            Ok(row.map(|r| Invitation {
                id= r.get("id"),
                code: r.get("code"),
                school_name: r.get("school_name"),
                invited_by_user_id= r.get("invited_by_user_id"),
                role: r.get("role"),
                max_uses: r.get("max_uses"),
                current_uses: r.get("current_uses"),
                expires_at: r.get("expires_at"),
                created_at: r.get("created_at"),
            }))
        }

        pub async fn use_invitation(pool: &PgPool, code: &str) -> Result<bool, sqlx::Error> {
            let result = sqlx::query(
                r#"
                UPDATE invitations 
                SET current_uses = current_uses + 1 
                WHERE code = $1 
                  AND current_uses < max_uses 
                  AND (expires_at IS NULL OR expires_at > NOW())
                "#,
            )
            .bind(code)
            .execute(pool)
            .await?;

            Ok(result.rows_affected() > 0)
        }

        pub async fn get_invitations_by_user(
            pool: &PgPool,
            user_id= i64,
        ) -> Result<Vec<Invitation>, sqlx::Error> {
            let rows = sqlx::query(
                r#"
                SELECT id, code, school_name, invited_by_user_id, role, max_uses, current_uses, expires_at, created_at 
                FROM invitations 
                WHERE invited_by_user_id = $1 
                ORDER BY created_at DESC
                "#,
            )
            .bind(user_id)
            .fetch_all(pool)
            .await?;

            Ok(rows
                .into_iter()
                .map(|r| Invitation {
                    id= r.get("id"),
                    code: r.get("code"),
                    school_name: r.get("school_name"),
                    invited_by_user_id= r.get("invited_by_user_id"),
                    role: r.get("role"),
                    max_uses: r.get("max_uses"),
                    current_uses: r.get("current_uses"),
                    expires_at: r.get("expires_at"),
                    created_at: r.get("created_at"),
                })
                .collect())
        }

        pub async fn create_verification_code(
            pool: &PgPool,
            user_id= i64,
            verification_type: VerificationType,
        ) -> Result<VerificationCode, sqlx::Error> {
            let code = generate_verification_code();
            let expires_at = Utc::now() + Duration::minutes(10); // 10-minute expiration

            // Invalidate any existing unused codes for this user and type
            sqlx::query(
                "UPDATE verification_codes SET used_at = NOW() WHERE user_id = $1 AND type = $2 AND used_at IS NULL"
            )
            .bind(user_id)
            .bind(verification_type.as_str())
            .execute(pool)
            .await?;

            let row = sqlx::query(
                r#"
                INSERT INTO verification_codes (user_id, code, type, expires_at)
                VALUES ($1, $2, $3, $4)
                RETURNING id, user_id, code, type, expires_at, used_at, created_at
                "#,
            )
            .bind(user_id)
            .bind(&code)
            .bind(verification_type.as_str())
            .bind(expires_at)
            .fetch_one(pool)
            .await?;

            Ok(VerificationCode {
                id= row.get("id"),
                user_id= row.get("user_id"),
                code: row.get("code"),
                verification_type: VerificationType::from_str(row.get("type")).unwrap(),
                expires_at: row.get("expires_at"),
                used_at: row.get("used_at"),
                created_at: row.get("created_at"),
            })
        }

        pub async fn validate_verification_code(
            pool: &PgPool,
            user_id= i64,
            code: &str,
            verification_type: VerificationType,
        ) -> Result<bool, sqlx::Error> {
            // Find the code and mark it as used if valid
            let result = sqlx::query(
                r#"
                UPDATE verification_codes 
                SET used_at = NOW() 
                WHERE user_id = $1 
                  AND code = $2 
                  AND type = $3 
                  AND used_at IS NULL 
                  AND expires_at > NOW()
                "#,
            )
            .bind(user_id)
            .bind(code)
            .bind(verification_type.as_str())
            .execute(pool)
            .await?;

            let is_valid = result.rows_affected() > 0;

            if is_valid {
                match verification_type {
                    VerificationType::Email => {
                        sqlx::query("UPDATE users SET email_verified = true WHERE id = $1")
                            .bind(user_id)
                            .execute(pool)
                            .await?;
                        info!("Email verified for user_id= {}", user_id);
                    }
                    VerificationType::Phone => {
                        sqlx::query("UPDATE users SET phone_verified = true WHERE id = $1")
                            .bind(user_id)
                            .execute(pool)
                            .await?;
                        info!("Phone verified for user_id= {}", user_id);
                    }
                }
            }

            Ok(is_valid)
        }

        pub async fn cleanup_expired_codes(pool: &PgPool) -> Result<u64, sqlx::Error> {
            let result = sqlx::query("DELETE FROM verification_codes WHERE expires_at < NOW()")
                .execute(pool)
                .await?;

            debug!(
                "Cleaned up {} expired verification codes",
                result.rows_affected()
            );
            Ok(result.rows_affected())
        }

        pub async fn update_user_phone_number(
            pool: &PgPool,
            user_id= i64,
            phone_number: &str,
        ) -> Result<(), sqlx::Error> {
            sqlx::query("UPDATE users SET phone_number = $1 WHERE id = $2")
                .bind(phone_number)
                .bind(user_id)
                .execute(pool)
                .await?;

            Ok(())
        }

        pub async fn get_user_verification_status(
            pool: &PgPool,
            user_id= i64,
        ) -> Result<Option<(bool, bool)>, sqlx::Error> {
            let row = sqlx::query("SELECT email_verified, phone_verified FROM users WHERE id = $1")
                .bind(user_id)
                .fetch_optional(pool)
                .await?;

            Ok(row.map(|r| {
                (
                    r.get::<Option<bool>, _>("email_verified").unwrap_or(false),
                    r.get::<Option<bool>, _>("phone_verified").unwrap_or(false),
                )
            }))
        }

        pub async fn is_user_fully_verified(pool: &PgPool, user_id= i64) -> Result<bool, sqlx::Error> {
            let row = sqlx::query("SELECT email_verified, phone_verified FROM users WHERE id = $1")
                .bind(user_id)
                .fetch_optional(pool)
                .await?;

            Ok(row
                .map(|r| {
                    r.get::<Option<bool>, _>("email_verified").unwrap_or(false)
                        && r.get::<Option<bool>, _>("phone_verified").unwrap_or(false)
                })
                .unwrap_or(false))
        }

        // ===== ADMIN QUERIES =====

        pub async fn get_all_invitations_for_admin(
            pool: &PgPool,
            limit: i64,
            offset: i64,
        ) -> Result<Vec<Invitation>, sqlx::Error> {
            let rows = sqlx::query(
                r#"
                SELECT i.id, i.code, i.school_name, i.invited_by_user_id, i.role, 
                       i.max_uses, i.current_uses, i.expires_at, i.created_at
                FROM invitations i
                ORDER BY i.created_at DESC
                LIMIT $1 OFFSET $2
                "#,
            )
            .bind(limit)
            .bind(offset)
            .fetch_all(pool)
            .await?;

            Ok(rows
                .into_iter()
                .map(|r| Invitation {
                    id= r.get("id"),
                    code: r.get("code"),
                    school_name: r.get("school_name"),
                    invited_by_user_id= r.get("invited_by_user_id"),
                    role: r.get("role"),
                    max_uses: r.get("max_uses"),
                    current_uses: r.get("current_uses"),
                    expires_at: r.get("expires_at"),
                    created_at: r.get("created_at"),
                })
                .collect())
        }

        pub async fn delete_invitation(pool: &PgPool, invitation_id= i64) -> Result<bool, sqlx::Error> {
            let result = sqlx::query("DELETE FROM invitations WHERE id = $1")
                .bind(invitation_id)
                .execute(pool)
                .await?;

            Ok(result.rows_affected() > 0)
        }

        pub async fn count_recent_verification_codes(
            pool: &PgPool,
            user_id= i64,
            verification_type: VerificationType,
            minutes: i32,
        ) -> Result<i64, sqlx::Error> {
            let since = Utc::now() - Duration::minutes(minutes as i64);

            let count = sqlx::query(
                "SELECT COUNT(*) as count FROM verification_codes WHERE user_id = $1 AND type = $2 AND created_at > $3"
            )
            .bind(user_id)
            .bind(verification_type.as_str())
            .bind(since)
            .fetch_one(pool)
            .await?;

            Ok(count.get::<Option<i64>, _>("count").unwrap_or(0))
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use crate::app::models::course::{Course, CreateCourseRequest, UpdateCourseRequest};
        use crate::app::models::student::GradeEnum;
        use crate::app::models::enrollment::AcademicYear;
        use chrono::{DateTime, Utc};
        use leptos::prelude::*;
        use log::{debug, error, info, warn};
        use sqlx::prelude::*;
        use sqlx::PgPool;

        pub async fn get_all_courses(pool: &PgPool) -> Result<Vec<Course>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses ORDER BY academic_year DESC, course_level, subject, name"
            )
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let courses: Vec<Course> = rows
                .into_iter()
                .map(|row| {
                    Course {
                        id= row.get("id"),
                        name: row.get("name"),
                        subject: row.get("subject"),
                        course_code: row.get("course_code"),
                        course_level: row.get("course_level"),
                        teacher_id= row.get("teacher_id"),
                        academic_year: row.get("academic_year"),
                        semester_period: row.get("semester_period"),
                        credits: row.get("credits"),
                        description: row.get("description"),
                        max_students: row.get("max_students"),
                        room_number: row.get("room_number"),
                        created_at: row.get("created_at"),
                        updated_at: row.get("updated_at"),
                    }
                })
                .collect();

            Ok(courses)
        }

        pub async fn get_course_by_id(pool: &PgPool, course_id= i32) -> Result<Course, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses WHERE id = $1"
            )
            .bind(course_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let course = Course {
                id= row.get("id"),
                name: row.get("name"),
                subject: row.get("subject"),
                course_code: row.get("course_code"),
                course_level: row.get("course_level"),
                teacher_id= row.get("teacher_id"),
                academic_year: row.get("academic_year"),
                semester_period: row.get("semester_period"),
                credits: row.get("credits"),
                description: row.get("description"),
                max_students: row.get("max_students"),
                room_number: row.get("room_number"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            };

            Ok(course)
        }

        pub async fn get_course_by_code(pool: &PgPool, course_code: &str) -> Result<Course, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses WHERE course_code = $1"
            )
            .bind(course_code)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let course = Course {
                id= row.get("id"),
                name: row.get("name"),
                subject: row.get("subject"),
                course_code: row.get("course_code"),
                course_level: row.get("course_level"),
                teacher_id= row.get("teacher_id"),
                academic_year: row.get("academic_year"),
                semester_period: row.get("semester_period"),
                credits: row.get("credits"),
                description: row.get("description"),
                max_students: row.get("max_students"),
                room_number: row.get("room_number"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            };

            Ok(course)
        }

        pub async fn add_course(pool: &PgPool, request: CreateCourseRequest) -> Result<Course, leptos::ServerFnError> {
            let row = sqlx::query(
                "INSERT INTO courses (name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at"
            )
            .bind(&request.name)
            .bind(&request.subject)
            .bind(&request.course_code)
            .bind(&request.course_level)
            .bind(&request.teacher_id)
            .bind(&request.academic_year)
            .bind(&request.semester_period)
            .bind(&request.credits)
            .bind(&request.description)
            .bind(&request.max_students)
            .bind(&request.room_number)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let course = Course {
                id= row.get("id"),
                name: row.get("name"),
                subject: row.get("subject"),
                course_code: row.get("course_code"),
                course_level: row.get("course_level"),
                teacher_id= row.get("teacher_id"),
                academic_year: row.get("academic_year"),
                semester_period: row.get("semester_period"),
                credits: row.get("credits"),
                description: row.get("description"),
                max_students: row.get("max_students"),
                room_number: row.get("room_number"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            };

            Ok(course)
        }

        pub async fn update_course(pool: &PgPool, course_id= i32, request: UpdateCourseRequest) -> Result<Course, leptos::ServerFnError> {
            // First, get the current course to use as defaults for None values
            let current_course = get_course_by_id(pool, course_id).await?;

            let row = sqlx::query(
                "UPDATE courses SET name = $2, subject = $3, course_code = $4, course_level = $5, teacher_id = $6, academic_year = $7, semester_period = $8, credits = $9, description = $10, max_students = $11, room_number = $12, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at"
            )
            .bind(course_id)
            .bind(request.name.as_ref().unwrap_or(&current_course.name))
            .bind(request.subject.as_ref().unwrap_or(&current_course.subject))
            .bind(request.course_code.as_ref().unwrap_or(&current_course.course_code))
            .bind(request.course_level.as_ref().unwrap_or(&current_course.course_level))
            .bind(request.teacher_id.unwrap_or(current_course.teacher_id))
            .bind(request.academic_year.as_ref().unwrap_or(&current_course.academic_year))
            .bind(request.semester_period.as_ref().unwrap_or(&current_course.semester_period))
            .bind(request.credits.unwrap_or(current_course.credits))
            .bind(request.description.as_ref().unwrap_or(&current_course.description))
            .bind(request.max_students.unwrap_or(current_course.max_students))
            .bind(
                match &request.room_number {
                    Some(new_room) => new_room.as_ref(), // Some(Some(val)) -> Some(val), Some(None) -> None
                    None => current_course.room_number.as_ref(), // Use current value if not specified
                }
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let course = Course {
                id= row.get("id"),
                name: row.get("name"),
                subject: row.get("subject"),
                course_code: row.get("course_code"),
                course_level: row.get("course_level"),
                teacher_id= row.get("teacher_id"),
                academic_year: row.get("academic_year"),
                semester_period: row.get("semester_period"),
                credits: row.get("credits"),
                description: row.get("description"),
                max_students: row.get("max_students"),
                room_number: row.get("room_number"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            };

            Ok(course)
        }

        pub async fn delete_course(pool: &PgPool, course_id= i32) -> Result<(), leptos::ServerFnError> {
            let result = sqlx::query("DELETE FROM courses WHERE id = $1")
                .bind(course_id)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            if result.rows_affected() == 0 {
                return Err(leptos::ServerFnError::new("Course not found".to_string()));
            }

            Ok(())
        }

        // Additional helper functions
        pub async fn get_courses_by_teacher(pool: &PgPool, teacher_id= i32) -> Result<Vec<Course>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses WHERE teacher_id = $1 ORDER BY academic_year DESC, course_level, subject, name"
            )
            .bind(teacher_id)
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let courses: Vec<Course> = rows
                .into_iter()
                .map(|row| {
                    Course {
                        id= row.get("id"),
                        name: row.get("name"),
                        subject: row.get("subject"),
                        course_code: row.get("course_code"),
                        course_level: row.get("course_level"),
                        teacher_id= row.get("teacher_id"),
                        academic_year: row.get("academic_year"),
                        semester_period: row.get("semester_period"),
                        credits: row.get("credits"),
                        description: row.get("description"),
                        max_students: row.get("max_students"),
                        room_number: row.get("room_number"),
                        created_at: row.get("created_at"),
                        updated_at: row.get("updated_at"),
                    }
                })
                .collect();

            Ok(courses)
        }

        pub async fn get_courses_by_academic_year(pool: &PgPool, academic_year: AcademicYear) -> Result<Vec<Course>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses WHERE academic_year = $1 ORDER BY course_level, subject, name"
            )
            .bind(&academic_year)
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let courses: Vec<Course> = rows
                .into_iter()
                .map(|row| {
                    Course {
                        id= row.get("id"),
                        name: row.get("name"),
                        subject: row.get("subject"),
                        course_code: row.get("course_code"),
                        course_level: row.get("course_level"),
                        teacher_id= row.get("teacher_id"),
                        academic_year: row.get("academic_year"),
                        semester_period: row.get("semester_period"),
                        credits: row.get("credits"),
                        description: row.get("description"),
                        max_students: row.get("max_students"),
                        room_number: row.get("room_number"),
                        created_at: row.get("created_at"),
                        updated_at: row.get("updated_at"),
                    }
                })
                .collect();

            Ok(courses)
        }

        pub async fn get_courses_by_level(pool: &PgPool, level: GradeEnum) -> Result<Vec<Course>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, name, subject, course_code, course_level, teacher_id, academic_year, semester_period, credits, description, max_students, room_number, created_at, updated_at FROM courses WHERE course_level = $1 ORDER BY academic_year DESC, subject, name"
            )
            .bind(&level)
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let courses: Vec<Course> = rows
                .into_iter()
                .map(|row| {
                    Course {
                        id= row.get("id"),
                        name: row.get("name"),
                        subject: row.get("subject"),
                        course_code: row.get("course_code"),
                        course_level: row.get("course_level"),
                        teacher_id= row.get("teacher_id"),
                        academic_year: row.get("academic_year"),
                        semester_period: row.get("semester_period"),
                        credits: row.get("credits"),
                        description: row.get("description"),
                        max_students: row.get("max_students"),
                        room_number: row.get("room_number"),
                        created_at: row.get("created_at"),
                        updated_at: row.get("updated_at"),
                    }
                })
                .collect();

            Ok(courses)
        }

        pub async fn check_course_exists(pool: &PgPool, course_code: &str) -> Result<bool, leptos::ServerFnError> {
            let row = sqlx::query("SELECT EXISTS(SELECT 1 FROM courses WHERE course_code = $1)")
                .bind(course_code)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let exists: bool = row.get("exists");
            Ok(exists)
        }

        pub async fn get_course_enrollment_count(pool: &PgPool, course_id= i32) -> Result<i64, leptos::ServerFnError> {
            let row = sqlx::query("SELECT COUNT(*) as count FROM student_enrollments WHERE course_id = $1")
                .bind(course_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let count: i64 = row.get("count");
            Ok(count)
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::{Pool, Postgres, Row};
        use leptos::leptos::ServerFnError;
        use crate::app::models::auth::{SamlConfig, SamlResponse, AuthProvider};
        use crate::app::models::user::{SessionUser, UserRole, AccountStatus};
        use crate::app::db::user_database;
        use uuid=:Uuid;
        use std::collections::HashMap;
        use roxmltree::Document;
        use base64::{Engine as _, engine::general_purpose};
        use chrono::{DateTime, Utc};

        pub struct SamlManager {
            pub base_url: String,
        }

        impl SamlManager {
            pub fn new(base_url: &str) -> Result<Self, Box<dyn std::error::Error>> {
                Ok(SamlManager {
                    base_url: base_url.to_string(),
                })
            }

            pub fn generate_auth_request(&self, institution_id= &str, relay_state: Option<&str>) -> Result<String, Box<dyn std::error::Error>> {
                // Generate a simple SAML AuthnRequest
                let request_id = format!("_{}", uuid=:Uuid=:new_v4().simple());
                let issue_instant = chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

                let auth_request_xml = format!(r#"<?xml version="1.0" encoding="UTF-8"?>
            <samlp:AuthnRequest 
                xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                ID="{}"
                Version="2.0"
                IssueInstant="{}"
                Destination=""
                AssertionConsumerServiceURL="{}/saml/acs"
                ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST">
                <saml:Issuer>{}/saml/metadata</saml:Issuer>
                <samlp:NameIDPolicy 
                    Format="urn:oasis:names:tc:SAML:2.0:nameid-format:emailAddress"
                    AllowCreate="true"/>
            </samlp:AuthnRequest>"#, 
                    request_id,
                    issue_instant,
                    self.base_url,
                    self.base_url
                );

                // Base64 encode the request
                let encoded = general_purpose::STANDARD.encode(&auth_request_xml);

                // Create redirect URL - this should be customized based on your IdP
                let mut url = url::Url::parse(&format!("{}/sso", self.base_url))?;
                url.query_pairs_mut()
                    .append_pair("SAMLRequest", &encoded);

                if let Some(state) = relay_state {
                    url.query_pairs_mut().append_pair("RelayState", state);
                }

                Ok(url.to_string())
            }

            pub fn parse_saml_response(&self, saml_xml: &str, institution_id= &str) -> Result<SamlResponse, Box<dyn std::error::Error>> {
                let doc = Document::parse(saml_xml)?;

                // Extract NameID
                let name_id = doc
                    .descendants()
                    .find(|n| n.has_tag_name("NameID") || n.has_tag_name("saml:NameID"))
                    .and_then(|n| n.text())
                    .ok_or("NameID not found in SAML response")?
                    .to_string();

                // Extract attributes
                let mut attributes = HashMap::new();
                for attr_node in doc.descendants().filter(|n| n.has_tag_name("Attribute") || n.has_tag_name("saml:Attribute")) {
                    if let Some(name) = attr_node.attribute("Name") {
                        let values: Vec<String> = attr_node
                            .descendants()
                            .filter(|n| n.has_tag_name("AttributeValue") || n.has_tag_name("saml:AttributeValue"))
                            .filter_map(|n| n.text())
                            .map(|s| s.to_string())
                            .collect();
                        if !values.is_empty() {
                            attributes.insert(name.to_string(), values);
                        }
                    }
                }

                // Extract common attributes with fallbacks
                let email = self.extract_attribute(&attributes, &[
                    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
                    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name",
                    "mail",
                    "email",
                    "emailAddress"
                ]).or_else(|| {
                    // If no email attribute, try to use NameID if it looks like an email
                    if name_id.contains('@') { Some(name_id.clone()) } else { None }
                });

                let first_name = self.extract_attribute(&attributes, &[
                    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
                    "givenName",
                    "firstName",
                    "given_name"
                ]);

                let last_name = self.extract_attribute(&attributes, &[
                    "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",
                    "sn",
                    "surname",
                    "lastName",
                    "last_name",
                    "familyName"
                ]);

                let display_name = self.extract_attribute(&attributes, &[
                    "http://schemas.microsoft.com/identity/claims/displayname",
                    "displayName",
                    "cn",
                    "commonName"
                ]).or_else(|| {
                    // Construct display name from first and last name if available
                    match (first_name.as_ref(), last_name.as_ref()) {
                        (Some(first), Some(last)) => Some(format!("{} {}", first, last)),
                        (Some(first), None) => Some(first.clone()),
                        (None, Some(last)) => Some(last.clone()),
                        _ => None
                    }
                });

                let session_index = doc
                    .descendants()
                    .find(|n| n.has_tag_name("AuthnStatement") || n.has_tag_name("saml:AuthnStatement"))
                    .and_then(|n| n.attribute("SessionIndex"))
                    .map(|s| s.to_string());

                log::info!("Parsed SAML response - NameID: {}, Email: {:?}, DisplayName: {:?}",
                    name_id, email, display_name);

                Ok(SamlResponse {
                    name_id,
                    email,
                    first_name,
                    last_name,
                    display_name,
                    attributes,
                    session_index,
                })
            }

            fn extract_attribute(&self, attributes: &HashMap<String, Vec<String>>, keys: &[&str]) -> Option<String> {
                for key in keys {
                    if let Some(values) = attributes.get(*key) {
                        if let Some(value) = values.first() {
                            if !value.trim().is_empty() {
                                return Some(value.clone());
                            }
                        }
                    }
                }
                None
            }

            pub fn generate_logout_request(&self, name_id= &str, session_index: Option<&str>) -> Result<String, Box<dyn std::error::Error>> {
                let request_id = format!("_{}", uuid=:Uuid=:new_v4().simple());
                let issue_instant = chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

                let session_index_xml = if let Some(index) = session_index {
                    format!("<samlp:SessionIndex>{}</samlp:SessionIndex>", index)
                } else {
                    String::new()
                };

                let logout_request_xml = format!(r#"<?xml version="1.0" encoding="UTF-8"?>
    <samlp:LogoutRequest 
        xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
        xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
        ID="{}"
        Version="2.0"
        IssueInstant="{}"
        Destination="">
        <saml:Issuer>{}/saml/metadata</saml:Issuer>
        <saml:NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:emailAddress">{}</saml:NameID>
        {}
    </samlp:LogoutRequest>"#, 
                        request_id,
                        issue_instant,
                        self.base_url,
                        name_id,
                        session_index_xml
                    );

                let encoded = general_purpose::STANDARD.encode(&logout_request_xml);
                Ok(encoded)
            }
        }

        pub async fn get_saml_config(pool: &Pool<Postgres>, institution_id= &str) -> Result<Option<SamlConfig>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, institution_name, entity_id, sso_url, slo_url, x509_cert, metadata_url,
                        active, created_at, updated_at, attribute_mapping, role_mapping, 
                        auto_provision, require_encrypted_assertions
                 FROM saml_configs WHERE institution_name = $1 AND active = true"
            )
            .bind(institution_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                    let role_mapping: serde_json::Value = row.get("role_mapping");

                    Ok(Some(SamlConfig {
                        id= row.get("id"),
                        institution_name: row.get("institution_name"),
                        entity_id= row.get("entity_id"),
                        sso_url: row.get("sso_url"),
                        slo_url: row.get("slo_url"),
                        x509_cert: row.get("x509_cert"),
                        metadata_url: row.get("metadata_url"),
                        active: row.get("active"),
                        created_at: row.get("created_at"),
                        updated_at: row.get("updated_at"),
                        attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                        role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                        auto_provision: row.get("auto_provision"),
                        require_encrypted_assertions: row.get("require_encrypted_assertions"),
                    }))
                }
                None => Ok(None),
            }
        }

        // FIXED: Use manual query instead of query_as! to handle type conversions
        pub async fn get_saml_config_by_name(
            pool: &sqlx::PgPool,
            institution_name: &str,
        ) -> Result<Option<SamlConfig>, sqlx::Error> {
            let row = sqlx::query(
                "SELECT id, institution_name, entity_id, sso_url, slo_url, x509_cert, metadata_url,
                        active, created_at, updated_at, attribute_mapping, role_mapping, 
                        auto_provision, require_encrypted_assertions
                 FROM saml_configs WHERE institution_name = $1 AND active = true"
            )
            .bind(institution_name)
            .fetch_optional(pool)
            .await?;

            match row {
                Some(row) => {
                    // Manual conversion from time::OffsetDateTime to chrono::DateTime<Utc>
                    let created_at: time::OffsetDateTime = row.get("created_at");
                    let updated_at: time::OffsetDateTime = row.get("updated_at");

                    // Convert time::OffsetDateTime to chrono::DateTime<Utc>
                    let created_at_chrono = DateTime::<Utc>::from_timestamp(
                        created_at.unix_timestamp(),
                        created_at.nanosecond()
                    ).unwrap_or_else(|| Utc::now());

                    let updated_at_chrono = DateTime::<Utc>::from_timestamp(
                        updated_at.unix_timestamp(),
                        updated_at.nanosecond()
                    ).unwrap_or_else(|| Utc::now());

                    // Manual conversion for JSON fields
                    let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                    let role_mapping: serde_json::Value = row.get("role_mapping");

                    Ok(Some(SamlConfig {
                        id= row.get("id"),
                        institution_name: row.get("institution_name"),
                        entity_id= row.get("entity_id"),
                        sso_url: row.get("sso_url"),
                        slo_url: row.get("slo_url"),
                        x509_cert: row.get("x509_cert"),
                        metadata_url: row.get("metadata_url"),
                        active: row.get("active"),
                        created_at: created_at_chrono,
                        updated_at: updated_at_chrono,
                        attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                        role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                        auto_provision: row.get("auto_provision"),
                        require_encrypted_assertions: row.get("require_encrypted_assertions"),
                    }))
                }
                None => Ok(None),
            }
        }

        // Just-in-time user provisioning
        pub async fn provision_saml_user(
            pool: &Pool<Postgres>,
            saml_response: &SamlResponse,
            institution_id= &str,
        ) -> Result<SessionUser, leptos::ServerFnError> {
            // First check if user already exists with SAML mapping
            if let Some(existing_user) = get_user_by_saml_mapping(pool, institution_id, &saml_response.name_id).await? {
                // Update last login time
                update_saml_user_mapping_login(pool, existing_user.id, institution_id).await?;
                return Ok(existing_user);
            }

            // Check if user exists by email
            let email = saml_response.email.as_ref().unwrap_or(&saml_response.name_id);
            if let Some(existing_user) = user_database::get_user_by_email(pool, email).await? {
                // Link existing user to SAML
                link_user_to_saml(pool, existing_user.id, institution_id, &saml_response.name_id).await?;
                return Ok(existing_user.to_session_user());
            }

            // Create new user with SAML data
            let username = email.split('@').next().unwrap_or(&saml_response.name_id).to_string();

            // Generate a random password (user won't use it for SAML login)
            let temp_password = uuid=:Uuid=:new_v4().to_string();

            // Determine role from SAML attributes
            let role = determine_role_from_saml_attributes(&saml_response.attributes);

            // Create user with profile data from SAML
            let user = create_user_from_saml(pool, username, email.clone(), temp_password, role, saml_response).await?;

            // Store SAML association
            store_saml_user_association(pool, user.id, institution_id, &saml_response.name_id).await?;

            Ok(user)
        }

        async fn create_user_from_saml(
            pool: &Pool<Postgres>,
            username: String,
            email: String,
            password: String,
            role: UserRole,
            saml_response: &SamlResponse,
        ) -> Result<SessionUser, leptos::ServerFnError> {
            use argon2::{Argon2, PasswordHasher, password_hash::{SaltString, rand_core::OsRng}};

            let salt = SaltString::generate(&mut OsRng);
            let argon2 = Argon2::default();
            let password_hash = argon2
                .hash_password(password.as_bytes(), &salt)
                .map_err(|e| leptos::ServerFnError::new(format!("Password hashing error: {}", e)))?
                .to_string();

            // Map UserRole to database enum values
            let role_str = match role {
                UserRole::Admin => "admin",
                UserRole::Teacher => "teacher",
                UserRole::User => "user",           // This maps to DB 'user'
                UserRole::Guest => "guest",         // This maps to DB 'guest'
                UserRole::SuperAdmin => "superadmin",
            };

            // Provide sensible defaults for missing fields
            let first_name = saml_response.first_name
                .as_ref()
                .filter(|name| !name.trim().is_empty())
                .cloned()
                .or_else(|| {
                    // Extract from email if no first name
                    email.split('@').next()
                        .map(|name| name.to_string())
                })
                .unwrap_or_else(|| "User".to_string());

            let last_name = saml_response.last_name
                .as_ref()
                .filter(|name| !name.trim().is_empty())
                .cloned()
                .unwrap_or_else(|| "".to_string());

            let display_name = saml_response.display_name
                .as_ref()
                .filter(|name| !name.trim().is_empty())
                .cloned()
                .or_else(|| {
                    // Construct from first/last name
                    if !last_name.is_empty() {
                        Some(format!("{} {}", first_name, last_name).trim().to_string())
                    } else {
                        Some(first_name.clone())
                    }
                })
                .filter(|name| !name.trim().is_empty())
                .unwrap_or_else(|| username.clone());

            log::info!("Creating SAML user: {} ({}) with role: {}", username, email, role_str);

            let row = sqlx::query(
                "INSERT INTO users (
                    username, 
                    email, 
                    password_hash, 
                    role, 
                    account_status, 
                    email_verified,
                    first_name, 
                    last_name, 
                    display_name, 
                    created_at, 
                    updated_at
                )
                VALUES ($1, $2, $3, $4::user_role_enum, 'active'::account_status_enum, true, $5, $6, $7, NOW(), NOW())
                RETURNING id, username, email, role, display_name, first_name, last_name"
            )
            .bind(&username)
            .bind(&email)
            .bind(&password_hash)
            .bind(role_str)
            .bind(&first_name)
            .bind(&last_name)
            .bind(&display_name)
            .fetch_one(pool)
            .await
            .map_err(|e| {
                log::error!("Failed to create SAML user: {}", e);
                leptos::ServerFnError::new(format!("Failed to create user: {}", e))
            })?;

            Ok(SessionUser {
                id= row.get("id"),
                username: row.get("username"),
                email: row.get("email"),
                role,
                display_name: Some(row.get("display_name")),
                first_name: Some(row.get("first_name")),
                last_name: Some(row.get("last_name")),
            })
        }

        fn determine_role_from_saml_attributes(attributes: &HashMap<String, Vec<String>>) -> UserRole {
            // Check for role attributes in common SAML claim formats
            let role_claims = [
                "http://schemas.microsoft.com/ws/2008/06/identity/claims/role",
                "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/role",
                "eduPersonAffiliation",
                "memberOf",
                "groups",
                "role",
                "roles",
            ];

            for claim in &role_claims {
                if let Some(roles) = attributes.get(*claim) {
                    for role in roles {
                        let role_lower = role.to_lowercase();

                        // Check for admin roles
                        if role_lower.contains("admin") ||
                           role_lower.contains("administrator") ||
                           role_lower.contains("superadmin") {
                            return UserRole::Admin;
                        }

                        // Check for teacher/instructor roles
                        if role_lower.contains("teacher") ||
                           role_lower.contains("instructor") ||
                           role_lower.contains("faculty") ||
                           role_lower.contains("staff") ||
                           role_lower.contains("educator") {
                            return UserRole::Teacher;
                        }

                        // Check for student roles
                        if role_lower.contains("student") ||
                           role_lower.contains("learner") {
                            return UserRole::User;  // Changed from UserRole::User to map to DB 'user'
                        }
                    }
                }
            }

            // Default to Guest role (safest default)
            UserRole::Guest
        }

        async fn get_user_by_saml_mapping(
            pool: &Pool<Postgres>,
            institution_id= &str,
            saml_name_id= &str,
        ) -> Result<Option<SessionUser>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT u.id, u.username, u.email, u.role, u.account_status, u.email_verified,
                        u.first_name, u.last_name, u.display_name, u.created_at
                 FROM users u
                 INNER JOIN saml_user_mappings sum ON u.id = sum.user_id
                 WHERE sum.institution_id = $1 AND sum.saml_name_id = $2 AND u.account_status = 'active'"
            )
            .bind(institution_id)
            .bind(saml_name_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let role: UserRole = row.get("role");

                    Ok(Some(SessionUser {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        role,
                        display_name: row.get("display_name"),
                        first_name: row.get("first_name"),
                        last_name: row.get("last_name"),
                    }))
                }
                None => Ok(None),
            }
        }

        async fn link_user_to_saml(
            pool: &Pool<Postgres>,
            user_id= i64,
            institution_id= &str,
            saml_name_id= &str,
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "INSERT INTO saml_user_mappings (user_id, institution_id, saml_name_id, created_at, last_login)
                 VALUES ($1, $2, $3, NOW(), NOW())
                 ON CONFLICT (user_id, institution_id) DO UPDATE SET 
                 saml_name_id = $3, last_login = NOW()"
            )
            .bind(user_id)
            .bind(institution_id)
            .bind(saml_name_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to link user to SAML: {}", e)))?;

            Ok(())
        }

        async fn store_saml_user_association(
            pool: &Pool<Postgres>,
            user_id= i64,
            institution_id= &str,
            saml_name_id= &str,
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "INSERT INTO saml_user_mappings (user_id, institution_id, saml_name_id, created_at, last_login)
                 VALUES ($1, $2, $3, NOW(), NOW())"
            )
            .bind(user_id)
            .bind(institution_id)
            .bind(saml_name_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to store SAML association: {}", e)))?;

            Ok(())
        }

        async fn update_saml_user_mapping_login(
            pool: &Pool<Postgres>,
            user_id= i64,
            institution_id= &str,
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE saml_user_mappings SET last_login = NOW()
                 WHERE user_id = $1 AND institution_id = $2"
            )
            .bind(user_id)
            .bind(institution_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to update login time: {}", e)))?;

            Ok(())
        }

        // Admin functions for SAML management
        pub async fn get_institution_users(
            pool: &Pool<Postgres>,
            institution_id= &str,
        ) -> Result<Vec<SessionUser>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT u.id, u.username, u.email, u.role, u.account_status, u.email_verified,
                        u.first_name, u.last_name, u.display_name, u.created_at,
                        sum.last_login
                 FROM users u
                 INNER JOIN saml_user_mappings sum ON u.id = sum.user_id
                 WHERE sum.institution_id = $1 AND u.account_status = 'active'
                 ORDER BY sum.last_login DESC"
            )
            .bind(institution_id)
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let mut users = Vec::new();
            for row in rows {
                let role: UserRole = row.get("role"); // Direct read

                users.push(SessionUser {
                    id= row.get("id"),
                    username: row.get("username"),
                    email: row.get("email"),
                    role, // Use the directly read role
                    display_name: row.get("display_name"),
                    first_name: row.get("first_name"),
                    last_name: row.get("last_name"),
                });
            }


            Ok(users)
        }

        // Update session to track auth provider
        pub async fn create_saml_session(
            pool: &Pool<Postgres>,
            user_id= i64,
            institution_id= &str
        ) -> Result<String, leptos::ServerFnError> {
            use rand::{distributions::Alphanumeric, Rng};

            let token: String = rand::thread_rng()
                .sample_iter(&Alphanumeric)
                .take(64)
                .map(char::from)
                .collect();

            sqlx::query(
                "INSERT INTO sessions (user_id, token, expires_at, created_at, auth_provider, institution_id)
                 VALUES ($1, $2, NOW() + INTERVAL '7 days', NOW(), 'saml', $3)"
            )
            .bind(user_id)
            .bind(&token)
            .bind(institution_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to create session: {}", e)))?;

            Ok(token)
        }

        pub async fn create_session_with_provider(
            pool: &Pool<Postgres>, user_id= i64,
            auth_provider: &str,
            institution_id= Option<&str>
        ) -> Result<String, sqlx::Error> {
            use rand::{distributions::Alphanumeric, Rng};

            let token: String = rand::thread_rng()
                .sample_iter(&Alphanumeric)
                .take(64)
                .map(char::from)
                .collect();

            sqlx::query(
                "INSERT INTO sessions (user_id, token, expires_at, created_at, auth_provider, institution_id)
                 VALUES ($1, $2, NOW() + INTERVAL '7 days', NOW(), $3, $4)"
            )
            .bind(user_id)
            .bind(&token)
            .bind(auth_provider)
            .bind(institution_id)
            .execute(pool)
            .await?;

            Ok(token)
        }

        pub async fn list_saml_configs(pool: &Pool<Postgres>) -> Result<Vec<SamlConfig>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, institution_name, entity_id, sso_url, slo_url, x509_cert, metadata_url,
                        active, created_at, updated_at, attribute_mapping, role_mapping, 
                        auto_provision, require_encrypted_assertions
                 FROM saml_configs ORDER BY institution_name"
            )
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let mut configs = Vec::new();
            for row in rows {
                let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                let role_mapping: serde_json::Value = row.get("role_mapping");

                configs.push(SamlConfig {
                    id= row.get("id"),
                    institution_name: row.get("institution_name"),
                    entity_id= row.get("entity_id"),
                    sso_url: row.get("sso_url"),
                    slo_url: row.get("slo_url"),
                    x509_cert: row.get("x509_cert"),
                    metadata_url: row.get("metadata_url"),
                    active: row.get("active"),
                    created_at: row.get("created_at"),
                    updated_at: row.get("updated_at"),
                    attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                    role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                    auto_provision: row.get("auto_provision"),
                    require_encrypted_assertions: row.get("require_encrypted_assertions"),
                });
            }

            Ok(configs)
        }

        pub async fn create_saml_config(pool: &Pool<Postgres>, config: &SamlConfig) -> Result<(), leptos::ServerFnError> {
            let attribute_mapping_json = serde_json::to_value(&config.attribute_mapping)
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to serialize attribute mapping: {}", e)))?;
            let role_mapping_json = serde_json::to_value(&config.role_mapping)
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to serialize role mapping: {}", e)))?;

            sqlx::query(
                "INSERT INTO saml_configs (id, institution_name, entity_id, sso_url, slo_url, x509_cert,
                                          metadata_url, active, created_at, updated_at, attribute_mapping,
                                          role_mapping, auto_provision, require_encrypted_assertions)
                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)"
            )
            .bind(config.id)
            .bind(&config.institution_name)
            .bind(&config.entity_id)
            .bind(&config.sso_url)
            .bind(&config.slo_url)
            .bind(&config.x509_cert)
            .bind(&config.metadata_url)
            .bind(config.active)
            .bind(config.created_at)
            .bind(config.updated_at)
            .bind(attribute_mapping_json)
            .bind(role_mapping_json)
            .bind(config.auto_provision)
            .bind(config.require_encrypted_assertions)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to create SAML config: {}", e)))?;

            Ok(())
        }

        // Get SAML config by ID
        pub async fn get_saml_config_by_id(
            pool: &Pool<Postgres>,
            config_id= uuid=:Uuid,
        ) -> Result<Option<SamlConfig>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, institution_name, entity_id, sso_url, slo_url, x509_cert, metadata_url,
                        active, created_at, updated_at, attribute_mapping, role_mapping, 
                        auto_provision, require_encrypted_assertions
                 FROM saml_configs WHERE id = $1"
            )
            .bind(config_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    // Manual conversion from time::OffsetDateTime to chrono::DateTime<Utc>
                    let created_at: time::OffsetDateTime = row.get("created_at");
                    let updated_at: time::OffsetDateTime = row.get("updated_at");

                    let created_at_chrono = DateTime::<Utc>::from_timestamp(
                        created_at.unix_timestamp(),
                        created_at.nanosecond()
                    ).unwrap_or_else(|| Utc::now());

                    let updated_at_chrono = DateTime::<Utc>::from_timestamp(
                        updated_at.unix_timestamp(),
                        updated_at.nanosecond()
                    ).unwrap_or_else(|| Utc::now());

                    let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                    let role_mapping: serde_json::Value = row.get("role_mapping");

                    Ok(Some(SamlConfig {
                        id= row.get("id"),
                        institution_name: row.get("institution_name"),
                        entity_id= row.get("entity_id"),
                        sso_url: row.get("sso_url"),
                        slo_url: row.get("slo_url"),
                        x509_cert: row.get("x509_cert"),
                        metadata_url: row.get("metadata_url"),
                        active: row.get("active"),
                        created_at: created_at_chrono,
                        updated_at: updated_at_chrono,
                        attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                        role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                        auto_provision: row.get("auto_provision"),
                        require_encrypted_assertions: row.get("require_encrypted_assertions"),
                    }))
                }
                None => Ok(None),
            }
        }

        // Update SAML config
        pub async fn update_saml_config(
            pool: &Pool<Postgres>,
            config_id= uuid=:Uuid,
            institution_name: &str,
            entity_id= &str,
            sso_url: &str,
            slo_url: Option<&str>,
            x509_cert: &str,
            metadata_url: Option<&str>,
            active: bool,
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE saml_configs SET
                    institution_name = $2,
                    entity_id = $3,
                    sso_url = $4,
                    slo_url = $5,
                    x509_cert = $6,
                    metadata_url = $7,
                    active = $8,
                    updated_at = NOW()
                 WHERE id = $1"
            )
            .bind(config_id)
            .bind(institution_name)
            .bind(entity_id)
            .bind(sso_url)
            .bind(slo_url)
            .bind(x509_cert)
            .bind(metadata_url)
            .bind(active)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to update SAML config: {}", e)))?;

            Ok(())
        }

        // Delete SAML config
        pub async fn delete_saml_config(
            pool: &Pool<Postgres>,
            config_id= uuid=:Uuid,
        ) -> Result<String, leptos::ServerFnError> {
            // First get the institution name for the response
            let institution_name: String = sqlx::query_scalar(
                "SELECT institution_name FROM saml_configs WHERE id = $1"
            )
            .bind(config_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?
            .ok_or_else(|| leptos::ServerFnError::new("SAML configuration not found"))?;

            // Delete associated user mappings first (foreign key constraint)
            sqlx::query("DELETE FROM saml_user_mappings WHERE institution_id = $1")
                .bind(&institution_name)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to delete user mappings: {}", e)))?;

            // Delete the SAML config
            let result = sqlx::query("DELETE FROM saml_configs WHERE id = $1")
                .bind(config_id)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to delete SAML config: {}", e)))?;

            if result.rows_affected() == 0 {
                return Err(leptos::ServerFnError::new("SAML configuration not found"));
            }

            Ok(institution_name)
        }

        // Toggle SAML config active status
        pub async fn toggle_saml_config_status(
            pool: &Pool<Postgres>,
            config_id= uuid=:Uuid,
        ) -> Result<(String, bool), leptos::ServerFnError> {
            // Get current status and institution name
            let row = sqlx::query("SELECT institution_name, active FROM saml_configs WHERE id = $1")
                .bind(config_id)
                .fetch_optional(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?
                .ok_or_else(|| leptos::ServerFnError::new("SAML configuration not found"))?;

            let institution_name: String = row.get("institution_name");
            let current_status: bool = row.get("active");
            let new_status = !current_status;

            // Toggle the status
            sqlx::query(
                "UPDATE saml_configs SET active = $2, updated_at = NOW() WHERE id = $1"
            )
            .bind(config_id)
            .bind(new_status)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to toggle SAML config status: {}", e)))?;

            Ok((institution_name, new_status))
        }

        // Get SAML statistics
        pub async fn get_saml_statistics(pool: &Pool<Postgres>) -> Result<crate::app::server_functions::saml_auth::SamlStats, leptos::ServerFnError> {
            // Get total and active institutions
            let institutions_row = sqlx::query(
                "SELECT
                    COUNT(*) as total,
                    COUNT(*) FILTER (WHERE active = true) as active
                 FROM saml_configs"
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let total_institutions: i64 = institutions_row.get("total");
            let active_institutions: i64 = institutions_row.get("active");

            // Get total SAML users
            let total_saml_users: i64 = sqlx::query_scalar(
                "SELECT COUNT(DISTINCT user_id) FROM saml_user_mappings"
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            // Get recent logins (last 30 days)
            let recent_logins: i64 = sqlx::query_scalar(
                "SELECT COUNT(DISTINCT user_id) FROM saml_user_mappings
                 WHERE last_login >= NOW() - INTERVAL '30 days'"
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(crate::app::server_functions::saml_auth::SamlStats {
                total_institutions,
                active_institutions,
                total_saml_users,
                recent_logins,
            })
        }

        // Fetch and parse SAML metadata from URL
        pub async fn fetch_and_parse_metadata(metadata_url: &str) -> Result<crate::app::server_functions::saml_auth::SamlMetadataResponse, leptos::ServerFnError> {
            use reqwest;

            // Fetch metadata XML
            let client = reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(30))
                .build()
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to create HTTP client: {}", e)))?;

            let response = client
                .get(metadata_url)
                .send()
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to fetch metadata: {}", e)))?;

            if !response.status().is_success() {
                return Err(leptos::ServerFnError::new(format!(
                    "HTTP error fetching metadata: {}",
                    response.status()
                )));
            }

            let metadata_xml = response
                .text()
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to read metadata response: {}", e)))?;

            // Parse the XML
            let doc = Document::parse(&metadata_xml)
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to parse metadata XML: {}", e)))?;

            // Extract entity ID
            let entity_id = doc
                .root()
                .attribute("entityID")
                .ok_or_else(|| leptos::ServerFnError::new("EntityID not found in metadata"))?
                .to_string();

            // Extract SSO URL
            let sso_url = doc
                .descendants()
                .find(|n| {
                    n.has_tag_name("SingleSignOnService") || n.has_tag_name("md:SingleSignOnService")
                })
                .and_then(|n| n.attribute("Location"))
                .ok_or_else(|| leptos::ServerFnError::new("SSO URL not found in metadata"))?
                .to_string();

            // Extract SLO URL (optional)
            let slo_url = doc
                .descendants()
                .find(|n| {
                    n.has_tag_name("SingleLogoutService") || n.has_tag_name("md:SingleLogoutService")
                })
                .and_then(|n| n.attribute("Location"))
                .map(|s| s.to_string());

            // Extract X.509 certificate
            let x509_cert = doc
                .descendants()
                .find(|n| n.has_tag_name("X509Certificate") || n.has_tag_name("ds:X509Certificate"))
                .and_then(|n| n.text())
                .ok_or_else(|| leptos::ServerFnError::new("X.509 certificate not found in metadata"))?
                .trim()
                .to_string();

            // Format the certificate properly
            let formatted_cert = if !x509_cert.starts_with("-----BEGIN CERTIFICATE-----") {
                format!(
                    "-----BEGIN CERTIFICATE-----\n{}\n-----END CERTIFICATE-----",
                    x509_cert
                )
            } else {
                x509_cert
            };

            Ok(crate::app::server_functions::saml_auth::SamlMetadataResponse {
                success: true,
                message: "Metadata parsed successfully".to_string(),
                entity_id,
                sso_url,
                slo_url,
                x509_cert: formatted_cert,
            })
        }

        // Get all SAML configurations with detailed info (for admin management)
        pub async fn get_all_saml_configs_detailed(pool: &Pool<Postgres>) -> Result<Vec<SamlConfig>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT sc.id, sc.institution_name, sc.entity_id, sc.sso_url, sc.slo_url,
                        sc.x509_cert, sc.metadata_url, sc.active, sc.created_at, sc.updated_at,
                        sc.attribute_mapping, sc.role_mapping, sc.auto_provision, 
                        sc.require_encrypted_assertions,
                        COUNT(sum.user_id) as user_count,
                        MAX(sum.last_login) as last_used
                 FROM saml_configs sc
                 LEFT JOIN saml_user_mappings sum ON sc.institution_name = sum.institution_id
                 GROUP BY sc.id, sc.institution_name, sc.entity_id, sc.sso_url, sc.slo_url,
                          sc.x509_cert, sc.metadata_url, sc.active, sc.created_at, sc.updated_at,
                          sc.attribute_mapping, sc.role_mapping, sc.auto_provision,
                          sc.require_encrypted_assertions
                 ORDER BY sc.institution_name"
            )
            .fetch_all(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let mut configs = Vec::new();
            for row in rows {
                // Manual conversion from time::OffsetDateTime to chrono::DateTime<Utc>
                let created_at: time::OffsetDateTime = row.get("created_at");
                let updated_at: time::OffsetDateTime = row.get("updated_at");

                let created_at_chrono = DateTime::<Utc>::from_timestamp(
                    created_at.unix_timestamp(),
                    created_at.nanosecond()
                ).unwrap_or_else(|| Utc::now());

                let updated_at_chrono = DateTime::<Utc>::from_timestamp(
                    updated_at.unix_timestamp(),
                    updated_at.nanosecond()
                ).unwrap_or_else(|| Utc::now());

                let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                let role_mapping: serde_json::Value = row.get("role_mapping");

                configs.push(SamlConfig {
                    id= row.get("id"),
                    institution_name: row.get("institution_name"),
                    entity_id= row.get("entity_id"),
                    sso_url: row.get("sso_url"),
                    slo_url: row.get("slo_url"),
                    x509_cert: row.get("x509_cert"),
                    metadata_url: row.get("metadata_url"),
                    active: row.get("active"),
                    created_at: created_at_chrono,
                    updated_at: updated_at_chrono,
                    attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                    role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                    auto_provision: row.get("auto_provision"),
                    require_encrypted_assertions: row.get("require_encrypted_assertions"),
                });
            }

            Ok(configs)
        }

        // Validate SAML configuration
        pub async fn validate_saml_config(
            pool: &Pool<Postgres>,
            config: &SamlConfig,
        ) -> Result<Vec<String>, leptos::ServerFnError> {
            let mut validation_errors = Vec::new();

            // Check for duplicate institution names (excluding current config if updating)
            let existing_count: i64 = sqlx::query_scalar(
                "SELECT COUNT(*) FROM saml_configs WHERE institution_name = $1 AND id != $2"
            )
            .bind(&config.institution_name)
            .bind(config.id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            if existing_count > 0 {
                validation_errors.push(format!(
                    "Institution name '{}' already exists",
                    config.institution_name
                ));
            }

            // Validate URLs
            if !config.sso_url.starts_with("https://") && !config.sso_url.starts_with("http://") {
                validation_errors.push("SSO URL must be a valid HTTP/HTTPS URL".to_string());
            }

            if let Some(ref slo_url) = config.slo_url {
                if !slo_url.starts_with("https://") && !slo_url.starts_with("http://") {
                    validation_errors.push("SLO URL must be a valid HTTP/HTTPS URL".to_string());
                }
            }

            if let Some(ref metadata_url) = config.metadata_url {
                if !metadata_url.starts_with("https://") && !metadata_url.starts_with("http://") {
                    validation_errors.push("Metadata URL must be a valid HTTP/HTTPS URL".to_string());
                }
            }

            // Validate certificate format
            if !config.x509_cert.contains("-----BEGIN CERTIFICATE-----") ||
               !config.x509_cert.contains("-----END CERTIFICATE-----") {
                validation_errors.push("X.509 certificate must be in PEM format".to_string());
            }

            // Validate entity ID format
            if config.entity_id.trim().is_empty() {
                validation_errors.push("Entity ID cannot be empty".to_string());
            }

            Ok(validation_errors)
        }

        // Helper function to update SAML config status
        #[cfg(feature = "ssr")]
        pub async fn update_saml_config_status(
            pool: &Pool<Postgres>,
            config_id= Uuid,
            active: bool,
        ) -> Result<String, leptos::ServerFnError> {
            // Get institution name first
            let institution_name: String = sqlx::query_scalar(
                "SELECT institution_name FROM saml_configs WHERE id = $1"
            )
            .bind(config_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?
            .ok_or_else(|| leptos::ServerFnError::new("SAML configuration not found"))?;

            // Update the status
            sqlx::query(
                "UPDATE saml_configs SET active = $2, updated_at = NOW() WHERE id = $1"
            )
            .bind(config_id)
            .bind(active)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to update SAML config status: {}", e)))?;

            Ok(institution_name)
        }

        // Helper function to get SAML config summary for dashboard
        #[cfg(feature = "ssr")]
        pub async fn get_saml_config_summary(
            pool: &Pool<Postgres>,
        ) -> Result<SamlConfigSummary, leptos::ServerFnError> {
            let summary_row = sqlx::query(
                "SELECT
                    COUNT(*) as total_configs,
                    COUNT(*) FILTER (WHERE active = true) as active_configs,
                    COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '30 days') as recent_configs
                 FROM saml_configs"
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let users_row = sqlx::query(
                "SELECT
                    COUNT(DISTINCT user_id) as total_saml_users,
                    COUNT(DISTINCT user_id) FILTER (WHERE last_login >= NOW() - INTERVAL '30 days') as active_saml_users
                 FROM saml_user_mappings"
            )
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(SamlConfigSummary {
                total_configs: summary_row.get("total_configs"),
                active_configs: summary_row.get("active_configs"),
                recent_configs: summary_row.get("recent_configs"),
                total_saml_users: users_row.get("total_saml_users"),
                active_saml_users: users_row.get("active_saml_users"),
            })
        }

        #[cfg(feature = "ssr")]
        #[derive(Clone, Debug)]
        pub struct SamlConfigSummary {
            pub total_configs: i64,
            pub active_configs: i64,
            pub recent_configs: i64,
            pub total_saml_users: i64,
            pub active_saml_users: i64,
        }

        // Helper function to search and filter SAML configs
        #[cfg(feature = "ssr")]
        pub async fn search_saml_configs(
            pool: &Pool<Postgres>,
            search_term: Option<&str>,
            active_only: bool,
            limit: Option<i64>,
            offset: Option<i64>,
        ) -> Result<Vec<SamlConfig>, leptos::ServerFnError> {
            let mut query = "SELECT id, institution_name, entity_id, sso_url, slo_url, x509_cert, metadata_url,
                                   active, created_at, updated_at, attribute_mapping, role_mapping, 
                                   auto_provision, require_encrypted_assertions
                            FROM saml_configs WHERE 1=1".to_string();

            let mut bind_params: Vec<Box<dyn sqlx::Encode<'_, sqlx::Postgres> + Send + Sync>> = Vec::new();
            let mut param_count = 0;

            if let Some(term) = search_term {
                param_count += 1;
                query.push_str(&format!(" AND (institution_name ILIKE ${} OR entity_id ILIKE ${})", param_count, param_count));
                bind_params.push(Box::new(format!("%{}%", term)));
            }

            if active_only {
                query.push_str(" AND active = true");
            }

            query.push_str(" ORDER BY institution_name");

            if let Some(limit_val) = limit {
                param_count += 1;
                query.push_str(&format!(" LIMIT ${}", param_count));
                bind_params.push(Box::new(limit_val));
            }

            if let Some(offset_val) = offset {
                param_count += 1;
                query.push_str(&format!(" OFFSET ${}", param_count));
                bind_params.push(Box::new(offset_val));
            }

            // This is a simplified version - in practice, you'd want to use sqlx::query_builder
            // for dynamic queries to avoid SQL injection
            let rows = sqlx::query(&query)
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let mut configs = Vec::new();
            for row in rows {
                // Convert time types and JSON as done in other functions
                let created_at: time::OffsetDateTime = row.get("created_at");
                let updated_at: time::OffsetDateTime = row.get("updated_at");

                let created_at_chrono = chrono::DateTime::<chrono::Utc>::from_timestamp(
                    created_at.unix_timestamp(),
                    created_at.nanosecond()
                ).unwrap_or_else(|| chrono::Utc::now());

                let updated_at_chrono = chrono::DateTime::<chrono::Utc>::from_timestamp(
                    updated_at.unix_timestamp(),
                    updated_at.nanosecond()
                ).unwrap_or_else(|| chrono::Utc::now());

                let attribute_mapping: serde_json::Value = row.get("attribute_mapping");
                let role_mapping: serde_json::Value = row.get("role_mapping");

                configs.push(SamlConfig {
                    id= row.get("id"),
                    institution_name: row.get("institution_name"),
                    entity_id= row.get("entity_id"),
                    sso_url: row.get("sso_url"),
                    slo_url: row.get("slo_url"),
                    x509_cert: row.get("x509_cert"),
                    metadata_url: row.get("metadata_url"),
                    active: row.get("active"),
                    created_at: created_at_chrono,
                    updated_at: updated_at_chrono,
                    attribute_mapping: serde_json::from_value(attribute_mapping).unwrap_or_default(),
                    role_mapping: serde_json::from_value(role_mapping).unwrap_or_default(),
                    auto_provision: row.get("auto_provision"),
                    require_encrypted_assertions: row.get("require_encrypted_assertions"),
                });
            }

            Ok(configs)
        }

        // Helper function to export SAML configurations for backup
        #[cfg(feature = "ssr")]
        pub async fn export_saml_configs_csv(
            pool: &Pool<Postgres>,
        ) -> Result<String, leptos::ServerFnError> {
            let configs = list_saml_configs(pool).await?;

            let mut csv_content = String::from("institution_name,entity_id,sso_url,slo_url,active,created_at,metadata_url\n");

            for config in configs {
                csv_content.push_str(&format!(
                    "{},{},{},{},{},{},{}\n",
                    escape_csv_field(&config.institution_name),
                    escape_csv_field(&config.entity_id),
                    escape_csv_field(&config.sso_url),
                    escape_csv_field(&config.slo_url.unwrap_or_default()),
                    config.active,
                    config.created_at.format("%Y-%m-%d %H:%M:%S"),
                    escape_csv_field(&config.metadata_url.unwrap_or_default())
                ));
            }

            Ok(csv_content)
        }

        #[cfg(feature = "ssr")]
        fn escape_csv_field(field: &str) -> String {
            if field.contains(',') || field.contains('"') || field.contains('\n') {
                format!("\"{}\"", field.replace('"', "\"\""))
            } else {
                field.to_string()
            }
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use sqlx::PgPool;
        use leptos::prelude::*;
        use crate::app::models::global::{GlobalSetting, SettingsCache};
        use sqlx::Row;

        pub async fn get_all_global_settings(pool: &sqlx::PgPool) -> Result<SettingsCache, leptos::ServerFnError> {
            let rows = sqlx::query("SELECT key, value, updated_by, updated_at FROM global_settings")
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database query failed: {}", e)))?;

            let settings = rows.into_iter().map(|row| {
                GlobalSetting {
                    key_name: row.get("key"),
                    value: row.get::<serde_json::Value, _>("value").to_string(),
                    updated_by: row.get("updated_by"),
                    updated_at: row.get("updated_at"),
                }
            }).collect();

            Ok(SettingsCache::from_settings(settings))
        }

        pub async fn get_global_settings(pool: &sqlx::PgPool) -> Result<Vec<GlobalSetting>, leptos::ServerFnError> {
            let rows = sqlx::query("SELECT key, value, updated_by, updated_at FROM global_settings")
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database query failed: {}", e)))?;

            let settings = rows.into_iter().map(|row| {
                GlobalSetting {
                    key_name: row.get("key"),
                    value: row.get::<serde_json::Value, _>("value").to_string(),
                    updated_by: row.get("updated_by"),
                    updated_at: row.get("updated_at"),
                }
            }).collect();

            Ok(settings)
        }

        pub async fn get_global_setting(pool: &sqlx::PgPool, key: &str) -> Result<Option<GlobalSetting>, leptos::ServerFnError> {
            let row = sqlx::query("SELECT key, value, updated_by, updated_at FROM global_settings WHERE key = $1")
                .bind(key)
                .fetch_optional(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database query failed: {}", e)))?;

            let result = row.map(|r| GlobalSetting {
                key_name: r.get("key"),
                value: r.get::<serde_json::Value, _>("value").to_string(),
                updated_by: r.get("updated_by"),
                updated_at: r.get("updated_at"),
            });

            Ok(result)
        }

        pub async fn update_global_setting(pool: &sqlx::PgPool, key: &str, value: serde_json::Value, updated_by: i32) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                r#"
                INSERT INTO global_settings (key, value, updated_by, updated_at)
                VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
                ON CONFLICT (key) 
                DO UPDATE SET 
                    value = EXCLUDED.value,
                    updated_by = EXCLUDED.updated_by,
                    updated_at = CURRENT_TIMESTAMP
                "#
            )
            .bind(key)
            .bind(value)
            .bind(updated_by)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database update failed: {}", e)))?;

            Ok(())
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {

    if #[cfg(feature = "ssr")] {

        use crate::app::models::{Score, CreateScoreRequest};
        use chrono::{Local, DateTime, Utc, NaiveDateTime};
        use leptos::prelude::*;
        use uuid=:Uuid;
        use log::{debug, error, info, warn};
        use sqlx::prelude::*;
        use sqlx::PgPool;

        pub async fn get_all_scores(pool: &PgPool) -> Result<Vec<Score>, leptos::ServerFnError> {
            let row = sqlx::query("SELECT student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt FROM scores ORDER BY date_administered DESC")
                .fetch_all(pool)
                .await?;


            let scores: Vec<Score> = row
                .into_iter()
                .map(|row| {

                    let naive_datetime: NaiveDateTime = row.get("date_administered");

                    let student_id= i32 =  row.get("student_id");
                    let date_administered: DateTime<Utc> = DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc);
                   let test_id= String = row.get("test_id");
                   let test_scores: Vec<i32> = row.get("test_scores");
                   let comments: Vec<String> = row.get("comments");
                   let test_variant: i32 = row.get("test_variant");
                   let evaluator: String = row.get("evaluator");
                   let attempt: i32 = row.get("attempt");

                   Score {
                       student_id,
                       date_administered,
                       test_id,
                       test_scores,
                       comments,
                       test_variant,
                       evaluator,
                       attempt,
                   }
                })
                .collect();
            Ok(scores)
        }

        pub async fn get_scores_by_test(test_ids: Vec<Uuid>, pool: &PgPool) -> Result<Vec<Score>, leptos::ServerFnError> {
            let row = sqlx::query("SELECT student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt FROM scores WHERE test_id = ANY($1) ORDER BY date_administered DESC")
                .bind(&test_ids)
                .fetch_all(pool)
                .await?;

            let scores: Vec<Score> = row
                .into_iter()
                .map(|row| {

                    let naive_datetime: NaiveDateTime = row.get("date_administered");

                    let student_id= i32 =  row.get("student_id");
                    let date_administered: DateTime<Utc> = DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc);
                    let test_id= String = row.get("test_id");
                    let test_scores: Vec<i32> = row.get("test_scores");
                    let comments: Vec<String> = row.get("comments");
                    let test_variant: i32 = row.get("test_variant");
                    let evaluator: String = row.get("evaluator");
                    let attempt: i32 = row.get("attempt");

                   Score {
                       student_id,
                       date_administered,
                       test_id,
                       test_scores,
                       comments,
                       test_variant,
                       evaluator,
                       attempt,
                   }
                })
                .collect();
            Ok(scores)
        }

        pub async fn get_score(student_id= i32, test_id= String, test_variant: i32, attempt: i32, pool: &PgPool)-> Result<Score, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).expect("Invalid UUID format");

            let row = sqlx::query("SELECT student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt FROM scores WHERE student_id = $1 AND test_id = $2 AND test_variant = $3 AND attempt = $4").bind(&student_id).bind(ID).bind(&test_variant).bind(&attempt).fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let naive_datetime: NaiveDateTime = row.get("date_administered");



            let score = Score {
                student_id= row.get("student_id"),
                date_administered: DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc),
                test_id= row.get("test_id"),
                test_scores: row.get("test_scores"),
                comments: row.get("comments"),
                test_variant: row.get("test_variant"),
                evaluator: row.get("evaluator"),
                attempt: row.get("attempt"),
            };

            Ok(score)
        }

        pub async fn get_all_student_scores(student_id= i32, pool: &PgPool) -> Result<Vec<Score>, leptos::ServerFnError> {
            let row = sqlx::query("SELECT student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt FROM scores WHERE student_id = $1 ORDER BY date_administered DESC")
                .bind(&student_id)
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;


            let scores: Vec<Score> = row
                .into_iter()
                .map(|row| {

                    let naive_datetime: NaiveDateTime = row.get("date_administered");

                    let student_id= i32 =  row.get("student_id");
                    let date_administered: DateTime<Utc> = DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc);
                    let test_id= String = row.get("test_id");
                    let test_scores: Vec<i32> = row.get("test_scores");
                    let comments: Vec<String> = row.get("comments");
                    let test_variant: i32 = row.get("test_variant");
                    let evaluator: String = row.get("evaluator");
                    let attempt: i32 = row.get("attempt");

                    Score {
                        student_id,
                        date_administered,
                        test_id,
                        test_scores,
                        comments,
                        test_variant,
                        evaluator,
                        attempt,
                    }
                })
                .collect();
            Ok(scores)
        }

        pub async fn add_score(new_score_request: &CreateScoreRequest, pool: &sqlx::PgPool) -> Result<Score, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&new_score_request.test_id).expect("Invalid UUID format");
            let timestamp = Local::now();
            let row = sqlx::query("INSERT INTO scores (student_id, date_administered, test_id, test_scores, comments, test_variant, evaluator, attempt) VALUES($1, $2, $3, $4, $5, $6, $7, next_attempt_number($1, $3, $6)) RETURNING student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt")
                .bind(&new_score_request.student_id)
                .bind(timestamp)
                .bind(ID)
                .bind(&new_score_request.test_scores)
                .bind(&new_score_request.comments)
                .bind(&new_score_request.test_variant)
                .bind(&new_score_request.evaluator)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let naive_datetime: NaiveDateTime = row.get("date_administered");

            let score = Score {
                student_id= row.get("student_id"),
                date_administered: DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc),
                test_id= row.get("test_id"),
                test_scores: row.get("test_scores"),
                comments: row.get("comments"),
                test_variant: row.get("test_variant"),
                evaluator: row.get("evaluator"),
                attempt: row.get("attempt"),
            };

            Ok(score)
        }

        pub async fn delete_score(student_id= i32, test_id= String, test_variant: i32, attempt: i32, pool: &sqlx::PgPool) -> Result<Score, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).expect("Invalid UUID format");

            let row = sqlx::query("DELETE FROM scores WHERE student_id = $1 AND test_id = $2 AND test_variant = $3 AND attempt = $4 RETURNING student_id, date_administered, test_id=:text, test_scores, comments, test_variant, evaluator, attempt")
                .bind(&student_id)
                .bind(ID)
                .bind(&test_variant)
                .bind(&attempt)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let naive_datetime: NaiveDateTime = row.get("date_administered");

            let deleted_score = Score {
                student_id= row.get("student_id"),
                date_administered: DateTime::<Utc>::from_naive_utc_and_offset(naive_datetime, Utc),
                test_id= row.get("test_id"),
                test_scores: row.get("test_scores"),
                comments: row.get("comments"),
                test_variant: row.get("test_variant"),
                evaluator: row.get("evaluator"),
                attempt: row.get("attempt"),
            };

            Ok(deleted_score)

        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {

        use argon2::{
            password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
            Argon2,
        };
        use sqlx::{Pool, Postgres};
        use leptos::leptos::ServerFnError;
        use crate::app::models::user::{SessionUser, User, UserRole};
        use sqlx::Row;
        use chrono::{DateTime, Utc};
        use crate::app::models::user::AccountStatus;
        use crate::app::models::setting_data::{UserSettings, UserSettingsUpdate};

        // Hash a password
        pub fn hash_password(password: &str) -> Result<String, leptos::ServerFnError> {
            let salt = SaltString::generate(&mut OsRng);
            let argon2 = Argon2::default();
            argon2
                .hash_password(password.as_bytes(), &salt)
                .map(|hash| hash.to_string())
                .map_err(|e| leptos::ServerFnError::new(format!("Password hashing error: {}", e)))
        }

        // Verify a user's password
        pub fn verify_password(password: &str, password_hash: &str) -> bool {
            let parsed_hash = match PasswordHash::new(password_hash) {
                Ok(hash) => hash,
                Err(_) => return false,
            };

            Argon2::default()
                .verify_password(password.as_bytes(), &parsed_hash)
                .is_ok()
        }

        // Create a new user - returns FULL User struct (for registration flow)
        pub async fn create_user(
            pool: &Pool<Postgres>,
            username: String,
            email: String,
            password: String,
            role: UserRole,
        ) -> Result<User, leptos::ServerFnError> {
            let password_hash = hash_password(&password)?;

            let row = sqlx::query(
                "INSERT INTO users (username, email, password_hash, role, account_status, email_verified, phone_verified)
                 VALUES ($1, $2, $3, $4, 'pending', false, false)
                 RETURNING id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name"
            )
                .bind(&username)
                .bind(&email)
                .bind(password_hash)
                .bind(&role)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let user = User {
                id= row.get("id"),
                username: row.get("username"),
                email: row.get("email"),
                password_hash: row.get("password_hash"),
                role: row.get("role"),
                password_salt: row.try_get("password_salt").unwrap_or(None),
                account_status: AccountStatus::from_str(row.get("account_status")),
                email_verified: row.get("email_verified"),
                phone_number: row.try_get("phone_number").unwrap_or(None),
                phone_verified: row.get("phone_verified"),
                display_name: row.try_get("display_name").unwrap_or(None),
                first_name: row.try_get("first_name").unwrap_or(None),
                last_name: row.try_get("last_name").unwrap_or(None),
            };

            Ok(user)
        }

        // Get all users (admin function) - returns FULL User structs
        pub async fn get_all_users(pool: &sqlx::PgPool) -> Result<Vec<User>, leptos::ServerFnError> {
            let rows = sqlx::query("SELECT id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name FROM users ORDER BY id ASC")
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let users: Vec<User> = rows
                .into_iter()
                .map(|row| {
                    User {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        password_hash: row.get("password_hash"),
                        role: row.get("role"),
                        password_salt: row.try_get("password_salt").unwrap_or(None),
                        account_status: AccountStatus::from_str(row.get("account_status")),
                        email_verified: row.get("email_verified"),
                        phone_number: row.try_get("phone_number").unwrap_or(None),
                        phone_verified: row.get("phone_verified"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    }
                })
                .collect();
            Ok(users)
        }

        // Get full user by ID (returns FULL User struct with all fields)
        pub async fn get_user(id= i64, pool: &sqlx::PgPool) -> Result<User, leptos::ServerFnError> {
            let row = sqlx::query("SELECT id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name FROM users WHERE id = $1")
                .bind(id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let user = User {
                id= row.get("id"),
                username: row.get("username"),
                email: row.get("email"),
                password_hash: row.get("password_hash"),
                role: row.get("role"),
                password_salt: row.try_get("password_salt").unwrap_or(None),
                account_status: AccountStatus::from_str(row.get("account_status")),
                email_verified: row.get("email_verified"),
                phone_number: row.try_get("phone_number").unwrap_or(None),
                phone_verified: row.get("phone_verified"),
                display_name: row.try_get("display_name").unwrap_or(None),
                first_name: row.try_get("first_name").unwrap_or(None),
                last_name: row.try_get("last_name").unwrap_or(None),
            };
            Ok(user)
        }

        //Get user settings
        pub async fn get_user_settings(
            pool: &Pool<Postgres>,
            user_id= i64
        ) -> Result<UserSettings, leptos::ServerFnError> {
            let row = sqlx::query("SELECT settings FROM users WHERE id = $1")
                .bind(user_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let settings_json: serde_json::Value = row.get("settings");
            let settings: UserSettings = serde_json::from_value(settings_json).unwrap_or_else(|_| UserSettings::default());

            Ok(settings)
        }

        // Get user by username for AUTHENTICATION - returns FULL User (needs password_hash for verification)
        pub async fn get_user_by_username(
            pool: &Pool<Postgres>,
            username: &str,
        ) -> Result<Option<User>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name
                 FROM users
                 WHERE username = $1"
            )
                .bind(&username)
                .fetch_optional(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let user = User {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        password_hash: row.get("password_hash"),
                        role: row.get("role"),
                        password_salt: row.try_get("password_salt").unwrap_or(None),
                        account_status: AccountStatus::from_str(row.get("account_status")),
                        email_verified: row.get("email_verified"),
                        phone_number: row.try_get("phone_number").unwrap_or(None),
                        phone_verified: row.get("phone_verified"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    };
                    Ok(Some(user))
                },
                None => Ok(None),
            }
        }

        // Get user by email for PASSWORD RESET - returns FULL User
        pub async fn get_user_by_email(
            pool: &Pool<Postgres>,
            email: &str,
        ) -> Result<Option<User>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name
                 FROM users
                 WHERE email = $1"
            )
                .bind(&email)
                .fetch_optional(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let user = User {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        password_hash: row.get("password_hash"),
                        role: row.get("role"),
                        password_salt: row.try_get("password_salt").unwrap_or(None),
                        account_status: AccountStatus::from_str(row.get("account_status")),
                        email_verified: row.get("email_verified"),
                        phone_number: row.try_get("phone_number").unwrap_or(None),
                        phone_verified: row.get("phone_verified"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    };
                    Ok(Some(user))
                },
                None => Ok(None),
            }
        }

        // Get user by ID for general purposes - returns lightweight SessionUser
        pub async fn get_user_by_id(pool: &Pool<Postgres>, id= i64) -> Result<Option<SessionUser>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, username, email, role, display_name, first_name, last_name
                FROM users
                WHERE id = $1"
            )
                .bind(&id)
                .fetch_optional(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let user = SessionUser {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        role: row.get("role"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    };
                    Ok(Some(user))
                },
                None => Ok(None),
            }
        }

        //Update user settings
        pub async fn update_user_settings(pool: &Pool<Postgres>, user_id= i64, settings_update: UserSettingsUpdate) -> Result<UserSettings, leptos::ServerFnError> {
            let current_settings = get_user_settings(pool, user_id).await?;

            //apply settings
            let mut new_settings = current_settings;

            if let Some(ui_update) = settings_update.ui {
                if let Some(dark_mode) = ui_update.dark_mode {
                    new_settings.ui.dark_mode = dark_mode;
                }
                if let Some(pinned_sidebar) = ui_update.pinned_sidebar {
                    new_settings.ui.pinned_sidebar = pinned_sidebar;
                }
            }

            let settings_json = serde_json::to_value(&new_settings)
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to serialize settings: {}", e)))?;

            sqlx::query("UPDATE users SET settings = $1 WHERE id = $2")
                .bind(&settings_json)
                .bind(user_id)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to update user settings: {}", e)))?;

            Ok(new_settings)
        }

        //Reset user settings to default
        pub async fn reset_user_settings(pool: &Pool<Postgres>, user_id= i64) -> Result<UserSettings, leptos::ServerFnError> {
            let default_settings = UserSettings::default();
            let settings_json = serde_json::to_value(&default_settings)
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to serialize default settings: {}", e)))?;

            sqlx::query("UPDATE users SET settings = $1 WHERE id = $2")
                .bind(&settings_json)
                .bind(user_id)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to reset user settings: {}", e)))?;

            Ok(default_settings)
        }

        // Session Management
        pub async fn create_session(pool: &Pool<Postgres>, user_id= i64) -> Result<String, leptos::ServerFnError> {
            let session_token = uuid=:Uuid=:new_v4().to_string();

            sqlx::query("INSERT INTO sessions (user_id, token, expires_at) VALUES ($1, $2, NOW() + INTERVAL '7 days')")
                .bind(user_id)
                .bind(&session_token)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Error creating session: {}", e)))?;

            Ok(session_token)
        }

        // Validate session and return SessionUser (MAIN SESSION VALIDATION FUNCTION)
        // Returns SessionUser - safe for session storage and client use
        pub async fn validate_session(
            pool: &Pool<Postgres>,
            session_token: &str,
        ) -> Result<Option<SessionUser>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT u.id, u.username, u.email, u.role, u.display_name, u.first_name, u.last_name
                 FROM users u
                 JOIN sessions s ON u.id = s.user_id
                 WHERE s.token = $1 AND s.expires_at > NOW()"
            )
            .bind(&session_token)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Error validating session: {}", e)))?;

            match row {
                Some(row) => {
                    let user = SessionUser {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        role: row.get("role"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    };
                    Ok(Some(user))
                },
                None => Ok(None),
            }
        }

        // Delete a session (logout)
        pub async fn delete_session(pool: &Pool<Postgres>, token: &str) -> Result<(), leptos::ServerFnError> {
            sqlx::query("DELETE FROM sessions WHERE token = $1")
                .bind(token)
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Error deleting session: {}", e)))?;

            Ok(())
        }

        // Clean up expired sessions (call this periodically)
        pub async fn cleanup_expired_sessions(pool: &Pool<Postgres>) -> Result<u64, leptos::ServerFnError> {
            let result = sqlx::query("DELETE FROM sessions WHERE expires_at <= NOW()")
                .execute(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Error cleaning up sessions: {}", e)))?;

            Ok(result.rows_affected())
        }

        // Password Reset Functions
        pub async fn set_password_reset_token(
            pool: &Pool<Postgres>,
            user_id= i64,
            token: &str,
            expires: DateTime<Utc>
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE users
                 SET password_reset_token = $1, password_reset_expires = $2 
                 WHERE id = $3"
            )
            .bind(token)
            .bind(expires)
            .bind(user_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to set reset token: {}", e)))?;

            Ok(())
        }

        pub async fn validate_password_reset_token(
            pool: &Pool<Postgres>,
            token: &str
        ) -> Result<bool, leptos::ServerFnError> {
            let result = sqlx::query(
                "SELECT COUNT(*) as count
                 FROM users 
                 WHERE password_reset_token = $1 
                 AND password_reset_expires > NOW()"
            )
            .bind(token)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Error validating token: {}", e)))?;

            let count: i64 = result.get("count");
            Ok(count > 0)
        }

        pub async fn get_user_by_reset_token(
            pool: &Pool<Postgres>,
            token: &str
        ) -> Result<Option<User>, leptos::ServerFnError> {
            let row = sqlx::query(
                "SELECT id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name
                 FROM users
                 WHERE password_reset_token = $1
                 AND password_reset_expires > NOW()"
            )
            .bind(token)
            .fetch_optional(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Error getting user by token: {}", e)))?;

            match row {
                Some(row) => {
                    let user = User {
                        id= row.get("id"),
                        username: row.get("username"),
                        email: row.get("email"),
                        password_hash: row.get("password_hash"),
                        role: row.get("role"),
                        password_salt: row.try_get("password_salt").unwrap_or(None),
                        account_status: AccountStatus::from_str(row.get("account_status")),
                        email_verified: row.get("email_verified"),
                        phone_number: row.try_get("phone_number").unwrap_or(None),
                        phone_verified: row.get("phone_verified"),
                        display_name: row.try_get("display_name").unwrap_or(None),
                        first_name: row.try_get("first_name").unwrap_or(None),
                        last_name: row.try_get("last_name").unwrap_or(None),
                    };
                    Ok(Some(user))
                },
                None => Ok(None),
            }
        }

        pub async fn update_password_and_clear_token(
            pool: &Pool<Postgres>,
            user_id= i64,
            password_hash: &str
        ) -> Result<(), leptos::ServerFnError> {
            sqlx::query(
                "UPDATE users
                 SET password_hash = $1, password_reset_token = NULL, password_reset_expires = NULL 
                 WHERE id = $2"
            )
            .bind(password_hash)
            .bind(user_id)
            .execute(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Failed to update password: {}", e)))?;

            Ok(())
        }

        // Admin Functions
        pub async fn update_permissions(user_id= i64, role: UserRole, pool: &sqlx::PgPool) -> Result<User, leptos::ServerFnError> {
            let row = sqlx::query("UPDATE users SET role = $1 WHERE id = $2 RETURNING id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name")
                .bind(&role)
                .bind(user_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to update user permissions: {}", e)))?;

            let user = User {
                id= row.get("id"),
                username: row.get("username"),
                email: row.get("email"),
                password_hash: row.get("password_hash"),
                role: row.get("role"),
                password_salt: row.try_get("password_salt").unwrap_or(None),
                account_status: AccountStatus::from_str(row.get("account_status")),
                email_verified: row.get("email_verified"),
                phone_number: row.try_get("phone_number").unwrap_or(None),
                phone_verified: row.get("phone_verified"),
                display_name: row.try_get("display_name").unwrap_or(None),
                first_name: row.try_get("first_name").unwrap_or(None),
                last_name: row.try_get("last_name").unwrap_or(None),
            };
            Ok(user)
        }

        pub async fn update_user_data(new_user_data: User, pool: &sqlx::PgPool) -> Result<User, leptos::ServerFnError> {
            let row = sqlx::query("UPDATE users SET username = $1, phone_number = $2, first_name = $3, last_name = $4 WHERE id = $5 RETURNING id, username, email, password_hash, role, password_salt, account_status::text, email_verified, phone_number, phone_verified, display_name, first_name, last_name")
                .bind(new_user_data.username)
                .bind(new_user_data.phone_number)
                .bind(new_user_data.first_name)
                .bind(new_user_data.last_name)
                .bind(new_user_data.id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Failed to update user: {}", e)))?;

            let user = User {
                id= row.get("id"),
                username: row.get("username"),
                email: row.get("email"),
                password_hash: row.get("password_hash"),
                role: row.get("role"),
                password_salt: row.try_get("password_salt").unwrap_or(None),
                account_status: AccountStatus::from_str(row.get("account_status")),
                email_verified: row.get("email_verified"),
                phone_number: row.try_get("phone_number").unwrap_or(None),
                phone_verified: row.get("phone_verified"),
                display_name: row.try_get("display_name").unwrap_or(None),
                first_name: row.try_get("first_name").unwrap_or(None),
                last_name: row.try_get("last_name").unwrap_or(None),
            };
            Ok(user)
        }
    }
}
use leptos::prelude::*;

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")]{
        use crate::app::models::enrollment::{Enrollment, EnrollmentStatus, AcademicYear};
        use crate::app::models::student::GradeEnum;
        use log::{debug, error, info, warn};
        use chrono::NaiveDate;
        use leptos::prelude::*;
        use sqlx::PgPool;
        use sqlx::prelude::*;

        pub async fn get_all_enrollments(pool: &PgPool) -> Result<Vec<Enrollment>, ServerFnError> {
            let rows = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments ORDER BY enrollment_date DESC")
                .fetch_all(pool)
                .await?;

            let enrollments: Vec<Enrollment> = rows
                .into_iter()
                .map(|row| {
                    let student_id= i32 = row.get("student_id");
                    let academic_year: AcademicYear = row.get("academic_year");
                    let grade_level: GradeEnum = row.get("grade_level");
                    let teacher_id= i32 = row.get("teacher_id");
                    let status: EnrollmentStatus = row.get("status");
                    let enrollment_date: chrono::NaiveDate = row.get("enrollment_date");
                    let status_change_date: Option<chrono::NaiveDate> = row.get("status_change_date");
                    let notes: Option<String> = row.get("notes");

                    Enrollment {
                        student_id,
                        academic_year,
                        grade_level,
                        teacher_id,
                        status,
                        enrollment_date,
                        status_change_date,
                        notes,
                    }
                })
                .collect();
            Ok(enrollments)
        }

        pub async fn get_enrollments_by_student(student_id= &i32, pool: &PgPool) -> Result<Vec<Enrollment>, ServerFnError> {
            let rows = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments WHERE student_id = $1 ORDER BY enrollment_date DESC")
                .bind(student_id)
                .fetch_all(pool)
                .await?;

            let enrollments: Vec<Enrollment> = rows
                .into_iter()
                .map(|row| {
                    Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    }
                })
                .collect();
            Ok(enrollments)
        }

        pub async fn get_enrollment_by_student_and_year(
            pool: &PgPool,
            student_id= i32,
            academic_year: AcademicYear,
        ) -> Result<Enrollment, ServerFnError> {
            let row = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments WHERE student_id = $1 AND academic_year = $2 LIMIT 1")
                .bind(student_id)
                .bind(academic_year)
                .fetch_one(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            let enrollment = Enrollment {
                student_id= row.get("student_id"),
                academic_year: row.get("academic_year"),
                grade_level: row.get("grade_level"),
                teacher_id= row.get("teacher_id"),
                status: row.get("status"),
                enrollment_date: row.get("enrollment_date"),
                status_change_date: row.get("status_change_date"),
                notes: row.get("notes"),
            };

            Ok(enrollment)
        }

        pub async fn get_enrollments_by_academic_year(academic_year: &AcademicYear, pool: &PgPool) -> Result<Vec<Enrollment>, ServerFnError> {
            let rows = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments WHERE academic_year = $1 ORDER BY enrollment_date DESC")
                .bind(academic_year)
                .fetch_all(pool)
                .await?;

            let enrollments: Vec<Enrollment> = rows
                .into_iter()
                .map(|row| {
                    Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    }
                })
                .collect();
            Ok(enrollments)
        }

        pub async fn get_enrollments_by_teacher(teacher_id= i32, pool: &PgPool) -> Result<Vec<Enrollment>, ServerFnError> {
            let rows = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments WHERE teacher_id = $1 ORDER BY enrollment_date DESC")
                .bind(teacher_id)
                .fetch_all(pool)
                .await?;

            let enrollments: Vec<Enrollment> = rows
                .into_iter()
                .map(|row| {
                    Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    }
                })
                .collect();
            Ok(enrollments)
        }

        pub async fn get_current_enrollment(student_id= &i32, pool: &PgPool) -> Result<Option<Enrollment>, ServerFnError> {
            let row = sqlx::query("SELECT student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes FROM student_enrollments WHERE student_id = $1 AND status = 'active' ORDER BY enrollment_date DESC LIMIT 1")
                .bind(student_id)
                .fetch_optional(pool)
                .await?;

            match row {
                Some(row) => {
                    let enrollment = Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    };
                    Ok(Some(enrollment))
                }
                None => Ok(None),
            }
        }

        pub async fn add_enrollment(new_enrollment: &Enrollment, pool: &PgPool) -> Result<Enrollment, ServerFnError> {
            let row = sqlx::query("INSERT INTO student_enrollments (student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes) VALUES($1, $2::school_year_enum, $3::grade_enum, $4, $5::enrollment_status_enum, $6, $7, $8) RETURNING student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes")
                .bind(&new_enrollment.student_id)
                .bind(&new_enrollment.academic_year)
                .bind(&new_enrollment.grade_level)
                .bind(&new_enrollment.teacher_id)
                .bind(&new_enrollment.status)
                .bind(&new_enrollment.enrollment_date)
                .bind(&new_enrollment.status_change_date)
                .bind(&new_enrollment.notes)
                .fetch_one(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            let enrollment = Enrollment {
                student_id= row.get("student_id"),
                academic_year: row.get("academic_year"),
                grade_level: row.get("grade_level"),
                teacher_id= row.get("teacher_id"),
                status: row.get("status"),
                enrollment_date: row.get("enrollment_date"),
                status_change_date: row.get("status_change_date"),
                notes: row.get("notes"),
            };

            Ok(enrollment)
        }

        pub async fn update_enrollment_status(
            student_id= &i32,
            academic_year: &AcademicYear,
            new_status: EnrollmentStatus,
            status_change_date: NaiveDate,
            pool: &PgPool
        ) -> Result<Option<Enrollment>, ServerFnError> {
            let row = sqlx::query("UPDATE student_enrollments SET status = $3::enrollment_status_enum, status_change_date = $4 WHERE student_id = $1 AND academic_year = $2::school_year_enum RETURNING student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes")
                .bind(student_id)
                .bind(academic_year)
                .bind(new_status)
                .bind(status_change_date)
                .fetch_optional(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let enrollment = Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    };
                    Ok(Some(enrollment))
                }
                None => Ok(None),
            }
        }

        pub async fn update_enrollment(
            student_id= &i32,
            academic_year: &AcademicYear,
            grade_level: GradeEnum,
            teacher_id= i32,
            status: EnrollmentStatus,
            enrollment_date: NaiveDate,
            status_change_date: Option<NaiveDate>,
            notes: Option<String>,
            pool: &PgPool
        ) -> Result<Option<Enrollment>, ServerFnError> {
            let row = sqlx::query("UPDATE student_enrollments SET grade_level = $3::grade_enum, teacher_id = $4, status = $5::enrollment_status_enum, enrollment_date = $6, status_change_date = $7, notes = $8 WHERE student_id = $1 AND academic_year = $2::school_year_enum RETURNING student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes")
                .bind(student_id)
                .bind(academic_year)
                .bind(grade_level)
                .bind(teacher_id)
                .bind(status)
                .bind(enrollment_date)
                .bind(status_change_date)
                .bind(notes)
                .fetch_optional(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let enrollment = Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    };
                    Ok(Some(enrollment))
                }
                None => Ok(None),
            }
        }

        pub async fn delete_enrollment(
            student_id= i32,
            academic_year: AcademicYear,
            pool: &PgPool
        ) -> Result<Option<Enrollment>, ServerFnError> {
            let row = sqlx::query("DELETE FROM student_enrollments WHERE student_id = $1 AND academic_year = $2::school_year_enum RETURNING student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes")
                .bind(student_id)
                .bind(academic_year)
                .fetch_optional(pool)
                .await
                .map_err(|e| ServerFnError::new(format!("Database error: {}", e)))?;

            match row {
                Some(row) => {
                    let enrollment = Enrollment {
                        student_id= row.get("student_id"),
                        academic_year: row.get("academic_year"),
                        grade_level: row.get("grade_level"),
                        teacher_id= row.get("teacher_id"),
                        status: row.get("status"),
                        enrollment_date: row.get("enrollment_date"),
                        status_change_date: row.get("status_change_date"),
                        notes: row.get("notes"),
                    };
                    Ok(Some(enrollment))
                }
                None => Ok(None),
            }
        }

        pub async fn bulk_insert_enrollments(pool: &PgPool, enrollments: &[Enrollment]) -> Result<usize, ServerFnError> {
            if enrollments.is_empty() {
                return Ok(0);
            }

            let mut tx = pool.begin().await?;

            let result = bulk_insert_with_unnest(enrollments, &mut tx).await;

            match result {
                Ok(count) => {
                    tx.commit().await?;
                    Ok(count)
                }
                Err(e) => {
                    tx.rollback().await?;
                    Err(ServerFnError::new(format!("Bulk insert failed: {}", e)))
                }
            }
        }

        pub async fn bulk_insert_enrollments_batch(pool: &PgPool, enrollments: &[Enrollment]) -> Result<usize, ServerFnError> {
            if enrollments.is_empty() {
                return Ok(0);
            }

            let mut tx = pool.begin().await?;
            let batch_size = 100;
            let mut total_inserted = 0;

            for chunk in enrollments.chunks(batch_size) {
                let count = insert_enrollment_batch(chunk, &mut tx).await?;
                total_inserted += count;
            }

            tx.commit().await?;
            Ok(total_inserted)
        }

        async fn bulk_insert_with_unnest(
            enrollments: &[Enrollment],
            tx: &mut sqlx::Transaction<'_, sqlx::Postgres>
        ) -> Result<usize, sqlx::Error> {
            let mut student_ids = Vec::new();
            let mut academic_years = Vec::new();
            let mut grade_levels = Vec::new();
            let mut teacher_ids = Vec::new();
            let mut statuses = Vec::new();
            let mut enrollment_dates = Vec::new();
            let mut status_change_dates = Vec::new();
            let mut notes = Vec::new();

            for enrollment in enrollments {
                student_ids.push(&enrollment.student_id);
                academic_years.push(enrollment.academic_year.to_string());
                grade_levels.push(enrollment.grade_level.to_string());
                teacher_ids.push(enrollment.teacher_id);
                statuses.push(enrollment.status.to_string());
                enrollment_dates.push(enrollment.enrollment_date);
                status_change_dates.push(enrollment.status_change_date);
                notes.push(enrollment.notes.as_ref().map(|s| s.as_str()));
            }

            let query = r#"
                INSERT INTO student_enrollments (
                    student_id, academic_year, grade_level, teacher_id, status, 
                    enrollment_date, status_change_date, notes
                )
                SELECT * FROM UNNEST(
                    $1::int4[], $2::school_year_enum[], $3::grade_enum[], $4::int4[], 
                    $5::enrollment_status_enum[], $6::date[], $7::date[], $8::text[]
                )
            "#;

            let result = sqlx::query(query)
                .bind(&student_ids)
                .bind(&academic_years)
                .bind(&grade_levels)
                .bind(&teacher_ids)
                .bind(&statuses)
                .bind(&enrollment_dates)
                .bind(&status_change_dates)
                .bind(&notes)
                .execute(&mut **tx)
                .await?;

            Ok(result.rows_affected() as usize)
        }

        async fn insert_enrollment_batch(
            enrollments: &[Enrollment],
            tx: &mut sqlx::Transaction<'_, sqlx::Postgres>
        ) -> Result<usize, sqlx::Error> {
            let mut query_builder = sqlx::QueryBuilder::new(
                "INSERT INTO student_enrollments (student_id, academic_year, grade_level, teacher_id, status, enrollment_date, status_change_date, notes) "
            );

            query_builder.push_values(enrollments, |mut b, enrollment| {
                b.push_bind(&enrollment.student_id)
                 .push_bind(&enrollment.academic_year)
                 .push_bind(&enrollment.grade_level)
                 .push_bind(enrollment.teacher_id)
                 .push_bind(&enrollment.status)
                 .push_bind(enrollment.enrollment_date)
                 .push_bind(&enrollment.status_change_date)
                 .push_bind(&enrollment.notes);
            });

            let query = query_builder.build();
            let result = query.execute(&mut **tx).await?;

            Ok(result.rows_affected() as usize)
        }

        pub async fn get_enrollment_counts_by_grade(
            academic_year: &AcademicYear,
            pool: &PgPool
        ) -> Result<Vec<(GradeEnum, i64)>, ServerFnError> {
            let rows = sqlx::query("SELECT grade_level, COUNT(*) as count FROM student_enrollments WHERE academic_year = $1 AND status = 'active' GROUP BY grade_level ORDER BY grade_level")
                .bind(academic_year)
                .fetch_all(pool)
                .await?;

            let counts: Vec<(GradeEnum, i64)> = rows
                .into_iter()
                .map(|row| {
                    let grade_level: GradeEnum = row.get("grade_level");
                    let count: i64 = row.get("count");
                    (grade_level, count)
                })
                .collect();

            Ok(counts)
        }

        pub async fn get_enrollment_counts_by_teacher(
            academic_year: &AcademicYear,
            pool: &PgPool
        ) -> Result<Vec<(i32, i64)>, ServerFnError> {
            let rows = sqlx::query("SELECT teacher_id, COUNT(*) as count FROM student_enrollments WHERE academic_year = $1 AND status = 'active' GROUP BY teacher_id ORDER BY teacher_id")
                .bind(academic_year)
                .fetch_all(pool)
                .await?;

            let counts: Vec<(i32, i64)> = rows
                .into_iter()
                .map(|row| {
                    let teacher_id= i32 = row.get("teacher_id");
                    let count: i64 = row.get("count");
                    (teacher_id, count)
                })
                .collect();

            Ok(counts)
        }

        pub async fn get_enrollment_status_summary(
            academic_year: &AcademicYear,
            pool: &PgPool
        ) -> Result<Vec<(EnrollmentStatus, i64)>, ServerFnError> {
            let rows = sqlx::query("SELECT status, COUNT(*) as count FROM student_enrollments WHERE academic_year = $1 GROUP BY status ORDER BY status")
                .bind(academic_year)
                .fetch_all(pool)
                .await?;

            let counts: Vec<(EnrollmentStatus, i64)> = rows
                .into_iter()
                .map(|row| {
                    let status: EnrollmentStatus = row.get("status");
                    let count: i64 = row.get("count");
                    (status, count)
                })
                .collect();

            Ok(counts)
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {

    if #[cfg(feature = "ssr")] {

        use leptos::leptos::ServerFnError;
        use crate::app::models::assessment::ScopeEnum;
        use crate::app::models::student::GradeEnum;
        use crate::app::models::test::BenchmarkCategory;
        use crate::app::models::{Test, TestType};
        use crate::app::errors::{ErrorMessageTest, TestError};
        use uuid=:Uuid;
        use sqlx::PgPool;
        use sqlx::types::Json;
        use leptos::prelude::*;
        use sqlx::prelude::*;

        pub async fn get_all_tests(pool: &sqlx::PgPool) -> Result<Vec<Test>, leptos::ServerFnError>{
           let rows = sqlx::query("SELECT name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id FROM tests ORDER BY name DESC")
               .fetch_all(pool)
               .await?;

            let tests: Vec<Test> = rows
                .into_iter()
                .map(|row| {
                    let name: String = row.get("name");
                    let score: i32 = row.get("score");
                    let instructions: Option<String> = row.get("instructions");
                    let comments: String = row.get("comments");
                    let testarea: TestType = row.get("testarea");
                    let school_year: Option<String> = row.get("school_year");
                    let test_variant: i32 = row.get("test_variant");
                    let grade_level: Option<GradeEnum> = row.get("grade_level");
                    let test_id  = row.get::<String,_>("test_id");
                    let scope: Option<ScopeEnum> = row.get("scope");
                    let course_id= Option<i32> = row.get("course_id");

                    let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                        Ok(Some(json)) => Some(json.0),
                        _ => None,
                    };

                    Test {
                        name,
                        score,
                        instructions,
                        comments,
                        testarea,
                        school_year,
                        benchmark_categories,
                        test_variant,
                        grade_level,
                        test_id,
                        scope,
                        course_id,
                    }
                })
                .collect();
            Ok(tests)
        }

        pub async fn get_tests_batch(test_ids: Vec<Uuid>, pool: &sqlx::PgPool) -> Result<Vec<Test>, leptos::ServerFnError> {
            let rows = sqlx::query("SELECT name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id FROM tests WHERE test_id = ANY($1)")
                .bind(&test_ids)
                .fetch_all(pool)
                .await?;

            let tests: Vec<Test> = rows
                .into_iter()
                .map(|row| {
                    let name: String = row.get("name");
                    let score: i32 = row.get("score");
                    let instructions: Option<String> = row.get("instructions");
                    let comments: String = row.get("comments");
                    let testarea: TestType = row.get("testarea");
                    let school_year: Option<String> = row.get("school_year");
                    let test_variant: i32 = row.get("test_variant");
                    let grade_level: Option<GradeEnum> = row.get("grade_level");
                    let test_id  = row.get::<String,_>("test_id");
                    let scope: Option<ScopeEnum> = row.get("scope");
                    let course_id= Option<i32> = row.get("course_id");

                    let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                        Ok(Some(json)) => Some(json.0),
                        _ => None,
                    };

                    Test {
                        name,
                        score,
                        instructions,
                        comments,
                        testarea,
                        school_year,
                        benchmark_categories,
                        test_variant,
                        grade_level,
                        test_id,
                        scope,
                        course_id,
                    }
                })
                .collect();
            Ok(tests)
        }

        pub async fn get_test(test_id= String, pool: &sqlx::PgPool) -> Result<Test, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;
            let row = sqlx::query("SELECT name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id FROM tests WHERE test_id=:text = $1")
                .bind(&test_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let test = Test {
                name: row.get("name"),
                score: row.get("score"),
                instructions: row.get("instructions"),
                comments: row.get("comments"),
                testarea: row.get("testarea"),
                school_year: row.get("school_year"),
                benchmark_categories,
                test_variant: row.get("test_variant"),
                grade_level: row.get("grade_level"),
                test_id= row.get("test_id"),
                scope: row.get("scope"),
                course_id= row.get("course_id"),
            };

            Ok(test)
        }

        pub async fn add_test(new_test: &Test, pool: &PgPool) -> Result<Test, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&new_test.test_id)
                .map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            log::info!("Benchmark categories before insert: {:?}", &new_test.benchmark_categories);

            let benchmark_json = match &new_test.benchmark_categories {
                Some(categories) => Json(categories.clone()),
                None => Json(Vec::new()),
            };

            let row = sqlx::query("INSERT INTO tests (name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id, scope, course_id) VALUES($1, $2, $3, $4, $5::testarea_enum, $6, $7, $8, $9, $10::uuid, $11, $12) RETURNING name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id") .bind(&new_test.name).bind(&new_test.score).bind(&new_test.instructions).bind(&new_test.comments).bind(&new_test.testarea.to_string()).bind(&new_test.school_year).bind(benchmark_json).bind(&new_test.test_variant).bind(&new_test.grade_level).bind(&ID).bind(&new_test.scope).bind(&new_test.course_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let test = Test {
                    name: row.get("name"),
                    score: row.get("score"),
                    instructions: row.get("instructions"),
                    comments: row.get("comments"),
                    testarea: row.get("testarea"),
                    school_year: row.get("school_year"),
                    benchmark_categories,
                    test_variant: row.get("test_variant"),
                    grade_level: row.get("grade_level"),
                    test_id= row.get("test_id"),
                    scope: row.get("scope"),
                    course_id= row.get("course_id"),
            };

            Ok(test)
        }

        pub async fn update_test(test: &Test, pool: &sqlx::PgPool) -> Result<Option<Test>, leptos::ServerFnError> {
            //let query = "UPDATE tests SET name =$1, score =$2, comments =$3, testarea =$4::testarea_enum, school_year =$5, benchmark_categories=$6, test_variant=$7, grade_level=$8, questions =$9 WHERE test_id =$10";
            let ID = Uuid=:parse_str(&test.test_id).expect("The UUID conversion did not occur correctly");
            let benchmark_json = match &test.benchmark_categories {
                Some(categories) => Json(categories.clone()),
                None => Json(Vec::new()),
            };

            let row = sqlx::query("UPDATE tests SET name =$1, score =$2, instructions =$3, comments =$4, testarea =$5::testarea_enum, school_year =$6, benchmark_categories=$7, test_variant=$8, grade_level=$9, scope =$10, course_id=$11 WHERE test_id =$12 RETURNING name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id")
                .bind(&test.name)
                .bind(&test.score)
                .bind(&test.instructions)
                .bind(&test.comments)
                .bind(&test.testarea.to_string())
                .bind(&test.school_year)
                .bind(benchmark_json)
                .bind(&test.test_variant)
                .bind(&test.grade_level)
                .bind(&test.scope)
                .bind(&test.course_id)
                .bind(ID)
                .fetch_one(pool)
                .await?;



            let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let test = Test {
                name: row.get("name"),
                score: row.get("score"),
                instructions: row.get("instructions"),
                comments: row.get("comments"),
                testarea: row.get("testarea"),
                school_year: row.get("school_year"),
                benchmark_categories,
                test_variant: row.get("test_variant"),
                grade_level: row.get("grade_level"),
                test_id= row.get("test_id"),
                scope: row.get("scope"),
                course_id= row.get("course_id"),
            };

            Ok(Some(test))
        }

        pub async fn delete_test(test_id= String, pool: &sqlx::PgPool) -> Result<Test, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).expect("The test_id did not correctly become a UUID");
            let row = sqlx::query("DELETE FROM tests WHERE test_id = $1 RETURNING name, score, instructions, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id")
                .bind(ID)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };


            let test = Test {
                name: row.get("name"),
                score: row.get("score"),
                instructions: row.get("instructions"),
                comments: row.get("comments"),
                testarea: row.get("testarea"),
                school_year: row.get("school_year"),
                benchmark_categories,
                test_variant: row.get("test_variant"),
                grade_level: row.get("grade_level"),
                test_id= row.get("test_id"),
                scope: row.get("scope"),
                course_id= row.get("course_id"),
            };

            Ok(test)
        }

        pub async fn score_override(test_id= String, score: i32, pool: &sqlx::PgPool) -> Result<Test, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).expect("The test id was not correctly converted to UUID");

            let row = sqlx::query("UPDATE tests SET score = $1 WHERE test_id = $2 RETURNING name, score, comments, testarea, school_year, benchmark_categories, test_variant, grade_level, test_id=:text, scope, course_id")
                .bind(score)
                .bind(ID)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error occured: {}", e)))?;

            let benchmark_categories: Option<Vec<BenchmarkCategory>> = match row.try_get::<Option<Json<Vec<BenchmarkCategory>>>, _>("benchmark_categories") {
                Ok(Some(json)) => Some(json.0),
                _ => None,
            };

            let test = Test {
                name: row.get("name"),
                score: row.get("score"),
                instructions: row.get("instructions"),
                comments: row.get("comments"),
                testarea: row.get("testarea"),
                school_year: row.get("school_year"),
                benchmark_categories,
                test_variant: row.get("test_variant"),
                grade_level: row.get("grade_level"),
                test_id= row.get("test_id"),
                scope: row.get("scope"),
                course_id= row.get("course_id"),
            };

            Ok(test)
        }

    }
}
use leptos::prelude::*;
use leptos::leptos::ServerFnError;

use crate::app::models::student;

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")]{

        use crate::app::models::{Student, AddStudentRequest};
        use crate::app::models::student::{GradeEnum, ESLEnum, GenderEnum, InterventionEnum};
        use log::{debug, error, info, warn};
        use chrono::NaiveDate;
        use leptos::prelude::*;
        use sqlx::PgPool;
        use sqlx::prelude::*;

        pub async fn get_all_students(pool: &PgPool) -> Result<Vec<Student>, leptos::ServerFnError>{
            let rows  = sqlx::query("SELECT firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin FROM students ORDER BY lastname")
                .fetch_all(pool)
                .await?;

            let students: Vec<Student> = rows
                .into_iter()
                .map(|row| {
                    let firstname: Option<String> = row.get("firstname");
                    let lastname: Option<String> = row.get("lastname");
                    let preferred: String = row.get("preferred");
                    let gender: GenderEnum = row.get("gender");
                    let date_of_birth: chrono::NaiveDate = row.get::<NaiveDate, _>("date_of_birth");
                    let student_id= i32 = row.get("student_id");
                    let esl: ESLEnum = row.get("esl");
                    let current_grade_level: GradeEnum = row.get("current_grade_level");
                    let teacher: String = row.get("teacher");
                    let iep: bool = row.get("iep");
                    let bip: bool = row.get("bip");
                    let student_504: bool = row.get("student_504");
                    let readplan: bool = row.get("readplan");
                    let gt: bool = row.get("gt");
                    let intervention: Option<InterventionEnum> = row.get("intervention");
                    let eye_glasses: bool = row.get("eye_glasses");
                    let notes: String = row.get("notes");
                    let pin: Option<i32> = row.get("pin");

                    Student {
                        firstname,
                        lastname,
                        preferred,
                        gender,
                        date_of_birth,
                        student_id,
                        esl,
                        current_grade_level,
                        teacher,
                        iep,
                        bip,
                        student_504,
                        readplan,
                        gt,
                        intervention,
                        eye_glasses,
                        notes,
                        pin,
                    }
                })
                .collect();
            Ok(students)
        }

        pub async fn get_certain_student(student_id= i32, pool: &PgPool) -> Result<Student, leptos::ServerFnError> {
            let row = sqlx::query("SELECT firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin FROM students WHERE student_id = $1")
                .bind(&student_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let student = Student {
                firstname: row.get("firstname"),
                lastname: row.get("lastname"),
                preferred: row.get("preferred"),
                gender: row.get("gender"),
                date_of_birth: row.get("date_of_birth"),
                student_id= row.get("student_id"),
                esl: row.get("esl"),
                current_grade_level: row.get("current_grade_level"),
                teacher: row.get("teacher"),
                iep: row.get("iep"),
                bip: row.get("bip"),
                student_504: row.get("student_504"),
                readplan: row.get("readplan"),
                gt: row.get("gt"),
                intervention: row.get("intervention"),
                eye_glasses: row.get("eye_glasses"),
                notes: row.get("notes"),
                pin: row.get("pin"),
            };

            Ok(student)
        }

        pub async fn add_student(new_student: &Student, pool: &PgPool) -> Result<Student, leptos::ServerFnError>{
            let row = sqlx::query("INSERT INTO students (firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin) VALUES($1, $2, $3, $4::gender_enum, $5, $6, $7::esl_enum, $8::grade_enum, $9, $10, $11, $12, $13, $14, $15::intervention_enum, $16, $17, $18) RETURNING firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin")
                .bind(&new_student.firstname)
                .bind(&new_student.lastname)
                .bind(&new_student.preferred)
                .bind(&new_student.gender.to_string())
                .bind(&new_student.date_of_birth)
                .bind(&new_student.student_id)
                .bind(&new_student.esl.to_string())
                .bind(&new_student.current_grade_level.to_string())
                .bind(&new_student.teacher)
                .bind(&new_student.iep)
                .bind(&new_student.bip)
                .bind(&new_student.student_504)
                .bind(&new_student.readplan)
                .bind(&new_student.gt)
                .bind(&new_student.intervention)
                .bind(&new_student.eye_glasses)
                .bind(&new_student.notes)
                .bind(&new_student.pin)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let student = Student {
                firstname: row.get("firstname"),
                lastname: row.get("lastname"),
                preferred: row.get("preferred"),
                gender: row.get("gender"),
                date_of_birth: row.get("date_of_birth"),
                student_id= row.get("student_id"),
                esl: row.get("esl"),
                current_grade_level: row.get("current_grade_level"),
                teacher: row.get("teacher"),
                iep: row.get("iep"),
                bip: row.get("bip"),
                student_504: row.get("student_504"),
                readplan: row.get("readplan"),
                gt: row.get("gt"),
                intervention: row.get("intervention"),
                eye_glasses: row.get("eye_glasses"),
                notes: row.get("notes"),
                pin: row.get("pin"),
            };

            Ok(student)
        }

        pub async fn delete_student(firstname: String, lastname: String, student_id= i32, pool: &PgPool) -> Result<Student, leptos::ServerFnError> {
            let row = sqlx::query("DELETE FROM students WHERE firstname = $1 AND lastname = $2 AND student_id =$3 RETURNING firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin")
                .bind(firstname)
                .bind(lastname)
                .bind(student_id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let student = Student {
                firstname: row.get("firstname"),
                lastname: row.get("lastname"),
                preferred: row.get("preferred"),
                gender: row.get("gender"),
                date_of_birth: row.get::<chrono::NaiveDate,_>("date_of_birth"),
                student_id= row.get("student_id"),
                esl: row.get("esl"),
                current_grade_level: row.get("current_grade_level"),
                teacher: row.get("teacher"),
                iep: row.get("iep"),
                bip: row.get("bip"),
                student_504: row.get("student_504"),
                readplan: row.get("readplan"),
                gt: row.get("gt"),
                intervention: row.get("intervention"),
                eye_glasses: row.get("eye_glasses"),
                notes: row.get("notes"),
                pin: row.get("pin"),
            };

            Ok(student)

        }

        pub async fn update_student(firstname: String, lastname: String, preferred: String, gender: GenderEnum, date_of_birth: NaiveDate, student_id= i32, esl: ESLEnum, current_grade_level: GradeEnum, teacher: String, iep: bool, bip: bool, student_504: bool, readplan: bool, gt: bool, intervention: Option<InterventionEnum>, eye_glasses: bool, notes: String, pin: i32, pool: &PgPool) -> Result<Option<Student>, leptos::ServerFnError> {

            let row = sqlx::query("UPDATE students SET firstname =$1, lastname =$2, preferred =$3, gender =$4::gender_enum, date_of_birth=$5::DATE, student_id=$6, esl =$7::esl_enum, current_grade_level =$8::grade_enum, teacher =$9, iep =$10, bip =$11, student_504 =$12, readplan =$13, gt =$14, intervention =$15::intervention_enum, eye_glasses =$16, notes =$17, pin =$18 WHERE student_id = $6 RETURNING firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin")
                .bind(firstname)
                .bind(lastname)
                .bind(preferred)
                .bind(gender)
                .bind(date_of_birth)
                .bind(student_id)
                .bind(esl)
                .bind(current_grade_level)
                .bind(teacher)
                .bind(iep)
                .bind(bip)
                .bind(student_504)
                .bind(readplan)
                .bind(gt)
                .bind(intervention)
                .bind(eye_glasses)
                .bind(notes)
                .bind(pin)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let student = Student {
                firstname: row.get("firstname"),
                lastname: row.get("lastname"),
                preferred: row.get("preferred"),
                gender: row.get("gender"),
                date_of_birth: row.get::<chrono::NaiveDate,_>("date_of_birth"),
                student_id= row.get("student_id"),
                esl: row.get("esl"),
                current_grade_level: row.get("current_grade_level"),
                teacher: row.get("teacher"),
                iep: row.get("iep"),
                bip: row.get("bip"),
                student_504: row.get("student_504"),
                readplan: row.get("readplan"),
                gt: row.get("gt"),
                intervention: row.get("intervention"),
                eye_glasses: row.get("eye_glasses"),
                notes: row.get("notes"),
                pin: row.get("pin"),
            };

            Ok(Some(student))
        }

        pub async fn bulk_insert_students(students: Vec<AddStudentRequest>, pool: &PgPool) -> Result<Vec<Student>, leptos::ServerFnError> {
            // Start a database transaction for bulk insert
            let mut tx = pool.begin().await?;

            let mut inserted_students = Vec::new();

            // Prepare the bulk insert query
            for student in students {
                // Use the existing add_student logic within the transaction
                let row = sqlx::query("INSERT INTO students (firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin) VALUES($1, $2, $3, $4::gender_enum, $5, $6, $7::esl_enum, $8::grade_enum, $9, $10, $11, $12, $13, $14, $15::intervention_enum, $16, $17, $18) RETURNING firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin")
                    .bind(&student.firstname)
                    .bind(&student.lastname)
                    .bind(&student.preferred)
                    .bind(&student.gender.to_string())
                    .bind(&student.date_of_birth)
                    .bind(&student.student_id)
                    .bind(&student.esl.to_string())
                    .bind(&student.current_grade_level.to_string())
                    .bind(&student.teacher)
                    .bind(&student.iep)
                    .bind(&student.bip)
                    .bind(&student.student_504)
                    .bind(&student.readplan)
                    .bind(&student.gt)
                    .bind(&student.intervention)
                    .bind(&student.eye_glasses)
                    .bind(&student.notes)
                    .bind(&student.pin)
                    .fetch_one(&mut *tx)
                    .await
                    .map_err(|e| leptos::ServerFnError::new(format!("Bulk insert error: {}", e)))?;

                let inserted_student = Student {
                    firstname: row.get("firstname"),
                    lastname: row.get("lastname"),
                    preferred: row.get("preferred"),
                    gender: row.get("gender"),
                    date_of_birth: row.get("date_of_birth"),
                    student_id= row.get("student_id"),
                    esl: row.get("esl"),
                    current_grade_level: row.get("current_grade_level"),
                    teacher: row.get("teacher"),
                    iep: row.get("iep"),
                    bip: row.get("bip"),
                    student_504: row.get("student_504"),
                    readplan: row.get("readplan"),
                    gt: row.get("gt"),
                    intervention: row.get("intervention"),
                    eye_glasses: row.get("eye_glasses"),
                    notes: row.get("notes"),
                    pin: row.get("pin"),
                };

                inserted_students.push(inserted_student);
            }

            // Commit the transaction
            tx.commit().await?;

            Ok(inserted_students)
        }

        pub async fn bulk_insert_students_optimized(students: Vec<AddStudentRequest>, pool: &PgPool) -> Result<usize, leptos::ServerFnError> {
            if students.is_empty() {
                return Ok(0);
            }

            // Start a database transaction
            let mut tx = pool.begin().await?;

            // Method 1: Using UNNEST for maximum efficiency (PostgreSQL specific)
            let result = bulk_insert_with_unnest(&students, &mut tx).await;

            match result {
                Ok(count) => {
                    tx.commit().await?;
                    Ok(count)
                }
                Err(e) => {
                    tx.rollback().await?;
                    Err(leptos::ServerFnError::new(format!("Bulk insert failed: {}", e)))
                }
            }
        }

        // Alternative method using batch inserts if UNNEST doesn't work
        pub async fn bulk_insert_students_batch(students: Vec<AddStudentRequest>, pool: &PgPool) -> Result<usize, leptos::ServerFnError> {
            if students.is_empty() {
                return Ok(0);
            }

            let mut tx = pool.begin().await?;
            let batch_size = 100; // Adjust based on your needs
            let mut total_inserted = 0;

            for chunk in students.chunks(batch_size) {
                let count = insert_batch(chunk, &mut tx).await?;
                total_inserted += count;
            }

            tx.commit().await?;
            Ok(total_inserted)
        }

        async fn bulk_insert_with_unnest(students: &[AddStudentRequest], tx: &mut sqlx::Transaction<'_, sqlx::Postgres>) -> Result<usize, sqlx::Error> {
            let mut firstnames = Vec::new();
            let mut lastnames = Vec::new();
            let mut preferreds = Vec::new();
            let mut genders = Vec::new();
            let mut dates_of_birth = Vec::new();
            let mut student_ids = Vec::new();
            let mut esls = Vec::new();
            let mut grades = Vec::new();
            let mut teachers = Vec::new();
            let mut ieps = Vec::new();
            let mut bips = Vec::new();
            let mut student_504s = Vec::new();
            let mut readplans = Vec::new();
            let mut gts = Vec::new();
            let mut interventions = Vec::new();
            let mut eye_glasses = Vec::new();
            let mut notes = Vec::new();
            let mut pins = Vec::new();

            for student in students {
                firstnames.push(&student.firstname);
                lastnames.push(&student.lastname);
                preferreds.push(&student.preferred);
                genders.push(student.gender.to_string());
                dates_of_birth.push(student.date_of_birth);
                student_ids.push(student.student_id);
                esls.push(student.esl.to_string());
                grades.push(student.current_grade_level.to_string());
                teachers.push(&student.teacher);
                ieps.push(student.iep);
                bips.push(student.bip);
                student_504s.push(student.student_504);
                readplans.push(student.readplan);
                gts.push(student.gt);
                interventions.push(student.intervention.as_ref().map(|i| i.to_string()));
                eye_glasses.push(student.eye_glasses);
                notes.push(&student.notes);
                pins.push(student.pin);
            }

            let query = r#"
                INSERT INTO students (
                    firstname, lastname, preferred, gender, date_of_birth, student_id, 
                    esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, 
                    intervention, eye_glasses, notes, pin
                )
                SELECT * FROM UNNEST(
                    $1::text[], $2::text[], $3::text[], $4::gender_enum[], $5::date[], $6::int4[],
                    $7::esl_enum[], $8::grade_enum[], $9::text[], $10::bool[], $11::bool[], $12::bool[],
                    $13::bool[], $14::bool[], $15::intervention_enum[], $16::bool[], $17::text[], $18::int4[]
                )
                ON CONFLICT (student_id) DO UPDATE SET
                    firstname = EXCLUDED.firstname,
                    lastname = EXCLUDED.lastname,
                    preferred = EXCLUDED.preferred,
                    gender = EXCLUDED.gender,
                    date_of_birth = EXCLUDED.date_of_birth,
                    esl = EXCLUDED.esl,
                    current_grade_level = EXCLUDED.current_grade_level,
                    teacher = EXCLUDED.teacher,
                    iep = EXCLUDED.iep,
                    bip = EXCLUDED.bip,
                    student_504 = EXCLUDED.student_504,
                    readplan = EXCLUDED.readplan,
                    gt = EXCLUDED.gt,
                    intervention = EXCLUDED.intervention,
                    eye_glasses = EXCLUDED.eye_glasses,
                    notes = EXCLUDED.notes,
                    pin = EXCLUDED.pin
            "#;

            let result = sqlx::query(query)
                .bind(&firstnames)
                .bind(&lastnames)
                .bind(&preferreds)
                .bind(&genders)
                .bind(&dates_of_birth)
                .bind(&student_ids)
                .bind(&esls)
                .bind(&grades)
                .bind(&teachers)
                .bind(&ieps)
                .bind(&bips)
                .bind(&student_504s)
                .bind(&readplans)
                .bind(&gts)
                .bind(&interventions)
                .bind(&eye_glasses)
                .bind(&notes)
                .bind(&pins)
                .execute(&mut **tx)
                .await?;

            Ok(result.rows_affected() as usize)
        }

        async fn insert_batch(students: &[AddStudentRequest], tx: &mut sqlx::Transaction<'_, sqlx::Postgres>) -> Result<usize, sqlx::Error> {
            let mut query_builder = sqlx::QueryBuilder::new(
                "INSERT INTO students (firstname, lastname, preferred, gender, date_of_birth, student_id, esl, current_grade_level, teacher, iep, bip, student_504, readplan, gt, intervention, eye_glasses, notes, pin) "
            );

            query_builder.push_values(students, |mut b, student| {
                b.push_bind(&student.firstname)
                 .push_bind(&student.lastname)
                 .push_bind(&student.preferred)
                 .push_bind(student.gender.to_string())
                 .push_bind(student.date_of_birth)
                 .push_bind(student.student_id)
                 .push_bind(student.esl.to_string())
                 .push_bind(student.current_grade_level.to_string())
                 .push_bind(&student.teacher)
                 .push_bind(student.iep)
                 .push_bind(student.bip)
                 .push_bind(student.student_504)
                 .push_bind(student.readplan)
                 .push_bind(student.gt)
                 .push_bind(&student.intervention)
                 .push_bind(student.eye_glasses)
                 .push_bind(&student.notes)
                 .push_bind(student.pin);
            });

            // Add conflict resolution if needed
            query_builder.push(" ON CONFLICT (student_id) DO UPDATE SET firstname = EXCLUDED.firstname, lastname = EXCLUDED.lastname");

            let query = query_builder.build();
            let result = query.execute(&mut **tx).await?;

            Ok(result.rows_affected() as usize)
        }
    }
}
use leptos::prelude::*;
cfg_if::cfg_if! {

    if #[cfg(feature = "ssr")] {

        use crate::app::models::{Student, Test, TestType, QuestionType, Question, Score, CreateScoreRequest};
        use crate::app::errors::{ErrorMessage, StudentError, TestError, ErrorMessageTest, QuestionError, ErrorMessageQuestion};
        use leptos::prelude::*;
        use sqlx::PgPool;
        use uuid=:{Uuid, uuid};
        use log::{debug, error, info, warn};
        use sqlx::prelude::*;

        pub async fn get_all_questions(test_id= String, pool: &sqlx::PgPool) -> Result<Vec<Question>, leptos::ServerFnError> {
            let ID = Uuid=:parse_str(&test_id).expect("Invalid UUID format");

            let rows = sqlx::query("SELECT word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker, weighted_multiple_choice FROM question_table WHERE testlinker = $1::uuid ORDER BY qnumber ASC")
                .bind(&ID)
                .fetch_all(pool)
                .await?;

            let questions: Vec<Question> = rows
                .into_iter()
                .map(|row| {
                    let word_problem: String = row.get("word_problem");
                    let point_value: i32 = row.get("point_value");
                    let question_type: QuestionType = row.get("question_type");
                    let options: Vec<String> = row.get("options");
                    let correct_answer: String = row.get("correct_answer");
                    let qnumber: i32 = row.get("qnumber");
                    let testlinker_one: Uuid = row.get("testlinker");
                    let weighted_multiple_choice: Option<String> = row.get("weighted_multiple_choice");

                    let testlinker = testlinker_one.to_string();

                    Question {
                        word_problem,
                        point_value,
                        question_type,
                        options,
                        correct_answer,
                        qnumber,
                        testlinker,
                        weighted_options: weighted_multiple_choice, // Map from database field
                    }
                })
                .collect();
            Ok(questions)
        }

        pub async fn add_question(question: &Question, pool: &sqlx::PgPool)-> Result<Question, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&question.testlinker).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let row = sqlx::query("INSERT INTO question_table (word_problem, point_value, question_type, options, correct_answer, testlinker, weighted_multiple_choice) VALUES($1, $2, $3::questiontype_enum, $4, $5, $6::uuid, $7) RETURNING word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker::text, weighted_multiple_choice")
                .bind(&question.word_problem)
                .bind(&question.point_value)
                .bind(&question.question_type)
                .bind(&question.options)
                .bind(&question.correct_answer)
                .bind(testlinker_uuid)
                .bind(&question.weighted_options) // Include weighted_options in INSERT
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let question = Question {
                word_problem: row.get("word_problem"),
                point_value: row.get("point_value"),
                question_type: row.get("question_type"),
                options: row.get("options"),
                correct_answer: row.get("correct_answer"),
                qnumber: row.get("qnumber"),
                testlinker: row.get("testlinker"),
                weighted_options: row.get("weighted_multiple_choice"), // Map from database field
            };

            Ok(question)
        }


        pub async fn update_question(question: &Question, pool: &sqlx::PgPool) -> Result<Option<Question>, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&question.testlinker).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let row = sqlx::query("UPDATE question_table SET word_problem = $1, point_value = $2, question_type = $3::questiontype_enum, options = $4, correct_answer = $5, weighted_multiple_choice = $6 WHERE qnumber = $7 AND testlinker = $8::uuid RETURNING word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker::text, weighted_multiple_choice")
                .bind(&question.word_problem)
                .bind(&question.point_value)
                .bind(&question.question_type)
                .bind(&question.options)
                .bind(&question.correct_answer)
                .bind(&question.weighted_options) // Include weighted_options in UPDATE
                .bind(&question.qnumber)
                .bind(testlinker_uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let question: Question = Question {
                word_problem: row.get("word_problem"),
                point_value: row.get("point_value"),
                question_type: row.get("question_type"),
                options: row.get("options"),
                correct_answer: row.get("correct_answer"),
                qnumber: row.get("qnumber"),
                testlinker: row.get("testlinker"),
                weighted_options: row.get("weighted_multiple_choice"), // Map from database field
            };
            Ok(Some(question))
        }


        pub async fn delete_all_questions(test_id= String, pool: &PgPool) -> Result<Vec<Question>, leptos::ServerFnError> {
            let testlinker = Uuid=:parse_str(&test_id).expect("This did not convert to a UUID correctly");

            let rows = sqlx::query("DELETE FROM question_table WHERE testlinker = $1 RETURNING word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker, weighted_multiple_choice")
                .bind(&testlinker)
                .fetch_all(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let questions: Vec<Question> = rows
                .into_iter()
                .map(|row| {
                    let word_problem: String = row.get("word_problem");
                    let point_value: i32 = row.get("point_value");
                    let question_type: QuestionType = row.get("question_type");
                    let options: Vec<String> = row.get("options");
                    let correct_answer: String = row.get("correct_answer");
                    let qnumber: i32 = row.get("qnumber");
                    let testlinker_one: Uuid = row.get("testlinker");
                    let weighted_multiple_choice: Option<String> = row.get("weighted_multiple_choice");

                    let testlinker = testlinker_one.to_string();

                    Question {
                        word_problem,
                        point_value,
                        question_type,
                        options,
                        correct_answer,
                        qnumber,
                        testlinker,
                        weighted_options: weighted_multiple_choice, // Map from database field
                    }
                })
                .collect();
            Ok(questions)
        }
        pub async fn delete_question(qnumber: i32, test_id= String, pool: &PgPool) -> Result<Question, leptos::ServerFnError> {
            let testlinker = Uuid=:parse_str(&test_id).expect("This did not convert to a UUID correctly");

            let row = sqlx::query("DELETE FROM question_table WHERE qnumber = $1 AND testlinker = $2 RETURNING word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker, weighted_multiple_choice")
                .bind(&qnumber)
                .bind(&testlinker)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let deleted_question = Question {
                word_problem: row.get("word_problem"),
                point_value: row.get("point_value"),
                question_type: row.get("question_type"),
                options: row.get("options"),
                correct_answer: row.get("correct_answer"),
                qnumber: row.get("qnumber"),
                testlinker: row.get("testlinker"),
                weighted_options: row.get("weighted_multiple_choice"), // Map from database field
            };

            Ok(deleted_question)
        }

        pub async fn get_single_question(qnumber: i32, test_id= String, pool: &PgPool) -> Result<Question, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&test_id).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let row = sqlx::query("SELECT word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker, weighted_multiple_choice FROM question_table WHERE qnumber = $1 AND testlinker = $2")
                .bind(qnumber)
                .bind(testlinker_uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let question = Question {
                word_problem: row.get("word_problem"),
                point_value: row.get("point_value"),
                question_type: row.get("question_type"),
                options: row.get("options"),
                correct_answer: row.get("correct_answer"),
                qnumber: row.get("qnumber"),
                testlinker: row.get("testlinker"),
                weighted_options: row.get("weighted_multiple_choice"), // Map from database field
            };

            Ok(question)
        }

        pub async fn update_question_options(qnumber: i32, test_id= String, new_options: Vec<String>, pool: &PgPool) -> Result<Question, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&test_id).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let row = sqlx::query("UPDATE question_table SET options = $1 WHERE qnumber = $2 AND testlinker = $3 RETURNING word_problem, point_value, question_type, options, correct_answer, qnumber, testlinker, weighted_multiple_choice")
                .bind(&new_options)
                .bind(qnumber)
                .bind(testlinker_uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let question = Question {
                word_problem: row.get("word_problem"),
                point_value: row.get("point_value"),
                question_type: row.get("question_type"),
                options: row.get("options"),
                correct_answer: row.get("correct_answer"),
                qnumber: row.get("qnumber"),
                testlinker: row.get("testlinker"),
                weighted_options: row.get("weighted_multiple_choice"), // Map from database field
            };

            Ok(question)
        }

        pub async fn count_questions_by_test(test_id= String, pool: &PgPool) -> Result<i64, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&test_id).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM question_table WHERE testlinker = $1")
                .bind(testlinker_uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(count)
        }

        pub async fn count_multiple_choice_questions(test_id= String, pool: &PgPool) -> Result<i64, leptos::ServerFnError> {
            let testlinker_uuid = Uuid=:parse_str(&test_id).map_err(|e| leptos::ServerFnError::new(format!("Invalid UUID: {}", e)))?;

            let count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM question_table WHERE testlinker = $1 AND question_type = 'MultipleChoice'")
                .bind(testlinker_uuid)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            Ok(count)
        }
    }
}
use leptos::prelude::*;
//this is a filler comment for now
cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {

        use crate::app::models::student::GradeEnum;
        use crate::app::models::employee::{Employee, EmployeeRole, StatusEnum};
        use log::{debug, error, info, warn};
        use leptos::prelude::*;
        use sqlx::prelude::*;
        use sqlx::PgPool;
        use tokio::*;

        pub async fn get_all_teachers(pool: &sqlx::PgPool) -> Result<Vec<Employee>, leptos::ServerFnError> {
            let rows = sqlx::query(
                "SELECT id, firstname, lastname, status, grade
                 FROM employees 
                 WHERE role = 'Teacher'::employee_role
                 ORDER BY lastname DESC"
            )
            .fetch_all(pool)
            .await?;

            let teachers: Vec<Employee> = rows
                .into_iter()
                .map(|row| {
                    let id= i32 = row.get("id");
                    let firstname: String = row.get("firstname");
                    let lastname: String = row.get("lastname");
                    let status: StatusEnum = row.get("status");
                    let grade: Option<GradeEnum> = row.get("grade");

                    Employee::new_teacher(
                        id,
                        firstname,
                        lastname,
                        status,
                        grade,
                    )
                })
                .collect();
            Ok(teachers)
        }

        pub async fn add_teacher(buffer_teacher: &Employee, pool: &PgPool) -> Result<Employee, leptos::ServerFnError> {
            // Verify that we're actually adding a teacher
            if let EmployeeRole::Teacher { grade } = &buffer_teacher.role {
                let row = sqlx::query(
                    "INSERT INTO employees (id, firstname, lastname, status, role, grade)
                     VALUES ($1, $2, $3, $4, 'Teacher'::employee_role, $5) 
                     RETURNING id, firstname, lastname, status, grade"
                )
                    .bind(&buffer_teacher.id)
                    .bind(&buffer_teacher.firstname)
                    .bind(&buffer_teacher.lastname)
                    .bind(&buffer_teacher.status)
                    .bind(grade)
                    .fetch_one(pool)
                    .await
                    .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

                let teacher = Employee::new_teacher(
                    row.get("id"),
                    row.get("firstname"),
                    row.get("lastname"),
                    row.get("status"),
                    row.get("grade"),
                );

                Ok(teacher)
            } else {
                Err(leptos::ServerFnError::new("Attempted to add non-teacher employee using add_teacher"))
            }
        }

        pub async fn delete_teacher(id= i32, pool: &PgPool) -> Result<Employee, leptos::ServerFnError> {
            let row = sqlx::query(
                "DELETE FROM employees
                 WHERE id = $1 AND role = 'Teacher'::employee_role 
                 RETURNING id, firstname, lastname, status, grade"
            )
                .bind(id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let teacher = Employee::new_teacher(
                row.get("id"),
                row.get("firstname"),
                row.get("lastname"),
                row.get("status"),
                row.get("grade"),
            );

            Ok(teacher)
        }

        pub async fn update_teacher(
            id= i32,
            firstname: String,
            lastname: String,
            status: StatusEnum,
            grade: Option<GradeEnum>,
            pool: &PgPool
        ) -> Result<Option<Employee>, leptos::ServerFnError> {
            let row = sqlx::query(
                "UPDATE employees
                 SET firstname = $1, lastname = $2, status = $3::status_enum, grade = $4
                 WHERE id = $5 AND role = 'Teacher'::employee_role 
                 RETURNING id, firstname, lastname, status, grade"
            )
                .bind(&firstname)
                .bind(&lastname)
                .bind(&status)
                .bind(&grade)
                .bind(&id)
                .fetch_one(pool)
                .await
                .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let teacher = Employee::new_teacher(
                row.get("id"),
                row.get("firstname"),
                row.get("lastname"),
                row.get("status"),
                row.get("grade"),
            );

            Ok(Some(teacher))
        }
    }
}
use leptos::prelude::*;
use crate::app::models::student::GradeEnum;
use crate::app::models::EmployeeRole;

cfg_if::cfg_if! {

    if #[cfg(feature = "ssr")] {

        use log::{debug, error, info, warn};
        use crate::app::models::Employee;
        use crate::app::models::StatusEnum;
        use dotenvy::dotenv;
        use sqlx::{PgPool, Row};
        use std::env;
        use leptos::prelude::*;
        use tokio::*;
        use std::sync::Once;

        // Use Once to ensure dotenv is only called once
        static INIT: Once = Once::new();

        fn init_env() {
            INIT.call_once(|| {
                match dotenv() {
                    Ok(_) => info!("Environment variables loaded from .env file"),
                    Err(e) => {
                        warn!("Could not load .env file: {}. Using system environment variables.", e);
                    }
                }
            });
        }

       pub async fn create_pool() -> sqlx::PgPool {
           // Initialize environment variables only once
           init_env();

            let database_url = env::var("DATABASE_URL")
                .expect("DATABASE_URL must be set in environment variables or .env file");

            info!("Creating database connection pool...");

            //create the connection pool using sqlx
            let pool = sqlx::postgres::PgPoolOptions::new()
            .max_connections(20)
            .min_connections(5)
            .acquire_timeout(std::time::Duration::from_secs(3))
            .idle_timeout(std::time::Duration::from_secs(600))
            .max_lifetime(std::time::Duration::from_secs(1800))
            .connect(&database_url.as_str())
            .await
            .expect("Failed to create PostgreSQL pool");

            info!("Running database migrations...");
            sqlx::migrate!()
                .run(&pool)
                .await
                .expect("migrations failed");

            info!("Database pool and migrations completed successfully");
           pool
        }

       pub async fn get_all_employees(pool: &sqlx::PgPool) -> Result<Vec<Employee>, leptos::ServerFnError> {
           let rows = sqlx::query("SELECT id, firstname, lastname, status, role, grade FROM employees")
               .fetch_all(pool)
               .await?;

           let employees: Vec<Employee> = rows
               .into_iter()
               .map(|row| {
                   let id= i32 = row.get("id");
                   let firstname: String = row.get("firstname");
                   let lastname: String = row.get("lastname");
                   let status: StatusEnum = row.get("status");
                   let role: EmployeeRole = row.get("role");
                   let grade: Option<GradeEnum> = row.get("grade");

                   let role = match role {
                       EmployeeRole::Teacher { grade: _ } => EmployeeRole::Teacher { grade },
                       other => other,
                   };

                   Employee {
                            id,
                            firstname,
                            lastname,
                            status,
                            role,
                   }
               }).collect();
           Ok(employees)
       }

        pub async fn add_employee(employee: &Employee, pool: &PgPool) -> Result<Employee, leptos::ServerFnError> {
            let grade = match &employee.role {
                EmployeeRole::Teacher { grade } => grade.clone(),
                _ => None
            };

            let row = match &employee.role {
                EmployeeRole::Teacher { grade } => {
                    sqlx::query(
                        "INSERT INTO employees (firstname, lastname, status, role, grade)
                         VALUES ($1, $2, $3, $4, $5) 
                         RETURNING id, firstname, lastname, status, role, grade"
                    )
                    .bind(&employee.firstname)
                    .bind(&employee.lastname)
                    .bind(&employee.status)
                    .bind(&employee.role)
                    .bind(&grade)
                    .fetch_one(pool)
                    .await
                },
                _ => {
                    sqlx::query(
                        "INSERT INTO employees (firstname, lastname, status, role)
                         VALUES ($1, $2, $3, $4) 
                         RETURNING id, firstname, lastname, status, role, grade"
                    )
                    .bind(&employee.firstname)
                    .bind(&employee.lastname)
                    .bind(&employee.status)
                    .bind(&employee.role)
                    .fetch_one(pool)
                    .await
                }
            }.map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            debug!("Raw database role: {:?}", row.get::<String, _>("role"));
            debug!("Raw database grade: {:?}", row.get::<Option<String>, _>("grade"));

            let id= i32 = row.get("id");
            let firstname: String = row.get("firstname");
            let lastname: String = row.get("lastname");
            let status: StatusEnum = row.get("status");
            let role: EmployeeRole = row.get("role");

            Ok(Employee::new(id, firstname, lastname, status, role))
        }

        pub async fn update_employee(employee: &Employee, pool: &PgPool) -> Result<Option<Employee>, leptos::ServerFnError> {
            info!("Starting employee update for ID: {}", employee.id);
            let grade = match &employee.role {
                EmployeeRole::Teacher { grade } => grade.clone(),
                _ => None
            };

            let row = match &employee.role {
                EmployeeRole::Teacher { grade } => {
                    sqlx::query(
                        "UPDATE employees
                         SET firstname = $1, lastname = $2, status = $3, 
                             role = $4, grade = $5
                         WHERE id = $6 
                         RETURNING id, firstname, lastname, status, role, grade"
                    )
                    .bind(&employee.firstname)
                    .bind(&employee.lastname)
                    .bind(&employee.status)
                    .bind(&employee.role)
                    .bind(&grade)
                    .bind(&employee.id)
                    .fetch_one(pool)
                    .await
                },
                _ => {
                    sqlx::query(
                        "UPDATE employees
                         SET firstname = $1, lastname = $2, status = $3::status_enum, 
                             role = $4::employee_role, grade = NULL
                         WHERE id = $5 
                         RETURNING id, firstname, lastname, status, role, grade"
                    )
                    .bind(&employee.firstname)
                    .bind(&employee.lastname)
                    .bind(&employee.status)
                    .bind(&employee.role)
                    .bind(&employee.id)
                    .fetch_one(pool)
                    .await
                }
            }.map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            let id= i32 = row.get("id");
            let firstname: String = row.get("firstname");
            let lastname: String = row.get("lastname");
            let status: StatusEnum = row.get("status");
            let role: EmployeeRole = row.get("role");
            let grade: Option<GradeEnum> = row.get("grade");

            let role = match role {
               EmployeeRole::Teacher { grade: _ } => EmployeeRole::Teacher { grade },
               other => other,
            };
            log::info!("Successfully returned from database with updated employee");
           let updated_employee = Employee {
                    id,
                    firstname,
                    lastname,
                    status,
                    role,
           };

           Ok(Some(updated_employee))
        }

        pub async fn delete_employee(employee_id= i32, pool: &PgPool) -> Result<Employee, leptos::ServerFnError> {
            let row = sqlx::query(
                "DELETE FROM employees
                 WHERE id = $1
                 RETURNING id, firstname, lastname, status, role, grade"
            )
            .bind(employee_id)
            .fetch_one(pool)
            .await
            .map_err(|e| leptos::ServerFnError::new(format!("Database error: {}", e)))?;

            log::debug!("Deleted row: {:?}", row);

            let id= i32 = row.get("id");
            let firstname: String = row.get("firstname");
            let lastname: String = row.get("lastname");
            let status: StatusEnum = row.get("status");
            let role: EmployeeRole = row.get("role");
            let grade: Option<GradeEnum> = row.get("grade");

            // Fix the role for Teacher to include grade
            let role = match role {
                EmployeeRole::Teacher { grade: _ } => EmployeeRole::Teacher { grade },
                other => other,
            };

            Ok(Employee {
                id,
                firstname,
                lastname,
                status,
                role,
            })
        }
    }
}
use leptos::prelude::*;
pub mod student_errors;
pub use student_errors::ErrorMessage;
pub use student_errors::ResponseErrorTrait;
pub use student_errors::StudentError;

pub mod test_errors;
pub use test_errors::ErrorMessageTest;
pub use test_errors::ResponseErrorTraitTest;
pub use test_errors::TestError;

pub mod question_errors;
pub use question_errors::ErrorMessageQuestion;
pub use question_errors::QuestionError;
pub use question_errors::ResponseErrorTraitQuestion;
use leptos::prelude::*;
pub mod benchmark_utils;
pub use benchmark_utils::*;

//Re-exporting the benchmark_utils module to make its contents available at the top level of the `utils` module.
pub use benchmark_utils::{BenchmarkStats, BenchmarkUtils};
use leptos::prelude::*;
// src/app/routes/saml_routes.rs

cfg_if::cfg_if! {
    if #[cfg(feature = "ssr")] {
        use crate::app::db::{saml_database, user_database};
        use crate::app::models::user::SessionUser;
        use leptos::html::form as leptos_form;
        use actix_web::{web, HttpRequest, HttpResponse, Result};
        use flate2::{write::DeflateEncoder, Compression};
        use std::io::Write;
        use serde::Deserialize;

        #[derive(Deserialize)]
        pub struct SamlAcsRequest {
            #[serde(rename = "SAMLResponse")]
            saml_response: String,
            #[serde(rename = "RelayState")]
            relay_state: Option<String>,
        }

        #[derive(Deserialize)]
        pub struct SamlSloRequest {
            #[serde(rename = "SAMLRequest")]
            saml_request: Option<String>,
            #[serde(rename = "SAMLResponse")]
            saml_response: Option<String>,
            #[serde(rename = "RelayState")]
            relay_state: Option<String>,
        }

        #[derive(Deserialize)]
        pub struct SamlLoginQuery {
            institution: String,
            relay_state: Option<String>,
        }

        // Initiate SAML login flow
        pub async fn saml_login(
            pool: web::Data<sqlx::PgPool>,
            query: web::Query<SamlLoginQuery>,
        ) -> Result<HttpResponse> {
            log::info!("Initiating SAML login for institution: {}", query.institution);

            // Convert institution name to match database format
            let institution_name = query
                .institution
                .split('-')
                .map(|word| {
                    if word.to_lowercase() == "saml" {
                        "SAML".to_string()
                    } else {
                        let mut chars = word.chars();
                        match chars.next() {
                            None => String::new(),
                            Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                        }
                    }
                })
                .collect::<Vec<_>>()
                .join(" ");

            log::info!("Converted '{}' to '{}'", query.institution, institution_name);

            // Get SAML config for institution
            let config = match saml_database::get_saml_config_by_name(&pool, &institution_name).await {
                Ok(Some(config)) => config,
                Ok(None) => {
                    log::error!("No SAML config found for institution: {}", institution_name);
                    return Ok(HttpResponse::BadRequest().body(format!(
                        "Institution '{}' not configured for SAML SSO",
                        institution_name
                    )));
                }
                Err(e) => {
                    log::error!("Error getting SAML config: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("Configuration error"));
                }
            };

            if !config.active {
                log::warn!("SAML config is disabled for institution: {}", institution_name);
                return Ok(HttpResponse::BadRequest().body("SAML SSO is disabled for this institution"));
            }

            // Create SAML manager
            let base_url = std::env::var("BASE_URL").expect("BASE_URL environment variable must be set for SAML functionality");
            let saml_manager = match saml_database::SamlManager::new(&base_url) {
                Ok(manager) => manager,
                Err(e) => {
                    log::error!("Failed to create SAML manager: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("SAML configuration error"));
                }
            };

            // Generate SAML auth request - institution info will be embedded in RelayState
            let auth_url = match generate_auth_request_url(&saml_manager, &config, query.relay_state.as_deref()) {
                Ok(url) => url,
                Err(e) => {
                    log::error!("Failed to generate SAML auth request: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("Failed to generate SAML request"));
                }
            };

            log::info!("Redirecting to SAML IdP: {}", auth_url);

            // Simple redirect without cookies
            Ok(HttpResponse::Found()
                .append_header(("Location", auth_url))
                .finish())
        }

// Replace your generate_auth_request_url function with this version:

    fn generate_auth_request_url(
        saml_manager: &saml_database::SamlManager,
        config: &crate::app::models::auth::SamlConfig,
        relay_state: Option<&str>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        use uuid=:Uuid;
        use chrono::Utc;
        use base64::{engine::general_purpose, Engine as _};
        use flate2::write::DeflateEncoder;
        use flate2::Compression;
        use std::io::Write;

        // Build the SAML AuthnRequest with proper XML formatting
        let request_id = Uuid=:new_v4().to_string();
        let timestamp = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");

        let saml_request = format!(
            r#"<?xml version="1.0" encoding="UTF-8"?>
    <samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" ID="{}" Version="2.0" IssueInstant="{}" Destination="{}" ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" AssertionConsumerServiceURL="{}">
        <saml:Issuer>{}</saml:Issuer>
    </samlp:AuthnRequest>"#,
            request_id,
            timestamp,
            config.sso_url,
            format!("{}/saml/acs", saml_manager.base_url),
            format!("{}/saml/metadata", saml_manager.base_url)
        );

        log::debug!("Generated SAML Request XML: {}", saml_request);

        // Compress and encode the request
        let mut encoder = DeflateEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(saml_request.as_bytes())?;
        let compressed_data = encoder.finish()?;
        let encoded_request = general_purpose::STANDARD.encode(&compressed_data);

        // Build the redirect URL
        let mut auth_url = url::Url::parse(&config.sso_url)?;
        auth_url
            .query_pairs_mut()
            .append_pair("SAMLRequest", &encoded_request);

        // IMPORTANT: Encode institution info in RelayState
        // Format: "institution_id|original_relay_state"
        let encoded_relay_state = match relay_state {
            Some(original_relay_state) => {
                format!("{}|{}", config.institution_name, original_relay_state)
            }
            None => {
                format!("{}|/dashboard", config.institution_name)
            }
        };

        auth_url
            .query_pairs_mut()
            .append_pair("RelayState", &encoded_relay_state);

        log::info!("Generated auth URL: {}", auth_url);

        Ok(auth_url.to_string())
    }

        // Serve SAML metadata for service provider
        pub async fn saml_metadata(_pool: web::Data<sqlx::PgPool>) -> Result<HttpResponse> {
            let base_url =
                std::env::var("BASE_URL").expect("BASE_URL environment variable must be set for SAML functionality");

            let metadata_xml = format!(
                r#"<?xml version="1.0" encoding="UTF-8"?>
        <md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
                             entityID="{}/saml/metadata">
            <md:SPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
                <md:NameIDFormat>urn:oasis:names:tc:SAML:2.0:nameid-format:emailAddress</md:NameIDFormat>
                <md:AssertionConsumerService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                                            Location="{}/saml/acs"
                                            index="1"/>
                <md:SingleLogoutService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
                                       Location="{}/saml/sls"/>
            </md:SPSSODescriptor>
        </md:EntityDescriptor>"#,
                base_url, base_url, base_url
            );

            Ok(HttpResponse::Ok()
                .content_type("application/xml")
                .body(metadata_xml))
        }

        // Handle SAML Assertion Consumer Service (ACS)
        pub async fn saml_acs(
            pool: web::Data<sqlx::PgPool>,
            req: HttpRequest,
            form: web::Form<SamlAcsRequest>,
        ) -> Result<HttpResponse> {
            log::info!("Received SAML ACS request");

            // Debug: Log all cookies (for debugging purposes)
            if let Ok(cookies) = req.cookies() {
                log::info!("Available cookies:");
                for cookie in cookies.iter() {
                    log::info!("  Cookie: {} = {}", cookie.name(), cookie.value());
                }
            }

            // Extract institution info from RelayState instead of cookies
            let (institution_name, redirect_url) = match &form.relay_state {
                Some(relay_state) if !relay_state.is_empty() => {
                    log::info!("Processing RelayState: {}", relay_state);

                    if relay_state.contains('|') {
                        let parts: Vec<&str> = relay_state.split('|').collect();
                        if parts.len() >= 2 {
                            let institution = parts[0].to_string();
                            let redirect = parts[1].to_string();
                            log::info!("Extracted institution: '{}', redirect: '{}'", institution, redirect);
                            (institution, redirect)
                        } else {
                            log::error!("Invalid RelayState format: {}", relay_state);
                            return Ok(HttpResponse::BadRequest().body("Invalid RelayState format"));
                        }
                    } else {
                        // Fallback: treat entire RelayState as institution name
                        log::warn!("RelayState doesn't contain separator, treating as institution name");
                        (relay_state.clone(), "/dashboard".to_string())
                    }
                }
                _ => {
                    log::error!("No RelayState provided in SAML response");
                    return Ok(HttpResponse::BadRequest().body("No institution information found"));
                }
            };

            log::info!("Processing SAML response for institution: {}", institution_name);

            // Get SAML config - institution_name is already in the correct format from RelayState
            let config = match saml_database::get_saml_config_by_name(&pool, &institution_name).await {
                Ok(Some(config)) => config,
                Ok(None) => {
                    log::error!("No SAML config found for institution: {}", institution_name);
                    return Ok(HttpResponse::BadRequest().body("Institution not configured"));
                }
                Err(e) => {
                    log::error!("Error getting SAML config: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("Configuration error"));
                }
            };

            // Rest of your SAML processing logic remains the same...
            // Decode and parse SAML response
            let base_url = std::env::var("BASE_URL").expect("BASE_URL environment variable msut be set for SAML functionality");
            let saml_manager = match saml_database::SamlManager::new(&base_url) {
                Ok(manager) => manager,
                Err(e) => {
                    log::error!("Failed to create SAML manager: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("SAML configuration error"));
                }
            };

            // Decode base64 SAML response
            use base64::{engine::general_purpose, Engine as _};
            let decoded_response = match general_purpose::STANDARD.decode(&form.saml_response) {
                Ok(decoded) => decoded,
                Err(e) => {
                    log::error!("Failed to decode SAML response: {:?}", e);
                    return Ok(HttpResponse::BadRequest().body("Invalid SAML response format"));
                }
            };

            let saml_xml = match String::from_utf8(decoded_response) {
                Ok(xml) => xml,
                Err(e) => {
                    log::error!("Invalid UTF-8 in SAML response: {:?}", e);
                    return Ok(HttpResponse::BadRequest().body("Invalid SAML response encoding"));
                }
            };

            log::debug!("SAML Response XML: {}", saml_xml);

            // Parse SAML response
            let parsed_response = match saml_manager.parse_saml_response(&saml_xml, &institution_name) {
                Ok(response) => response,
                Err(e) => {
                    log::error!("Failed to parse SAML response: {:?}", e);
                    return Ok(HttpResponse::BadRequest().body("Invalid SAML response"));
                }
            };

            log::info!("Parsed SAML response for user: {}", parsed_response.name_id);

            // Provision or get existing user
            let user = match saml_database::provision_saml_user(&pool, &parsed_response, &institution_name).await {
                Ok(user) => user,
                Err(e) => {
                    log::error!("Failed to provision SAML user: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("User provisioning failed"));
                }
            };

            // Create session
            let session_token = match user_database::create_session(&pool, user.id).await {
                Ok(token) => token,
                Err(e) => {
                    log::error!("Failed to create session: {:?}", e);
                    return Ok(HttpResponse::InternalServerError().body("Session creation failed"));
                }
            };

            log::info!("SAML login successful for user: {} ({})", user.username, user.id);

            // Use the redirect_url extracted from RelayState
            log::info!("Redirecting to: {}", redirect_url);

            // Create HTML response with auto-redirect and session cookie
            let html_response = format!(
                r#"<!DOCTYPE html>
        <html>
        <head>
            <title>Login Successful</title>
            <meta http-equiv="refresh" content="0;url={}">
        </head>
        <body>
            <p>Login successful! Redirecting...</p>
            <script>
                window.location.href = '{}';
            </script>
        </body>
        </html>"#,
                redirect_url, redirect_url
            );

            Ok(HttpResponse::Ok()
                .content_type("text/html")
                .cookie(
                    actix_web::cookie::Cookie::build("session", session_token)
                        .path("/")
                        .http_only(true)
                        .same_site(actix_web::cookie::SameSite::Strict)
                        .max_age(actix_web::cookie::time::Duration::days(7))
                        .secure(true)
                        .finish(),
                )
                .body(html_response))
        }

        // Handle SAML Single Logout Service (SLS)
        pub async fn saml_sls(
            pool: web::Data<sqlx::PgPool>,
            req: HttpRequest,
            query: web::Query<SamlSloRequest>,
        ) -> Result<HttpResponse> {
            log::info!("Received SAML SLS request");

            // Get current session
            let session_token = req
                .cookie("session")
                .map(|cookie| cookie.value().to_string());

            if let Some(token) = session_token {
                // Delete the session
                if let Err(e) = user_database::delete_session(&pool, &token).await {
                    log::error!("Failed to delete session: {:?}", e);
                }
            }

            // If this is a logout response, just redirect
            if query.saml_response.is_some() {
                return Ok(HttpResponse::Found()
                    .append_header(("Location", "/login"))
                    .cookie(
                        actix_web::cookie::Cookie::build("session", "")
                            .path("/")
                            .http_only(true)
                            .max_age(actix_web::cookie::time::Duration::seconds(0))
                            .finish(),
                    )
                    .finish());
            }

            // If this is a logout request, we should process it and send a response
            // For now, just redirect to login page
            let redirect_url = match query.relay_state.as_deref() {
                Some(relay_state) if !relay_state.is_empty() && relay_state != "undefined" && relay_state != "null" => {
                    // If using the RelayState encoding method:
                    if relay_state.contains('|') {
                        let parts: Vec<&str> = relay_state.split('|').collect();
                        if parts.len() >= 2 {
                            parts[1].to_string()  // Get the redirect part
                        } else {
                            "/dashboard".to_string()
                        }
                    } else {
                        relay_state.to_string()
                    }
                }
                _ => "/dashboard".to_string()  // Default fallback
            };

            log::info!("Redirecting to: {}", redirect_url);

            // Create HTML response with auto-redirect and session cookie
            let html_response = format!(
                r#"
            <!DOCTYPE html>
            <html>
            <head>
                <title>Login Successful</title>
                <meta http-equiv="refresh" content="0;url={}">
            </head>
            <body>
                <p>Login successful! Redirecting...</p>
                <script>
                    window.location.href = '{}';
                </script>
            </body>
            </html>"#,
                redirect_url, redirect_url  // Use redirect_url instead of form.relay_state
            );

            Ok(HttpResponse::Found()
                .append_header(("Location", redirect_url))
                .cookie(
                    actix_web::cookie::Cookie::build("session", "")
                        .path("/")
                        .http_only(true)
                        .max_age(actix_web::cookie::time::Duration::seconds(0))
                        .finish(),
                )
                .finish())
        }

        // Health check endpoint for SAML functionality
        pub async fn saml_health(pool: web::Data<sqlx::PgPool>) -> Result<HttpResponse> {
            // Check if we can connect to database and have SAML configs
            match saml_database::list_saml_configs(&pool).await {
                Ok(configs) => {
                    let active_configs = configs.iter().filter(|c| c.active).count();
                    Ok(HttpResponse::Ok().json(serde_json::json!({
                        "status": "ok",
                        "saml_enabled": true,
                        "active_institutions": active_configs,
                        "total_institutions": configs.len(),
                        "institutions": configs.iter().map(|c| &c.institution_name).collect::<Vec<_>>()
                    })))
                }
                Err(e) => {
                    log::error!("SAML health check failed: {:?}", e);
                    Ok(HttpResponse::ServiceUnavailable().json(serde_json::json!({
                        "status": "error",
                        "saml_enabled": false,
                        "error": "Database connectivity issue"
                    })))
                }
            }
        }

        // Configure SAML routes
        pub fn configure_saml_routes(cfg: &mut web::ServiceConfig) {
            cfg.service(
                web::scope("/saml")
                    .route("/login", web::get().to(saml_login))
                    .route("/metadata", web::get().to(saml_metadata))
                    .route("/acs", web::post().to(saml_acs))
                    .route("/sls", web::get().to(saml_sls))
                    .route("/sls", web::post().to(saml_sls))
                    .route("/health", web::get().to(saml_health)),
            );
        }
    }
}

// Non-SSR placeholder for client-side compilation
#[cfg(not(feature = "ssr"))]
pub fn configure_saml_routes(_cfg: &mut ()) {
    // This function exists only for client-side compilation compatibility
    // The actual implementation is behind the SSR feature gate
}

//validates that the production environment is correctly configured for SAML
#[cfg(feature = "ssr")]
fn validate_production_config() -> Result<(), Box<dyn std::error::Error>> {
    let base_url = std::env::var("BASE_URL")?;

    if !base_url.starts_with("https://") {
        return Err("BASE_URL must use HTTPS in production".into());
    }

    if base_url.contains("localhost") || base_url.contains("127.0.0.1") {
        log::warn!("BASE_URL appears to be localhost - ensure this is intentional");
    }

    // Validate that required environment variables are set
    if std::env::var("DATABASE_URL").is_err() {
        return Err("DATABASE_URL must be set".into());
    }

    log::info!("Production SAML configuration validated successfully");
    Ok(())
}

// Call this in your main.rs or app startup:
#[cfg(feature = "ssr")]
pub fn initialize_saml() -> Result<(), Box<dyn std::error::Error>> {
    validate_production_config()?;
    log::info!("SAML subsystem initialized for production");
    Ok(())
}
use leptos::prelude::*;
pub mod lobby;
pub mod messages;
pub mod start_connection;
pub mod ws;

pub use lobby::*;
pub use messages::*;
pub use start_connection::*;
pub use ws::*;
use crate::app::components::assessment_page::{
    assessment_form::AssessmentForm, assessment_list::AssessmentList,
    shared::hooks::use_assessment_form,
};
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::header::Header;
use crate::app::components::server_auth_components::ServerAuthGuard;
use crate::app::models::assessment::{Assessment, DeleteAssessmentRequest};
use crate::app::models::test::Test;
use crate::app::server_functions::assessments::{delete_assessment, get_assessments};
use crate::app::server_functions::courses::get_courses;
use crate::app::server_functions::tests::get_tests;
use leptos::prelude::*;
use leptos_router::path;
use uuid::Uuid;

#[component]
pub fn AssessmentPage() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/assessments">
            <AssessmentPageContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn AssessmentPageContent() -> impl IntoView {
    let (selected_view, set_selected_view) = signal(SidebarSelected::Assessments);
    let (show_modal, set_show_modal) = signal(false);

    // Resources
    let assessments_resource =
        LocalResource::new(|| (), |_| async move { get_assessments().await });
    let tests_resource = LocalResource::new(|| (), |_| async move { get_tests().await });
    let courses_resource = LocalResource::new(|| (), |_| async move { get_courses().await });

    // Form state management
    let form_hook = use_assessment_form();

    // Delete action
    let delete_action = Action::new(|id: &Uuid| {
        let id = *id;
        async move {
            let request = DeleteAssessmentRequest::new(1, id);
            delete_assessment(request).await
        }
    });

    // Handle successful form submission
    let handle_form_success = move || {
        assessments_resource.refetch();
    };

    // Handle edit assessment
    let handle_edit_assessment = move |assessment: Assessment| {
        form_hook.load_assessment.call(assessment); // FIXED: Added .call()
        set_show_modal.set(true);
    };

    // Handle delete assessment
    let handle_delete_assessment = move |id: Uuid| {
        delete_action.dispatch(id);
    };

    // Handle new assessment
    let handle_new_assessment = move || {
        form_hook.reset_form.call(()); // FIXED: Added .call(())
        set_show_modal.set(true);
    };

    // Effect to refetch assessments after successful deletion
    Effect::new(move |_| {
        if let Some(Ok(_)) = delete_action.value().get() {
            assessments_resource.refetch();
        }
    });

    view! {
        <div class="min-h-screen bg-[#F9F9F8] text-[#2E3A59] font-sans">
            <Header />
            <DashboardSidebar
                selected_item=selected_view
                set_selected_item=set_selected_view
            />
            <div class="max-w-6xl mx-auto px-4 py-8">
                <AssessmentPageHeader on_new_assessment=handle_new_assessment />

                <AssessmentListSection
                    assessments_resource=assessments_resource
                    tests_resource=tests_resource
                    on_edit=handle_edit_assessment
                    on_delete=handle_delete_assessment
                />

                <AssessmentForm
                    show_modal=show_modal
                    set_show_modal=set_show_modal
                    form_hook=form_hook
                    tests_resource=tests_resource
                    courses_resource=courses_resource
                    on_success=handle_form_success
                />
            </div>
        </div>
    }
}

#[component]
fn AssessmentPageHeader(on_new_assessment: impl Fn() + 'static + Copy) -> impl IntoView {
    view! {
        <div class="flex justify-between">
            <h1 class="text-3xl font-medium mb-8 text-[#2E3A59]">"Assessments"</h1>
            <div class="mb-8">
                <button
                    class="bg-[#2E3A59] text-white px-4 py-2 rounded shadow-md hover:opacity-90 transition-opacity text-sm font-medium"
                    on:click=move |_| on_new_assessment()
                >
                    "Add New Assessment"
                </button>
            </div>
        </div>
    }
}

#[component]
fn AssessmentListSection(
    assessments_resource: Resource<(), Result<Vec<Assessment>, ServerFnError>>,
    tests_resource: Resource<(), Result<Vec<Test>, ServerFnError>>,
    on_edit: impl Fn(Assessment) + 'static + Copy,
    on_delete: impl Fn(Uuid) + 'static + Copy,
) -> impl IntoView {
    view! {
        {move || {
            match (assessments_resource.get(), tests_resource.get()) {
                (Some(Ok(assessments)), Some(Ok(tests))) => {
                    view! {
                        <AssessmentList
                            assessments=assessments
                            tests=tests
                            on_edit=on_edit
                            on_delete=on_delete
                        />
                    }.into_any()
                },
                (Some(Err(e)), _) | (_, Some(Err(e))) => {
                    view! {
                        <div class="bg-white rounded-lg shadow-sm mb-8 overflow-hidden">
                            <div class="p-6">
                                <div class="p-4 bg-red-50 text-red-700 rounded border border-red-200">
                                    "Error loading data: " {e.to_string()}
                                </div>
                            </div>
                        </div>
                    }.into_any()
                },
                _ => {
                    view! {
                        <div class="bg-white rounded-lg shadow-sm mb-8 overflow-hidden">
                            <div class="border-b border-[#DADADA] px-6 py-4">
                                <h2 class="text-xl font-medium text-[#2E3A59]">"All Assessments"</h2>
                            </div>
                            <div class="p-6">
                                <div class="flex items-center justify-center py-12">
                                    <div class="text-center">
                                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-[#2E3A59] mx-auto mb-4"></div>
                                        <p class="text-gray-500">"Loading assessments..."</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    }.into_any()
                }
            }
        }}
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::auth::test_saml::SamlTestButton;
use crate::app::components::dashboard::dashboard_deanonymizer::DashboardDeanonymizer;
use crate::app::components::dashboard::scores_ledger::ScoresLedger;
use crate::app::components::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::header::Header;
use crate::app::models::user::{SessionUser, UserRole};
use crate::app::server_functions::saml_auth::{create_saml_config, get_saml_institutions};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;

#[component]
pub fn Dashboard() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/dashboard">
            <DashboardContent />
        </ServerAuthGuard>
    }
}

#[component]
fn DashboardContent() -> impl IntoView {
    let (selected_view, set_selected_view) = signal(SidebarSelected::Overview);
    let location = use_location();

    Effect::new(move |_| {
        let path = location.pathname.get();
        if path.starts_with("/dashboard") {
            set_selected_view(SidebarSelected::Overview);
        } else if path.starts_with("/studentview") {
            set_selected_view(SidebarSelected::StudentView);
        } else if path.starts_with("/teachers") {
            set_selected_view(SidebarSelected::TeacherView);
        }
    });

    view! {
        <div class="bg-[#F9F9F8] h-full">
            <Header />
            <div class="flex h-full">
                <DashboardSidebar
                    selected_item=selected_view
                    set_selected_item=set_selected_view
                />
                <main class="flex-1 ml-20 px-10 mt-5">
                    {move || match selected_view() {
                        SidebarSelected::Overview => view! {
                            <div>
                                <DashboardDeanonymizer />
                                <div class="flex justify-between items-center my-4">
                                    <div class="text-2xl font-bold text-[#2E3A59]">
                                        "Overview"
                                    </div>
                                    //<SamlTestButton /> this was used for testing SAML, can be
                                //moved or removed later
                                </div>
                                <div class="flex gap-4 w-full">
                                    <div class="flex-1 w-1/2">
                                        <div class="shadow-lg border-gray border-2 h-[20rem] rounded-lg">
                                            <h1 class="text-base font-bold text-xl ml-2 p-2 text-[#2E3A59]">
                                                Today
                                            </h1>
                                            <hr class="text-sm text-gray" />
                                        </div>
                                    </div>
                                    <div class="flex-1 w-1/2">
                                        <div class="shadow-lg border-gray border-2 h-[20rem] rounded-lg">
                                            <h1 class="text-base font-bold text-xl ml-2 p-2 text-[#2E3A59]">
                                                Logs
                                            </h1>
                                            <hr class="text-sm text-gray" />
                                        </div>
                                    </div>
                                </div>
                                <div class="text-2xl font-bold mt-5 ">
                                    <div class="flex-1 w-full h-[20rem] rounded-lg mt-2">
                                        <Suspense fallback=move || view! {
                                            <div class="flex justify-center items-center h-40">
                                                <svg class="animate-spin h-6 w-6 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                <span class="ml-2 text-[#2E3A59]">Loading scores...</span>
                                            </div>
                                        }>
                                            <ScoresLedger />
                                        </Suspense>
                                    </div>
                                </div>
                            </div>
                        },
                        _ => view! {
                            <div class="text-2xl font-bold text-[#2E3A59]">
                                "Admin-only content"
                            </div>
                        }
                    }}
                </main>
            </div>
        </div>
    }
}
use crate::app::components::data_processing::test_pie_chart::PieChart;
use crate::app::components::Header;
use crate::app::models::question::QuestionType;
use crate::app::models::score::Score;
use crate::app::models::student::{ESLEnum, GenderEnum, GradeEnum, Student};
use crate::app::models::test::Test;
use crate::app::server_functions::questions::get_questions;
use crate::app::server_functions::scores::get_score;
use crate::app::server_functions::students::get_student;
use crate::app::server_functions::tests::get_test;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;

#[derive(Clone, PartialEq)]
enum ReviewTab {
    Detailed,
    Grid,
}

#[component]
pub fn ReviewTest() -> impl IntoView {
    let params = use_params_map();
    let test_id = move || params().get("test_id").cloned().unwrap_or_default();
    let student_id = move || {
        params()
            .get("student_id")
            .cloned()
            .unwrap_or_default()
            .parse::<i32>()
            .unwrap()
    };
    let test_variant = move || {
        params()
            .get("test_variant")
            .cloned()
            .unwrap_or_default()
            .parse::<i32>()
            .unwrap()
    };
    let attempt = move || {
        params()
            .get("attempt")
            .cloned()
            .unwrap_or_default()
            .parse::<i32>()
            .unwrap()
    };

    // Active tab state
    let (active_tab, set_active_tab) = signal(ReviewTab::Detailed);

    //Create resources for fetching score, test, and questions
    let score = Resource::new(
        move || (student_id(), test_id(), test_variant(), attempt()),
        |(student_id, test_id, test_variant, attempt)| async move {
            match get_score(student_id, test_id, test_variant, attempt).await {
                Ok(score) => Ok(score),
                Err(e) => {
                    log::error!("Failed to load score: {}", e);
                    Err(ServerFnError::new("Failed to load score"))
                }
            }
        },
    );
    let test = Resource::new(
        move || test_id(),
        |test_id| async move {
            match get_test(test_id).await {
                Ok(test) => Ok(test),
                Err(e) => {
                    log::error!("Failed to load test: {}", e);
                    Err(ServerFnError::new("Failed to load test"))
                }
            }
        },
    );
    let questions = Resource::new(
        move || test_id(),
        |test_id| async move {
            match get_questions(test_id).await {
                Ok(questions) => questions,
                Err(e) => {
                    log::error!("Failed to fetch questions: {}", e);
                    Vec::new()
                }
            }
        },
    );
    let student = Resource::new(
        move || student_id(),
        |student_id| async move {
            match get_student(student_id).await {
                Ok(student) => student,
                Err(e) => {
                    log::error!("Failed to fetch student: {}", e);
                    Student::new(
                        Some(String::from("Unknown")),
                        Some(String::from("Student")),
                        String::new(),
                        GenderEnum::Male,
                        chrono::NaiveDate::from_ymd_opt(2000, 1, 1).unwrap(),
                        0,
                        ESLEnum::NotApplicable,
                        crate::app::models::student::GradeEnum::First,
                        String::new(),
                        false,
                        false,
                        false,
                        false,
                        false,
                        None,
                        false,
                        String::new(),
                        Some(0),
                    )
                }
            }
        },
    );

    // Signal to determine if all questions are true/false
    let all_true_false = Memo::new(move |_| {
        questions
            .get()
            .map(|qs| {
                !qs.is_empty()
                    && qs
                        .iter()
                        .all(|q| q.question_type == QuestionType::TrueFalse)
            })
            .unwrap_or(false)
    });

    view! {
        <Header />
        <div class="flex h-full">
            <main class="flex-1 px-8 py-6 bg-gray-50 min-h-screen">
                // Header section with test info
                <div class="mb-8">
                    {move || {
                        test.get().map(|test_result| {
                            match test_result {
                                Ok(test) => {
                                    view! {
                                        <div class="mt-2 flex justify-between items-center">
                                            <div>
                                                <h1 class="text-3xl font-bold text-gray-900">{&test.name}</h1>
                                                {move || {
                                                    student.get().map(|student_data| {
                                                        let firstname = match &student_data.firstname {
                                                            Some(name) => name.clone(),
                                                            None => "Unknown".to_string(),
                                                        };
                                                        let lastname = match &student_data.lastname {
                                                            Some(name) => name.clone(),
                                                            None => "Student".to_string(),
                                                        };
                                                        view! {
                                                            <p class="text-gray-600">
                                                                Student: {firstname}{" "}{lastname}
                                                            </p>
                                                        }
                                                    })
                                                }}
                                                <p class="text-gray-600">Test Type: {test.testarea.to_string()}</p>
                                                {match &test.school_year {
                                                    Some(year) => view! { <p class="text-gray-600">School Year: {year}</p> },
                                                    None => view! { <p class="text-gray-600">School Year: Not specified</p> }
                                                }}
                                            </div>
                                            <div class="bg-white shadow rounded-lg p-4 text-center">
                                                <p class="text-sm text-gray-500">Test Variant</p>
                                                <p class="text-2xl font-semibold">{test.test_variant}</p>
                                            </div>
                                        </div>
                                    }
                                },
                                Err(_) => {
                                    view! { <div class="bg-red-50 p-4 rounded-md">
                                        <p class="text-red-700">Failed to load test information.</p>
                                    </div> }
                                }
                            }
                        })
                    }}
                </div>

                // Score summary card
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="bg-white shadow rounded-lg p-6">
                        {move || {
                            score.get().map(|score_result| {
                                match score_result {
                                    Ok(score) => {
                                        // Calculate total correct answers
                                        let total_correct = Memo::new(move |_| {
                                            if let Some(qs) = questions.get() {
                                                qs.iter().enumerate().filter(|(i, q)| {
                                                    *i < score.test_scores.len() && score.test_scores[*i] == q.point_value
                                                }).count() as i32
                                            } else {
                                                0
                                            }
                                        });

                                        let total_possible = move || {
                                            questions.get().map(|q| q.len()).unwrap_or(0) as i32
                                        };

                                        let percentage = move || {
                                            let total = total_possible();
                                            if total > 0 {
                                                (total_correct.get() as f32 / total as f32) * 100.0
                                            } else {
                                                0.0
                                            }
                                        };

                                        view! {
                                            <div class="grid grid-cols-3 gap-6">
                                                <div class="border-r pr-6">
                                                    <h3 class="text-sm font-medium text-gray-500">Student ID</h3>
                                                    <p class="text-2xl font-semibold">{score.student_id}</p>
                                                </div>
                                                <div class="border-r px-6">
                                                    <h3 class="text-sm font-medium text-gray-500">Date Administered</h3>
                                                    <p class="text-2xl font-semibold">{score.date_administered.format("%b %d, %Y").to_string()}</p>
                                                </div>
                                                <div class="pl-6">
                                                    <h3 class="text-sm font-medium text-gray-500">Evaluator</h3>
                                                    <p class="text-2xl font-semibold">{&score.evaluator}</p>
                                                </div>
                                            </div>
                                            <div class="mt-6 pt-6 border-t">
                                                <div class="flex justify-between items-end">
                                                    <div>
                                                        <h3 class="text-sm font-medium text-gray-500">Total Score</h3>
                                                        <div class="flex items-baseline">
                                                            <p class="text-3xl font-bold text-indigo-600">{move || total_correct.get()}</p>
                                                            <p class="ml-2 text-lg text-gray-500">/ {total_possible}</p>
                                                        </div>
                                                    </div>
                                                    <div class="bg-indigo-50 px-4 py-2 rounded-md">
                                                        <p class="text-indigo-700 text-xl font-semibold">{move || format!("{:.1}%", percentage())}</p>
                                                    </div>
                                                </div>
                                                <div class="mt-4 w-full bg-gray-200 rounded-full h-2.5">
                                                    <div class="bg-indigo-600 h-2.5 rounded-full" style={move || format!("width: {}%", percentage())}></div>
                                                </div>
                                            </div>
                                        }.into_any()
                                    },
                                    Err(_) => {
                                        view! {
                                            <div class="bg-red-50 p-4 rounded-md">
                                                <p class="text-red-700">Failed to load score information.</p>
                                            </div>
                                        }.into_any()
                                    }
                                }
                            })
                        }}
                    </div>

                    <div>
                        {move || {
                            match (score.get(), test.get()) {
                                (Some(Ok(score_data)), Some(Ok(test_data))) => {
                                    let total_possible = test_data.score;
                                    view! {
                                        <PieChart
                                            score=score_data.clone()
                                            test=test_data.clone()
                                        />
                                    }.into_any()
                                },
                                _ => {
                                    view! {
                                        <div class="bg-white shadow rounded-lg p-6 h-64 flex items-center justify-center">
                                            <p class="text-gray-500">Loading chart...</p>
                                        </div>
                                    }.into_any()
                                }
                            }
                        }}
                    </div>
                </div>

                // Tab selection - Only show Grid tab if all questions are true/false
                <div class="border-b border-gray-200 mb-6">
                    <nav class="-mb-px flex space-x-6">
                        {
                            let detailed_tab_class = move || {
                                let base = "py-4 px-1 border-b-2 font-medium text-sm";
                                if active_tab.get() == ReviewTab::Detailed {
                                    format!("{} border-indigo-500 text-indigo-600", base)
                                } else {
                                    format!("{} border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300", base)
                                }
                            };

                            let grid_tab_class = move || {
                                let base = "py-4 px-1 border-b-2 font-medium text-sm";
                                if active_tab.get() == ReviewTab::Grid {
                                    format!("{} border-indigo-500 text-indigo-600", base)
                                } else {
                                    format!("{} border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300", base)
                                }
                            };

                            view! {
                                <div class="border-b border-gray-200 mb-6">
                                    <nav class="-mb-px flex space-x-6">
                                        <button
                                            class=detailed_tab_class
                                            on:click=move |_| set_active_tab.set(ReviewTab::Detailed)
                                        >
                                            "Detailed View"
                                        </button>

                                        // Only show Grid tab if all questions are true/false
                                        {move || {
                                            if all_true_false.get() {
                                                view! {
                                                    <button
                                                        class=grid_tab_class
                                                        on:click=move |_| set_active_tab.set(ReviewTab::Grid)
                                                    >
                                                        "Grid View"
                                                    </button>
                                                }.into_any()
                                            } else {
                                                view! {}.into_any()
                                            }
                                        }}
                                    </nav>
                                </div>
                            }
                        }

                        // Only show Grid tab if all questions are true/false
                        {move || {
                            if all_true_false.get() {
                                view! {
                                    <button
                                        class="py-4 px-1 border-b-2 font-medium text-sm"
                                        class=border-indigo-500=move || active_tab.get() == ReviewTab::Grid
                                        class=text-indigo-600=move || active_tab.get() == ReviewTab::Grid
                                        class=border-transparent=move || active_tab.get() != ReviewTab::Grid
                                        class=text-gray-500=move || active_tab.get() != ReviewTab::Grid
                                        class=hover:text-gray-700=move || active_tab.get() != ReviewTab::Grid
                                        class=hover:border-gray-300=move || active_tab.get() != ReviewTab::Grid
                                        on:click=move |_| set_active_tab.set(ReviewTab::Grid)
                                    >
                                        "Grid View"
                                    </button>
                                }.into_any()
                            } else {
                                view! {}.into_any()
                            }
                        }}
                    </nav>
                </div>

                // Content based on selected tab
                {move || {
                    match active_tab.get() {
                        ReviewTab::Detailed => view! {
                            <DetailedView
                                questions=questions.clone()
                                score=score.clone()
                            />
                        }.into_any(),
                        ReviewTab::Grid => view! {
                            <GridView
                                questions=questions.clone()
                                score=score.clone()
                            />
                        }.into_any()
                    }
                }}
            </main>
        </div>
    }
}

// Separate component for the detailed view (original content)
#[component]
fn DetailedView(
    questions: Resource<String, Vec<crate::app::models::question::Question>>,
    score: Resource<(i32, String, i32, i32), Result<Score, ServerFnError>>,
) -> impl IntoView {
    view! {
        <div class="bg-white shadow rounded-lg p-6">
            <h2 class="text-xl font-semibold mb-4">Question Breakdown</h2>

            {move || {
                score.get().map(|score_result| {
                    questions.get().map(|questions_data| {
                        match score_result {
                            Ok(score) => {
                                view! {
                                    <div class="space-y-6">
                                        {questions_data.iter().enumerate().map(|(i, question)| {
                                            let student_answer = if i < score.test_scores.len() {
                                                score.test_scores[i]
                                            } else {
                                                0
                                            };

                                            let student_comment = if i < score.comments.len() {
                                                score.comments[i].clone()
                                            } else {
                                                String::new()
                                            };

                                            // Fixed: A student answer is correct if it equals the point value
                                            let is_correct = student_answer == question.point_value;

                                            view! {
                                                <div class="border rounded-lg overflow-hidden">
                                                    <div class={"flex items-center justify-between p-4 border-b ".to_string() + if is_correct { "bg-green-50" } else { "bg-red-50" }}>
                                                        <div class="flex items-center">
                                                            <span class={"flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ".to_string() +
                                                                if is_correct { "bg-green-100 text-green-600" } else { "bg-red-100 text-red-600" }}>
                                                                {if is_correct { "âœ“" } else { "âœ—" }}
                                                            </span>
                                                            <span class="ml-3 font-medium">Question {question.qnumber}: {&question.word_problem}</span>
                                                        </div>
                                                        <div class="flex items-baseline">
                                                            <span class={"font-semibold ".to_string() + if is_correct { "text-green-600" } else { "text-red-600" }}>
                                                                {student_answer}
                                                            </span>
                                                            <span class="text-gray-500 ml-1">/ {question.point_value}</span>
                                                        </div>
                                                    </div>

                                                    <div class="p-4 bg-white">
                                                        <div class="grid grid-cols-2 gap-4">
                                                            <div>
                                                                <h4 class="text-sm font-medium text-gray-500 mb-2">Question Type</h4>
                                                                <p>{question.question_type.to_string()}</p>
                                                            </div>
                                                            <div>
                                                                <h4 class="text-sm font-medium text-gray-500 mb-2">Correct Answer</h4>
                                                                <p>{&question.correct_answer}</p>
                                                            </div>
                                                        </div>

                                                        {if !question.options.is_empty() {
                                                            view! {
                                                                <div class="mt-4">
                                                                    <h4 class="text-sm font-medium text-gray-500 mb-2">Options</h4>
                                                                    <div class="grid grid-cols-2 gap-2">
                                                                        {question.options.iter().enumerate().map(|(j, option)| {
                                                                            let is_correct_option = *option == question.correct_answer;
                                                                            view! {
                                                                                <div class={"p-2 rounded ".to_string() +
                                                                                    if is_correct_option { "bg-green-100 border border-green-200" }
                                                                                    else { "bg-gray-50 border border-gray-200" }}>
                                                                                    {option}
                                                                                </div>
                                                                            }
                                                                        }).collect::<Vec<_>>()}
                                                                    </div>
                                                                </div>
                                                            }
                                                        } else {
                                                            view! { <div></div> }
                                                        }}

                                                        {if !student_comment.is_empty() {
                                                            view! {
                                                                <div class="mt-4">
                                                                    <h4 class="text-sm font-medium text-gray-500 mb-2">Evaluator Comment</h4>
                                                                    <p class="bg-gray-50 p-3 rounded border border-gray-200">{student_comment}</p>
                                                                </div>
                                                            }
                                                        } else {
                                                            view! { <div></div> }
                                                        }}
                                                    </div>
                                                </div>
                                            }
                                        }).collect::<Vec<_>>()}
                                    </div>
                                }
                            },
                            Err(_) => {
                                view! { <div class="bg-red-50 p-4 rounded-md">
                                    <p class="text-red-700">Failed to load score data.</p>
                                </div> }
                            }
                        }
                    })
                })
            }}
        </div>
    }
}

// New component for grid view
#[component]
fn GridView(
    questions: Resource<String, Vec<crate::app::models::question::Question>>,
    score: Resource<(i32, String, i32, i32), Result<Score, ServerFnError>>,
) -> impl IntoView {
    // Calculate square grid dimensions
    let grid_dimensions = Memo::new(move |_| {
        if let Some(questions_list) = questions.get() {
            let count = questions_list.len();
            if count == 0 {
                return (0, 0);
            }

            // Calculate dimensions for a perfect square grid
            let sqrt = (count as f64).sqrt().ceil() as usize;

            // Make sure grid is square - use same value for rows and columns
            (sqrt, sqrt)
        } else {
            (0, 0)
        }
    });

    // Calculate cell size based on question count
    let cell_size_class = Memo::new(move |_| {
        if let Some(questions_list) = questions.get() {
            let count = questions_list.len();
            // Determine appropriate cell size based on question count
            if count > 100 {
                "text-xl" // Extremely small text for very many questions
            } else if count > 64 {
                "text-2xl" // Very small text for many questions
            } else if count > 36 {
                "text-2xl" // Small text for lots of questions
            } else if count > 16 {
                "text-3xl" // Normal text for medium count
            } else if count > 9 {
                "text-3xl" // Larger text for few questions
            } else {
                "text-4xl" // Very large text for very few questions
            }
        } else {
            "text-lg" // Default size
        }
    });

    // Currently selected question for details
    let (selected_question, set_selected_question) = signal(None::<i32>);

    view! {
        <div class="bg-white shadow rounded-lg p-6">
            <h2 class="text-xl font-semibold mb-4">Grid View</h2>

            <div class="flex flex-col h-full">
                <div class="flex-grow flex items-center justify-center p-4 overflow-hidden">
                    <div class="aspect-square w-full max-w-4xl bg-white rounded shadow-inner">
                        {move || {
                            let (rows, cols) = grid_dimensions();

                            view! {
                                <div
                                    class="grid h-full w-full"
                                    style=move || format!(
                                        "grid-template-columns: repeat({}, minmax(0, 1fr)); grid-template-rows: repeat({}, minmax(0, 1fr)); gap: 1px; background-color: #e5e7eb;",
                                        cols, rows
                                    )
                                >
                                    {move || {
                                        match (questions.get(), score.get()) {
                                            (Some(questions_data), Some(Ok(score_data))) => {
                                                let mut sorted_questions = questions_data.clone();
                                                sorted_questions.sort_by_key(|q| q.qnumber);

                                                sorted_questions.iter().enumerate().map(|(i, question)| {
                                                    let qnumber = question.qnumber;
                                                    let display_text = question.word_problem.clone();

                                                    let student_answer = if i < score_data.test_scores.len() {
                                                        score_data.test_scores[i]
                                                    } else {
                                                        0
                                                    };

                                                    // Fixed: A student answer is correct if it equals the point value
                                                    let is_correct = student_answer == question.point_value;
                                                    let is_selected = Memo::new(move |_| {
                                                        selected_question.get() == Some(qnumber)
                                                    });

                                                    let current_cell_size = cell_size_class();

                                                    view! {
                                                        {
                                                            let grid_cell_class = move || {
                                                                let mut classes = vec!["flex items-center justify-center cursor-pointer transition-all relative"];

                                                                if is_correct {
                                                                    classes.push("bg-green-100");
                                                                } else {
                                                                    classes.push("bg-red-100");
                                                                }

                                                                if is_selected() {
                                                                    classes.extend(&["ring-2", "ring-blue-500"]);
                                                                }

                                                                classes.join(" ")
                                                            };

                                                            view! {
                                                                <div
                                                                    class=grid_cell_class
                                                                    on:click=move |_| {
                                                                        if selected_question.get() == Some(qnumber) {
                                                                            set_selected_question.set(None);
                                                                        } else {
                                                                            set_selected_question.set(Some(qnumber));
                                                                        }
                                                                    }
                                                                >
                                                                    <span class=format!("select-none font-bold {} px-0.5 py-0.5 text-center", current_cell_size)>{display_text}</span>
                                                                    {move || if !is_correct {
                                                                        view! {
                                                                            <span class="absolute top-0 right-0 text-xs bg-red-500 text-white rounded-full w-3 h-3 flex items-center justify-center">
                                                                                "Ã—"
                                                                            </span>
                                                                        }.into_any()
                                                                    } else {
                                                                        view! { <span></span> }.into_any()
                                                                    }}
                                                                </div>
                                                            }
                                                        }
                                                    }
                                                }).collect_view()
                                            },
                                            _ => view! { <div>Loading...</div> }.into_any()
                                        }
                                    }}
                                </div>
                            }
                        }}
                    </div>
                </div>

                // Selected question details
                <div class="mt-6 border-t pt-6">
                    {move || {
                        match (questions.get(), score.get(), selected_question.get()) {
                            (Some(questions_data), Some(Ok(score_data)), Some(qnumber)) => {
                                // Find the relevant question and score data
                                let question = questions_data.iter().find(|q| q.qnumber == qnumber);

                                match question {
                                    Some(q) => {
                                        // Find the index of this question to map to score
                                        let index = questions_data.iter().position(|quest| quest.qnumber == qnumber).unwrap_or(0);

                                        let student_answer = if index < score_data.test_scores.len() {
                                            score_data.test_scores[index]
                                        } else {
                                            0
                                        };

                                        let student_comment = if index < score_data.comments.len() {
                                            score_data.comments[index].clone()
                                        } else {
                                            String::new()
                                        };

                                        // Fixed: A student answer is correct if it equals the point value
                                        let is_correct = student_answer == q.point_value;

                                        view! {
                                            <div class="bg-gray-100 rounded-lg p-4">
                                                <h3 class="text-lg font-semibold mb-2">Question {q.qnumber}: {&q.word_problem}</h3>
                                                <div class="grid grid-cols-2 gap-4 mb-3">
                                                    <div>
                                                        <h4 class="text-sm font-medium text-gray-500 mb-1">Correct Answer</h4>
                                                        <p>{&q.correct_answer}</p>
                                                    </div>
                                                    <div>
                                                        <h4 class="text-sm font-medium text-gray-500 mb-1">"Student's Result"</h4>
                                                        <p class=if is_correct { "text-green-600 font-semibold" } else { "text-red-600 font-semibold" }>
                                                            {if is_correct { "Correct" } else { "Incorrect" }}
                                                        </p>
                                                    </div>
                                                </div>

                                                {if !student_comment.is_empty() {
                                                    view! {
                                                        <div>
                                                            <h4 class="text-sm font-medium text-gray-500 mb-1">Evaluator Comment</h4>
                                                            <p class="bg-white p-3 rounded border">{student_comment}</p>
                                                        </div>
                                                    }.into_any()
                                                } else {
                                                    view! {}.into_any()
                                                }}
                                            </div>
                                        }.into_any()
                                    },
                                    None => view! {
                                        <div class="text-gray-500 italic">Question not found.</div>
                                    }.into_any()
                                }
                            },
                            (_, _, Some(_)) => view! {
                                <div class="text-gray-500 italic">Loading question details...</div>
                            }.into_any(),
                            _ => view! {
                                <div class="text-gray-500 italic">Click on any grid cell to view question details.</div>
                            }.into_any()
                        }
                    }}
                </div>
            </div>
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::test_components::select_test_modal::SelectTestModal;
use crate::app::components::{Header, MathTestDisplay, Toast, ToastMessage, ToastMessageType};
use crate::app::models::test::CreateNewTestRequest;
use crate::app::models::{DeleteTestRequest, Test, TestType};
use crate::app::server_functions::questions::duplicate_and_randomize_questions;
use crate::app::server_functions::{
    get_tests,
    tests::{add_test, delete_test},
};
use leptos::callback::*;
use leptos::ev;
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::hooks::use_navigate;
use leptos_router::path;
use std::rc::Rc;

// =============================================================================
// TYPES AND ENUMS
// =============================================================================

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum TestFilter {
    All,
    Math,
    Reading,
    Spelling,
    PhonemicAwareness,
    Other,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ViewMode {
    Cards,   // Your existing card view
    Table,   // New dense table view
    Compact, // Ultra-compact list
}

#[derive(Debug, Clone, PartialEq)]
pub struct TestGroup {
    pub base_test: Test,
    pub variations: Vec<Test>,
    pub is_expanded: bool,
}

// =============================================================================
// STYLES CONSTANTS
// =============================================================================

mod styles {
    pub const PRIMARY_BUTTON: &str = "bg-[#2E3A59] px-4 py-2 rounded-md text-white font-medium text-sm shadow-sm hover:bg-[#1f2937] transition-all focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:ring-offset-2";
    pub const SECONDARY_BUTTON: &str = "bg-white px-4 py-2 rounded-md text-gray-700 font-medium text-sm border border-gray-300 shadow-sm hover:bg-gray-50 transition-all focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2";
    pub const SECONDARY_BUTTON_ACTIVE: &str = "bg-indigo-100 px-4 py-2 rounded-md text-indigo-700 font-medium text-sm border border-[#2E3A59] shadow-sm hover:bg-indigo-50 transition-all focus:outline-none focus:ring-2 focus:ring-[#2E3A59] focus:ring-offset-2";
    pub const DANGER_BUTTON: &str = "bg-white px-4 py-2 rounded-md text-red-600 font-medium text-sm border border-gray-300 shadow-sm hover:bg-red-50 transition-all focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2";
    pub const FILTER_TAB: &str = "px-4 py-2 text-sm font-medium rounded-lg transition-all focus:outline-none focus:ring-2 focus:ring-offset-2";
    pub const SEARCH_INPUT: &str = "focus:ring-indigo-500 focus:border-indigo-500 block w-full pl-10 pr-3 text-sm border-gray-300 rounded-md h-10 border";
    pub const MODAL_BACKDROP: &str =
        "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4";
    pub const MODAL_CONTAINER: &str = "bg-white rounded-xl shadow-2xl max-w-md w-full";
    pub const CARD: &str = "bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden hover:shadow-md transition-all duration-200";
    pub const TABLE_CONTAINER: &str =
        "bg-white rounded-lg border border-gray-200 overflow-hidden shadow-sm";
    pub const TABLE_HEADER: &str = "bg-gray-50 border-b border-gray-200";
    pub const TABLE_ROW: &str = "border-b border-gray-100 hover:bg-gray-50 transition-colors";
    pub const TABLE_ROW_DELETE: &str =
        "border-b border-gray-100 hover:bg-red-50 bg-red-25 transition-colors";
    pub const TABLE_CELL: &str = "px-3 py-2 text-sm";
    pub const TABLE_HEADER_CELL: &str =
        "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider";
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

impl TestGroup {
    pub fn new(base_test: Test) -> Self {
        Self {
            base_test,
            variations: Vec::new(),
            is_expanded: false,
        }
    }

    pub fn add_variation(&mut self, variation: Test) {
        self.variations.push(variation);
    }

    pub fn total_tests(&self) -> usize {
        1 + self.variations.len()
    }

    pub fn has_variations(&self) -> bool {
        !self.variations.is_empty()
    }

    pub fn get_variation_types(&self) -> Vec<String> {
        self.variations
            .iter()
            .filter_map(|v| {
                if v.name.contains(" - ") {
                    v.name.split(" - ").nth(1).map(|s| s.to_string())
                } else {
                    None
                }
            })
            .collect()
    }
}

fn get_test_type_styling(test_type: &TestType) -> (&'static str, &'static str) {
    match test_type {
        TestType::Math => ("bg-green-100 text-green-800 border-green-200", "Math"),
        TestType::Reading => ("bg-purple-100 text-purple-800 border-purple-200", "Reading"),
        TestType::PhonemicAwareness => (
            "bg-yellow-100 text-yellow-800 border-yellow-200",
            "Phonemic Awareness",
        ),
        TestType::Spelling => (
            "bg-orange-100 text-orange-800 border-orange-200",
            "Spelling",
        ),
        TestType::Other => ("bg-gray-100 text-gray-800 border-gray-200", "Other"),
    }
}

fn get_variation_styling(variation_name: &str) -> (&'static str, &'static str) {
    let name_lower = variation_name.to_lowercase();
    match name_lower.as_str() {
        name if name.contains("randomized") => {
            ("bg-blue-100 text-blue-800 border-blue-300", "Randomized")
        }
        name if name.contains("distinct") => {
            ("bg-green-100 text-green-800 border-green-300", "Distinct")
        }
        name if name.contains("practice") => (
            "bg-purple-100 text-purple-800 border-purple-300",
            "Practice",
        ),
        _ => ("bg-gray-100 text-gray-800 border-gray-300", "Standard"),
    }
}

fn is_variation_test(test: &Test) -> bool {
    test.name.contains(" - ")
        && (test.name.to_lowercase().contains("randomized")
            || test.name.to_lowercase().contains("distinct")
            || test.name.to_lowercase().contains("practice")
            || test.comments.to_lowercase().contains("variation:"))
}

async fn get_next_variant_number_for_base(base_test_name: &str) -> Result<i32, ServerFnError> {
    let all_tests = get_tests().await?;

    // Find all tests related to this base test
    let related_tests: Vec<&Test> = all_tests
        .iter()
        .filter(|test| {
            let test_base_name = if test.name.contains(" - ") {
                test.name.split(" - ").next().unwrap_or(&test.name)
            } else {
                &test.name
            };
            test_base_name == base_test_name
        })
        .collect();

    // Find the highest variant number
    let max_variant = related_tests
        .iter()
        .map(|test| test.test_variant)
        .max()
        .unwrap_or(0);

    Ok(max_variant + 1)
}

// =============================================================================
// COMPONENT FRAGMENTS
// =============================================================================

#[component]
fn StatsPanel(
    test_stats: Memo<(usize, usize, usize, usize, usize, usize, usize)>,
    show_stats: ReadSignal<bool>,
    set_show_stats: WriteSignal<bool>,
) -> impl IntoView {
    view! {
        {move || {
            if show_stats() {
                let (total, math, reading, other, spelling, phonemic, variations) = test_stats();
                view! {
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4 border border-blue-200">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-semibold text-gray-800">Test Collection Overview</h3>
                            <button
                                class="text-gray-400 hover:text-gray-600 transition-colors"
                                on:click=move |_| set_show_stats(false)
                            >
                                "Hide"
                            </button>
                        </div>
                        <div class="grid grid-cols-2 sm:grid-cols-5 gap-4">
                            <StatCard value=total label="Total Tests" color="blue" />
                            <StatCard value=math label="Math Tests" color="green" />
                            <StatCard value=reading label="Reading Tests" color="purple" />
                            <StatCard value=spelling label="Spelling Tests" color="orange" />
                            <StatCard value=phonemic label="Phonemic Awareness" color="yellow" />
                            <StatCard value=other label="Other Tests" color="gray" />
                            <StatCard value=variations label="Variations" color="red" />
                        </div>
                    </div>
                }
            } else {
                view! {
                    <div>
                        <button
                            class="flex items-center space-x-2 text-blue-600 hover:text-blue-800 transition-colors"
                            on:click=move |_| set_show_stats(true)
                        >
                            <span class="text-sm font-medium">Show Statistics</span>
                        </button>
                    </div>
                }
            }
        }}
    }
}

#[component]
fn StatCard(value: usize, label: &'static str, color: &'static str) -> impl IntoView {
    let color_class = match color {
        "blue" => "text-blue-600",
        "green" => "text-green-600",
        "purple" => "text-purple-600",
        "gray" => "text-gray-600",
        "orange" => "text-orange-600",
        "yellow" => "text-yellow-600",
        "red" => "text-red-600",
        _ => "text-gray-600",
    };

    view! {
        <div class="text-center">
            <div class=format!("text-2xl font-bold {}", color_class)>{value}</div>
            <div class="text-xs text-gray-600">{label}</div>
        </div>
    }
}

#[component]
fn FilterTabs(
    test_filter: ReadSignal<TestFilter>,
    set_test_filter: WriteSignal<TestFilter>,
) -> impl IntoView {
    view! {
        <div class="flex flex-wrap gap-2">
            <FilterTab
                filter=TestFilter::All
                label="All Tests"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="blue"
            />
            <FilterTab
                filter=TestFilter::Math
                label="Math Only"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="green"
            />
            <FilterTab
                filter=TestFilter::Reading
                label="Reading Only"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="purple"
            />
            <FilterTab
                filter=TestFilter::Spelling
                label="Spelling"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="orange"
            />
            <FilterTab
                filter=TestFilter::PhonemicAwareness
                label="Phonemic Awareness"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="yellow"
            />
            <FilterTab
                filter=TestFilter::Other
                label="Other"
                current_filter=test_filter
                set_filter=set_test_filter
                active_color="gray"
            />
        </div>
    }
}

#[component]
fn FilterTab(
    filter: TestFilter,
    label: &'static str,
    current_filter: ReadSignal<TestFilter>,
    set_filter: WriteSignal<TestFilter>,
    active_color: &'static str,
) -> impl IntoView {
    let active_class = match active_color {
        "blue" => "bg-blue-100 text-blue-700 border border-blue-300",
        "green" => "bg-green-100 text-green-700 border border-green-300",
        "purple" => "bg-purple-100 text-purple-700 border border-purple-300",
        "gray" => "bg-gray-100 text-gray-700 border border-gray-300",
        "orange" => "bg-orange-100 text-orange-700 border border-orange-300",
        "yellow" => "bg-yellow-100 text-yellow-700 border border-yellow-300",
        "red" => "bg-red-100 text-red-700 border border-red-300",
        _ => "bg-blue-100 text-blue-700 border border-blue-300",
    };

    view! {
        <button
            class=move || {
                let base_style = styles::FILTER_TAB;
                if current_filter() == filter {
                    format!("{} {}", base_style, active_class)
                } else {
                    format!("{} bg-white text-gray-600 border border-gray-300 hover:bg-gray-50", base_style)
                }
            }
            on:click=move |_| set_filter(filter)
        >
            <span>{label}</span>
        </button>
    }
}

#[component]
fn SearchBar(
    search_term: ReadSignal<String>,
    set_search_term: WriteSignal<String>,
) -> impl IntoView {
    view! {
        <div class="relative flex-1 max-w-md">
            <input
                type="text"
                class=styles::SEARCH_INPUT
                placeholder="Search tests and variations..."
                prop:value=move || search_term()
                on:input=move |ev| set_search_term(event_target_value(&ev))
            />
        </div>
    }
}

#[component]
fn ActionButtons(
    if_show_edit: ReadSignal<bool>,
    if_show_delete: ReadSignal<bool>,
    view_mode: ReadSignal<ViewMode>,
    set_view_mode: WriteSignal<ViewMode>,
    on_click_add: impl Fn(ev::MouseEvent) + 'static + Clone,
    on_click_delete_mode: impl Fn(ev::MouseEvent) + 'static + Clone,
) -> impl IntoView {
    view! {
        <div class="grid grid-cols-2 items-center w-full gap-3">

            // Center section - view mode toggle on desktop
            <div class="sm:flex justify-end mr-10">
                <div class="flex items-center space-x-1 bg-gray-100 rounded-lg p-1">
                    <button
                        class=move || {
                            if view_mode() == ViewMode::Cards {
                                "px-3 py-1.5 text-sm font-medium bg-white text-gray-900 rounded-md shadow-sm"
                            } else {
                                "px-3 py-1.5 text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors"
                            }
                        }
                        on:click=move |_| set_view_mode(ViewMode::Cards)
                    >
                        "Cards"
                    </button>

                    <button
                        class=move || {
                            if view_mode() == ViewMode::Table {
                                "px-3 py-1.5 text-sm font-medium bg-white text-gray-900 rounded-md shadow-sm"
                            } else {
                                "px-3 py-1.5 text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors"
                            }
                        }
                        on:click=move |_| set_view_mode(ViewMode::Table)
                    >
                        "Table"
                    </button>

                    <button
                        class=move || {
                            if view_mode() == ViewMode::Compact {
                                "px-3 py-1.5 text-sm font-medium bg-white text-gray-900 rounded-md shadow-sm"
                            } else {
                                "px-3 py-1.5 text-sm font-medium text-gray-600 hover:text-gray-900 transition-colors"
                            }
                        }
                        on:click=move |_| set_view_mode(ViewMode::Compact)
                    >
                        "Compact"
                    </button>
                </div>
            </div>

            // Right section - action buttons
            <div class="flex space-x-2 justify-end col-span-2 sm:col-span-1">
                <button on:click=on_click_add class=styles::PRIMARY_BUTTON>
                    "New Test"
                </button>

                <button
                    class="px-4 py-2 bg-purple-600 text-white rounded-md font-medium text-sm shadow-sm hover:bg-purple-700 transition-all focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2"
                    on:click=move |_| {
                        let navigate = use_navigate();
                        navigate("/test-variations", Default::default());
                    }
                >
                    "Manage Variations"
                </button>

                <button
                    on:click=on_click_delete_mode
                    class=move || {
                        if if_show_delete() {
                            "px-4 py-2 bg-red-600 text-white rounded-md font-medium text-sm shadow-sm hover:bg-red-700 transition-all focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
                        } else {
                            styles::DANGER_BUTTON
                        }
                    }
                    title=move || {
                        if if_show_delete() {
                            "Exit Delete Mode - Click to stop deleting"
                        } else {
                            "Enter Delete Mode - Show delete buttons"
                        }
                    }
                >
                    {move || {
                        if if_show_delete() {
                            "ðŸ—‘ï¸ Exit Delete Mode"
                        } else {
                            "Delete Mode"
                        }
                    }}
                </button>
            </div>
        </div>
    }
}

#[component]
fn EmptyState(
    test_filter: ReadSignal<TestFilter>,
    on_click_add: impl Fn(ev::MouseEvent) + 'static,
) -> impl IntoView {
    view! {
        <div class="text-center py-12">
            <h3 class="mt-4 text-lg font-medium text-gray-900">No tests found</h3>
            <p class="mt-2 text-sm text-gray-500">
                {move || match test_filter() {
                    TestFilter::All => "Get started by creating your first test.",
                    TestFilter::Math => "No math tests found. Create a new math test to get started.",
                    TestFilter::Reading => "No reading tests found. Create a new reading test to get started.",
                    TestFilter::Spelling => "No spelling tests found. Create a new spelling test to get started.",
                    TestFilter::PhonemicAwareness => "No phonemic awareness tests found. Create a new test to get started.",
                    TestFilter::Other => "No other tests found. Create a new test to get started.",
                }}
            </p>
            <div class="mt-6">
                <button on:click=on_click_add class=styles::PRIMARY_BUTTON>
                    "Create Your First Test"
                </button>
            </div>
        </div>
    }
}

#[component]
fn TestGroupCard(
    group: TestGroup,
    expanded_groups: ReadSignal<std::collections::HashSet<String>>,
    if_show_delete: ReadSignal<bool>,
    on_delete_test: Callback<String>,
    on_create_variation: Callback<Test>,
    toggle_group_expansion: impl Fn(String) + 'static + Clone,
) -> impl IntoView {
    let base_test = group.base_test.clone();
    let variations = group.variations.clone();
    let base_name = base_test.name.clone();
    let base_name_for_memo = base_name.clone();
    let has_variations = group.has_variations();

    let is_expanded = Memo::new(move |_| expanded_groups().contains(&base_name_for_memo));

    let (test_type_badge_class, test_type_label) = get_test_type_styling(&base_test.testarea);

    view! {
        <div class=move || {
            let base_class = "bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden hover:shadow-md transition-all duration-200";
            if if_show_delete() {
                format!("{} ring-2 ring-red-200", base_class)
            } else {
                base_class.to_string()
            }
        }>
            // Base test header
            <div class=move || {
                let base_class = "bg-gradient-to-r from-gray-50 to-gray-100 px-6 py-5 border-b border-gray-200";
                if if_show_delete() {
                    format!("{} bg-red-50 border-red-200", base_class)
                } else {
                    base_class.to_string()
                }
            }>
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="flex items-center space-x-3 mb-2">
                            <h3 class="text-xl font-semibold text-gray-900">{base_test.name.clone()}</h3>
                            <span class=format!("inline-flex items-center px-3 py-1 rounded-full text-xs font-medium border {}", test_type_badge_class)>
                                {test_type_label}
                            </span>
                            // Delete mode indicator
                            {move || {
                                if if_show_delete() {
                                    view! {
                                        <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800 border border-red-300">
                                            "ðŸ—‘ï¸ Delete Mode"
                                        </span>
                                    }.into_any()
                                } else {
                                    view! { <span></span> }.into_any()
                                }
                            }}
                        </div>

                        <div class="flex flex-wrap items-center gap-4 text-sm text-gray-600">
                            <div class="flex items-center space-x-1">
                                <span class="font-medium">{base_test.score} points</span>
                            </div>
                            <div class="flex items-center space-x-1">
                                <span>Grade: {base_test.grade_level.as_ref().map(|g| format!("{:?}", g)).unwrap_or("Not specified".to_string())}</span>
                            </div>
                            {if has_variations {
                                view! {
                                    <div class="flex items-center space-x-1 text-blue-600">
                                        <span>Test Variations: {variations.len()}</span>
                                    </div>
                                }
                            } else {
                                view! { <div></div> }
                            }}
                        </div>
                    </div>

                    <div class="flex items-center space-x-2">
                        <TestActionButtons test=base_test.clone() on_create_variation=Some(on_create_variation)/>
                        {if has_variations {
                            let toggle_fn = toggle_group_expansion.clone();
                            let base_name_clone = base_name.clone();
                            view! {
                                <button
                                    class="px-3 py-1 text-sm text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md transition-all duration-200 border border-gray-300"
                                    on:click=move |_| {
                                        log::info!("Toggling expansion for: {}", base_name_clone.clone());
                                        toggle_fn(base_name_clone.clone());
                                    }
                                >
                                    {move || {
                                        if is_expanded() {
                                            "â–¼ Hide Variations"
                                        } else {
                                            "â–¶ Show Variations"
                                        }
                                    }}
                                </button>
                            }.into_any()
                        } else {
                            view! { <span></span> }.into_any()
                        }}
                    </div>
                </div>
            </div>

            // Variations section
            {if has_variations {
                view! {
                    <div class=move || {
                        if is_expanded() {
                            let base_class = "p-6 bg-gray-50 border-t border-gray-200";
                            if if_show_delete() {
                                format!("{} bg-red-25", base_class)
                            } else {
                                base_class.to_string()
                            }
                        } else {
                            "hidden".to_string()
                        }
                    }>
                        <div class="flex items-center justify-between mb-4">
                            <h4 class="text-lg font-medium text-gray-900">
                                "Test Variations (" {variations.len()} ")"
                            </h4>
                            {move || {
                                if if_show_delete() {
                                    view! {
                                        <div class="text-sm text-red-600 font-medium">
                                            "âš ï¸ Click variation delete buttons below"
                                        </div>
                                    }.into_any()
                                } else {
                                    view! { <span></span> }.into_any()
                                }
                            }}
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                            <For
                                each=move || variations.clone()
                                key=|variation| variation.test_id.clone()
                                children=move |variation: Test| {
                                    view! {
                                        <VariationCard
                                            variation=variation
                                            if_show_delete=if_show_delete
                                            on_delete_test=on_delete_test
                                        />
                                    }
                                }
                            />
                        </div>
                    </div>
                }.into_any()
            } else {
                view! { <div class="hidden"></div> }.into_any()
            }}
        </div>
    }
}

#[component]
fn CompactListView(
    all_tests: Vec<Test>,
    if_show_delete: ReadSignal<bool>,
    on_delete_test: Callback<String>,
    on_create_variation: Callback<Test>,
) -> impl IntoView {
    // Group tests by base name for compact display
    let grouped_tests = Memo::new(move |_| {
        let tests = all_tests.clone();
        let mut groups: std::collections::HashMap<String, (Test, Vec<Test>)> =
            std::collections::HashMap::new();

        for test in tests {
            let base_name = if test.name.contains(" - ") {
                test.name
                    .split(" - ")
                    .next()
                    .unwrap_or(&test.name)
                    .to_string()
            } else {
                test.name.clone()
            };

            if is_variation_test(&test) {
                groups
                    .entry(base_name)
                    .and_modify(|(_, variations)| variations.push(test.clone()))
                    .or_insert((test.clone(), vec![test.clone()])); // fallback if no base test
            } else {
                groups
                    .entry(base_name.clone())
                    .and_modify(|(base, _)| *base = test.clone())
                    .or_insert((test.clone(), Vec::new()));
            }
        }

        let mut sorted_groups: Vec<(Test, Vec<Test>)> = groups.into_values().collect();
        sorted_groups.sort_by(|a, b| a.0.name.cmp(&b.0.name));
        sorted_groups
    });

    view! {
    <div class="space-y-2">
        <For
            each=move || grouped_tests()
            key=|(base_test, _)| base_test.test_id.clone()
            children=move |(base_test, variations): (Test, Vec<Test>)| {
                let (type_class, type_label) = get_test_type_styling(&base_test.testarea);
                let variation_count = variations.len();

                view! {
                    <div class=move || {
                        let base_class = "bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-sm transition-all";
                        if if_show_delete() {
                            format!("{} ring-2 ring-red-200", base_class)
                        } else {
                            base_class.to_string()
                        }
                    }>
                        // Base test row
                        <div class="flex items-center justify-between p-4 border-b border-gray-100 last:border-b-0">
                            <div class="flex items-center space-x-3 flex-1 min-w-0">
                                <span class=format!("inline-flex px-2 py-1 text-xs font-medium rounded {}", type_class)>
                                    {type_label}
                                </span>
                                <span class="font-medium text-gray-900 truncate" title=base_test.name.clone()>
                                    {base_test.name.clone()}
                                </span>
                                <span class="text-sm text-gray-500 font-mono">{base_test.score}"pts"</span>
                                {if variation_count > 0 {
                                    view! {
                                        <span class="inline-flex px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded">
                                            {variation_count}" var"
                                        </span>
                                    }.into_any()
                                } else {
                                    view! { <span></span> }.into_any()
                                }}
                                {move || {
                                    if if_show_delete() {
                                        view! {
                                            <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800 border border-red-300">
                                                "ðŸ—‘ï¸ Delete Mode"
                                            </span>
                                        }.into_any()
                                    } else {
                                        view! { <span></span> }.into_any()
                                    }
                                }}
                            </div>

                            <CompactActions
                                test=base_test.clone()
                                is_variation=false
                                if_show_delete=if_show_delete
                                on_delete_test=on_delete_test.clone()
                                on_create_variation=Some(on_create_variation.clone())
                            />
                        </div>

                        // Variations (if any)
                        {if !variations.is_empty() {
                            view! {
                                <div class=move || {
                                    if if_show_delete() {
                                        "bg-red-25"
                                    } else {
                                        "bg-gray-50"
                                    }
                                }>
                                    <For
                                        each=move || variations.clone()
                                        key=|var| var.test_id.clone()
                                        children=move |variation: Test| {
                                            let var_name = if variation.name.contains(" - ") {
                                                variation.name.split(" - ").nth(1).unwrap_or("Variation").to_string()
                                            } else {
                                                "Variation".to_string()
                                            };

                                            view! {
                                                <div class="flex items-center justify-between px-6 py-3 border-b border-gray-200 last:border-b-0">
                                                    <div class="flex items-center space-x-3">
                                                            <span class="text-sm text-gray-600" title=variation.name.clone()>{var_name}</span>
                                                            <span class="text-xs text-gray-500 font-mono">{variation.score}"pts"</span>
                                                            <span class="text-xs text-gray-500">v{variation.test_variant}</span>
                                                            {move || {
                                                                if if_show_delete() {
                                                                    view! {
                                                                        <span class="text-xs text-red-600 font-medium">
                                                                            "âš ï¸ Can delete"
                                                                        </span>
                                                                    }.into_any()
                                                                } else {
                                                                    view! { <span></span> }.into_any()
                                                                }
                                                            }}
                                                        </div>

                                                        <CompactActions
                                                            test=variation.clone()
                                                            is_variation=true
                                                            if_show_delete=if_show_delete
                                                            on_delete_test=on_delete_test.clone()
                                                            on_create_variation=None
                                                        />
                                                    </div>
                                                }
                                            }
                                        />
                                    </div>
                                }.into_any()
                            } else {
                                view! { <div></div> }.into_any()
                            }}
                        </div>
                    }
                }
            />
        </div>
    }
}

#[component]
fn DenseTableView(
    all_tests: Vec<Test>,
    if_show_delete: ReadSignal<bool>,
    on_delete_test: Callback<String>,
    on_create_variation: Callback<Test>,
) -> impl IntoView {
    // Sort tests: base tests first, then variations grouped under them
    let sorted_tests = Memo::new(move |_| {
        let tests = all_tests.clone();

        // Separate base tests and variations
        let mut base_tests: Vec<Test> = tests
            .iter()
            .filter(|t| !is_variation_test(t))
            .cloned()
            .collect();

        let variations: Vec<Test> = tests
            .iter()
            .filter(|t| is_variation_test(t))
            .cloned()
            .collect();

        // Sort base tests by name
        base_tests.sort_by(|a, b| a.name.cmp(&b.name));

        // Build final list: base test followed by its variations
        let mut final_tests = Vec::new();

        for base_test in base_tests {
            final_tests.push(base_test.clone());

            // Add variations for this base test
            let mut test_variations: Vec<Test> = variations
                .iter()
                .filter(|v| {
                    let base_name = if v.name.contains(" - ") {
                        v.name.split(" - ").next().unwrap_or(&v.name)
                    } else {
                        &v.name
                    };
                    base_name == base_test.name
                })
                .cloned()
                .collect();

            test_variations.sort_by(|a, b| a.name.cmp(&b.name));
            final_tests.extend(test_variations);
        }

        final_tests
    });

    view! {
        <div class=styles::TABLE_CONTAINER>
            // Table header
            <div class=styles::TABLE_HEADER>
                <div class="grid grid-cols-12 gap-2">
                    <div class=format!("{} col-span-4", styles::TABLE_HEADER_CELL)>"Test Name"</div>
                    <div class=format!("{} col-span-1", styles::TABLE_HEADER_CELL)>"Type"</div>
                    <div class=format!("{} col-span-1", styles::TABLE_HEADER_CELL)>"Score"</div>
                    <div class=format!("{} col-span-1", styles::TABLE_HEADER_CELL)>"Grade"</div>
                    <div class=format!("{} col-span-1", styles::TABLE_HEADER_CELL)>"Variant"</div>
                    <div class=format!("{} col-span-2", styles::TABLE_HEADER_CELL)>"Status"</div>
                    <div class=format!("{} col-span-2", styles::TABLE_HEADER_CELL)>"Actions"</div>
                </div>
            </div>

            // Table body with max height and scroll
            <div class="max-h-[600px] overflow-y-auto">
                <For
                    each=move || sorted_tests()
                    key=|test| test.test_id.clone()
                    children=move |test: Test| {
                        let is_variation = is_variation_test(&test);
                        let (test_type_class, test_type_label) = get_test_type_styling(&test.testarea);

                        // Extract variation info
                        let (display_name, _variation_type) = if is_variation {
                            if let Some(var_part) = test.name.split(" - ").nth(1) {
                                (format!("  â†³ {}", var_part), var_part.to_string())
                            } else {
                                (format!("  â†³ Variation"), "Variation".to_string())
                            }
                        } else {
                            (test.name.clone(), String::new())
                        };

                        let grade_display = test.grade_level.as_ref()
                            .map(|g| format!("{:?}", g))
                            .unwrap_or("â€”".to_string());

                        view! {
                            <div class=move || {
                                if if_show_delete() {
                                    styles::TABLE_ROW_DELETE
                                } else {
                                    styles::TABLE_ROW
                                }
                            }>
                                <div class="grid grid-cols-12 gap-2 items-center">
                                    // Test Name
                                    <div class=format!("{} col-span-4", styles::TABLE_CELL)>
                                        <div class=move || {
                                            if is_variation {
                                                "text-gray-600 text-sm pl-4"
                                            } else {
                                                "font-medium text-gray-900"
                                            }
                                        }>
                                            <span
                                                title=test.name.clone()
                                                class="truncate block"
                                            >
                                                {display_name}
                                            </span>
                                        </div>
                                    </div>

                                    // Type
                                    <div class=format!("{} col-span-1", styles::TABLE_CELL)>
                                        <span class=format!("inline-flex px-2 py-1 text-xs font-medium rounded-full {}", test_type_class)>
                                            {test_type_label}
                                        </span>
                                    </div>

                                    // Score
                                    <div class=format!("{} col-span-1 font-mono text-center", styles::TABLE_CELL)>
                                        {test.score}
                                    </div>

                                    // Grade
                                    <div class=format!("{} col-span-1 text-center", styles::TABLE_CELL)>
                                        <span class="text-xs">{grade_display}</span>
                                    </div>

                                    // Variant Number
                                    <div class=format!("{} col-span-1 font-mono text-center", styles::TABLE_CELL)>
                                        {if test.test_variant > 0 { test.test_variant.to_string() } else { "â€”".to_string() }}
                                    </div>

                                    // Status
                                    <div class=format!("{} col-span-2", styles::TABLE_CELL)>
                                        <TestStatusBadges test=test.clone() />
                                    </div>

                                    // Actions
                                    <div class=format!("{} col-span-2", styles::TABLE_CELL)>
                                        <CompactActions
                                            test=test.clone()
                                            is_variation=is_variation
                                            if_show_delete=if_show_delete
                                            on_delete_test=on_delete_test.clone()
                                            on_create_variation=if !is_variation { Some(on_create_variation.clone()) } else { None }
                                        />
                                    </div>
                                </div>
                            </div>
                        }
                    }
                />
            </div>
        </div>
    }
}

#[component]
fn CompactActions(
    test: Test,
    is_variation: bool,
    if_show_delete: ReadSignal<bool>,
    on_delete_test: Callback<String>,
    on_create_variation: Option<Callback<Test>>,
) -> impl IntoView {
    let test_id_edit = test.test_id.clone();
    let test_id_use = test.test_id.clone();
    let test_id_delete = test.test_id.clone();
    let test_for_modal = Rc::new(test.clone());
    let test_for_variation = test.clone();

    //Modal state for selecting a test
    let (show_select_test_modal, set_show_select_test_modal) = signal(false);

    view! {
        <div class="flex items-center space-x-1">
            // Edit button
            <button
                class="p-1.5 text-gray-600 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors"
                title="Edit Test"
                on:click=move |_| {
                    let navigate = use_navigate();
                    navigate(&format!("/testbuilder/{}", test_id_edit.clone()), Default::default());
                }
            >
                <span class="text-sm">"âœï¸"</span>
            </button>

            // Test button (purple button from original)
            <button
                class="p-1.5 text-gray-600 hover:text-purple-600 hover:bg-purple-50 rounded transition-colors"
                title="Test"
                on:click=move |_| set_show_select_test_modal.set(true)
            >
                <span class="text-sm">"ðŸ§ª"</span>
            </button>

            // Create variation button (only for base tests)
            {if !is_variation && on_create_variation.is_some() {
                let callback = on_create_variation.unwrap();
                let test_clone = test_for_variation.clone();
                view! {
                    <button
                        class="p-1.5 text-gray-600 hover:text-orange-600 hover:bg-orange-50 rounded transition-colors"
                        title="Create Variation"
                        on:click=move |_| Callable::call(&callback, test_clone.clone())
                    >
                        <span class="text-sm">"ðŸ“"</span>
                    </button>
                }.into_any()
            } else {
                view! { <span></span> }.into_any()
            }}

            // Delete button (only in delete mode)
            <Show
                when=move || if_show_delete()
                fallback=|| view! { <span></span> }
            >
                {
                    let delete_id = test_id_delete.clone();
                    let delete_cb = on_delete_test.clone();
                    view! {
                        <button
                            class="p-1.5 text-red-600 hover:bg-red-100 rounded transition-colors"
                            title="Delete Test"
                            on:click=move |_| Callable::call(&delete_cb, delete_id.clone())
                        >
                            <span class="text-sm">"ðŸ—‘ï¸"</span>
                        </button>
                    }
                }
            </Show>
        </div>

        // Keep the modal from original TestActionButtons
        <SelectTestModal
            test=test_for_modal
            show_modal=show_select_test_modal
            set_show_modal=set_show_select_test_modal
        />
    }
}

#[component]
fn TestStatusBadges(test: Test) -> impl IntoView {
    let is_variation = is_variation_test(&test);

    view! {
        <div class="flex items-center space-x-1">
            {if is_variation {
                let (var_class, var_label) = get_variation_styling(&test.name);
                view! {
                    <span class=format!("inline-flex px-1.5 py-0.5 text-xs rounded {}", var_class)>
                        {var_label}
                    </span>
                }.into_any()
            } else {
                view! {
                    <span class="inline-flex px-1.5 py-0.5 text-xs bg-gray-100 text-gray-800 rounded">
                        "Base"
                    </span>
                }.into_any()
            }}

            {if !test.comments.is_empty() {
                view! {
                    <span
                        class="inline-flex px-1.5 py-0.5 text-xs bg-yellow-100 text-yellow-800 rounded cursor-help"
                        title=test.comments.clone()
                    >
                        "ðŸ’¬"
                    </span>
                }.into_any()
            } else {
                view! { <span></span> }.into_any()
            }}
        </div>
    }
}

#[component]
fn VariationCard(
    variation: Test,
    if_show_delete: ReadSignal<bool>,
    on_delete_test: Callback<String>,
) -> impl IntoView {
    let variation_name = if variation.name.contains(" - ") {
        let parts: Vec<&str> = variation.name.split(" - ").collect();
        parts
            .get(1)
            .map_or("Variation".to_string(), |v| v.to_string())
    } else {
        "Variation".to_string()
    };

    let (variation_badge_class, variation_label) = get_variation_styling(&variation_name);

    // Clone all the values we need to avoid borrow checker issues
    let variation_test_id_for_delete = variation.test_id.clone();
    let variation_test_id_for_display = variation.test_id.clone();
    let variation_name_display = variation.name.clone();
    let variation_score = variation.score;
    let variation_test_variant = variation.test_variant;
    let variation_comments = variation.comments.clone();
    let variation_for_actions = variation.clone();

    view! {
        <div class="bg-white rounded-lg border border-gray-200 hover:border-gray-300 hover:shadow-sm transition-all duration-200">
            <div class="p-4">
                <div class="flex items-start justify-between mb-3">
                    <span class=format!("inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium border {}", variation_badge_class)>
                        {variation_label}
                    </span>
                    // Enhanced delete button with better visibility
                    {move || {
                        if if_show_delete() {
                            let variation_id = variation_test_id_for_delete.clone();
                            view! {
                                <button
                                    class="px-2 py-1 bg-red-100 hover:bg-red-200 text-red-700 text-xs font-medium rounded-md transition-colors border border-red-300"
                                    on:click=move |_| {
                                        log::info!("Deleting variation: {}", variation_id.clone());
                                        Callable::call(&on_delete_test, variation_id.clone());
                                    }
                                    title="Delete this variation"
                                >
                                    "ðŸ—‘ï¸ Delete"
                                </button>
                            }.into_any()
                        } else {
                            view! { <span></span> }.into_any()
                        }
                    }}
                </div>

                <div class="mb-3">
                    <h5 class="font-medium text-gray-900 text-sm mb-1">{variation_name_display}</h5>
                    <p class="text-xs text-gray-600">
                        {format!("{} points â€¢ Variant {} â€¢ ID: {}", variation_score, variation_test_variant, variation_test_id_for_display)}
                    </p>
                    {if !variation_comments.is_empty() {
                        view! {
                            <p class="text-xs text-gray-500 mt-1 line-clamp-2">{variation_comments}</p>
                        }.into_any()
                    } else {
                        view! { <span></span> }.into_any()
                    }}
                </div>

                <TestActionButtons test=variation_for_actions on_create_variation=None />
            </div>
        </div>
    }
}

#[component]
fn TestActionButtons(test: Test, on_create_variation: Option<Callback<Test>>) -> impl IntoView {
    let test_id_for_edit = test.test_id.clone();
    let test_id_for_use = test.test_id.clone();
    let test_id_for_flash = test.test_id.clone();
    let test_for_variation = test.clone();
    let test_for_modal = Rc::new(test.clone());
    let is_base_test = !is_variation_test(&test);

    //Modal state for selecting a test
    let (show_select_test_modal, set_show_select_test_modal) = signal(false);

    view! {
        <div class="flex space-x-2">
            <button
                class="flex-1 px-3 py-2 bg-blue-50 hover:bg-blue-100 text-blue-700 text-xs font-medium rounded-md transition-colors"
                on:click=move |_| {
                    let test_id = test_id_for_edit.clone();
                    let navigate = use_navigate();
                    navigate(&format!("/testbuilder/{}", test_id), Default::default());
                }
            >
                "Edit Test"
            </button>

            <button
                class="flex-1 px-3 py-2 bg-purple-50 hover:bg-purple-100 text-purple-700 text-xs font-medium rounded-md transition-colors"
                on:click=move |_| set_show_select_test_modal.set(true)
            >
                "Test"
            </button>

            {if is_base_test && on_create_variation.is_some() {
                let create_variation_callback = on_create_variation.unwrap();
                view! {
                    <button
                        class="flex-1 px-3 py-2 bg-orange-50 hover:bg-orange-100 text-orange-700 text-xs font-medium rounded-md transition-colors"
                        on:click=move |_| Callable::call(&create_variation_callback, test_for_variation.clone())
                        title="Create variation"
                    >
                        "New Variation"
                    </button>
                }.into_any()
            } else {
                view! { <span></span> }.into_any()
            }}
        </div>

        // Modal component
        <SelectTestModal
            test=test_for_modal
            show_modal=show_select_test_modal
            set_show_modal=set_show_select_test_modal
        />
    }
}

// =============================================================================
// MAIN COMPONENTS
// =============================================================================

#[component]
pub fn UnifiedTestManager() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/test-manager">
            <UnifiedTestManagerContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn UnifiedTestManagerContent() -> impl IntoView {
    let (selected_view, set_selected_view) = signal(SidebarSelected::AdministerTest);

    // State management
    let (if_show_edit, set_if_show_edit) = signal(false);
    let (if_show_delete, set_if_show_delete) = signal(false);
    let (if_show_toast, set_if_show_toast) = signal(false);
    let (toast_message, set_toast_message) = signal(ToastMessage::new());
    let (search_term, set_search_term) = signal(String::new());
    let (view_mode, set_view_mode) = signal(ViewMode::Cards);
    let (test_filter, set_test_filter) = signal(TestFilter::All);
    let (expanded_groups, set_expanded_groups) = signal(std::collections::HashSet::<String>::new());
    let (show_stats, set_show_stats) = signal(false);

    //Variation signals
    let (show_create_variation_modal, set_show_create_variation_modal) = signal(false);
    let (selected_base_test_for_variation, set_selected_base_test_for_variation) =
        create_signal::<Option<Test>>(None);
    let (variation_type, set_variation_type) = signal(String::new());
    let (is_creating_variation, set_is_creating_variation) = signal(false);

    let get_tests_info = Resource::new(|| (), |_| async move { get_tests().await });

    // Calculate statistics
    let test_stats = Memo::new(move |_| {
        let tests_result = get_tests_info.get().unwrap_or(Ok(Vec::new()));
        let tests = tests_result.unwrap_or_default();

        let total_tests = tests.len();
        let math_tests = tests
            .iter()
            .filter(|t| t.testarea == TestType::Math)
            .count();
        let reading_tests = tests
            .iter()
            .filter(|t| t.testarea == TestType::Reading)
            .count();
        let other_tests = tests
            .iter()
            .filter(|t| t.testarea == TestType::Other)
            .count();
        let variations = tests.iter().filter(|t| is_variation_test(t)).count();
        let spelling_tests = tests
            .iter()
            .filter(|t| t.testarea == TestType::Spelling)
            .count();
        let phonemic_awareness_tests = tests
            .iter()
            .filter(|t| t.testarea == TestType::PhonemicAwareness)
            .count();

        (
            total_tests,
            math_tests,
            reading_tests,
            spelling_tests,
            phonemic_awareness_tests,
            other_tests,
            variations,
        )
    });

    // Group tests and apply filters
    let test_groups = Memo::new(move |_| {
        let tests_result = get_tests_info.get().unwrap_or(Ok(Vec::new()));
        let tests = tests_result.unwrap_or_default();

        let filtered_tests: Vec<Test> = tests
            .into_iter()
            .filter(|test| match test_filter.get() {
                TestFilter::All => true,
                TestFilter::Math => test.testarea == TestType::Math,
                TestFilter::Reading => test.testarea == TestType::Reading,
                TestFilter::Spelling => test.testarea == TestType::Spelling,
                TestFilter::PhonemicAwareness => test.testarea == TestType::PhonemicAwareness,
                TestFilter::Other => test.testarea == TestType::Other,
            })
            .collect();

        let mut groups: std::collections::HashMap<String, TestGroup> =
            std::collections::HashMap::new();

        for test in filtered_tests {
            let base_name = if test.name.contains(" - ") {
                test.name
                    .split(" - ")
                    .next()
                    .unwrap_or(&test.name)
                    .to_string()
            } else {
                test.name.clone()
            };

            if is_variation_test(&test) {
                groups
                    .entry(base_name.clone())
                    .and_modify(|group| group.add_variation(test.clone()))
                    .or_insert_with(|| {
                        let mut group = TestGroup::new(test.clone());
                        group.variations.clear();
                        group.add_variation(test.clone());
                        group
                    });
            } else {
                groups
                    .entry(base_name.clone())
                    .and_modify(|group| {
                        if group.base_test.name.contains(" - ") {
                            group.base_test = test.clone();
                        }
                    })
                    .or_insert_with(|| TestGroup::new(test.clone()));
            }
        }

        let mut sorted_groups: Vec<TestGroup> = groups.into_values().collect();
        sorted_groups.sort_by(|a, b| a.base_test.name.cmp(&b.base_test.name));
        sorted_groups
    });

    // Filter based on search and view mode
    let filtered_display = Memo::new(move |_| {
        let groups = test_groups.get();
        let search = search_term.get().to_lowercase();

        let filtered_groups: Vec<TestGroup> = if search.is_empty() {
            groups
        } else {
            groups
                .into_iter()
                .filter(|group| {
                    group.base_test.name.to_lowercase().contains(&search)
                        || group
                            .variations
                            .iter()
                            .any(|v| v.name.to_lowercase().contains(&search))
                })
                .collect()
        };

        // Extract all tests for table/compact views
        let mut all_tests = Vec::new();
        for group in &filtered_groups {
            all_tests.push(group.base_test.clone());
            all_tests.extend(group.variations.clone());
        }

        // Apply test filter to all tests
        let filtered_all_tests: Vec<Test> = all_tests
            .into_iter()
            .filter(|test| match test_filter.get() {
                TestFilter::All => true,
                TestFilter::Math => test.testarea == TestType::Math,
                TestFilter::Reading => test.testarea == TestType::Reading,
                TestFilter::Spelling => test.testarea == TestType::Spelling,
                TestFilter::PhonemicAwareness => test.testarea == TestType::PhonemicAwareness,
                TestFilter::Other => test.testarea == TestType::Other,
            })
            .collect();

        (filtered_all_tests, filtered_groups)
    });

    let create_variation = move |_| {
        if let Some(base_test) = selected_base_test_for_variation.get() {
            set_is_creating_variation(true);

            let base_test_clone = base_test.clone();
            let variation_type_value = variation_type.get();

            spawn_local(async move {
                let variation_name = format!("{} - {}", base_test_clone.name, variation_type_value);
                let variation_comments = format!(
                    "Variation: {} of {}",
                    variation_type_value, base_test_clone.name
                );

                // Determine variant number based on type
                let variant_number =
                    match get_next_variant_number_for_base(&base_test_clone.name).await {
                        Ok(num) => num,
                        Err(e) => {
                            log::error!("Failed to get next variant number: {:?}", e);
                            set_toast_message("Failed to determine variant number".to_string());
                            set_if_show_toast(true);
                            set_is_creating_variation(false);
                            return;
                        }
                    };

                let create_request = CreateNewTestRequest::new(
                    variation_name,
                    base_test_clone.score,
                    base_test_clone.instructions.clone(),
                    variation_comments,
                    base_test_clone.testarea.clone(),
                    base_test_clone.school_year.clone(),
                    base_test_clone.benchmark_categories.clone(),
                    variant_number,
                    base_test_clone.grade_level.clone(),
                    base_test_clone.scope.clone(),
                    base_test_clone.course_id.clone(),
                );

                match add_test(create_request).await {
                    Ok(new_test) => {
                        match variation_type_value.to_lowercase().as_str() {
                            "randomized" => {
                                // For randomized tests, generate questions automatically
                                match duplicate_and_randomize_questions(
                                    base_test_clone.test_id.clone(),
                                    new_test.test_id.clone(),
                                )
                                .await
                                {
                                    Ok(_) => {
                                        get_tests_info.refetch();
                                        set_show_create_variation_modal(false);
                                        set_variation_type(String::new());
                                        set_selected_base_test_for_variation(None);
                                        set_toast_message(ToastMessage::create(
                                            ToastMessageType::NewTestAdded,
                                        ));
                                        set_if_show_toast(true);

                                        // Navigate to test manager to view the completed randomized test
                                        let navigate = use_navigate();
                                        navigate("/test-manager", Default::default());
                                    }
                                    Err(e) => {
                                        log::error!(
                                            "Failed to create randomized questions: {:?}",
                                            e
                                        );
                                        set_toast_message(
                                            "Failed to create randomized questions".to_string(),
                                        );
                                        set_if_show_toast(true);
                                    }
                                }
                            }
                            "distinct" | "practice" => {
                                // For distinct and practice tests, navigate to test builder to add questions
                                get_tests_info.refetch();
                                set_show_create_variation_modal(false);
                                set_variation_type(String::new());
                                set_selected_base_test_for_variation(None);
                                set_toast_message(ToastMessage::create(
                                    ToastMessageType::NewTestAdded,
                                ));
                                set_if_show_toast(true);

                                // Navigate to edit the new variation
                                let navigate = use_navigate();
                                navigate(
                                    &format!("/testbuilder/{}", new_test.test_id),
                                    Default::default(),
                                );
                            }
                            _ => {
                                log::error!("Unknown variation type: {}", variation_type_value);
                            }
                        }
                    }
                    Err(e) => {
                        log::error!("Failed to create variation: {:?}", e);
                        set_toast_message("Failed to create test variation".to_string());
                        set_if_show_toast(true);
                    }
                }

                set_is_creating_variation(false);
            });
        }
    };

    // Event handlers
    let on_click_add = move |_| {
        let navigate = use_navigate();
        navigate("/testbuilder", Default::default());
    };

    let on_click_delete_mode = move |_| {
        set_if_show_delete(!if_show_delete());
        set_if_show_edit(false);
    };

    let on_toggle_view_mode = move |_: ev::MouseEvent| match view_mode.get() {
        ViewMode::Cards => set_view_mode(ViewMode::Table),
        ViewMode::Table => set_view_mode(ViewMode::Compact),
        ViewMode::Compact => set_view_mode(ViewMode::Cards),
    };

    let on_delete_test = Callback::new(move |test_id: String| {
        spawn_local(async move {
            let delete_test_request = DeleteTestRequest::new(test_id);
            match delete_test(delete_test_request).await {
                Ok(_) => {
                    get_tests_info.refetch();
                    set_toast_message(ToastMessage::create(ToastMessageType::TestDeleted));
                    set_if_show_toast(true);
                }
                Err(e) => {
                    log::error!("Error deleting test: {:?}", e);
                    set_if_show_toast(true);
                }
            }
        });
    });

    let toggle_group_expansion = move |base_name: String| {
        set_expanded_groups.update(|expanded| {
            if expanded.contains(&base_name) {
                expanded.remove(&base_name);
            } else {
                expanded.insert(base_name);
            }
        });
    };

    let on_create_variation = Callback::new(move |test: Test| {
        set_selected_base_test_for_variation(Some(test));
        set_show_create_variation_modal(true);
    });

    view! {
        <div class="min-h-screen bg-[#F9F9F8]">
            <Header />
            <DashboardSidebar
                selected_item=selected_view
                set_selected_item=set_selected_view
            />
            <div class="ml-0 sm:ml-10 md:ml-30 transition-all duration-300 ease-in-out">
                <div class="max-w-7xl mx-auto px-3 sm:px-6 lg:px-8 py-6 sm:py-12">
                    <Toast
                        toast_message
                        if_appear=if_show_toast
                        set_if_appear=set_if_show_toast
                    />

                    // Page header
                    <div class="pb-4 sm:pb-6 border-b border-gray-200 mb-6 sm:mb-8">
                        <div class="flex flex-col space-y-4">
                            <div>
                                <h1 class="text-3xl sm:text-4xl font-bold text-[#2E3A59]">Test Manager</h1>
                                <p class="mt-2 text-sm sm:text-base text-gray-600">
                                    "Unified test management with variation support and advanced filtering"
                                </p>
                            </div>

                            <StatsPanel
                                test_stats=test_stats
                                show_stats=show_stats
                                set_show_stats=set_show_stats
                            />

                            <FilterTabs
                                test_filter=test_filter
                                set_test_filter=set_test_filter
                            />

                            <div class="flex flex-col sm:flex-row sm:items-center gap-3">
                                // Search bar with fixed width - maintains its size
                                <div class="w-full sm:w-80 flex-shrink-0">
                                    <SearchBar
                                        search_term=search_term
                                        set_search_term=set_search_term
                                    />
                                </div>

                                // Action buttons container - takes remaining space
                                <div class="flex-1 min-w-0">
                                    <ActionButtons
                                        if_show_edit=if_show_edit
                                        if_show_delete=if_show_delete
                                        view_mode=view_mode
                                        set_view_mode=set_view_mode
                                        on_click_add=on_click_add
                                        on_click_delete_mode=on_click_delete_mode
                                    />
                                </div>
                            </div>
                        </div>
                    </div>

                    // Tests display
                    <Suspense fallback=move || {
                        view! {
                            <div class="flex justify-center items-center py-12">
                                <div class="animate-pulse flex space-x-4">
                                    <div class="rounded-full bg-gray-200 h-12 w-12"></div>
                                    <div class="flex-1 space-y-4 py-1">
                                        <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                                        <div class="space-y-2">
                                            <div class="h-4 bg-gray-200 rounded"></div>
                                            <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    }>
                        {move || {
                            let (all_tests, grouped_tests) = filtered_display.get();

                            match view_mode.get() {
                                ViewMode::Table => {
                                    if all_tests.is_empty() {
                                        view! {
                                            <EmptyState
                                                test_filter=test_filter
                                                on_click_add=on_click_add
                                            />
                                        }.into_any()
                                    } else {
                                        view! {
                                            <DenseTableView
                                                all_tests=all_tests
                                                if_show_delete=if_show_delete
                                                on_delete_test=on_delete_test
                                                on_create_variation=on_create_variation.clone()
                                            />
                                        }.into_any()
                                    }
                                }
                                ViewMode::Compact => {
                                    if all_tests.is_empty() {
                                        view! {
                                            <EmptyState
                                                test_filter=test_filter
                                                on_click_add=on_click_add
                                            />
                                        }.into_any()
                                    } else {
                                        view! {
                                            <CompactListView
                                                all_tests=all_tests
                                                if_show_delete=if_show_delete
                                                on_delete_test=on_delete_test
                                                on_create_variation=on_create_variation.clone()
                                            />
                                        }.into_any()
                                    }
                                }
                                ViewMode::Cards => {
                                    // Your existing grouped card view
                                    if grouped_tests.is_empty() {
                                        view! {
                                            <EmptyState
                                                test_filter=test_filter
                                                on_click_add=on_click_add
                                            />
                                        }.into_any()
                                    } else {
                                        view! {
                                            <div class="space-y-6">
                                                <For
                                                    each=move || grouped_tests.clone()
                                                    key=|group| group.base_test.test_id.clone()
                                                    children=move |group: TestGroup| {
                                                        view! {
                                                            <TestGroupCard
                                                                group=group
                                                                expanded_groups=expanded_groups
                                                                if_show_delete=if_show_delete
                                                                on_delete_test=on_delete_test
                                                                on_create_variation=on_create_variation.clone()
                                                                toggle_group_expansion=toggle_group_expansion
                                                            />
                                                        }
                                                    }
                                                />
                                            </div>
                                        }.into_any()
                                    }
                                }
                            }
                        }}
                    </Suspense>
                </div>
            </div>

            {move || {
                if show_create_variation_modal() {
                    view! {
                        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                                <h3 class="text-xl font-semibold text-gray-800 mb-4">Create Test Variation</h3>
                                {selected_base_test_for_variation.get().map(|test| view! {
                                    <p class="text-sm text-gray-600 mb-4">
                                        "Creating variation for: " <strong>{test.name.clone()}</strong>
                                    </p>
                                })}

                                <div class="mb-4">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">
                                        "Variation Type"
                                    </label>
                                    <div class="space-y-3">
                                        // Randomized Variation
                                        <div class="border rounded-lg p-3 hover:bg-gray-50 cursor-pointer"
                                             on:click=move |_| set_variation_type("Randomized".to_string())>
                                            <div class="flex items-start space-x-3">
                                                <input
                                                    type="radio"
                                                    name="variation_type"
                                                    value="Randomized"
                                                    class="mt-1"
                                                    prop:checked=move || variation_type() == "Randomized"
                                                    on:change=move |_| set_variation_type("Randomized".to_string())
                                                />
                                                <div class="flex-1">
                                                    <h4 class="font-medium text-gray-900">Randomized Version</h4>
                                                    <p class="text-sm text-gray-600 mt-1">
                                                        "Same questions with shuffled order and randomized answer choices. Questions are automatically generated."
                                                    </p>
                                                    <span class="inline-block mt-2 px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded">
                                                        "Auto-generated"
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        // Distinct Variation
                                        <div class="border rounded-lg p-3 hover:bg-gray-50 cursor-pointer"
                                             on:click=move |_| set_variation_type("Distinct".to_string())>
                                            <div class="flex items-start space-x-3">
                                                <input
                                                    type="radio"
                                                    name="variation_type"
                                                    value="Distinct"
                                                    class="mt-1"
                                                    prop:checked=move || variation_type() == "Distinct"
                                                    on:change=move |_| set_variation_type("Distinct".to_string())
                                                />
                                                <div class="flex-1">
                                                    <h4 class="font-medium text-gray-900">Distinct Version</h4>
                                                    <p class="text-sm text-gray-600 mt-1">
                                                        "Entirely different questions covering the same topics. You'll add new questions manually."
                                                    </p>
                                                    <span class="inline-block mt-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded">
                                                        "Manual entry required"
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        // Practice Variation
                                        <div class="border rounded-lg p-3 hover:bg-gray-50 cursor-pointer"
                                             on:click=move |_| set_variation_type("Practice".to_string())>
                                            <div class="flex items-start space-x-3">
                                                <input
                                                    type="radio"
                                                    name="variation_type"
                                                    value="Practice"
                                                    class="mt-1"
                                                    prop:checked=move || variation_type() == "Practice"
                                                    on:change=move |_| set_variation_type("Practice".to_string())
                                                />
                                                <div class="flex-1">
                                                    <h4 class="font-medium text-gray-900">Practice Version</h4>
                                                    <p class="text-sm text-gray-600 mt-1">
                                                        "Practice test for student preparation with new questions. You'll add practice questions manually."
                                                    </p>
                                                    <span class="inline-block mt-2 px-2 py-1 bg-purple-100 text-purple-800 text-xs rounded">
                                                        "Manual entry required"
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="flex justify-end space-x-3">
                                    <button
                                        class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
                                        on:click=move |_| {
                                            set_show_create_variation_modal(false);
                                            set_variation_type(String::new());
                                            set_selected_base_test_for_variation(None);
                                        }
                                        prop:disabled=is_creating_variation
                                    >
                                        "Cancel"
                                    </button>
                                    <button
                                        class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
                                        on:click=create_variation
                                        prop:disabled=move || is_creating_variation() || variation_type().is_empty()
                                    >
                                        {move || if is_creating_variation() {
                                            "Creating..."
                                        } else {
                                            "Create & Edit"
                                        }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::header::Header;
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::path;

#[component]
pub fn AdministerTest() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/admintest">
            <AdministerTestContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn AdministerTestContent() -> impl IntoView {
    view! {
        <Header />
        <main class="w-full absolute z-[-1] grain h-full">
            <div class="mx-auto max-w-8xl sm:px-6 mt-20 h-full">
                <div class="min-w-0 h-3/5">
                    <h1 class="text-2xl font-bold leading-7 text-white bg-[#00356b] rounded-2xl sm:truncate sm:text-3xl sm:tracking-tight ml-10">Administer Test</h1>
                </div>
                <ul role="list" class="grid grid-cols-2 gap-x-4 gap-y-8 sm:grid-cols-3 sm:gap-x-6 lg:grid-cols-4 xl:gap-x-8 mt-8">
                    <li class="relative">
                        //a href link to activity
                        //  then a div class
                        //   which contains both the starter image and a button and title paragraph
                    </li>
                </ul>
            </div>
        </main>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::header::Header;
use crate::app::models::{
    course::{Course, CreateCourseRequest, UpdateCourseRequest},
    enrollment::{AcademicYear, CreateEnrollmentRequest, Enrollment, EnrollmentStatus},
    student::GradeEnum,
};
use crate::app::server_functions::{courses::*, enrollments::*};
use chrono::{Local, NaiveDate};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;
use rust_decimal::Decimal;
use std::str::FromStr;
use strum::IntoEnumIterator;

#[cfg(feature = "hydrate")]
use wasm_bindgen::JsCast;

#[derive(Clone, Debug, PartialEq)]
enum EnrollmentAction {
    QuickEnroll,
    AddNew,
}

#[derive(Clone, Debug)]
struct EnrollmentFormData {
    student_id: String,
    course_id: String,
    academic_year: AcademicYear,
    grade_level: GradeEnum,
    teacher_id: String,
    status: EnrollmentStatus,
    enrollment_date: NaiveDate,
    status_change_date: Option<NaiveDate>,
    notes: Option<String>,
}
impl Default for EnrollmentFormData {
    fn default() -> Self {
        Self {
            student_id: String::new(),
            course_id: String::new(),
            academic_year: AcademicYear::Year2024_2025,
            grade_level: GradeEnum::Kindergarten,
            teacher_id: String::new(),
            status: EnrollmentStatus::Active,
            enrollment_date: Local::now().date_naive(),
            status_change_date: None,
            notes: None,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
enum DashboardView {
    Courses,
    Enrollments,
}

#[derive(Clone, Debug)]
struct CourseFormData {
    name: String,
    subject: String,
    course_code: String,
    course_level: GradeEnum,
    teacher_id: String,
    academic_year: AcademicYear,
    semester_period: String,
    credits: String,
    description: String,
    max_students: String,
    room_number: String,
}

impl Default for CourseFormData {
    fn default() -> Self {
        Self {
            name: String::new(),
            subject: String::new(),
            course_code: String::new(),
            course_level: GradeEnum::Kindergarten,
            teacher_id: String::new(),
            academic_year: AcademicYear::Year2024_2025,
            semester_period: String::new(),
            credits: String::new(),
            description: String::new(),
            max_students: String::new(),
            room_number: String::new(),
        }
    }
}

#[component]
pub fn AdminDashboard() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/admindashboard">
            <AdminDashboardContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn AdminDashboardContent() -> impl IntoView {
    let (selected_view, set_selected_view) = signal(SidebarSelected::AdminDashboard);
    let (current_tab, set_current_tab) = signal(DashboardView::Courses);

    // Course management state
    let (courses, set_courses) = create_signal::<Vec<Course>>(vec![]);
    let (course_search, set_course_search) = signal(String::new());
    let (show_course_form, set_show_course_form) = signal(false);
    let (editing_course, set_editing_course) = create_signal::<Option<Course>>(None);

    // Enrollment management state
    let (enrollments, set_enrollments) = create_signal::<Vec<Enrollment>>(vec![]);
    let (enrollment_search, set_enrollment_search) = signal(String::new());
    let (show_enrollment_form, set_show_enrollment_form) = signal(false);
    let (enrollment_action, set_enrollment_action) = signal(EnrollmentAction::AddNew);
    let (selected_course_for_enrollment, set_selected_course_for_enrollment) =
        create_signal::<Option<Course>>(None);

    // Load courses
    let load_courses = Action::new(|_: &()| async move {
        match get_courses().await {
            Ok(courses) => courses,
            Err(_) => vec![],
        }
    });

    // Load enrollments
    let load_enrollments = Action::new(|_: &()| async move {
        match get_enrollments().await {
            Ok(enrollments) => enrollments,
            Err(_) => vec![],
        }
    });

    // Delete course action
    let delete_course_action = Action::new(|course_id: &i32| {
        let course_id = *course_id;
        async move {
            match delete_course(course_id).await {
                Ok(_) => Some(course_id),
                Err(_) => None,
            }
        }
    });

    // Create/Update course action
    let save_course_action =
        Action::new(|(form_data, editing_id): &(CourseFormData, Option<i32>)| {
            let form_data = form_data.clone();
            let editing_id = *editing_id;
            async move {
                let teacher_id = form_data.teacher_id.parse::<i32>().unwrap_or(0);
                let credits = Decimal::from_str(&form_data.credits).unwrap_or_default();
                let max_students = form_data.max_students.parse::<i32>().unwrap_or(0);
                let room_number = if form_data.room_number.is_empty() {
                    None
                } else {
                    Some(form_data.room_number)
                };

                if let Some(course_id) = editing_id {
                    // Update existing course
                    let update_request = UpdateCourseRequest::new(
                        Some(form_data.name),
                        Some(form_data.subject),
                        Some(form_data.course_code),
                        Some(form_data.course_level),
                        Some(teacher_id),
                        Some(form_data.academic_year),
                        Some(form_data.semester_period),
                        Some(credits),
                        Some(form_data.description),
                        Some(max_students),
                        Some(room_number),
                    );
                    update_course(course_id, update_request).await.is_ok()
                } else {
                    // Create new course
                    let create_request = CreateCourseRequest::new(
                        form_data.name,
                        form_data.subject,
                        form_data.course_code,
                        form_data.course_level,
                        teacher_id,
                        form_data.academic_year,
                        form_data.semester_period,
                        credits,
                        form_data.description,
                        max_students,
                        room_number,
                    );
                    add_course(create_request).await.is_ok()
                }
            }
        });

    // Update enrollment status action
    let update_enrollment_status_action = Action::new(
        |(student_id, academic_year, status): &(i32, AcademicYear, EnrollmentStatus)| {
            let student_id = *student_id;
            let academic_year = academic_year.clone();
            let status = status.clone();
            async move {
                update_enrollment_status(student_id, academic_year, status)
                    .await
                    .is_ok()
            }
        },
    );

    // Create enrollment action
    let create_enrollment_action = Action::new(|form_data: &EnrollmentFormData| {
        let form_data = form_data.clone();
        async move {
            let student_id = form_data.student_id.parse::<i32>().unwrap_or(0);
            let course_id = form_data.course_id.parse::<i32>().unwrap_or(0);
            let teacher_id = form_data.teacher_id.parse::<i32>().unwrap_or(0);

            if student_id > 0 && course_id > 0 && teacher_id > 0 {
                let create_request = CreateEnrollmentRequest::new(
                    student_id,
                    form_data.course_id.parse::<i32>().unwrap_or(0),
                    form_data.academic_year,
                    form_data.grade_level,
                    teacher_id,
                    form_data.status,
                    Local::now().date_naive(),
                    Some(Local::now().date_naive()),
                    form_data.notes.clone(),
                );
                create_enrollment(create_request).await.is_ok()
            } else {
                false
            }
        }
    });

    // Delete enrollment action
    let delete_enrollment_action =
        Action::new(|(student_id, academic_year): &(i32, AcademicYear)| {
            let student_id = *student_id;
            let academic_year = academic_year.clone(); // Clone here
            async move {
                match delete_enrollment(student_id, academic_year.clone()).await {
                    // Clone again for the function call
                    Ok(_) => Some((student_id, academic_year)), // Now we can use the cloned value
                    Err(_) => None,
                }
            }
        });

    // Effects to reload data when actions complete
    Effect::new(move |_| {
        if load_courses.value().get().is_some() {
            if let Some(loaded_courses) = load_courses.value().get() {
                set_courses.set(loaded_courses);
            }
        }
    });

    Effect::new(move |_| {
        if load_enrollments.value().get().is_some() {
            if let Some(loaded_enrollments) = load_enrollments.value().get() {
                set_enrollments.set(loaded_enrollments);
            }
        }
    });

    Effect::new(move |_| {
        if let Some(Some(_)) = delete_course_action.value().get() {
            load_courses.dispatch(());
        }
    });

    Effect::new(move |_| {
        if save_course_action.value().get() == Some(true) {
            set_show_course_form.set(false);
            set_editing_course.set(None);
            load_courses.dispatch(());
        }
    });

    Effect::new(move |_| {
        if update_enrollment_status_action.value().get() == Some(true) {
            load_enrollments.dispatch(());
        }
    });

    // Initial data load
    Effect::new(move |_| {
        load_courses.dispatch(());
        load_enrollments.dispatch(());
    });

    Effect::new(move |_| {
        if create_enrollment_action.value().get() == Some(true) {
            set_show_enrollment_form.set(false);
            set_selected_course_for_enrollment.set(None);
            load_enrollments.dispatch(());
        }
    });

    Effect::new(move |_| {
        if let Some(Some(_)) = delete_enrollment_action.value().get() {
            load_enrollments.dispatch(());
        }
    });

    // Filtered courses based on search
    let filtered_courses = Memo::new(move |_| {
        let search = course_search.get().to_lowercase();
        if search.is_empty() {
            courses.get()
        } else {
            courses
                .get()
                .into_iter()
                .filter(|course| {
                    course.name.to_lowercase().contains(&search)
                        || course.course_code.to_lowercase().contains(&search)
                        || course.subject.to_lowercase().contains(&search)
                })
                .collect()
        }
    });

    // Filtered enrollments based on search
    let filtered_enrollments = Memo::new(move |_| {
        let search = enrollment_search.get();
        if search.is_empty() {
            enrollments.get()
        } else {
            if let Ok(student_id) = search.parse::<i32>() {
                enrollments
                    .get()
                    .into_iter()
                    .filter(|enrollment| enrollment.student_id == student_id)
                    .collect()
            } else {
                enrollments.get()
            }
        }
    });

    view! {
        <div class="min-h-screen bg-[#F9F9F8]">
            <Header />
            <DashboardSidebar
                selected_item=selected_view
                set_selected_item=set_selected_view
            />
            <div class="flex flex-1 ml-20 mt-20 p-6 max-h-screen overflow-y-auto">
                <div class="w-full max-w-7xl mx-auto max-h-full">
                    // Tab Navigation
                    <div class="mb-6">
                        <div class="border-b border-gray-200">
                            <nav class="-mb-px flex space-x-8">
                                <button
                                    class=move || if current_tab.get() == DashboardView::Courses {
                                        "border-indigo-500 text-indigo-600 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"
                                    } else {
                                        "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"
                                    }
                                    on:click=move |_| set_current_tab.set(DashboardView::Courses)
                                >
                                    "Courses"
                                </button>
                                <button
                                    class=move || if current_tab.get() == DashboardView::Enrollments {
                                        "border-indigo-500 text-indigo-600 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"
                                    } else {
                                        "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"
                                    }
                                    on:click=move |_| set_current_tab.set(DashboardView::Enrollments)
                                >
                                    "Enrollments"
                                </button>
                            </nav>
                        </div>
                    </div>

                    // Content based on selected tab
                    <div class="overflow-y-auto">
                        {move || match current_tab.get() {
                            DashboardView::Courses => view! {
                                <div class="space-y-6">
                                    // Course Management Header
                                    <div class="flex justify-between items-center">
                                        <h1 class="text-2xl font-bold text-gray-900">"Course Management"</h1>
                                        <div class="space-x-3">
                                            <button
                                                class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition-colors"
                                                on:click=move |_| {
                                                    set_enrollment_action.set(EnrollmentAction::QuickEnroll);
                                                    set_show_enrollment_form.set(true);
                                                    set_selected_course_for_enrollment.set(None);
                                                }
                                            >
                                                "Quick Enroll Student"
                                            </button>
                                            <button
                                                class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors"
                                                on:click=move |_| {
                                                    set_show_course_form.set(true);
                                                    set_editing_course.set(None);
                                                }
                                            >
                                                "Add New Course"
                                            </button>
                                        </div>
                                    </div>

                                    // Search Bar
                                    <div class="relative">
                                        <input
                                            type="text"
                                            placeholder="Search courses by name, code, or subject..."
                                            class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                            prop:value=course_search
                                            on:input=move |ev| set_course_search.set(event_target_value(&ev))
                                        />
                                    </div>

                                    // Courses Table
                                    <div class="bg-white shadow rounded-lg overflow-hidden border border-gray-300">
                                        <table class="min-w-full divide-y divide-gray-200">
                                            <thead class="bg-gray-50">
                                                <tr>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Course Code"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Name"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Subject"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Grade Level"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Academic Year"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Max Students"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Actions"</th>
                                                </tr>
                                            </thead>
                                            <tbody class="bg-white divide-y divide-gray-200">
                                                <For
                                                    each=filtered_courses
                                                    key=|course| course.id
                                                    children=move |course| {
                                                        let course_clone_edit = course.clone();
                                                        let course_clone_enroll = course.clone();
                                                        let delete_course_id = course.id;

                                                        view! {
                                                            <tr>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{&course.course_code}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{&course.name}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{&course.subject}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{format!("{:?}", course.course_level)}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{format!("{}", course.academic_year)}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{course.max_students}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
                                                                    <button
                                                                        class="text-indigo-600 hover:text-indigo-900"
                                                                        on:click=move |_| {
                                                                            set_editing_course.set(Some(course_clone_edit.clone()));
                                                                            set_show_course_form.set(true);
                                                                        }
                                                                    >
                                                                        "Edit"
                                                                    </button>
                                                                    <button
                                                                        class="text-green-600 hover:text-green-900 ml-2"
                                                                        on:click=move |_| {
                                                                            set_selected_course_for_enrollment.set(Some(course_clone_enroll.clone()));
                                                                            set_enrollment_action.set(EnrollmentAction::QuickEnroll);
                                                                            set_show_enrollment_form.set(true);
                                                                        }
                                                                    >
                                                                        "Enroll"
                                                                    </button>
                                                                    <button
                                                                        class="text-red-600 hover:text-red-900"
                                                                        on:click=move |_| {
                                                                            #[cfg(feature = "hydrate")]
                                                                            {
                                                                                if window().confirm_with_message("Are you sure you want to delete this course?").unwrap_or(false) {
                                                                                    delete_course_action.dispatch(delete_course_id);
                                                                                }
                                                                            }
                                                                        }
                                                                    >
                                                                        "Delete"
                                                                    </button>
                                                                </td>
                                                            </tr>
                                                        }
                                                    }
                                                />
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }.into_any(),

                            DashboardView::Enrollments => view! {
                                <div class="space-y-6">
                                    // Enrollment Management Header
                                    <div class="flex justify-between items-center">
                                        <h1 class="text-2xl font-bold text-gray-900">"Enrollment Management"</h1>
                                        <button
                                            class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors"
                                            on:click=move |_| {
                                                set_enrollment_action.set(EnrollmentAction::AddNew);
                                                set_show_enrollment_form.set(true);
                                                set_selected_course_for_enrollment.set(None);
                                            }
                                        >
                                            "Add New Enrollment"
                                        </button>
                                    </div>

                                    // Search Bar
                                    <div class="relative">
                                        <input
                                            type="text"
                                            placeholder="Search by student ID..."
                                            class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                            prop:value=enrollment_search
                                            on:input=move |ev| set_enrollment_search.set(event_target_value(&ev))
                                        />
                                    </div>

                                    // Enrollments Table
                                    <div class="bg-white shadow rounded-lg overflow-hidden">
                                        <table class="min-w-full divide-y divide-gray-200">
                                            <thead class="bg-gray-50">
                                                <tr>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Student ID"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Academic Year"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Grade Level"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Teacher ID"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Status"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Enrollment Date"</th>
                                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">"Actions"</th>
                                                </tr>
                                            </thead>
                                            <tbody class="bg-white divide-y divide-gray-200">
                                                <For
                                                    each=filtered_enrollments
                                                    key=|enrollment| (enrollment.student_id, enrollment.academic_year.clone())
                                                    children=move |enrollment| {
                                                        let enrollment_clone_status = enrollment.clone();
                                                        let enrollment_clone_delete = enrollment.clone();

                                                        view! {
                                                            <tr>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{enrollment.student_id}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{format!("{}", enrollment.academic_year)}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{format!("{:?}", enrollment.grade_level)}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{enrollment.teacher_id}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap">
                                                                    <select
                                                                        class="text-sm border border-gray-300 rounded px-2 py-1"
                                                                        on:change=move |ev| {
                                                                            let status_str = event_target_value(&ev);
                                                                            if let Some(new_status) = EnrollmentStatus::iter()
                                                                                .find(|s| s.to_string() == status_str) {
                                                                                update_enrollment_status_action.dispatch((
                                                                                    enrollment_clone_status.student_id,
                                                                                    enrollment_clone_status.academic_year.clone(),
                                                                                    new_status
                                                                                ));
                                                                            }
                                                                        }
                                                                    >
                                                                        {
                                                                            EnrollmentStatus::iter().map(|status| {
                                                                                let is_selected = enrollment.status == status;
                                                                                view! {
                                                                                    <option value=status.to_string() selected=is_selected>{status.to_string()}</option>
                                                                                }
                                                                            }).collect::<Vec<_>>()
                                                                        }
                                                                    </select>
                                                                </td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{enrollment.enrollment_date.format("%Y-%m-%d").to_string()}</td>
                                                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
                                                                    <button
                                                                        class="text-red-600 hover:text-red-900"
                                                                        on:click=move |_| {
                                                                            #[cfg(feature = "hydrate")]
                                                                            {
                                                                                if window().confirm_with_message("Are you sure you want to delete this enrollment?").unwrap_or(false) {
                                                                                    delete_enrollment_action.dispatch((enrollment_clone_delete.student_id, enrollment_clone_delete.academic_year.clone()));
                                                                                }
                                                                            }
                                                                        }
                                                                    >
                                                                        "Delete"
                                                                    </button>
                                                                </td>
                                                            </tr>
                                                        }
                                                    }
                                                />
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }.into_any(),
                        }}
                    </div>

                    // Course Form Modal
                    <Show when=show_course_form>
                        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
                            <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-2xl shadow-lg rounded-md bg-white">
                                <div class="mt-3">
                                    <h3 class="text-lg font-medium text-gray-900 mb-4">
                                        {move || if editing_course.get().is_some() { "Edit Course" } else { "Add New Course" }}
                                    </h3>
                                    <form on:submit=move |ev| {
                                        ev.prevent_default();
                                        #[cfg(feature = "hydrate")]
                                        {
                                            let form = ev.target().unwrap().dyn_into::<web_sys::HtmlFormElement>().unwrap();
                                            let form_data = web_sys::FormData::new_with_form(&form).unwrap();

                                            let course_data = CourseFormData {
                                                name: form_data.get("name").as_string().unwrap_or_default(),
                                                subject: form_data.get("subject").as_string().unwrap_or_default(),
                                                course_code: form_data.get("course_code").as_string().unwrap_or_default(),
                                                course_level: form_data.get("course_level").as_string()
                                                    .and_then(|s| GradeEnum::iter().find(|g| g.to_string() == s))
                                                    .unwrap_or(GradeEnum::Kindergarten),
                                                teacher_id: form_data.get("teacher_id").as_string().unwrap_or_default(),
                                                academic_year: form_data.get("academic_year").as_string()
                                                    .and_then(|s| AcademicYear::iter().find(|y| y.to_string() == s))
                                                    .unwrap_or(AcademicYear::Year2024_2025),
                                                semester_period: form_data.get("semester_period").as_string().unwrap_or_default(),
                                                credits: form_data.get("credits").as_string().unwrap_or_default(),
                                                description: form_data.get("description").as_string().unwrap_or_default(),
                                                max_students: form_data.get("max_students").as_string().unwrap_or_default(),
                                                room_number: form_data.get("room_number").as_string().unwrap_or_default(),
                                            };

                                            let editing_id = editing_course.get().map(|c| c.id);
                                            save_course_action.dispatch((course_data, editing_id));
                                        }

                                    }>
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Course Name"</label>
                                                <input
                                                    type="text"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="name"
                                                    value=move || editing_course.get().map(|c| c.name.clone()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Subject"</label>
                                                <input
                                                    type="text"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="subject"
                                                    value=move || editing_course.get().map(|c| c.subject.clone()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Course Code"</label>
                                                <input
                                                    type="text"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="course_code"
                                                    value=move || editing_course.get().map(|c| c.course_code.clone()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Teacher ID"</label>
                                                <input
                                                    type="number"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="teacher_id"
                                                    value=move || editing_course.get().map(|c| c.teacher_id.to_string()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Semester Period"</label>
                                                <input
                                                    type="text"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="semester_period"
                                                    value=move || editing_course.get().map(|c| c.semester_period.clone()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Credits"</label>
                                                <input
                                                    type="number"
                                                    step="0.1"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="credits"
                                                    value=move || editing_course.get().map(|c| c.credits.to_string()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Max Students"</label>
                                                <input
                                                    type="number"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="max_students"
                                                    value=move || editing_course.get().map(|c| c.max_students.to_string()).unwrap_or_default()
                                                />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Room Number"</label>
                                                <input
                                                    type="text"
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="room_number"
                                                    value=move || editing_course.get().and_then(|c| c.room_number.clone()).unwrap_or_default()
                                                />
                                            </div>
                                        </div>
                                        <div class="col-span-2 mt-4">
                                            <label class="block text-sm font-medium text-gray-700">"Description"</label>
                                            <textarea
                                                rows="3"
                                                class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                name="description"
                                            >{move || editing_course.get().map(|c| c.description.clone()).unwrap_or_default()}</textarea>
                                        </div>

                                        // Grade Level and Academic Year selects
                                        <div class="grid grid-cols-2 gap-4 mt-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Grade Level"</label>
                                                <select
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="course_level"
                                                >
                                                    {
                                                        GradeEnum::iter().map(|level| {
                                                            let is_selected = editing_course.get()
                                                                .map(|c| c.course_level == level)
                                                                .unwrap_or(level == GradeEnum::Kindergarten);
                                                            view! {
                                                                <option value=level.to_string() selected=is_selected>{level.to_string()}</option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }
                                                </select>
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Academic Year"</label>
                                                <select
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="academic_year"
                                                >
                                                    {
                                                        AcademicYear::iter().map(|year| {
                                                            let is_selected = editing_course.get()
                                                                .map(|c| c.academic_year == year)
                                                                .unwrap_or(year == AcademicYear::Year2024_2025);
                                                            view! {
                                                                <option value=year.to_string() selected=is_selected>{year.to_string()}</option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }
                                                </select>
                                            </div>
                                        </div>

                                        // Form Actions
                                        <div class="flex justify-end space-x-3 mt-6">
                                            <button
                                                type="button"
                                                class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                                on:click=move |_| {
                                                    set_show_course_form.set(false);
                                                    set_editing_course.set(None);
                                                }
                                            >
                                                "Cancel"
                                            </button>
                                            <button
                                                type="submit"
                                                class="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                                disabled=move || save_course_action.pending().get()
                                            >
                                                {move || if save_course_action.pending().get() {
                                                    if editing_course.get().is_some() { "Updating..." } else { "Creating..." }
                                                } else {
                                                    if editing_course.get().is_some() { "Update Course" } else { "Create Course" }
                                                }}
                                            </button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </Show>

                    // Enrollment Form Modal
                    <Show when=show_enrollment_form>
                        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
                            <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-2xl shadow-lg rounded-md bg-white">
                                <div class="mt-3">
                                    <h3 class="text-lg font-medium text-gray-900 mb-4">
                                        {move || match enrollment_action.get() {
                                            EnrollmentAction::QuickEnroll => "Quick Enroll Student",
                                            EnrollmentAction::AddNew => "Add New Enrollment",
                                        }}
                                    </h3>

                                    // Show selected course info for quick enroll
                                    <Show when=move || enrollment_action.get() == EnrollmentAction::QuickEnroll && selected_course_for_enrollment.get().is_some()>
                                        <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                                            <h4 class="font-medium text-blue-900">"Selected Course:"</h4>
                                            <p class="text-blue-800">
                                                {move || selected_course_for_enrollment.get().map(|c| format!("{} - {} ({})", c.course_code, c.name, c.subject)).unwrap_or_default()}
                                            </p>
                                        </div>
                                    </Show>

                                    <form on:submit=move |ev| {
                                        ev.prevent_default();
                                        #[cfg(feature = "hydrate")]
                                        {
                                            let form = ev.target().unwrap().dyn_into::<web_sys::HtmlFormElement>().unwrap();
                                            let form_data = web_sys::FormData::new_with_form(&form).unwrap();

                                            let enrollment_data = EnrollmentFormData {
                                                student_id: form_data.get("student_id").as_string().unwrap_or_default(),
                                                course_id: if let Some(course) = selected_course_for_enrollment.get() {
                                                    course.id.to_string()
                                                } else {
                                                    form_data.get("course_id").as_string().unwrap_or_default()
                                                },
                                                academic_year: form_data.get("academic_year").as_string()
                                                    .and_then(|s| AcademicYear::iter().find(|y| y.to_string() == s))
                                                    .unwrap_or(AcademicYear::Year2024_2025),
                                                grade_level: form_data.get("grade_level").as_string()
                                                    .and_then(|s| GradeEnum::iter().find(|g| g.to_string() == s))
                                                    .unwrap_or(GradeEnum::Kindergarten),
                                                teacher_id: form_data.get("teacher_id").as_string().unwrap_or_default(),
                                                status: form_data.get("status").as_string()
                                                    .and_then(|s| EnrollmentStatus::iter().find(|st| st.to_string() == s))
                                                    .unwrap_or(EnrollmentStatus::Active),
                                                enrollment_date: Local::now().date_naive(),
                                                status_change_date: Some(Local::now().date_naive()),
                                                notes: Some(form_data.get("notes").as_string().unwrap_or_default()),
                                            };

                                            create_enrollment_action.dispatch(enrollment_data);
                                        }

                                    }>
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Student ID"</label>
                                                <input
                                                    type="number"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="student_id"
                                                    placeholder="Enter student ID"
                                                />
                                            </div>

                                            // Show course selection only for new enrollment
                                            <Show when=move || enrollment_action.get() == EnrollmentAction::AddNew>
                                                <div>
                                                    <label class="block text-sm font-medium text-gray-700">"Course"</label>
                                                    <select
                                                        required
                                                        class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                        name="course_id"
                                                    >
                                                        <option value="">"Select a course"</option>
                                                        {move || courses.get().into_iter().map(|course| {
                                                            view! {
                                                                <option value=course.id.to_string()>
                                                                    {format!("{} - {} ({})", course.course_code, course.name, course.subject)}
                                                                </option>
                                                            }
                                                        }).collect::<Vec<_>>()}
                                                    </select>
                                                </div>
                                            </Show>

                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Teacher ID"</label>
                                                <input
                                                    type="number"
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="teacher_id"
                                                    placeholder="Enter teacher ID"
                                                />
                                            </div>

                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Academic Year"</label>
                                                <select
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="academic_year"
                                                >
                                                    {
                                                        AcademicYear::iter().map(|year| {
                                                            let is_selected = year == AcademicYear::Year2024_2025;
                                                            view! {
                                                                <option value=year.to_string() selected=is_selected>{year.to_string()}</option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }
                                                </select>
                                            </div>

                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Grade Level"</label>
                                                <select
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="grade_level"
                                                >
                                                    {
                                                        GradeEnum::iter().map(|level| {
                                                            let is_selected = level == GradeEnum::Kindergarten;
                                                            view! {
                                                                <option value=level.to_string() selected=is_selected>{level.to_string()}</option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }
                                                </select>
                                            </div>

                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">"Status"</label>
                                                <select
                                                    required
                                                    class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    name="status"
                                                >
                                                    {
                                                        EnrollmentStatus::iter().map(|status| {
                                                            let is_selected = status == EnrollmentStatus::Active;
                                                            view! {
                                                                <option value=status.to_string() selected=is_selected>{status.to_string()}</option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }
                                                </select>
                                            </div>
                                        </div>

                                        // Form Actions
                                        <div class="flex justify-end space-x-3 mt-6">
                                            <button
                                                type="button"
                                                class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                                on:click=move |_| {
                                                    set_show_enrollment_form.set(false);
                                                    set_selected_course_for_enrollment.set(None);
                                                }
                                            >
                                                "Cancel"
                                            </button>
                                            <button
                                                type="submit"
                                                class="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                                disabled=move || create_enrollment_action.pending().get()
                                            >
                                                {move || if create_enrollment_action.pending().get() {
                                                    "Creating..."
                                                } else {
                                                    match enrollment_action.get() {
                                                        EnrollmentAction::QuickEnroll => "Enroll Student",
                                                        EnrollmentAction::AddNew => "Create Enrollment",
                                                    }
                                                }}
                                            </button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </Show>

                    // Loading states
                    <Show when=move || load_courses.pending().get() || load_enrollments.pending().get()>
                        <div class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-40">
                            <div class="bg-white p-6 rounded-lg shadow-lg">
                                <div class="flex items-center space-x-2">
                                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600"></div>
                                    <span class="text-gray-700">"Loading..."</span>
                                </div>
                            </div>
                        </div>
                    </Show>

                    // Error handling and notifications could be added here
                    <Show when=move || delete_course_action.value().get().flatten().is_none() && !delete_course_action.pending().get() && delete_course_action.value().get().is_some()>
                        <div class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Error: "</span>
                            "Failed to delete course. Please try again."
                        </div>
                    </Show>

                    <Show when=move || save_course_action.value().get() == Some(false)>
                        <div class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Error: "</span>
                            "Failed to save course. Please check all fields and try again."
                        </div>
                    </Show>

                    <Show when=move || update_enrollment_status_action.value().get() == Some(false)>
                        <div class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Error: "</span>
                            "Failed to update enrollment status. Please try again."
                        </div>
                    </Show>

                    <Show when=move || delete_enrollment_action.value().get().flatten().is_none() && !delete_enrollment_action.pending().get() && delete_enrollment_action.value().get().is_some()>
                        <div class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Error: "</span>
                            "Failed to delete enrollment. Please try again."
                        </div>
                    </Show>

                    <Show when=move || create_enrollment_action.value().get() == Some(false)>
                        <div class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Error: "</span>
                            "Failed to create enrollment. Please check all fields and try again."
                        </div>
                    </Show>

                    // Success notification for enrollment creation
                    <Show when=move || create_enrollment_action.value().get() == Some(true) && !create_enrollment_action.pending().get()>
                        <div class="fixed top-4 right-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded z-50">
                            <span class="font-medium">"Success: "</span>
                            "Student enrolled successfully!"
                        </div>
                    </Show>
                </div>
            </div>
        </div>
    }
}
use crate::app::components::auth::login_form::{LoginForm, RegisterForm};
use crate::app::components::auth::saml_login_form::SamlLoginForm;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::user::SessionUser;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;

#[component]
pub fn LoginPage() -> impl IntoView {
    let (show_register, set_show_register) = signal(false);
    let current_user = use_context::<ReadSignal<Option<SessionUser>>>().unwrap();
    let navigate = use_navigate();

    // Get settings to check if student protections are enabled
    let (settings, _) = use_settings();
    let student_protections_enabled = move || settings.get().student_protections;

    // If already logged in, redirect to home
    Effect::new(move |_| {
        if current_user.get().is_some() {
            navigate("/", Default::default());
        }
    });

    view! {
        <div class="max-w-md mx-auto mt-10 bg-[#f9f9f8]">
            {move || {
                if show_register.get() {
                    view! {
                        <RegisterForm />
                        <div class="mt-4 text-center">
                            <span>"Already have an account? "</span>
                            <button
                                class="text-blue-500 hover:underline"
                                on:click=move |_| set_show_register.set(false)
                            >
                                "Login"
                            </button>
                        </div>
                    }.into_any()
                } else {
                    view! {
                        // Conditionally render the appropriate login form
                        <SamlLoginForm />

                        <div class="mt-4 text-center">
                            <div class="flex justify-center">
                                <button
                                    class="text-blue-500 hover:underline"
                                    on:click=move |_| set_show_register.set(true)
                                >
                                    "Register"
                                </button>
                                <a href="/forgot-password">
                                    <button
                                        class="text-red-500 hover:underline ml-4"
                                    >
                                        "Forgot Password?"
                                    </button>
                                </a>
                            </div>
                        </div>
                    }.into_any()
                }
            }}
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::header::Header;
use crate::app::components::question_builder::BuildingQuestion;
use crate::app::components::test_components::benchmark_color_selector::BenchmarkColorSelector;
use crate::app::models::assessment::ScopeEnum;
use crate::app::models::student::GradeEnum;
use crate::app::models::test::BenchmarkCategory;
use crate::app::models::test::{CreateNewTestRequest, Test, TestType, UpdateTestRequest};
use crate::app::models::{CreateNewQuestionRequest, Question, QuestionType, WeightedOption};
use crate::app::server_functions::assessments::update_assessment_score;
use crate::app::server_functions::courses::get_courses;
use crate::app::server_functions::questions::{add_question, delete_questions, get_questions};
use crate::app::server_functions::tests::get_tests;
use crate::app::server_functions::tests::{add_test, get_test, score_overrider, update_test};
use crate::app::utils::BenchmarkUtils;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;
use std::str::FromStr;
use strum::IntoEnumIterator;

#[cfg(feature = "hydrate")]
use leptos::wasm_bindgen::JsCast;

#[component]
pub fn TestBuilder() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/testbuilder">
            <TestBuilderContent />
        </ServerAuthGuard>
    }
}

async fn get_next_variant_number_for_new_test(test_name: &str) -> Result<i32, ServerFnError> {
    let all_tests = get_tests().await?;

    // Find all tests with the same name (exact match or base name match)
    let related_tests: Vec<&Test> = all_tests
        .iter()
        .filter(|test| {
            let test_base_name = if test.name.contains(" - ") {
                test.name.split(" - ").next().unwrap_or(&test.name)
            } else {
                &test.name
            };
            test_base_name == test_name || test.name == test_name
        })
        .collect();

    // Find the highest variant number
    let max_variant = related_tests
        .iter()
        .map(|test| test.test_variant)
        .max()
        .unwrap_or(-1); // Start from -1 so first test gets variant 0

    Ok(max_variant + 1)
}

#[component]
pub fn TestBuilderContent() -> impl IntoView {
    const TAB_BUTTON_STYLE: &str =
        "bg-[#00356b] px-8 py-2 rounded text-white transition-all duration-1000 ease-in-out ml-2";
    const INPUT_STYLE: &str = "w-[20rem] h-12 border-[#00356b] border pr-4 pl-6 py-4 text-[#00356b] rounded transition-all duration-1000 ease-in-out";
    const INPUT_STYLE_BOX: &str = "mt-5 h-[30rem] w-full max-w-7xl rounded border-[#00356b] border text-wrap pl-4 align-text-top text-start text-[#00356b] align-top transition-all duration-1000 ease-in-out";
    const DROPDOWN_STYLE: &str = "w-40 h-12 border-[#00356b] border pr-4 pl-6 py-2 text-[#00356b] rounded transition-all duration-1000 ease-in-out";

    let params = use_params_map();
    let maybe_id = params.with(|params| params.get("test_id").cloned());

    // Signal to track if we're in edit mode
    let (is_edit_mode, set_is_edit_mode) = signal(false);

    let test_resource = Resource::new(
        move || maybe_id.clone(),
        |id| async move {
            match id {
                Some(test_id) => get_test(test_id).await.ok(),
                None => None,
            }
        },
    );

    let courses_resource = Resource::new(
        || (),
        |_| async move {
            match get_courses().await {
                Ok(courses) => courses,
                Err(e) => {
                    log::error!("Failed to load courses: {:?}", e);
                    Vec::new()
                }
            }
        },
    );

    let (selected_tab, set_selected_tab) = signal(0);
    let (test_title, set_test_title) = signal(String::new());
    let (test_instructions, set_test_instructions) = signal(String::new());
    let (test_area, set_test_area) = signal(String::new());
    let (school_year, set_school_year) = signal(String::new());
    let (grade_level, set_grade_level) = create_signal::<Option<GradeEnum>>(None);
    let (benchmark_categories, set_benchmark_categories) =
        create_signal::<Vec<(i32, i32, i32, String, String)>>(Vec::new());
    let (test_variant, set_test_variant) = signal(0);
    let (test_comments, set_test_comments) = signal(String::new());
    let (test_id, set_test_id) = signal(String::new());
    let (scope, set_scope) = create_signal::<Option<ScopeEnum>>(None);
    let (course_id, set_course_id) = create_signal::<Option<i32>>(None);

    //Signal to track which question to autofocus
    let (auto_focus_question, set_auto_focus_question) = create_signal::<Option<i32>>(None);
    let (default_point_value, set_default_point_value) = create_signal::<Option<i32>>(None);
    let (default_question_type, set_default_question_type) =
        create_signal::<Option<QuestionType>>(None);

    //Signals for TestVariation Management
    let (is_variation, set_is_variation) = signal(false);
    let (base_test_name, set_base_test_name) = signal(String::new());
    let (variation_type_display, set_variation_type_display) = signal(String::new());
    let (related_variations, set_related_variations) = signal(Vec::<Test>::new());

    let (error_message, set_error_message) = signal(String::new());
    let (show_error, set_show_error) = signal(false);
    let (is_submitting, set_is_submitting) = signal(false);

    let (questions, set_questions) = signal(Vec::<Question>::new());

    let (force_update_key, set_force_update_key) = signal(0);

    // Resource to load questions when in edit mode
    let questions_resource = Resource::new(
        move || test_id.get(),
        |tid| async move {
            if tid.is_empty() {
                return Vec::new();
            }
            match get_questions(tid).await {
                Ok(qs) => qs,
                Err(e) => {
                    log::error!("Failed to load questions: {:?}", e);
                    Vec::new()
                }
            }
        },
    );

    let add_new_question = move |_| {
        let new_question_number = questions().len() + 1;
        set_questions.update(|qs| {
            // Use the default question type if set, otherwise fall back to MultipleChoice
            let question_type = default_question_type
                .get()
                .unwrap_or(QuestionType::MultipleChoice);

            let mut new_question = Question::new(
                String::new(),
                default_point_value.get().unwrap_or(1),
                question_type.clone(), // Use the variable directly
                vec![],
                String::new(),
                new_question_number as i32,
                test_id(),
            );

            // Set up initial options based on the ACTUAL question type being used
            match question_type {
                QuestionType::MultipleChoice => {
                    new_question.options = vec!["".to_string(), "".to_string()];
                    new_question.correct_answer = "".to_string();
                    new_question.weighted_options = None;
                }
                QuestionType::TrueFalse => {
                    new_question.options = vec!["true".to_string(), "false".to_string()];
                    new_question.correct_answer = "true".to_string();
                    new_question.weighted_options = None;
                }
                QuestionType::WeightedMultipleChoice => {
                    new_question.options = Vec::new();
                    new_question.correct_answer = String::new();
                    let default_weighted_options = vec![
                        WeightedOption::new("".to_string(), 1, true),
                        WeightedOption::new("".to_string(), 1, true),
                    ];
                    new_question.set_weighted_options(default_weighted_options);
                }
                _ => {
                    // Fallback for any other types
                    new_question.options = vec!["".to_string(), "".to_string()];
                    new_question.correct_answer = "".to_string();
                    new_question.weighted_options = None;
                }
            }

            qs.push(new_question);
        });

        // Focus logic remains the same
        #[cfg(feature = "hydrate")]
        {
            request_animation_frame(move || {
                set_auto_focus_question(Some(new_question_number as i32));
            });
        }
        #[cfg(not(feature = "hydrate"))]
        {
            set_auto_focus_question(Some(new_question_number as i32));
        }
    };

    let clear_auto_focus = move |question_number: i32| {
        // Only clear if this is the currently focused question
        if auto_focus_question() == Some(question_number) {
            set_auto_focus_question(None);
        }
    };

    let update_question = move |index: usize, updated_question: Question| {
        set_questions.update(|qs| {
            if index < qs.len() {
                qs[index] = updated_question;
            }
        });
    };

    let remove_question = move |index: usize| {
        set_questions.update(|qs| {
            qs.remove(index);

            // Renumber all questions to ensure sequential numbering
            for (i, q) in qs.iter_mut().enumerate() {
                q.qnumber = (i + 1) as i32;
            }
        });
    };

    //Load related variations in edit mode
    let related_variations_resource = Resource::new(
        move || (test_id.get(), is_edit_mode()),
        |(current_test_id, is_editing)| async move {
            if !is_editing || current_test_id.is_empty() {
                return Vec::new();
            }

            match get_tests().await {
                Ok(all_tests) => {
                    // Find the current test to determine the base name
                    let current_test = all_tests.iter().find(|t| t.test_id == current_test_id);

                    if let Some(current) = current_test {
                        let base_name = if current.name.contains(" - ") {
                            current
                                .name
                                .split(" - ")
                                .next()
                                .unwrap_or(&current.name)
                                .to_string()
                        } else {
                            current.name.clone()
                        };

                        // Find all related tests (base + variations)
                        all_tests
                            .into_iter()
                            .filter(|test| {
                                let test_base_name = if test.name.contains(" - ") {
                                    test.name
                                        .split(" - ")
                                        .next()
                                        .unwrap_or(&test.name)
                                        .to_string()
                                } else {
                                    test.name.clone()
                                };
                                test_base_name == base_name && test.test_id != current_test_id
                            })
                            .collect()
                    } else {
                        Vec::new()
                    }
                }
                Err(_) => Vec::new(),
            }
        },
    );

    //Helper to display benchmark categories in test summary
    let benchmark_summary = move || {
        if benchmark_categories().is_empty() {
            "No benchmark categories defined".to_string()
        } else {
            let temp_categories = BenchmarkUtils::from_tuples(benchmark_categories());
            BenchmarkUtils::format_summary(&temp_categories)
        }
    };

    // Effect to load test data when a test_id is available
    Effect::new(move |_| {
        if let Some(Some(test)) = test_resource.get() {
            set_is_edit_mode(true);
            set_test_id(test.test_id.clone());
            set_test_title(test.name.clone());
            set_grade_level(test.grade_level.clone());
            set_test_area(test.testarea.clone().to_string());
            set_school_year(test.school_year.clone().unwrap_or_default());
            set_test_comments(test.comments.clone());
            set_test_variant(test.test_variant);
            set_scope(test.scope.clone());
            set_course_id(test.course_id.clone());
            set_test_instructions(test.instructions.clone().unwrap_or_default());

            // Convert BenchmarkCategory to our internal tuple representation using utilities
            let categories = test.benchmark_categories.clone().unwrap_or_default();
            let tuple_categories = BenchmarkUtils::to_tuples(categories);
            set_benchmark_categories(tuple_categories);
        }
    });

    // Effect to load questions when questions_resource updates
    Effect::new(move |_| {
        if let Some(loaded_questions) = questions_resource.get() {
            if !loaded_questions.is_empty() {
                // Sort questions by question number
                let mut sorted_questions = loaded_questions.clone();
                sorted_questions.sort_by_key(|q| q.qnumber);

                // Renumber questions sequentially starting from 1
                for (i, q) in sorted_questions.iter_mut().enumerate() {
                    q.qnumber = (i + 1) as i32;
                }

                set_questions(sorted_questions);
            }
        }
    });

    //Loading related variations when in edit mode
    Effect::new(move |_| {
        if let Some(variations) = related_variations_resource.get() {
            set_related_variations(variations);
        }
    });

    // For editing a variation
    Effect::new(move |_| {
        if let Some(Some(test)) = test_resource.get() {
            let is_var = test.name.contains(" - ")
                && (test.name.to_lowercase().contains("randomized")
                    || test.name.to_lowercase().contains("distinct")
                    || test.name.to_lowercase().contains("practice")
                    || test.comments.to_lowercase().contains("variation:"));

            set_is_variation(is_var);

            if is_var {
                if let Some(base_name) = test.name.split(" - ").next() {
                    set_base_test_name(base_name.to_string());
                }
                if let Some(variation_part) = test.name.split(" - ").nth(1) {
                    set_variation_type_display(variation_part.to_string());
                }
            }
        }
    });

    Effect::new(move |_| {
        #[cfg(feature = "hydrate")]
        {
            use wasm_bindgen::prelude::*;
            use wasm_bindgen::JsCast;
            use web_sys::KeyboardEvent;

            let handle_keydown = Closure::wrap(Box::new(move |event: KeyboardEvent| {
                // Check if we're on the questions tab (tab 1)
                if selected_tab() == 1 {
                    // Check for Ctrl++ (Ctrl + Plus/Equal key)
                    if event.ctrl_key() && (event.key() == "+" || event.key() == "=") {
                        event.prevent_default();
                        add_new_question(());
                    }
                }
            }) as Box<dyn FnMut(KeyboardEvent)>);

            let window = web_sys::window().unwrap();

            // Convert the closure to a Function - use into() instead of unchecked_into on reference
            let function = handle_keydown.as_ref().unchecked_ref::<js_sys::Function>();
            window
                .add_event_listener_with_callback("keydown", function)
                .unwrap();

            // Store the closure
            let stored_closure = store_value(handle_keydown);

            // Cleanup function
            on_cleanup(move || {
                let window = web_sys::window().unwrap();
                stored_closure.with_value(|closure| {
                    let function = closure.as_ref().unchecked_ref::<js_sys::Function>();
                    window
                        .remove_event_listener_with_callback("keydown", function)
                        .unwrap();
                });
            });
        }
    });

    let validate_test_form = move || -> Result<(), String> {
        // Input validation
        if test_title().is_empty() {
            return Err("Test title cannot be empty".to_string());
        }

        if test_area().is_empty() {
            return Err("Test area must be selected".to_string());
        }

        match TestType::from_str(&test_area()) {
            Ok(_) => Ok(()),
            Err(_) => Err("Invalid test area selected".to_string()),
        }
    };

    let validate_questions = move || -> Result<Vec<CreateNewQuestionRequest>, String> {
        let current_questions = questions.get();

        if current_questions.is_empty() {
            return Err("Please add at least one question".to_string());
        }

        let valid_questions: Vec<_> = current_questions
            .into_iter()
            .filter(|q| {
                let is_valid = match &q.question_type {
                    QuestionType::MultipleChoice => {
                        !q.word_problem.is_empty()
                            && q.point_value > 0
                            && !q.options.is_empty()
                            && !q.correct_answer.is_empty()
                            && q.options.contains(&q.correct_answer)
                    }
                    QuestionType::TrueFalse => {
                        !q.word_problem.is_empty()
                            && q.point_value > 0
                            && (q.correct_answer == "true" || q.correct_answer == "false")
                            && !q.correct_answer.is_empty()
                    }
                    QuestionType::WeightedMultipleChoice => {
                        let weighted_options = q.get_weighted_options();
                        !q.word_problem.is_empty()
                            && q.point_value > 0
                            && !weighted_options.is_empty()
                            && weighted_options.iter().any(|opt| opt.is_selectable)
                            && weighted_options
                                .iter()
                                .all(|opt| !opt.text.trim().is_empty())
                    }
                    _ => false,
                };
                if !is_valid {
                    log::warn!("Invalid question found: {:?}", q);
                }
                is_valid
            })
            .collect();

        if valid_questions.is_empty() {
            return Err("No valid questions to submit".to_string());
        }

        let question_requests: Vec<CreateNewQuestionRequest> = valid_questions
            .into_iter()
            .map(|q| {
                let mut request = CreateNewQuestionRequest::from_question(&q);
                request.testlinker = q.testlinker.clone();
                request
            })
            .collect();

        Ok(question_requests)
    };

    let on_submit_test_and_questions = move |_| {
        if is_submitting() {
            return;
        }

        set_is_submitting(true);
        set_show_error(false);

        // First validate the test form
        if let Err(e) = validate_test_form() {
            set_show_error(true);
            set_error_message(e);
            set_is_submitting(false);
            return;
        }

        // Create the test
        let test_type = TestType::from_str(&test_area()).unwrap(); // Safe because we validated earlier

        // Calculate total points from current questions for initial test creation
        let total_points: i32 = questions.get().iter().map(|q| q.point_value).sum();

        // Convert our tuple representation back to BenchmarkCategory
        let converted_cats = if benchmark_categories().is_empty() {
            None
        } else {
            // Convert tuples to BenchmarkCategory objects
            let temp_categories = BenchmarkUtils::from_tuples(benchmark_categories());

            // Validate all categories
            match BenchmarkUtils::validate_all(&temp_categories) {
                Ok(_) => Some(temp_categories),
                Err(validation_error) => {
                    set_show_error(true);
                    set_error_message(format!(
                        "Benchmark category validation failed: {}",
                        validation_error
                    ));
                    set_is_submitting(false);
                    return;
                }
            }
        };

        // Convert scope back to Enum and course_id to i32
        let scope_value = scope();
        if scope_value != Some(ScopeEnum::Course) && course_id().is_some() {
            set_course_id(None);
        };
        let course_id_value = course_id();

        let converted_clone = converted_cats.clone();
        let test_title_clone = test_title();
        let test_comments_clone = test_comments();
        let school_year_clone = school_year();
        let grade_level_clone = grade_level();
        let scope_value_clone = scope_value.clone();
        let course_id_value_clone = course_id_value.clone();
        let test_instructions_clone = test_instructions();

        spawn_local(async move {
            let current_test_id = test_id();
            let is_editing = is_edit_mode();

            // Auto-assign variant number for new tests, keep existing for edits
            let final_test_variant = if !is_editing {
                // For new tests, get the next available variant number
                match get_next_variant_number_for_new_test(&test_title_clone).await {
                    Ok(num) => {
                        log::info!("Auto-assigned variant number: {}", num);
                        set_test_variant(num);
                        num
                    }
                    Err(e) => {
                        log::error!("Failed to get next variant number: {:?}", e);
                        set_show_error(true);
                        set_error_message(format!("Failed to determine variant number: {}", e));
                        set_is_submitting(false);
                        return;
                    }
                }
            } else {
                test_variant() // Keep existing variant for edits
            };

            // If we're editing, update the test rather than creating a new one
            let new_test_id = if is_editing && !current_test_id.is_empty() {
                let update_test_request = UpdateTestRequest::new(
                    test_title_clone.clone(),
                    total_points,
                    Some(test_instructions_clone.clone()),
                    test_comments_clone.clone(),
                    test_type.clone(),
                    Some(school_year_clone.clone()),
                    converted_clone.clone(),
                    final_test_variant,
                    grade_level_clone.clone(),
                    current_test_id.clone(),
                    scope_value_clone.clone(),
                    course_id_value_clone.clone(),
                );

                log::info!("Updating test with ID: {}", current_test_id);
                match update_test(update_test_request).await {
                    Ok(_) => {
                        log::info!("Successfully updated test");
                    }
                    Err(e) => {
                        log::error!("Error updating test: {:?}", e);
                        set_show_error(true);
                        set_error_message(format!("Failed to update test: {}", e));
                        set_is_submitting(false);
                        return;
                    }
                }
                current_test_id
            } else {
                // Create a new test with auto-assigned variant
                let add_test_request = CreateNewTestRequest::new(
                    test_title_clone.clone(),
                    total_points,
                    Some(test_instructions_clone.clone()),
                    test_comments_clone.clone(),
                    test_type.clone(),
                    Some(school_year_clone.clone()),
                    converted_clone.clone(),
                    final_test_variant,
                    grade_level_clone.clone(),
                    scope_value_clone.clone(),
                    course_id_value_clone.clone(),
                );

                match add_test(add_test_request).await {
                    Ok(added_test) => {
                        let new_id = added_test.test_id.clone();
                        set_test_id(new_id.clone());
                        log::info!(
                            "Created test with ID: {} and variant: {}",
                            new_id,
                            final_test_variant
                        );
                        new_id
                    }
                    Err(e) => {
                        log::error!("Error creating test: {:?}", e);
                        set_show_error(true);
                        set_error_message(format!("Failed to create test: {}", e));
                        set_is_submitting(false);
                        return;
                    }
                }
            };

            // Now validate questions
            let question_requests_result = validate_questions();

            if let Err(e) = question_requests_result {
                set_show_error(true);
                set_error_message(e.clone());
                set_is_submitting(false);
                log::warn!("Failed to validate questions: {}", e);
                return;
            }

            let mut question_requests = question_requests_result.unwrap();

            // Update question requests with the test ID
            for q in &mut question_requests {
                q.testlinker = new_test_id.clone();
            }

            if is_editing {
                match delete_questions(new_test_id.clone()).await {
                    Ok(_) => {
                        log::info!(
                            "Successfully deleted existing questions for test: {}",
                            new_test_id
                        );
                    }
                    Err(e) => {
                        log::error!("Failed to delete existing questions:{:?}", e);
                        set_show_error(true);
                        set_error_message(format!("Failed to delete existing questions: {}", e));
                        set_is_submitting(false);
                        return;
                    }
                }
            }

            // Add questions one by one
            let mut success_count = 0;
            for question in &question_requests {
                match add_question(new_test_id.clone(), question.clone()).await {
                    Ok(_) => {
                        log::info!("Added question {}", question.qnumber);
                        success_count += 1;
                    }
                    Err(e) => {
                        log::error!("Failed to add question {}: {:?}", question.qnumber, e)
                    }
                }
            }

            log::info!(
                "Added {}/{} questions successfully",
                success_count,
                &question_requests.len()
            );

            // Always update assessment scores, whether this is a new test or an edited one
            match update_assessment_score(new_test_id.clone()).await {
                Ok(_) => {
                    log::info!(
                        "Successfully updated assessment scores for test: {}",
                        new_test_id
                    );
                }
                Err(e) => {
                    log::error!("Failed to update assessment scores: {:?}", e);
                    // We continue even if updating assessment scores fails
                    // This allows the user to still complete their task
                }
            }

            set_is_submitting(false);

            // Navigate to the test list page only after all questions are processed
            let navigate = use_navigate();
            navigate("/test-manager", Default::default());
        });
    };

    view! {
        <Header />
        <main class="w-full max-w-5xl mx-auto px-6 py-12">
            <div class="flex flex-col mb-8">
                <h1 class="text-3xl font-semibold text-gray-800">
                    {move || if is_edit_mode() { "Edit Test" } else { "Test Builder" }}
                </h1>
                <div class="h-0.5 w-full bg-gray-300 mt-3"></div>
            </div>

            {move || {
                if is_variation() && is_edit_mode() {
                    let variation_info = variation_type_display();
                    let (info_class, icon_color, info_text, warning_text) = if variation_info.to_lowercase().contains("randomized") {
                        (
                            "bg-blue-50 border-blue-400",
                            "text-blue-400",
                            "This is a randomized variation with shuffled questions and answer choices.",
                            Some("Questions are automatically generated from the base test. You can edit them but they may be overwritten if regenerated.")
                        )
                    } else if variation_info.to_lowercase().contains("distinct") {
                        (
                            "bg-green-50 border-green-400",
                            "text-green-400",
                            "This is a distinct variation with entirely different questions.",
                            None
                        )
                    } else if variation_info.to_lowercase().contains("practice") {
                        (
                            "bg-purple-50 border-purple-400",
                            "text-purple-400",
                            "This is a practice variation for student preparation.",
                            None
                        )
                    } else {
                        (
                            "bg-blue-50 border-blue-400",
                            "text-blue-400",
                            "This is a test variation.",
                            None
                        )
                    };

                    view! {
                        <div class=format!("border-l-4 p-4 mb-6 {}", info_class)>
                            <div class="flex">
                                <div class="flex-shrink-0">
                                    <svg class=format!("h-5 w-5 {}", icon_color) viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                    </svg>
                                </div>
                                <div class="ml-3 flex-1">
                                    <h3 class="text-sm font-medium text-blue-800">
                                        "Editing Test Variation"
                                    </h3>
                                    <div class="mt-2 text-sm text-blue-700">
                                        <p>
                                            "This is a " <strong>{variation_type_display}</strong> " variation of "
                                            <strong>{base_test_name}</strong>
                                        </p>
                                        <p class="mt-1 text-xs">{info_text}</p>
                                        {if let Some(warning) = warning_text {
                                            view! {
                                                <p class="mt-2 text-xs bg-yellow-100 text-yellow-800 p-2 rounded border border-yellow-200">
                                                    {warning}
                                                </p>
                                            }.into_any()
                                        } else {
                                            view! { <div></div> }.into_any()
                                        }}
                                        <div class="mt-3">
                                            <div class="flex items-center space-x-4">
                                                <button
                                                    class="text-sm bg-blue-100 hover:bg-blue-200 text-blue-800 px-3 py-1 rounded-md transition-colors"
                                                    on:click=move |_| {
                                                        let navigate = use_navigate();
                                                        navigate("/test-variations", Default::default());
                                                    }
                                                >
                                                    "Manage All Variations"
                                                </button>
                                                <span class="text-blue-600">
                                                    {move || {
                                                        let count = related_variations().len();
                                                        if count > 0 {
                                                            format!("{} related test(s)", count)
                                                        } else {
                                                            "No other variations".to_string()
                                                        }
                                                    }}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}

            // Error message display
            <Show when=move || show_error()>
                <div class="bg-red-50 border-l-4 border-red-500 text-red-700 p-4 rounded mb-6">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div class="ml-3">
                            {error_message}
                        </div>
                    </div>
                </div>
            </Show>

            <div class="flex space-x-2 mb-8 border-b">
                <button
                    class=move || {
                        let base_class = "px-6 py-3 text-sm font-medium transition-all duration-200 focus:outline-none";
                        let active_class = "text-[#00356b] border-b-2 border-[#00356b]";
                        let inactive_class = "text-gray-500 hover:text-[#00356b]";
                        format!("{} {}", base_class, if selected_tab() == 0 { active_class } else { inactive_class })
                    }
                    on:click=move |_| set_selected_tab.set(0)
                >
                    "Test Details"
                </button>
                <button
                    class=move || {
                        let base_class = "px-6 py-3 text-sm font-medium transition-all duration-200 focus:outline-none";
                        let active_class = "text-[#00356b] border-b-2 border-[#00356b]";
                        let inactive_class = "text-gray-500 hover:text-[#00356b]";
                        format!("{} {}", base_class, if selected_tab() == 1 { active_class } else { inactive_class })
                    }
                    on:click=move |_| set_selected_tab.set(1)
                >
                    "Questions"
                </button>
                <button
                    class=move || {
                        let base_class = "px-6 py-3 text-sm font-medium transition-all duration-200 focus:outline-none";
                        let active_class = "text-[#00356b] border-b-2 border-[#00356b]";
                        let inactive_class = "text-gray-500 hover:text-[#00356b]";
                        format!("{} {}", base_class, if selected_tab() == 2 { active_class } else { inactive_class })
                    }
                    on:click=move |_| set_selected_tab.set(2)
                >
                    "Review"
                </button>
            </div>

            <div class="tab-content">
                {move || match selected_tab() {
                    0 => view!{
                        <div class="space-y-6">
                            <div class="form-group">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Test Title"
                                </label>
                                <input
                                    type="text"
                                    placeholder="Enter test title"
                                    class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                    value=test_title
                                    on:input=move |event| {
                                        set_test_title(event_target_value(&event));
                                    }
                                />
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="form-group">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                        "Test Area"
                                    </label>
                                    <select
                                        class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                        prop:value=test_area
                                        on:change=move |event| {
                                            set_test_area(event_target_value(&event));
                                        }
                                    >
                                        <option value="">"Please Select a Value"</option>
                                        <option value="Reading">"Reading"</option>
                                        <option value="Math">"Math"</option>
                                        <option value="PhonemicAwareness">"Phonemic Awareness"</option>
                                        <option value="Spelling">"Spelling"</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                        "School Year"
                                    </label>
                                    <select
                                        class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                        prop:value=school_year
                                        on:input=move |event| {
                                            set_school_year(event_target_value(&event));
                                        }
                                    >
                                        <option value="">"Please Select a Year"</option>
                                        <option value="2023-2024">"2023-2024"</option>
                                        <option value="2024-2025">"2024-2025"</option>
                                        <option value="2025-2026">"2025-2026"</option>
                                    </select>
                                </div>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="form-group">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                        "Test Grade Level"
                                    </label>
                                    <select
                                        required
                                        class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                        prop:value={move || grade_level.get().map(|g| g.to_string()).unwrap_or_else(|| "".to_string())}
                                        on:change=move |event| {
                                            let value = event_target_value(&event);
                                            if value.is_empty() || value == "None" {
                                                set_grade_level(None);
                                            } else {
                                                match value.parse::<GradeEnum>() {
                                                    Ok(grade_enum) => set_grade_level(Some(grade_enum)),
                                                    Err(_) => {
                                                        set_grade_level(None);
                                                    }
                                                }
                                            }
                                        }
                                    >
                                        <option value="">Select Grade</option>
                                        <option value="None">"None"</option>
                                        {GradeEnum::iter().map(|grade| view! {
                                            <option value=format!("{}", grade)>
                                                {format!("{}", grade)}
                                            </option>
                                        }).collect::<Vec<_>>()}
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                        "Variant Number"
                                    </label>
                                    {move || {
                                        if is_edit_mode() {
                                            // In edit mode, show the current variant number as read-only
                                            view! {
                                                <div class="w-full px-4 py-3 rounded-md border border-gray-300 bg-gray-100 text-gray-600">
                                                    {test_variant().to_string()}
                                                    <span class="text-sm text-gray-500 ml-2">"(Auto-assigned)"</span>
                                                </div>
                                            }.into_any()
                                        } else {
                                            // In create mode, show that it will be auto-assigned
                                            view! {
                                                <div class="w-full px-4 py-3 rounded-md border border-gray-300 bg-gray-100 text-gray-600">
                                                    "Will be auto-assigned"
                                                    <span class="text-sm text-gray-500 ml-2">"(Next available number)"</span>
                                                </div>
                                            }.into_any()
                                        }
                                    }}
                                </div>

                                <div class="form-group">
                                    <label class="block text-sm font-medium text-gray-700 mb-1">
                                        "Scope"
                                    </label>
                                    <select
                                        class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                        prop:value={move ||  match scope() {
                                            Some(s) => s.to_string(),
                                            None => "none".to_string()
                                        }}
                                        on:change=move |event| {
                                            let value = event_target_value(&event);
                                            if value == "none" {
                                                set_scope(None);
                                            } else {
                                                match ScopeEnum::from_str(&value) {
                                                    Ok(scope_enum) => set_scope(Some(scope_enum)),
                                                    Err(_) => set_scope(None),
                                                }
                                            }
                                        }
                                    >
                                        <option value="none">"None"</option>
                                        {
                                            ScopeEnum::iter().map(|scope_enum| {
                                                view! {
                                                    <option value=scope_enum.to_string()>
                                                        {scope_enum.to_string()}
                                                    </option>
                                                }
                                            }).collect::<Vec<_>>()
                                        }
                                    </select>
                                    <Show when=move || matches!(scope(),Some(ScopeEnum::Course))>
                                        <div class="mt-2">
                                            <label class="block text-sm font-medium text-gray-700 mb-1">
                                                "Course"
                                            </label>
                                            <Suspense fallback=move || view! {
                                                <div class="w-full px-4 py-3 rounded-md border border-gray-300 bg-gray-100 text-gray-500">
                                                    "Loading courses..."
                                                </div>
                                            }>
                                                <select
                                                    class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                                    prop:value=move || course_id().map(|id| id.to_string()).unwrap_or_default()
                                                    on:change=move |event| {
                                                        let value = event_target_value(&event);
                                                        if value.is_empty() {
                                                            set_course_id(None);
                                                        } else if let Ok(id) = value.parse::<i32>() {
                                                            set_course_id(Some(id));
                                                        }
                                                    }
                                                >
                                                    <option value="">"Select a Course"</option>
                                                    {move || {
                                                        courses_resource.get().unwrap_or_default().into_iter().map(|course| {
                                                            view! {
                                                                <option value=course.id.to_string()>
                                                                    {course.name.clone()}
                                                                </option>
                                                            }
                                                        }).collect::<Vec<_>>()
                                                    }}
                                                </select>
                                            </Suspense>
                                        </div>
                                    </Show>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Grading/Benchmark Categories"
                                </label>
                                <div class="space-y-4 p-4 bg-gray-50 rounded-md border border-gray-200">
                                    // Display existing benchmark categories
                                    <For
                                        each=move || benchmark_categories.get()
                                        key=|(id, _, _, _, _)| *id
                                        children=move |(id, min_score, max_score, label, color): (i32, i32, i32, String, String)| {
                                            let id_clone = id;
                                            let (is_single_value, set_is_single_value) = signal(min_score == max_score);

                                            view! {
                                                <div class="flex items-center space-x-3">
                                                    // Color selector
                                                    <BenchmarkColorSelector
                                                        current_color={
                                                            let id_for_color = id;
                                                            Memo::new(move |_| {
                                                                benchmark_categories()
                                                                    .iter()
                                                                    .find(|(cid, _, _, _, _)| *cid == id_for_color)
                                                                    .map(|(_, _, _, _, color)| color.clone())
                                                                    .unwrap_or_else(|| "#6b7280".to_string())
                                                            })
                                                        }
                                                        on_color_change={
                                                            let id_for_callback = id;
                                                            Callback::new(move |new_color: String| {
                                                                set_benchmark_categories.update(|cats| {
                                                                    if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id_for_callback) {
                                                                        cat.4 = new_color; // Update color (5th element)
                                                                    }
                                                                });
                                                            })
                                                        }
                                                    />

                                                    <div class="flex-1 grid grid-cols-4 gap-3">
                                                        <input
                                                            type="text"
                                                            placeholder="Category (e.g. A+)"
                                                            class="px-3 py-2 rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                            value=label.clone()
                                                            on:input=move |ev| {
                                                                let new_label = event_target_value(&ev);
                                                                set_benchmark_categories.update(|cats| {
                                                                    if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id) {
                                                                        cat.3 = new_label;
                                                                    }
                                                                });
                                                            }
                                                        />

                                                        // Toggle between single value and range
                                                        <div class="flex items-center space-x-2">
                                                            <label class="flex items-center space-x-1 text-sm">
                                                                <input
                                                                    type="checkbox"
                                                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                                                    checked=is_single_value.get()
                                                                    on:change=move |ev| {
                                                                        let checked = event_target_checked(&ev);
                                                                        set_is_single_value.set(checked);

                                                                        set_benchmark_categories.update(|cats| {
                                                                            if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id) {
                                                                                if checked {
                                                                                    // Convert to single value - use min as the single value
                                                                                    cat.2 = cat.1; // max = min
                                                                                } else {
                                                                                    // Convert to range - ensure max >= min
                                                                                    if cat.2 <= cat.1 {
                                                                                        cat.2 = cat.1 + 10; // Set a reasonable default range
                                                                                    }
                                                                                }
                                                                            }
                                                                        });
                                                                    }
                                                                />
                                                                <span>"Single Value"</span>
                                                            </label>
                                                        </div>

                                                        // Input fields that change based on single value vs range
                                                        {move || {
                                                            if is_single_value.get() {
                                                                // Single value input
                                                                view! {
                                                                    <div class="col-span-2">
                                                                        <input
                                                                            type="number"
                                                                            placeholder="Value"
                                                                            min="0"
                                                                            class="w-full px-3 py-2 rounded border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                                            value=min_score.to_string()
                                                                            on:input=move |ev| {
                                                                                if let Ok(new_value) = event_target_value(&ev).parse::<i32>() {
                                                                                    set_benchmark_categories.update(|cats| {
                                                                                        if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id) {
                                                                                            cat.1 = new_value; // min
                                                                                            cat.2 = new_value; // max = min for single value
                                                                                        }
                                                                                    });
                                                                                }
                                                                            }
                                                                        />
                                                                    </div>
                                                                }.into_any()
                                                            } else {
                                                                // Range inputs
                                                                view! {
                                                                    <div class="col-span-2 flex items-center">
                                                                        <input
                                                                            type="number"
                                                                            placeholder="Min"
                                                                            min="0"
                                                                            class="w-full px-3 py-2 rounded-l border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                                            value=min_score.to_string()
                                                                            on:input=move |ev| {
                                                                                if let Ok(new_min) = event_target_value(&ev).parse::<i32>() {
                                                                                    set_benchmark_categories.update(|cats| {
                                                                                        if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id) {
                                                                                            cat.1 = new_min;
                                                                                            // Ensure max is at least equal to min
                                                                                            if cat.2 < new_min {
                                                                                                cat.2 = new_min;
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                }
                                                                            }
                                                                        />
                                                                        <span class="px-2 py-2 bg-gray-200 border-t border-b border-gray-300">-</span>
                                                                        <input
                                                                            type="number"
                                                                            placeholder="Max"
                                                                            min=min_score.to_string()
                                                                            class="w-full px-3 py-2 rounded-r border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                                            value=max_score.to_string()
                                                                            on:input=move |ev| {
                                                                                if let Ok(new_max) = event_target_value(&ev).parse::<i32>() {
                                                                                    set_benchmark_categories.update(|cats| {
                                                                                        if let Some(cat) = cats.iter_mut().find(|(cid, _, _, _, _)| *cid == id) {
                                                                                            // Ensure max is at least equal to min
                                                                                            cat.2 = if new_max >= cat.1 { new_max } else { cat.1 };
                                                                                        }
                                                                                    });
                                                                                }
                                                                            }
                                                                        />
                                                                    </div>
                                                                }.into_any()
                                                            }
                                                        }}
                                                    </div>
                                                    <button
                                                        type="button"
                                                        class="p-1 text-red-600 hover:bg-red-100 rounded-full focus:outline-none"
                                                        on:click=move |_| {
                                                            set_benchmark_categories.update(|cats| {
                                                                cats.retain(|(cid, _, _, _, _)| *cid != id_clone);
                                                            });
                                                        }
                                                    >
                                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                                        </svg>
                                                    </button>
                                                </div>
                                            }
                                        }
                                    />

                                    // Add new category button
                                    <div class="flex space-x-2">
                                        <button
                                            type="button"
                                            class="flex items-center px-4 py-2 text-sm font-medium text-blue-700 bg-blue-50 border border-blue-300 rounded-md hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                            on:click=move |_| {
                                                set_benchmark_categories.update(|cats| {
                                                    // Generate a unique ID for the new category
                                                    let new_id = cats.iter().map(|(id, _, _, _, _)| *id).max().unwrap_or(0) + 1;
                                                    cats.push((new_id, 0, 10, String::new(), "#6b7280".to_string())); // Default range
                                                });
                                            }
                                        >
                                            <svg class="w-4 h-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                                            </svg>
                                            "Add Range Category"
                                        </button>

                                        <button
                                            type="button"
                                            class="flex items-center px-4 py-2 text-sm font-medium text-green-700 bg-green-50 border border-green-300 rounded-md hover:bg-green-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                                            on:click=move |_| {
                                                set_benchmark_categories.update(|cats| {
                                                    // Generate a unique ID for the new category
                                                    let new_id = cats.iter().map(|(id, _, _, _, _)| *id).max().unwrap_or(0) + 1;
                                                    cats.push((new_id, 0, 0, String::new(), "#6b7280".to_string())); // Single value (min = max)
                                                });
                                            }
                                        >
                                            <svg class="w-4 h-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                                            </svg>
                                            "Add Single Value"
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Comments (Optional)"
                                </label>
                                <input
                                    type="text"
                                    placeholder="Add any additional comments"
                                    class="w-full px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                    value=test_comments
                                    on:input=move |event| {
                                        set_test_comments(event_target_value(&event));
                                    }
                                />
                            </div>

                            <div class="form-group">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    "Test Instructions"
                                </label>
                                <textarea
                                    placeholder="Instructions for students taking the test"
                                    class="w-full h-64 px-4 py-3 rounded-md border border-gray-300 shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                                    on:input=move |event| {
                                        set_test_instructions(event_target_value(&event));
                                    }
                                ></textarea>
                            </div>

                            {move || {
                                if !is_edit_mode() {
                                    view! {
                                        <div class="form-group">
                                            <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                                                <h3 class="text-sm font-medium text-gray-700 mb-3">Test Variations</h3>
                                                <p class="text-sm text-gray-600 mb-4">
                                                    "After creating this test, you can create variations (easier, harder, practice versions) from the Variation Manager."
                                                </p>
                                                <button
                                                    type="button"
                                                    class="text-sm bg-blue-100 hover:bg-blue-200 text-blue-800 px-3 py-2 rounded-md transition-colors"
                                                    on:click=move |_| {
                                                        let navigate = use_navigate();
                                                        navigate("/test-variations", Default::default());
                                                    }
                                                >
                                                    "Go to Variation Manager"
                                                </button>
                                            </div>
                                        </div>
                                    }
                                } else {
                                    view! { <div></div> }
                                }
                            }}

                            <div class="pt-6">
                                <button
                                    class="px-6 py-3 bg-[#00356b] text-white rounded-md font-medium shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all"
                                    on:click=move |_| set_selected_tab.set(1)
                                >
                                    "Continue to Questions"
                                </button>
                            </div>
                        </div>
                    }.into_any(),
                    1 => view!{
                        <div class="space-y-8">
                            <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
                                <div class="flex justify-between items-center mb-4">
                                    <h3 class="text-lg font-medium text-gray-800">"Question Management"</h3>
                                    <div class="flex items-center space-x-4">
                                        <div class="text-sm text-gray-600">
                                            <span class="font-medium">
                                                {move || {
                                                    let count = questions().len();
                                                    let total = questions().iter().map(|q| q.point_value).sum::<i32>();
                                                    format!("{} questions â€¢ {} total points", count, total)
                                                }}
                                            </span>
                                        </div>
                                        <button
                                            class="flex items-center px-4 py-2 bg-[#00356b] text-white rounded-md font-medium shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all"
                                            on:click=move |_| add_new_question(())
                                            title="Add New Question (Ctrl + +)"
                                        >
                                            <svg class="w-5 h-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                                            </svg>
                                            "Add Question"
                                            <span class="ml-2 text-xs opacity-75 bg-blue-600 px-2 py-1 rounded">
                                                "Ctrl + +"
                                            </span>
                                        </button>
                                    </div>
                                </div>

                                // Preset controls section
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                                    // Point value preset
                                    <div class="flex items-center space-x-2">
                                        <label class="text-sm text-gray-600 whitespace-nowrap">"Set all points to:"</label>
                                        <select
                                            class="flex-1 px-3 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500"
                                            prop:value=move || default_point_value().map(|p| p.to_string()).unwrap_or_default()
                                            on:change=move |event| {
                                                let value = event_target_value(&event);
                                                if !value.is_empty() {
                                                    if let Ok(points) = value.parse::<i32>() {
                                                        // Set the default for new questions
                                                        set_default_point_value(Some(points));

                                                        // Update existing questions
                                                        set_questions.update(|qs| {
                                                            for q in qs.iter_mut() {
                                                                q.point_value = points;
                                                            }
                                                        });
                                                        // Force re-render by updating the key
                                                        set_force_update_key.update(|k| *k += 1);
                                                    }
                                                } else {
                                                    // Clear default when "Select..." is chosen
                                                    set_default_point_value(None);
                                                }
                                            }
                                        >
                                            <option value="">"Select..."</option>
                                            <option value="1">"1 point"</option>
                                            <option value="2">"2 points"</option>
                                            <option value="3">"3 points"</option>
                                            <option value="5">"5 points"</option>
                                            <option value="10">"10 points"</option>
                                        </select>
                                        {move || {
                                            if let Some(points) = default_point_value() {
                                                view! {
                                                    <span class="text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded whitespace-nowrap">
                                                        "New: " {points} " pts"
                                                    </span>
                                                }.into_any()
                                            } else {
                                                view! { <div></div> }.into_any()
                                            }
                                        }}
                                    </div>

                                    // Question type preset
                                    <div class="flex items-center space-x-2">
                                        <label class="text-sm text-gray-600 whitespace-nowrap">"Default question type:"</label>
                                        <select
                                            class="flex-1 px-3 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500"
                                            prop:value=move || {
                                                default_question_type().map(|qt| {
                                                    match qt {
                                                        QuestionType::MultipleChoice => "MultipleChoice",
                                                        QuestionType::TrueFalse => "TrueFalse",
                                                        QuestionType::WeightedMultipleChoice => "WeightedMultipleChoice",
                                                        _ => "MultipleChoice"
                                                    }
                                                }).unwrap_or("")
                                            }
                                            on:change=move |event| {
                                                let value = event_target_value(&event);
                                                if !value.is_empty() {
                                                    let question_type = match value.as_str() {
                                                        "MultipleChoice" => QuestionType::MultipleChoice,
                                                        "TrueFalse" => QuestionType::TrueFalse,
                                                        "WeightedMultipleChoice" => QuestionType::WeightedMultipleChoice,
                                                        _ => QuestionType::MultipleChoice,
                                                    };
                                                    set_default_question_type(Some(question_type));
                                                } else {
                                                    set_default_question_type(None);
                                                }
                                            }
                                        >
                                            <option value="">"Select..."</option>
                                            <option value="MultipleChoice">"Multiple Choice"</option>
                                            <option value="TrueFalse">"True/False"</option>
                                            <option value="WeightedMultipleChoice">"Weighted Multiple Choice"</option>
                                        </select>
                                        {move || {
                                            if let Some(qt) = default_question_type() {
                                                let display_name = match qt {
                                                    QuestionType::MultipleChoice => "MC",
                                                    QuestionType::TrueFalse => "T/F",
                                                    QuestionType::WeightedMultipleChoice => "WMC",
                                                    _ => "MC"
                                                };
                                                view! {
                                                    <span class="text-xs text-green-600 bg-green-50 px-2 py-1 rounded whitespace-nowrap">
                                                        "New: " {display_name}
                                                    </span>
                                                }.into_any()
                                            } else {
                                                view! { <div></div> }.into_any()
                                            }
                                        }}
                                    </div>
                                </div>

                                // Help text for the preset controls
                                <div class="mt-3 text-xs text-gray-600 bg-blue-50 p-3 rounded border-l-4 border-blue-400">
                                    <p class="font-medium mb-1">Quick Setup Tips:</p>
                                    <ul class="space-y-1">
                                        <li>"â€¢" <strong>Points:</strong> " Sets point value for all questions (existing + new)"</li>
                                        <li>"â€¢" <strong>Default Type:</strong> " Sets question type for newly added questions"</li>
                                    </ul>
                                </div>
                            </div>

                            // Show message if no questions exist
                            <Show when=move || questions().is_empty()>
                                <div class="text-center py-12 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
                                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                    <h3 class="mt-2 text-sm font-medium text-gray-900">"No questions added yet"</h3>
                                    <p class="mt-1 text-sm text-gray-500">
                                        {move || {
                                            if let Some(qt) = default_question_type() {
                                                let type_name = match qt {
                                                    QuestionType::MultipleChoice => "Multiple Choice",
                                                    QuestionType::TrueFalse => "True/False",
                                                    QuestionType::WeightedMultipleChoice => "Weighted Multiple Choice",
                                                    _ => "Multiple Choice"
                                                };
                                                format!("New questions will be {} type.", type_name)
                                            } else {
                                                "Get started by adding your first question.".to_string()
                                            }
                                        }}
                                    </p>
                                    <div class="mt-6">
                                        <button
                                            class="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-[#00356b] hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                            on:click=move |_| add_new_question(())
                                            title="Add Question (Ctrl + +)"
                                        >
                                            <svg class="-ml-1 mr-2 h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                                            </svg>
                                            "Add Question"
                                            <span class="ml-2 text-xs opacity-75 bg-blue-600 px-2 py-1 rounded">
                                                "Ctrl + +"
                                            </span>
                                        </button>
                                    </div>
                                </div>
                            </Show>

                            // Existing questions list
                            <div class="space-y-6">
                                <For
                                    each={move || questions.get().into_iter().enumerate().collect::<Vec<_>>()}
                                    key={move |(index, question)| (*index, question.qnumber, force_update_key.get())}
                                    children={move |(index, question): (usize, Question)| {
                                        // Create duplicate callback
                                        let duplicate_question = move |q: Question| {
                                            set_questions.update(|qs| {
                                                let mut new_q = q.clone();
                                                new_q.qnumber = (qs.len() + 1) as i32;
                                                new_q.word_problem = if new_q.word_problem.is_empty() {
                                                    "Copy of question".to_string()
                                                } else {
                                                    format!("{} (Copy)", new_q.word_problem)
                                                };
                                                // Reset the test linker to current test
                                                new_q.testlinker = test_id();
                                                qs.push(new_q);
                                            });
                                        };

                                        view! {
                                            <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                                                <div class="bg-gray-50 px-4 py-2 border-b border-gray-200">
                                                    <h3 class="font-medium text-gray-700">Question {question.qnumber}</h3>
                                                </div>
                                                <div class="p-4">
                                                    <BuildingQuestion
                                                        initial_question=question.clone()
                                                        on_update=Callback::new(move |updated_q| update_question(index, updated_q))
                                                        on_remove=Callback::new(move |_| remove_question(index))
                                                        on_duplicate=Some(Callback::new(duplicate_question))
                                                        should_auto_focus={
                                                            let current_question_number = question.qnumber;
                                                            Memo::new(move |_| auto_focus_question() == Some(current_question_number))
                                                        }
                                                        on_focus_complete=Callback::new(move |_| clear_auto_focus(question.qnumber))
                                                    />
                                                </div>
                                            </div>
                                        }
                                    }}
                                />
                            </div>

                            // Bottom actions
                            <div class="flex justify-between items-center pt-6 border-t">
                                <button
                                    class="flex items-center px-5 py-2 bg-[#00356b] text-white rounded-md font-medium shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all"
                                    on:click=move |_| add_new_question(())
                                    title="Add Another Question (Ctrl + +)"
                                >
                                    <svg class="w-5 h-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                                    </svg>
                                    "Add Another Question"
                                    <span class="ml-2 text-xs opacity-75 bg-blue-600 px-2 py-1 rounded">
                                        "Ctrl + +"
                                    </span>
                                </button>

                                <div class="flex space-x-3">
                                    <button
                                        class="px-5 py-2 bg-gray-100 text-gray-700 rounded-md font-medium hover:bg-gray-200 border border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-all"
                                        on:click=move |_| set_selected_tab.set(0)
                                    >
                                        "Back to Test Details"
                                    </button>
                                    <button
                                        class="px-5 py-2 bg-[#00356b] text-white rounded-md font-medium shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all"
                                        on:click=move |_| set_selected_tab.set(2)
                                    >
                                        "Continue to Review"
                                    </button>
                                </div>
                            </div>
                        </div>
                    }.into_any(),
                    2 => view!{
                        <div class="space-y-8">
                            <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                                <div class="bg-gray-50 px-4 py-3 border-b border-gray-200">
                                    <h2 class="text-lg font-medium text-gray-800">Test Summary</h2>
                                </div>
                                <div class="p-6 space-y-4">
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <h3 class="text-sm font-medium text-gray-500">Title</h3>
                                            <p class="mt-1 text-lg text-gray-800">{test_title}</p>
                                        </div>
                                        <div>
                                            <h3 class="text-sm font-medium text-gray-500">Area</h3>
                                            <p class="mt-1 text-lg text-gray-800">{test_area}</p>
                                        </div>
                                        <div>
                                            <h3 class="text-sm font-medium text-gray-500">Questions</h3>
                                            <p class="mt-1 text-lg text-gray-800">{move || questions().len()}</p>
                                        </div>
                                        <div>
                                            <h3 class="text-sm font-medium text-gray-500">Total Points</h3>
                                            <p class="mt-1 text-lg text-gray-800">{move || {
                                                questions().iter().map(|q| q.point_value).sum::<i32>()
                                            }}</p>
                                        </div>
                                        <div>
                                            <h3 class="text-sm font-medium text-gray-500">Benchmark Categories</h3>
                                            <p class="mt-1 text-lg text-gray-800">{benchmark_summary}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="pt-6 flex justify-between">
                                <button
                                    class="px-5 py-2 bg-gray-100 text-gray-700 rounded-md font-medium hover:bg-gray-200 border border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-all"
                                    on:click=move |_| set_selected_tab.set(1)
                                >
                                    "Back to Questions"
                                </button>
                                <button
                                    class="flex items-center px-5 py-2 bg-[#00356b] text-white rounded-md font-medium shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    on:click=on_submit_test_and_questions
                                    prop:disabled=is_submitting
                                >
                                    {move || if is_submitting() {
                                        view! {
                                            <>
                                                <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                "Submitting..."
                                            </>
                                        }.into_any()
                                    } else {
                                        view! {
                                            <>
                                                <svg class="w-5 h-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                                                </svg>
                                                "Submit Test & Questions"
                                            </>
                                        }.into_any()
                                    }}
                                </button>
                            </div>
                        </div>
                    }.into_any(),
                    _ => view!{<p>This is the backup tab</p>}.into_any(),
                }}
            </div>
        </main>
    }
}
use crate::app::components::dashboard::color_utils::ColorUtils;
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::dashboard::scores_ledger::ScoreUtils;
use crate::app::components::data_processing::{
    AssessmentProgressChart, AssessmentRadarChart, AssessmentSummary, PerformanceDistributionChart,
    Progress, StudentResultsSummary, TestAreaPerformanceChart, TestDetail, TestScoresTimelineChart,
};
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent, StudentMappingService,
};
use crate::app::components::header::Header;
use crate::app::components::student_report::assessments::progress_overview_tab::ProgressOverviewTab;
use crate::app::components::student_report::overview::{OverviewTab, SortOption, TimeFrame};
use crate::app::components::student_report::sequence_progress_bar::{
    CompactStripeProgress, StripeProgressBar,
};
use crate::app::components::student_report::sequence_web::SequenceWeb;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::test::Test;
use crate::app::server_functions::data_wrappers::get_student_results_server;
use crate::app::server_functions::tests::get_tests;
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_router::use_params_map;
use std::collections::HashSet;
use uuid::Uuid;

#[component]
pub fn TestResultsPage() -> impl IntoView {
    //Get global settings for anonymization
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    //Get student mapping service
    let (student_mapping_service, _) = use_student_mapping_service();

    // Get student ID from URL parameters
    let params = use_params_map();
    let student_id = move || {
        params.with(|params| {
            params
                .get("student_id")
                .and_then(|id| id.parse::<i32>().ok())
                .unwrap_or(0)
        })
    };

    // Resource to fetch consolidated student results data
    let student_results_resource = Resource::new(
        move || student_id(),
        |id| async move {
            if id > 0 {
                get_student_results_server(id).await.ok()
            } else {
                None
            }
        },
    );

    // Resource to fetch test data for benchmark categories
    let tests_resource = LocalResource::new(
        || (),
        |_| async {
            match get_tests().await {
                Ok(tests) => Some(tests),
                Err(e) => {
                    log::error!("Failed to load tests: {}", e);
                    None
                }
            }
        },
    );

    //Create enhanced student data with de-anonymization
    let enhanced_student_data = Memo::new(move |_| {
        student_results_resource
            .get()
            .unwrap_or(None)
            .map(|results| {
                if anonymization_enabled() {
                    let de_anon = DeAnonymizedStudent::from_student_with_mapping(
                        &results.student,
                        student_mapping_service.get().as_ref(),
                    );
                    (results, Some(de_anon))
                } else {
                    (results, None)
                }
            })
    });

    // Signal to track which assessment is expanded
    let (expanded_assessment, set_expanded_assessment) = create_signal::<Option<String>>(None);
    let (filter_test_name, set_filter_test_name) = create_signal::<Option<String>>(None);
    let (show_filters, set_show_filters) = create_signal::<bool>(false);
    let (view_mode, set_view_mode) = create_signal::<String>("overview".to_string());

    view! {
        <Header />
        <div class="p-5 max-w-7xl mx-auto">
            // Student Information Section
            <Suspense fallback=move || view! { <div class="text-center p-4">"Loading student data..."</div> }>
                {move || enhanced_student_data.get().map(|(results, de_anon_opt)| {
                    let (display_name, display_id) = if let Some(de_anon) = &de_anon_opt {
                        (de_anon.display_name.clone(), de_anon.display_id.clone())
                    } else {
                        let name = format!(
                            "{} {}",
                            results.student.firstname.clone().unwrap_or_else(|| "Unknown".to_string()),
                            results.student.lastname.clone().unwrap_or_else(|| "Student".to_string())
                        );
                        (name, results.student.student_id.to_string())
                    };

                    view! {
                        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                            <h1 class="text-2xl font-bold mb-4">
                                "Test Results for " {display_name}
                            </h1>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div class="bg-gray-50 p-4 rounded">
                                    <h3 class="font-semibold text-gray-700">"Student ID"</h3>
                                    <p>{display_id}</p>
                                </div>
                                <div class="bg-gray-50 p-4 rounded">
                                    <h3 class="font-semibold text-gray-700">"Grade Level"</h3>
                                    <p>{results.student.current_grade_level.to_string()}</p>
                                </div>
                                <div class="bg-gray-50 p-4 rounded">
                                    <h3 class="font-semibold text-gray-700">"School Year"</h3>
                                </div>
                            </div>
                        </div>
                    }
                }).unwrap_or_else(|| view! {
                    <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-6">
                        "Student not found or invalid ID"
                    </div>
                })}
            </Suspense>

            //View mode toggle
            <div class="flex justify-center mb-6">
                <div class="bg-white rounded-xl shadow-lg p-2 border border-slate-200">
                    <div class="flex space-x-2">
                        <button
                            class=move || {
                                if view_mode.get() == "overview" {
                                    "px-6 py-2 bg-blue-500 text-white rounded-lg font-medium transition-all duration-200"
                                } else {
                                    "px-6 py-2 text-slate-600 hover:text-slate-800 rounded-lg font-medium transition-all duration-200"
                                }
                            }
                            on:click=move |_| set_view_mode("overview".to_string())
                        >
                            "Overview"
                        </button>
                        <button
                            class=move || {
                                if view_mode.get() == "sequence" {
                                    "px-6 py-2 bg-blue-500 text-white rounded-lg font-medium transition-all duration-200"
                                } else {
                                    "px-6 py-2 text-slate-600 hover:text-slate-800 rounded-lg font-medium transition-all duration-200"
                                }
                            }
                            on:click=move |_| set_view_mode("sequence".to_string())
                        >
                            "Assessment Progress"
                        </button>
                        <button
                            class=move || {
                                if view_mode.get() == "detailed" {
                                    "px-6 py-2 bg-blue-500 text-white rounded-lg font-medium transition-all duration-200"
                                } else {
                                    "px-6 py-2 text-slate-600 hover:text-slate-800 rounded-lg font-medium transition-all duration-200"
                                }
                            }
                            on:click=move |_| set_view_mode("detailed".to_string())
                        >
                            "Detailed View"
                        </button>
                    </div>
                </div>
            </div>

            // Overview Section
            <Suspense fallback=move || view! {
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 animate-pulse">
                    <div class="h-6 bg-gray-200 rounded w-1/4 mb-6"></div>
                    <div class="space-y-3">
                        <div class="h-4 bg-gray-200 rounded w-full"></div>
                        <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                    </div>
                </div>
            }>
                {move || {
                    let results = enhanced_student_data.get().map(|(results, _)| results);
                    match results {
                        Some(data) => {
                            let test_history = data.test_history.clone();

                            if view_mode.get() == "overview" {
                                // Create signals for the overview controls
                                let (search_query, set_search_query) = signal(String::new());
                                let (selected_timeframe, set_selected_timeframe) = signal(TimeFrame::AllTime);
                                let (selected_sort, set_selected_sort) = signal(SortOption::DateDesc);

                                // Filter and sort logic
                                let filtered_and_sorted_tests = Memo::new(move |_| {
                                    let mut tests = test_history.clone();
                                    let query = search_query.get().to_lowercase();
                                    let timeframe = selected_timeframe.get();
                                    let sort = selected_sort.get();

                                    // Filter by search query
                                    if !query.is_empty() {
                                        tests = tests.into_iter()
                                            .filter(|test| {
                                                test.test_name.to_lowercase().contains(&query) ||
                                                test.performance_class.to_lowercase().contains(&query) ||
                                                test.evaluator.to_lowercase().contains(&query)
                                            })
                                            .collect();
                                    }

                                    // Filter by timeframe
                                    if timeframe != TimeFrame::AllTime {
                                        let days_back = match timeframe {
                                            TimeFrame::LastWeek => 7,
                                            TimeFrame::LastMonth => 30,
                                            TimeFrame::Last3Months => 90,
                                            TimeFrame::LastYear => 365,
                                            TimeFrame::AllTime => unreachable!(),
                                        };

                                        let cutoff_date = chrono::Utc::now() - chrono::Duration::days(days_back);
                                        tests = tests.into_iter()
                                            .filter(|test| test.date_administered >= cutoff_date)
                                            .collect();
                                    }

                                    // Sort
                                    match sort {
                                        SortOption::DateDesc => tests.sort_by(|a, b| b.date_administered.cmp(&a.date_administered)),
                                        SortOption::DateAsc => tests.sort_by(|a, b| a.date_administered.cmp(&b.date_administered)),
                                        SortOption::ScoreDesc => tests.sort_by(|a, b| {
                                            let a_percent = (a.score as f32 / a.total_possible as f32) * 100.0;
                                            let b_percent = (b.score as f32 / b.total_possible as f32) * 100.0;
                                            b_percent.partial_cmp(&a_percent).unwrap_or(std::cmp::Ordering::Equal)
                                        }),
                                        SortOption::ScoreAsc => tests.sort_by(|a, b| {
                                            let a_percent = (a.score as f32 / a.total_possible as f32) * 100.0;
                                            let b_percent = (b.score as f32 / b.total_possible as f32) * 100.0;
                                            a_percent.partial_cmp(&b_percent).unwrap_or(std::cmp::Ordering::Equal)
                                        }),
                                        SortOption::TestNameAsc => tests.sort_by(|a, b| a.test_name.cmp(&b.test_name)),
                                        SortOption::TestNameDesc => tests.sort_by(|a, b| b.test_name.cmp(&a.test_name)),
                                    }

                                    tests
                                });

                                view! {
                                    <div class="space-y-6">
                                        // Header section
                                        <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:justify-between sm:space-y-0">
                                            <div>
                                                <h2 class="text-2xl font-semibold text-gray-900">"Recent Tests"</h2>
                                                <p class="mt-1 text-sm text-gray-600">
                                                    "Track test performance and progress over time"
                                                </p>
                                            </div>
                                        </div>

                                        // Controls section
                                        <div class="flex flex-col space-y-4 sm:flex-row sm:items-center sm:space-y-0 sm:space-x-4">
                                            <div class="flex-1 max-w-md">
                                                // Search bar
                                                <div class="relative">
                                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                                        <svg
                                                            class="h-4 w-4 text-gray-400"
                                                            fill="none"
                                                            viewBox="0 0 24 24"
                                                            stroke="currentColor"
                                                        >
                                                            <path
                                                                stroke-linecap="round"
                                                                stroke-linejoin="round"
                                                                stroke-width="2"
                                                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                                                            />
                                                        </svg>
                                                    </div>
                                                    <input
                                                        type="text"
                                                        placeholder="Search tests, evaluators..."
                                                        class="block w-full pl-10 pr-3 py-2.5 border border-gray-200 rounded-lg text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 bg-white"
                                                        prop:value=search_query
                                                        on:input=move |ev| {
                                                            set_search_query(event_target_value(&ev));
                                                        }
                                                    />
                                                </div>
                                            </div>
                                            <div class="flex space-x-3">
                                                // Time frame selector
                                                <div class="relative">
                                                    <select
                                                        class="appearance-none bg-white border border-gray-200 rounded-lg px-4 py-2.5 pr-8 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 cursor-pointer"
                                                        on:change=move |ev| {
                                                            let value = event_target_value(&ev);
                                                            let timeframe = match value.as_str() {
                                                                "7" => TimeFrame::LastWeek,
                                                                "30" => TimeFrame::LastMonth,
                                                                "90" => TimeFrame::Last3Months,
                                                                "365" => TimeFrame::LastYear,
                                                                _ => TimeFrame::AllTime,
                                                            };
                                                            set_selected_timeframe(timeframe);
                                                        }
                                                    >
                                                        <option value="all">"All time"</option>
                                                        <option value="7">"Last 7 days"</option>
                                                        <option value="30">"Last 30 days"</option>
                                                        <option value="90">"Last 90 days"</option>
                                                        <option value="365">"Last year"</option>
                                                    </select>
                                                    <div class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none">
                                                        <svg class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                                        </svg>
                                                    </div>
                                                </div>
                                                // Sort selector
                                                <div class="relative">
                                                    <select
                                                        class="appearance-none bg-white border border-gray-200 rounded-lg px-4 py-2.5 pr-8 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 cursor-pointer"
                                                        on:change=move |ev| {
                                                            let value = event_target_value(&ev);
                                                            let sort = match value.as_str() {
                                                                "date_asc" => SortOption::DateAsc,
                                                                "score_desc" => SortOption::ScoreDesc,
                                                                "score_asc" => SortOption::ScoreAsc,
                                                                "name_asc" => SortOption::TestNameAsc,
                                                                "name_desc" => SortOption::TestNameDesc,
                                                                _ => SortOption::DateDesc,
                                                            };
                                                            set_selected_sort(sort);
                                                        }
                                                    >
                                                        <option value="date_desc">"Newest first"</option>
                                                        <option value="date_asc">"Oldest first"</option>
                                                        <option value="score_desc">"Highest score"</option>
                                                        <option value="score_asc">"Lowest score"</option>
                                                        <option value="name_asc">"Test name A-Z"</option>
                                                        <option value="name_desc">"Test name Z-A"</option>
                                                    </select>
                                                    <div class="absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none">
                                                        <svg class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        // Table section
                                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm flex flex-col" style="height: 400px; min-height: 400px;">
                                            {move || {
                                                let tests = filtered_and_sorted_tests.get();
                                                let test_count = tests.len();

                                                if tests.is_empty() {
                                                    view! {
                                                        <>
                                                            <div class="flex-1 flex items-center justify-center p-12">
                                                                <div class="text-center">
                                                                    <div class="w-12 h-12 mx-auto mb-4 bg-gray-100 rounded-full flex items-center justify-center">
                                                                        <svg class="w-6 h-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                                                        </svg>
                                                                    </div>
                                                                    <h3 class="text-lg font-medium text-gray-900 mb-1">"No tests found"</h3>
                                                                    <p class="text-gray-500 text-sm">"Try adjusting your search or time frame filters."</p>
                                                                </div>
                                                            </div>
                                                        </>
                                                    }
                                                } else {
                                                    view! {
                                                        <>
                                                            // Header with test count - fixed at top
                                                            <div class="flex-shrink-0 px-6 py-3 bg-gray-50 border-b border-gray-200 rounded-t-xl">
                                                                <div class="flex items-center justify-between">
                                                                    <span class="text-sm font-medium text-gray-700">
                                                                        {format!("{} test{} found", test_count, if test_count == 1 { "" } else { "s" })}
                                                                    </span>
                                                                </div>
                                                            </div>

                                                            // Scrollable table content
                                                            <div class="flex-1 overflow-auto">
                                                                <div class="overflow-x-auto h-full">
                                                                    <table class="min-w-full divide-y divide-gray-200">
                                                                        <thead class="bg-gray-50 sticky top-0 z-10">
                                                                            <tr>
                                                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                                                    "Test"
                                                                                </th>
                                                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                                                    "Score"
                                                                                </th>
                                                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                                                    "Performance"
                                                                                </th>
                                                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                                                    "Evaluator"
                                                                                </th>
                                                                                <th scope="col" class="px-6 py-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                                                    "Date"
                                                                                </th>
                                                                            </tr>
                                                                        </thead>
                                                                        <tbody class="bg-white divide-y divide-gray-200">
                                                                            {tests.into_iter().map(|test| {
                                                                                let score_percentage = (test.score as f32 / test.total_possible as f32) * 100.0;
                                                                                let evaluator_name = test.evaluator.clone();

                                                                                // Get test data for benchmark categories using test_id for accurate matching
                                                                                let test_data = tests_resource.get()
                                                                                    .and_then(|result| result)
                                                                                    .and_then(|tests| tests.iter().find(|t| t.test_id == test.test_id).cloned());

                                                                                let benchmark_categories = test_data.as_ref().and_then(|t| t.benchmark_categories.as_ref());

                                                                                // Get benchmark-based colors using ColorUtils
                                                                                let badge_classes = ColorUtils::get_badge_classes_for_score(
                                                                                    test.score,
                                                                                    test.total_possible,
                                                                                    benchmark_categories
                                                                                );
                                                                                let benchmark_label = ScoreUtils::get_benchmark_label(
                                                                                    test.score,
                                                                                    test.total_possible,
                                                                                    benchmark_categories
                                                                                );
                                                                                let score_text_color = ColorUtils::get_score_text_color_for_score(
                                                                                    test.score,
                                                                                    test.total_possible,
                                                                                    benchmark_categories
                                                                                );
                                                                                let progress_bar_color = ColorUtils::get_progress_bar_color_for_score(
                                                                                    test.score,
                                                                                    test.total_possible,
                                                                                    benchmark_categories
                                                                                );

                                                                                view! {
                                                                                    <tr class="hover:bg-gray-50 transition-colors duration-150">
                                                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                                                            <div class="text-sm font-medium text-gray-900">
                                                                                                {test.test_name}
                                                                                            </div>
                                                                                        </td>
                                                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                                                            <div class="flex items-center space-x-3">
                                                                                                <div class="flex-shrink-0">
                                                                                                    <span class={score_text_color}>
                                                                                                        {test.score}
                                                                                                    </span>
                                                                                                    <span class="text-sm text-gray-400 ml-1">
                                                                                                        "/" {test.total_possible}
                                                                                                    </span>
                                                                                                </div>
                                                                                                <div class="flex-1 min-w-0">
                                                                                                    <div class="w-16 bg-gray-200 rounded-full h-1.5">
                                                                                                        <div
                                                                                                            class={progress_bar_color}
                                                                                                            style=format!("width: {}%", score_percentage.min(100.0))
                                                                                                        ></div>
                                                                                                    </div>
                                                                                                </div>
                                                                                            </div>
                                                                                        </td>
                                                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                                                            <span class={format!("inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium {}", badge_classes)}>
                                                                                                {benchmark_label}
                                                                                            </span>
                                                                                        </td>
                                                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                                                            <div class="text-sm text-gray-900 font-medium">
                                                                                                {if evaluator_name.is_empty() {
                                                                                                    "Not specified".to_string()
                                                                                                } else {
                                                                                                    evaluator_name
                                                                                                }}
                                                                                            </div>
                                                                                        </td>
                                                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                                                            {format!("{}", test.date_administered.format("%b %d, %Y"))}
                                                                                        </td>
                                                                                    </tr>
                                                                                }
                                                                            }).collect::<Vec<_>>()}
                                                                        </tbody>
                                                                    </table>
                                                                </div>
                                                            </div>
                                                        </>
                                                    }
                                                }
                                            }}
                                        </div>
                                    </div>
                                }
                            } else {
                                view! { <div></div> }
                            }
                        },
                        None => view! { <div></div> }
                    }
                }}
            </Suspense>

            // Progress Overview Section
            <Suspense fallback=move || view! {
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 animate-pulse">
                    <div class="h-6 bg-gray-200 rounded w-1/4 mb-6"></div>
                    <div class="space-y-3">
                        <div class="h-4 bg-gray-200 rounded w-full"></div>
                        <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                    </div>
                </div>
            }>
                {move || {
                    let results = enhanced_student_data.get().map(|(results, _)| results);
                    match results {
                        Some(data) => {
                            if view_mode.get() == "sequence" {
                                let assessments = data.assessment_summaries.clone();

                                view! {
                                    <ProgressOverviewTab
                                        assessments=assessments
                                        tests_resource=tests_resource
                                    />
                                }.into_any()
                            } else {
                                view! { <div></div> }.into_any()
                            }
                        },
                        None => view! { <div></div> }.into_any()
                    }
                }}
            </Suspense>

            // Compact Progress Cards Section - Show in detailed view only
            <Suspense fallback=move || view! { <div>"Loading compact progress..."</div> }>
                {move || {
                    let results = enhanced_student_data.get().map(|(results, _)| results);
                    match results {
                        Some(data) => {
                            let assessments = data.assessment_summaries.clone();

                            if view_mode.get() == "detailed" && !assessments.is_empty() {
                                view! {
                                    <div class="mb-6">
                                        <h2 class="text-xl font-bold text-slate-800 mb-4">"Quick Progress Summary"</h2>
                                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                            {assessments.iter().map(|assessment| {
                                                view! {
                                                    <CompactStripeProgress
                                                        assessment_name={assessment.assessment_name.clone()}
                                                        current_score={assessment.current_score}
                                                        total_possible={assessment.total_possible}
                                                        test_details={assessment.test_details.clone()}
                                                    />
                                                }
                                            }).collect::<Vec<_>>()}
                                        </div>
                                    </div>
                                }
                            } else {
                                view! { <div></div> }
                            }
                        },
                        None => view! { <div></div> }
                    }
                }}
            </Suspense>

            // Performance Summary Section - Show only in detailed view
            {move || {
                if view_mode.get() == "detailed" {
                    view! {
                        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                            <h2 class="text-xl font-bold mb-4">"Performance Summary"</h2>
                            <Suspense fallback=move || view! { <div>"Loading summary data..."</div> }>
                                {move || {
                                    let results = enhanced_student_data.get().map(|(results, _)| results);
                                    match results {
                                        Some(data) => {
                                            let assessments = data.assessment_summaries.clone();
                                            let assessments_clone = assessments.clone();
                                            if assessments.is_empty() {
                                                view! { <div class="text-gray-600">"No assessment data available"</div> }
                                            } else {
                                                view! {
                                                    <div class="overflow-x-auto">
                                                        <table class="min-w-full bg-white">
                                                            <thead class="bg-gray-100">
                                                                <tr>
                                                                    <th class="py-2 px-4 text-left">"Assessment Name"</th>
                                                                    <th class="py-2 px-4 text-left">"Subject"</th>
                                                                    <th class="py-2 px-4 text-left">"Total Possible"</th>
                                                                    <th class="py-2 px-4 text-left">"Current Score"</th>
                                                                    <th class="py-2 px-4 text-left">"Grade Level"</th>
                                                                    <th class="py-2 px-4 text-left">"Performance"</th>
                                                                    <th class="py-2 px-4 text-left">"Status"</th>
                                                                    <th class="py-2 px-4 text-left">"Action"</th>
                                                                </tr>
                                                            </thead>
                                                            <tbody>
                                                                {assessments.into_iter().map(|assessment| {
                                                                    let assessment_id = assessment.assessment_id.clone();
                                                                    let assessment_id_for_button = assessment_id.clone();
                                                                    let assessment_id_for_details = assessment_id.clone();
                                                                    let assessment_id_for_closure = assessment_id.clone();
                                                                    let progress_clone = assessment.progress.clone();

                                                                    // Pre-clone all the values that will be used inside closures
                                                                    let test_details = assessment.test_details.clone();
                                                                    let distribution_data = assessment.distribution_data.clone();
                                                                    let assessment_rating = assessment.assessment_rating.clone();
                                                                    let assessment_current_score = assessment.current_score;
                                                                    let assessment_total_possible = assessment.total_possible;
                                                                    let test_details_len = assessment.test_details.len();

                                                                    view! {
                                                                        <>
                                                                            <tr class="border-t hover:bg-gray-50">
                                                                                <td class="py-3 px-4">{assessment.assessment_name}</td>
                                                                                <td class="py-3 px-4">{assessment.subject}</td>
                                                                                <td class="py-3 px-4">
                                                                                    {assessment.total_possible.map(|score| score.to_string()).unwrap_or_else(|| "N/A".to_string())}
                                                                                </td>
                                                                                <td class="py-3 px-4">{assessment.current_score}</td>
                                                                                <td class="py-3 px-4">{assessment.grade_level.unwrap_or_else(|| "Any".to_string())}</td>

                                                                                <td class="py-3 px-4">{assessment.assessment_rating}</td>
                                                                                <td class="py-3 px-4">
                                                                                    <span class=move || {
                                                                                        match progress_clone {
                                                                                            Progress::Completed => "px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs",
                                                                                            Progress::Ongoing => "px-2 py-1 bg-yellow-100 text-yellow-800 rounded-full text-xs",
                                                                                            Progress::NotStarted => "px-2 py-1 bg-gray-100 text-gray-800 rounded-full text-xs",
                                                                                        }
                                                                                    }>
                                                                                        {format!("{}", assessment.progress)}
                                                                                    </span>
                                                                                </td>
                                                                                <td class="py-3 px-4">
                                                                                    <button
                                                                                        class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
                                                                                        on:click=move |_| {
                                                                                            if expanded_assessment.get() == Some(assessment_id_for_button.clone()) {
                                                                                                set_expanded_assessment(None);
                                                                                            } else {
                                                                                                set_expanded_assessment(Some(assessment_id_for_button.clone()));
                                                                                            }
                                                                                        }
                                                                                    >
                                                                                        {move || {
                                                                                            if expanded_assessment.get() == Some(assessment_id_for_closure.clone()) {
                                                                                                "Hide Details"
                                                                                            } else {
                                                                                                "Show Details"
                                                                                            }
                                                                                        }}
                                                                                    </button>
                                                                                </td>
                                                                            </tr>
                                                                        </>
                                                                    }
                                                                }).collect::<Vec<_>>()}
                                                            </tbody>
                                                        </table>

                                                        {/* Assessment details display outside of the main table */}
                                                        {assessments_clone.into_iter().map(|assessment| {
                                                            let assessment_id = assessment.assessment_id.clone();
                                                            let assessment_name = assessment.assessment_name.clone();

                                                            // Pre-clone all the values that will be used inside closures
                                                            let test_details = assessment.test_details.clone();
                                                            let distribution_data = assessment.distribution_data.clone();
                                                            let assessment_rating = assessment.assessment_rating.clone();
                                                            let assessment_current_score = assessment.current_score;
                                                            let assessment_total_possible = assessment.total_possible;
                                                            let test_details_len = assessment.test_details.len();

                                                            view! {
                                                                {move || {
                                                                    if expanded_assessment.get() == Some(assessment_id.clone()) {
                                                                        let test_details_clone = test_details.clone();
                                                                        // Create a local clone of assessment_rating to avoid moving it
                                                                        let assessment_rating_clone = assessment_rating.clone();
                                                                        let rating = assessment_rating_clone.clone();

                                                                        view! {
                                                                            <div class="mt-4 mb-8 bg-gray-50 border rounded-lg p-4 shadow">
                                                                                <h3 class="font-semibold text-lg mb-2 text-blue-600">
                                                                                    {format!("{} Details", assessment_name)}
                                                                                </h3>

                                                                                <div class="mb-4">
                                                                                    <h4 class="font-semibold mb-2">{"Subtests Performance"}</h4>
                                                                                    {if test_details_clone.is_empty() {
                                                                                        view! { <div><p class="text-gray-500">"No test data available for this assessment"</p></div> }
                                                                                    } else {
                                                                                        view! {
                                                                                            <div class="overflow-x-auto">
                                                                                                <table class="min-w-full bg-white border">
                                                                                                    <thead class="bg-gray-100">
                                                                                                        <tr>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Test Name"</th>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Score"</th>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Total"</th>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Test Area"</th>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Taken"</th>
                                                                                                            <th class="py-2 px-3 text-left text-sm">"Performance"</th>
                                                                                                        </tr>
                                                                                                    </thead>
                                                                                                    <tbody>
                                                                                                        {test_details_clone.iter().map(|test| {
                                                                                                            // Get test data for benchmark categories
                                                                                                            let test_data = tests_resource.get()
                                                                                                                .and_then(|result| result)
                                                                                                                .and_then(|tests| tests.iter().find(|t| t.test_id == test.test_id).cloned());

                                                                                                            let benchmark_categories = test_data.as_ref().and_then(|t| t.benchmark_categories.as_ref());

                                                                                                            // Get benchmark-based colors for the detailed view too
                                                                                                            let badge_classes = ColorUtils::get_badge_classes_for_score(
                                                                                                                test.score,
                                                                                                                test.total_possible,
                                                                                                                benchmark_categories
                                                                                                            );
                                                                                                            let score_text_color = ColorUtils::get_score_text_color_for_score(
                                                                                                                test.score,
                                                                                                                test.total_possible,
                                                                                                                benchmark_categories
                                                                                                            );

                                                                                                            view! {
                                                                                                                <tr class="border-t">
                                                                                                                    <td class="py-2 px-3 text-sm">{test.test_name.clone()}</td>
                                                                                                                    <td class="py-2 px-3 text-sm">
                                                                                                                        <span class={score_text_color}>
                                                                                                                            {test.score}
                                                                                                                        </span>
                                                                                                                    </td>
                                                                                                                    <td class="py-2 px-3 text-sm">{test.total_possible}</td>
                                                                                                                    <td class="py-2 px-3 text-sm">{test.test_area.clone()}</td>
                                                                                                                    <td class="py-2 px-3 text-sm">{format!("{}", test.date_administered.format("%Y-%m-%d"))}</td>
                                                                                                                    <td class="py-2 px-3 text-sm">
                                                                                                                        <span class={format!("px-2 py-1 rounded-full text-xs {}", badge_classes)}>
                                                                                                                            {ScoreUtils::get_benchmark_label(
                                                                                                                                test.score,
                                                                                                                                test.total_possible,
                                                                                                                                benchmark_categories
                                                                                                                            )}
                                                                                                                        </span>
                                                                                                                    </td>
                                                                                                                </tr>
                                                                                                            }
                                                                                                        }).collect::<Vec<_>>()}
                                                                                                    </tbody>
                                                                                                </table>
                                                                                            </div>
                                                                                        }
                                                                                    }}
                                                                                </div>

                                                                                // Replaced old charts with new Chart.js component
                                                                                <div class="mt-6">
                                                                                    <h4 class="font-semibold mb-4">"Assessment Performance Charts"</h4>
                                                                                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                                                                        // Performance Distribution Chart
                                                                                        <PerformanceDistributionChart
                                                                                            distribution_data={distribution_data.clone()}
                                                                                            chart_id={format!("expanded-dist-{}", assessment_id)}
                                                                                            title="Performance Categories".to_string()
                                                                                        />

                                                                                        // Overall assessment rating display
                                                                                        <div class="bg-white rounded-lg border p-6 flex flex-col items-center justify-center">
                                                                                            <h5 class="text-sm font-medium text-gray-500 mb-2">"Overall Assessment Rating"</h5>
                                                                                            <div class=move || {
                                                                                                // Use the cloned value to avoid moving
                                                                                                let color_class = if rating.contains("Above") || rating.contains("High") {
                                                                                                    "text-4xl font-bold text-green-600"
                                                                                                } else if rating.contains("Average") || rating.contains("On Track") {
                                                                                                    "text-4xl font-bold text-blue-600"
                                                                                                } else if rating.contains("Below") || rating.contains("Risk") {
                                                                                                    "text-4xl font-bold text-red-600"
                                                                                                } else {
                                                                                                    "text-4xl font-bold text-gray-600"
                                                                                                };
                                                                                                color_class
                                                                                            }>
                                                                                                {&assessment_rating_clone}
                                                                                            </div>
                                                                                            <div class="mt-2 text-sm text-gray-600">
                                                                                                "Based on " {test_details_len} " completed tests"
                                                                                            </div>
                                                                                            <div class="mt-4 flex items-center w-full">
                                                                                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                                                                                    <div
                                                                                                        class=move || {
                                                                                                            let score_percent = if let Some(total) = assessment_total_possible {
                                                                                                                (assessment_current_score as f32 / total as f32 * 100.0) as i32
                                                                                                            } else {
                                                                                                                0
                                                                                                            };

                                                                                                            if score_percent >= 80 {
                                                                                                                "bg-green-600 h-2.5 rounded-full"
                                                                                                            } else if score_percent >= 60 {
                                                                                                                "bg-yellow-400 h-2.5 rounded-full"
                                                                                                            } else {
                                                                                                                "bg-red-600 h-2.5 rounded-full"
                                                                                                            }
                                                                                                        }
                                                                                                        style=move || {
                                                                                                            let percent = if let Some(total) = assessment_total_possible {
                                                                                                                let p = (assessment_current_score as f32 / total as f32 * 100.0) as i32;
                                                                                                                p.min(100)
                                                                                                            } else {
                                                                                                                0
                                                                                                            };
                                                                                                            format!("width: {}%", percent)
                                                                                                        }
                                                                                                    ></div>
                                                                                                </div>
                                                                                            </div>
                                                                                            <div class="mt-1 text-xs">
                                                                                                {assessment_current_score}
                                                                                                {assessment_total_possible.map(|t| format!(" / {}", t)).unwrap_or_else(|| String::new())}
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        }
                                                                    } else {
                                                                        view! { <div></div> }
                                                                    }
                                                                }}
                                                            }
                                                        }).collect::<Vec<_>>()}
                                                    </div>
                                                }
                                            }
                                        },
                                        None => view! { <div class="text-gray-600">"No assessment data available"</div> }
                                    }
                                }}
                            </Suspense>
                        </div>
                    }
                } else {
                    view! { <div></div> }
                }
            }}
        </div>
    }
}

// Helper function to calculate overall distribution across all assessments
fn calculate_overall_distribution(assessments: &[AssessmentSummary]) -> Vec<(String, i32)> {
    let mut distribution_map: std::collections::HashMap<String, i32> =
        std::collections::HashMap::new();

    for assessment in assessments {
        for (category, count) in &assessment.distribution_data {
            *distribution_map.entry(category.clone()).or_insert(0) += count;
        }
    }

    distribution_map.into_iter().collect()
}
use crate::app::components::Header;
use crate::app::models::user::SessionUser;
use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;

#[component]
pub fn HomePage() -> impl IntoView {
    // Access the auth context signals directly
    let current_user =
        use_context::<ReadSignal<Option<SessionUser>>>().expect("Auth context not found");
    let loading = use_context::<ReadSignal<bool>>().expect("Auth context not found");

    view! {
        <Suspense fallback=move || view! { <p>"Loading..."</p> }>
            {move || {
                // If not loading and user is already logged in, redirect to dashboard
                if !loading.get() && current_user.get().is_some() {
                    view! { <Redirect path="/dashboard"/> }
                } else {
                    // Otherwise, show the enhanced homepage content
                    view! {
                        <div class="bg-[#F9F9F8] min-h-screen flex flex-col">
                            <Header />

                            // Hero Section
                            <main id="main-content" role="main" class="flex-1">
                                <section class="relative overflow-hidden">
                                    <div class="max-w-8xl mx-auto px-10">
                                        <div class="h-screen items-center justify-center rounded-2xl flex-col relative overflow-hidden">
                                            // Multi-layered background
                                            <div class="absolute inset-0 bg-gradient-to-br from-slate-700 via-gray-600 to-stone-600"></div>
                                            <div class="absolute inset-0 bg-[url('/assets/home23.png')] bg-cover bg-center"></div>

                                            <div class="h-5/6 pt-20 ml-20 mt-30 relative z-10">
                                                <h1 class="text-6xl font-extrabold text-left text-white mt-20 mb-10 drop-shadow-lg leading-tight">
                                                    Simplify Testing.<br/>Put Teachers First.
                                                </h1>
                                                <p class="text-2xl font-medium text-left text-white mt-10 drop-shadow-md leading-relaxed max-w-2xl">
                                                    A complete testing platform with real-time sessions,<br/>
                                                    automated grading, and comprehensive analytics.
                                                </p>
                                                <div class="flex gap-4 mt-12">
                                                    <A href="/login" class="font-semibold text-white">
                                                        <div class="bg-[#2E3A59] rounded-2xl border-white border-2 px-8 py-4 hover:bg-[#3a4660] transition-all duration-300 shadow-xl hover:shadow-2xl transform hover:-translate-y-1">
                                                            "Get Started"
                                                            <img src="/assets/arrow.png" alt="arrow" class="inline h-6 w-6 ml-2" />
                                                        </div>
                                                    </A>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </section>

                                // Core Features Section - Based on actual routes
                                <section class="py-24 bg-white">
                                    <div class="max-w-7xl mx-auto px-10">
                                        <div class="text-center mb-20">
                                            <h2 class="text-5xl font-bold text-gray-900 mb-6">
                                                "Complete testing solution"
                                            </h2>
                                            <p class="text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed">
                                                "From test creation to real-time administration and detailed analytics - everything you need in one integrated platform."
                                            </p>
                                        </div>

                                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                                            // Test Builder Feature
                                            <div class="bg-gradient-to-br from-blue-50 to-indigo-100 rounded-3xl p-8 h-full">
                                                <div class="w-16 h-16 bg-blue-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Advanced Test Builder"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Create sophisticated assessments with multiple question types, test variations, and custom templates including flashcard sets and grid tests."
                                                </p>
                                            </div>

                                            // Real-time Testing Feature
                                            <div class="bg-gradient-to-br from-green-50 to-emerald-100 rounded-3xl p-8 h-full">
                                                <div class="w-16 h-16 bg-green-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Live Test Sessions"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Administer tests in real-time with live monitoring, instant feedback, and support for both authenticated and anonymous student participation."
                                                </p>
                                            </div>

                                            // Gradebook & Analytics Feature
                                            <div class="bg-gradient-to-br from-purple-50 to-pink-100 rounded-3xl p-8 h-full">
                                                <div class="w-16 h-16 bg-purple-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012-2z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Comprehensive Gradebook"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Track student progress with detailed analytics, automated grading, and comprehensive reporting across all assessments and test sessions."
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </section>

                                // Platform Workflow Section
                                <section class="py-24 bg-gray-50">
                                    <div class="max-w-7xl mx-auto px-10">
                                        <div class="text-center mb-16">
                                            <h2 class="text-4xl font-bold text-gray-900 mb-6">
                                                "How it works"
                                            </h2>
                                            <p class="text-xl text-gray-600 max-w-2xl mx-auto">
                                                "A streamlined workflow from test creation to results analysis"
                                            </p>
                                        </div>

                                        <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                                            // Step 1
                                            <div class="text-center">
                                                <div class="w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mx-auto mb-6 text-white font-bold text-xl">
                                                    "1"
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-3">"Build Tests"</h3>
                                                <p class="text-gray-600 text-sm leading-relaxed">
                                                    "Use our test builder to create assessments with multiple question types and variations"
                                                </p>
                                            </div>

                                            // Step 2
                                            <div class="text-center">
                                                <div class="w-16 h-16 bg-green-600 rounded-full flex items-center justify-center mx-auto mb-6 text-white font-bold text-xl">
                                                    "2"
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-3">"Launch Sessions"</h3>
                                                <p class="text-gray-600 text-sm leading-relaxed">
                                                    "Start real-time test sessions with live monitoring and student management"
                                                </p>
                                            </div>

                                            // Step 3
                                            <div class="text-center">
                                                <div class="w-16 h-16 bg-purple-600 rounded-full flex items-center justify-center mx-auto mb-6 text-white font-bold text-xl">
                                                    "3"
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-3">"Monitor & Grade"</h3>
                                                <p class="text-gray-600 text-sm leading-relaxed">
                                                    "Track progress in real-time with automatic grading and immediate feedback"
                                                </p>
                                            </div>

                                            // Step 4
                                            <div class="text-center">
                                                <div class="w-16 h-16 bg-indigo-600 rounded-full flex items-center justify-center mx-auto mb-6 text-white font-bold text-xl">
                                                    "4"
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-3">"Analyze Results"</h3>
                                                <p class="text-gray-600 text-sm leading-relaxed">
                                                    "Review detailed analytics and generate comprehensive reports"
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </section>

                                // Test Format Showcase
                                <section class="py-24 bg-white">
                                    <div class="max-w-7xl mx-auto px-10">
                                        <div class="text-center mb-16">
                                            <h2 class="text-4xl font-bold text-gray-900 mb-6">
                                                "Multiple test formats supported"
                                            </h2>
                                            <p class="text-xl text-gray-600 max-w-3xl mx-auto">
                                                "Create engaging assessments that fit your teaching style and learning objectives"
                                            </p>
                                        </div>

                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                                            // Flashcard Sets
                                            <div class="bg-gradient-to-br from-orange-50 to-red-100 rounded-3xl p-8">
                                                <div class="w-16 h-16 bg-orange-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Interactive Flashcard Sets"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Create digital flashcard assessments perfect for vocabulary, definitions, and quick recall exercises with immediate feedback."
                                                </p>
                                            </div>

                                            // Grid Tests
                                            <div class="bg-gradient-to-br from-teal-50 to-cyan-100 rounded-3xl p-8">
                                                <div class="w-16 h-16 bg-teal-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Advanced Grid Tests"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Design complex grid-based assessments ideal for mathematical problems, data analysis, and structured response formats."
                                                </p>
                                            </div>

                                            // Live Testing Sessions
                                            <div class="bg-gradient-to-br from-yellow-50 to-amber-100 rounded-3xl p-8">
                                                <div class="w-16 h-16 bg-yellow-600 rounded-2xl flex items-center justify-center mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path d="M17 19a1 1 0 0 1-1-1v-2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2a1 1 0 0 1-1 1z"/>
                                                        <path d="M17 21v-2"/>
                                                        <path d="M19 14V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V10"/>
                                                        <path d="M21 21v-2"/>
                                                        <path d="M3 5V3"/>
                                                        <path d="M4 10a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2z"/>
                                                        <path d="M7 5V3"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-2xl font-bold text-gray-900 mb-4">"Real-Time Live Testing"</h3>
                                                <p class="text-gray-600 leading-relaxed">
                                                    "Take your tests live with the click of a button: real-time testing across multiple your devices."
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </section>

                                // Role-Based Access Section
                                <section class="py-24 bg-gray-50">
                                    <div class="max-w-7xl mx-auto px-10">
                                        <div class="text-center mb-16">
                                            <h2 class="text-4xl font-bold text-gray-900 mb-6">
                                                "Built for all educators"
                                            </h2>
                                            <p class="text-xl text-gray-600 max-w-2xl mx-auto">
                                                "Different interfaces and capabilities for teachers, administrators, and students"
                                            </p>
                                        </div>

                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                                            // Teacher Dashboard
                                            <div class="bg-white rounded-3xl p-8 shadow-lg border border-gray-100">
                                                <div class="w-16 h-16 bg-blue-600 rounded-2xl flex items-center justify-center mx-auto mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-4 text-center">"Teacher Dashboard"</h3>
                                                <ul class="text-gray-600 space-y-2 text-sm">
                                                    <li>"â€¢ Create and manage tests"</li>
                                                    <li>"â€¢ Launch live sessions"</li>
                                                    <li>"â€¢ Monitor student progress"</li>
                                                    <li>"â€¢ Access detailed gradebook"</li>
                                                    <li>"â€¢ Review test results"</li>
                                                </ul>
                                            </div>

                                            // Admin Panel
                                            <div class="bg-white rounded-3xl p-8 shadow-lg border border-gray-100">
                                                <div class="w-16 h-16 bg-purple-600 rounded-2xl flex items-center justify-center mx-auto mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-4 text-center">"Admin Controls"</h3>
                                                <ul class="text-gray-600 space-y-2 text-sm">
                                                    <li>"â€¢ Manage teachers and students"</li>
                                                    <li>"â€¢ Configure SAML authentication"</li>
                                                    <li>"â€¢ System-wide test administration"</li>
                                                    <li>"â€¢ Advanced analytics dashboard"</li>
                                                    <li>"â€¢ Anonymized Student Data"</li>
                                                </ul>
                                            </div>

                                            // Student Experience
                                            <div class="bg-white rounded-3xl p-8 shadow-lg border border-gray-100">
                                                <div class="w-16 h-16 bg-green-600 rounded-2xl flex items-center justify-center mx-auto mb-6">
                                                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                                                    </svg>
                                                </div>
                                                <h3 class="text-xl font-semibold text-gray-900 mb-4 text-center">"Student Tracking"</h3>
                                                <ul class="text-gray-600 space-y-2 text-sm">
                                                    <li>"â€¢ Clean, distraction-free testing"</li>
                                                    <li>"â€¢ Anonymous or authenticated access"</li>
                                                    <li>"â€¢ Identify at risk students easily"</li>
                                                    <li>"â€¢ Design personalized progression plans"</li>
                                                    <li>"â€¢ Watch your students grow"</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </section>

                                // CTA Section
                                <section class="py-24 bg-gradient-to-br from-slate-700 via-gray-700 to-stone-700">
                                    <div class="max-w-4xl mx-auto px-10 text-center">
                                        <h2 class="text-5xl font-bold text-white mb-6">
                                            "Ready to streamline your testing?"
                                        </h2>
                                        <p class="text-xl text-white/90 mb-12 leading-relaxed">
                                            "Join educators who are already using our comprehensive platform to create, administer, and analyze tests with unprecedented ease and insight."
                                        </p>

                                        <div class="flex flex-col sm:flex-row gap-6 justify-center">
                                            <A href="/login" class="font-semibold">
                                                <div class="bg-white text-slate-700 rounded-2xl px-10 py-4 hover:bg-gray-100 transition-all duration-300 shadow-xl hover:shadow-2xl transform hover:-translate-y-1">
                                                    "Sign In to Get Started"
                                                </div>
                                            </A>
                                        </div>
                                    </div>
                                </section>
                            </main>
                        </div>
                    }.into_any()
                }
            }}
        </Suspense>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::header::Header;
use crate::app::components::student_page::bulk_upload_modal::BulkUploadModal;
use crate::app::components::student_page::student_search_filter::SearchFilter;
use crate::app::components::student_page::student_table::StudentTable;
use crate::app::components::student_page::update_student_form::UpdateStudent;
use crate::app::components::student_page::{
    add_student_form::AddStudentForm, student_details::StudentDetails,
};
use crate::app::models::student::{DeleteStudentRequest, ESLEnum, Student};
use crate::app::models::user::SessionUser;
use crate::app::server_functions::students::{delete_student, get_students};
use crate::app::server_functions::teachers::get_teachers;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use leptos::task::spawn_local;
use leptos_router::path;
use log::{debug, error, info};
use std::rc::Rc;

// Side panel styles - Updated for responsiveness and toggle behavior
const SIDE_PANEL_STYLE: &str = "lg:w-[30%] w-full h-[calc(100vh-2rem)] fixed lg:right-0 right-0 top-0 mt-10 p-5 lg:p-10 z-20 lg:z-10 transform transition-all duration-300 ease-in-out duration-300";
const SIDE_PANEL_STYLE_HIDDEN: &str = "w-0 h-[calc(100vh-2rem)] fixed lg:right-0 right-0 top-0 mt-10 overflow-hidden z-20 lg:z-10 transform transition-all duration-300 ease-in-out duration-300";

// Toggle button styles
const TOGGLE_BUTTON_STYLE: &str = "absolute left-0 top-1/2 -ml-8 bg-[#2E3A59] text-white p-2 rounded-l-md shadow-md hidden lg:flex items-center justify-center transition-all duration-300 transform";

// Table styles - Updated to be responsive to panel toggle
const TABLE_CONTAINER_STYLE_DEFAULT: &str = "w-full lg:w-[68%] fixed p-3 lg:p-5 h-[calc(100vh-2rem)] flex flex-col lg:ml-20 transition-all duration-300 ease-in-out overflow-hidden";
const TABLE_CONTAINER_STYLE_EXPANDED: &str = "w-full lg:w-[92%] fixed p-3 lg:p-5 h-[calc(100vh-2rem)] flex flex-col lg:ml-20 transition-all duration-300 ease-in-out overflow-hidden";

#[component]
pub fn StudentView() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/studentview">
            <StudentViewContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn StudentViewContent() -> impl IntoView {
    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not found");

    // Signals for gathering data from existing students
    let (refresh_trigger, set_refresh_trigger) = signal(0);
    let (selected_view, set_selected_view) = signal(SidebarSelected::StudentView);

    // Resource for fetching students
    let students = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            match get_students().await {
                Ok(students) => Some(students),
                Err(e) => {
                    log::error!("Failed to fetch students: {}", e);
                    None
                }
            }
        },
    );

    // Resource for fetching teachers
    let teachers = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            match get_teachers().await {
                Ok(teachers) => {
                    log::info!("Teachers fetched successfully: {} teachers", teachers.len());
                    Some(teachers)
                }
                Err(e) => {
                    log::error!("Failed to fetch teachers: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    // Selected student state
    let (selected_student, set_selected_student) = signal(None::<Rc<Student>>);

    // Editing state
    let (editing, set_editing) = signal(false);

    // Filter state signals
    let (search_term, set_search_term) = signal(String::new());
    let (grade_filter, set_grade_filter) = signal(String::from("all"));
    let (iep_filter, set_iep_filter) = signal(false);
    let (esl_filter, set_esl_filter) = signal(false);
    let (intervention_filter, set_intervention_filter) = signal(String::from("all"));
    let (teacher_filter, set_teacher_filter) = signal(String::from("all"));

    // Additional filter signals
    let (student_504_filter, set_student_504_filter) = signal(false);
    let (readplan_filter, set_readplan_filter) = signal(false);
    let (gt_filter, set_gt_filter) = signal(false);
    let (bip_filter, set_bip_filter) = signal(false);

    // Adding student state
    let (adding_student, set_adding_student) = signal(false);

    // Delete student confirmation state
    let (confirm_delete_one, set_confirm_delete_one) = signal(false);
    let (confirm_delete_two, set_confirm_delete_two) = signal(String::new());

    // Signal for showing bulk upload modal
    let (show_bulk_upload_modal, set_show_bulk_upload_modal) = signal(false);

    // Panel visibility control
    let (show_side_panel, set_show_side_panel) = signal(true);

    // Panel toggle for desktop view
    let (panel_expanded, set_panel_expanded) = signal(false);

    // Watch for selected student changes to show panel on mobile
    Effect::new(move |_| {
        if selected_student().is_some() || adding_student() || editing() {
            set_show_side_panel(true);
            set_panel_expanded(true);
        }
    });

    // Extract teacher names for the filter dropdown
    let teacher_names = Memo::new(move |_| {
        if let Some(Some(teacher_list)) = teachers.get() {
            teacher_list
                .iter()
                .map(|teacher| teacher.lastname.clone())
                .collect::<Vec<_>>()
        } else {
            vec![]
        }
    });

    // Handle student deletion
    let handle_delete_student = move |ev: SubmitEvent| {
        ev.prevent_default();
        let student_to_be_deleted = selected_student().unwrap();
        match confirm_delete_two().parse::<i32>() {
            Ok(validated_delete_two) => {
                if validated_delete_two == student_to_be_deleted.student_id {
                    let delete_student_request = DeleteStudentRequest::new(
                        student_to_be_deleted.firstname.clone().unwrap(),
                        student_to_be_deleted.lastname.clone().unwrap(),
                        validated_delete_two,
                    );

                    spawn_local(async move {
                        match delete_student(delete_student_request).await {
                            Ok(_) => {
                                set_refresh_trigger.update(|count| *count += 1);
                                set_selected_student(None);
                                set_confirm_delete_one(false);
                                set_show_side_panel(false); // Close panel on mobile after deletion
                            }
                            Err(e) => {
                                log::error!("Error deleting student: {:?}", e);
                                set_confirm_delete_one(false);
                            }
                        };
                    });
                } else {
                    set_confirm_delete_one(false);
                    log::info!("Delete was cancelled - ID mismatch");
                }
            }
            Err(e) => {
                log::error!("Invalid student ID entered: {:?}", e);
                set_confirm_delete_one(false);
            }
        }
    };

    // Handle adding a new student
    let handle_add_student = move |_| {
        set_selected_student(None);
        set_adding_student(true);
        set_editing(false);
        set_show_side_panel(true); // Show panel on mobile when adding
        set_panel_expanded(true); // Ensure panel is expanded
    };

    // Handle clearing all filters
    let handle_clear_filters = move |_| {
        set_search_term(String::new());
        set_grade_filter(String::from("all"));
        set_teacher_filter(String::from("all"));
        set_iep_filter(false);
        set_esl_filter(false);
        set_intervention_filter(String::from("all"));
        set_student_504_filter(false);
        set_readplan_filter(false);
        set_gt_filter(false);
        set_bip_filter(false);
    };

    // Grade filter transformer (converts "all" to empty string for matching logic)
    let transformed_grade_filter = Memo::new(move |_| {
        if grade_filter() == "all" {
            String::new()
        } else {
            grade_filter()
        }
    });

    // Intervention filter transformer (converts "all" to empty string for matching logic)
    let transformed_intervention_filter = Memo::new(move |_| {
        if intervention_filter() == "all" {
            String::new()
        } else {
            intervention_filter()
        }
    });

    view! {
        <div class="min-h-screen flex flex-col bg-[#F9F9F8]">
            <Header />
            <DashboardSidebar
                selected_item=selected_view
                set_selected_item=set_selected_view
            />

            // Delete confirmation modal
            <Show when=move || confirm_delete_one() && selected_student().is_some()>
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div class="bg-white p-4 md:p-6 rounded-lg shadow-xl max-w-md w-full mx-4">
                        <h3 class="text-xl font-bold mb-4">"Confirm Delete"</h3>
                        <p class="mb-4">
                            "To confirm deletion, please enter the student ID number: "
                            {selected_student().unwrap().student_id}
                        </p>
                        <form on:submit=handle_delete_student>
                            <input
                                type="text"
                                class="w-full p-2 border rounded mb-4"
                                placeholder="Enter student ID"
                                on:input=move |ev| set_confirm_delete_two(event_target_value(&ev))
                                required
                            />
                            <div class="flex justify-end gap-2">
                                <button
                                    type="button"
                                    class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                                    on:click=move |_| set_confirm_delete_one(false)
                                >
                                    "Cancel"
                                </button>
                                <button
                                    type="submit"
                                    class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                                >
                                    "Delete"
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </Show>

            {/* Bulk Upload Modal */}
            <Show when=move || show_bulk_upload_modal()>
                <BulkUploadModal
                    set_show_modal=set_show_bulk_upload_modal
                    set_refresh_trigger=set_refresh_trigger
                />
            </Show>

            // Main content area with dynamic width based on panel state
            <div class=move || {
                if panel_expanded() {
                    TABLE_CONTAINER_STYLE_DEFAULT.to_string()
                } else {
                    TABLE_CONTAINER_STYLE_EXPANDED.to_string()
                }
            }>
                // Search and filter component
                <div class="flex-shrink-0">
                    <SearchFilter
                        set_search_term=set_search_term
                        set_grade_filter=set_grade_filter
                        set_teacher_filter=set_teacher_filter
                        set_iep_filter=set_iep_filter
                        set_esl_filter=set_esl_filter
                        set_intervention_filter=set_intervention_filter
                        set_student_504_filter=set_student_504_filter
                        set_readplan_filter=set_readplan_filter
                        set_gt_filter=set_gt_filter
                        set_bip_filter=set_bip_filter
                        search_term=search_term
                        teachers=Signal::derive(move || teacher_names())
                        on_clear_filters=Callback::new(handle_clear_filters)
                        is_panel_expanded=Signal::derive(move || panel_expanded())
                    />
                </div>

                // Student table component
                <StudentTable
                    students=students
                    search_term=search_term
                    grade_filter=Signal::derive(move || transformed_grade_filter())
                    teacher_filter=teacher_filter
                    iep_filter=iep_filter
                    esl_filter=esl_filter
                    intervention_filter=Signal::derive(move || transformed_intervention_filter())
                    student_504_filter=student_504_filter
                    readplan_filter=readplan_filter
                    gt_filter=gt_filter
                    bip_filter=bip_filter
                    is_panel_expanded=Signal::derive(move || panel_expanded())
                    selected_student=selected_student
                    set_selected_student=set_selected_student
                />


                // Bottom action buttons
                <div class="flex-shrink-0 mt-4 pt-2 flex flex-wrap gap-2 justify-end sticky bottom-0 bg-[#F9F9F8] border-t border-[#DADADA]">
                    <button
                        class="px-3 md:px-4 py-2 bg-[#F9F9F8] hover:bg-[#DADADA] hover:bg-opacity-30 font-bold text-[#2E3A59] border-[#DADADA] rounded-md border transition-colors text-sm md:text-base"
                        on:click=move |_| set_show_bulk_upload_modal(true)
                    >
                        "Bulk Upload"
                    </button>
                    <button
                        class="inline-flex items-center justify-center px-3 md:px-4 py-2 bg-[#F44336] text-white rounded-md font-semibold hover:bg-[#D32F2F] focus:outline-none focus:ring-2 focus:ring-[#F44336]/50 transition-colors duration-200 shadow-sm hover:shadow-md text-sm md:text-base"
                        class=opacity-50=move || selected_student().is_none()
                        class=cursor-not-allowed=move || selected_student().is_none()
                        on:click=move |_| {
                            if selected_student().is_some() {
                                set_confirm_delete_one(true)
                            }
                        }
                    >
                        "Delete"
                    </button>
                    <button
                        class="inline-flex items-center justify-center px-3 md:px-4 py-2 bg-[#4CAF50] text-white rounded-md font-semibold hover:bg-[#388E3C] focus:outline-none focus:ring-2 focus:ring-[#4CAF50]/50 transition-colors duration-200 shadow-sm hover:shadow-md text-sm md:text-base"
                        on:click=handle_add_student
                    >
                        "Add Student"
                    </button>
                </div>
            </div>

            // Student Detail Side Panel - modified for responsive behavior with toggle capability
            <div class=move || {
                if show_side_panel() && panel_expanded() {
                    format!("{} {}", SIDE_PANEL_STYLE, "translate-x-0")
                } else if !panel_expanded() {
                    SIDE_PANEL_STYLE_HIDDEN.to_string()
                } else {
                    format!("{} {}", SIDE_PANEL_STYLE, "translate-x-full lg:translate-x-0")
                }
            }>
                // Panel header with close button
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-[#2E3A59]">
                        {move || {
                            if adding_student() {
                                "Add New Student"
                            } else if editing() {
                                "Edit Student"
                            } else if selected_student().is_some() {
                                "Student Details"
                            } else {
                                "Details"
                            }
                        }}
                    </h2>
                    <div class="flex gap-2">
                        // Desktop toggle button
                        <button
                            class="hidden lg:block text-[#2E3A59] p-1 rounded hover:bg-[#DADADA] transition-colors"
                            on:click=move |_| {
                                set_panel_expanded(false);
                            }
                            title="Collapse panel"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7" />
                            </svg>
                        </button>

                        // Mobile close button
                        <button
                            class="lg:hidden rounded p-1 hover:bg-[#DADADA] text-[#2E3A59]"
                            on:click=move |_| set_show_side_panel(false)
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                </div>

                <Show
                    when=move || selected_student().is_some() || adding_student() || editing()
                    fallback=|| view! {
                        <div class="hidden lg:flex items-center justify-center border-t-8 border-[#2E3A59] h-[95%] text-gray-500 rounded-lg shadow-lg bg-[#F9F9F8]">
                            <span>"Select a student to view details"</span>
                        </div>
                    }
                >
                    {move || {
                        if adding_student() {
                            view! {
                                <div class="h-full">
                                    <AddStudentForm
                                        set_adding_student=set_adding_student
                                        set_refresh_trigger=set_refresh_trigger
                                    />
                                </div>
                            }
                        } else if editing() {
                            view!{
                                <div class="h-full">
                                    <UpdateStudent
                                        student=selected_student().expect("A student struct")
                                        on_cancel=Callback::new(move |_| {
                                            set_editing(false);
                                            set_show_side_panel(false); // Close panel on mobile
                                        })
                                        on_update_success=Callback::new(move |updated| {
                                            set_selected_student(Some(Rc::new(updated)));
                                            set_editing(false);
                                            set_refresh_trigger.update(|count| *count +=1);
                                        })
                                    />
                                </div>
                            }
                        } else if let Some(student) = selected_student() {
                            view! {
                                <div class="h-full">
                                    <StudentDetails
                                        student=student
                                        on_edit_student=Callback::new(move |_| {
                                            set_adding_student(false);
                                            set_editing(true);
                                        })
                                    />
                                </div>
                            }
                        } else {
                            view! {
                                <div>"An error has occurred"</div>
                            }
                        }
                    }}
                </Show>
            </div>

            // Global Panel toggle button for when panel is fully collapsed
            <Show when=move || !panel_expanded()>
                <button
                    class="fixed right-4 top-16 lg:right-8 lg:top-20 bg-[#2E3A59] text-white p-2 rounded-full shadow-lg z-20"
                    on:click=move |_| {
                        set_panel_expanded(true);
                        if selected_student().is_some() || adding_student() || editing() {
                            set_show_side_panel(true);
                        }
                    }
                    title="Expand panel"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7" />
                    </svg>
                </button>
            </Show>
        </div>
    }
}
use leptos::prelude::*;
use leptos::prelude::*;

#[component]
pub fn Settings() -> impl IntoView {
    view! {
        <div class="bg-[#F9F9F8]">
            <p>"This is the settings menu"</p>
        </div>
    }
}
use crate::app::components::auth::login_form::LogoutButton;
use crate::app::components::update_user_modal::UpdateProfileModal; // Import the new modal component
use crate::app::components::Header;
use crate::app::models::user::SessionUser;
use crate::app::models::user::User;
use crate::app::server_functions::auth::{get_current_user, Logout};
use crate::app::server_functions::users::get_user;
use leptos::prelude::*;

#[component]
pub fn MyAccount() -> impl IntoView {
    // State to control the visibility of the update profile modal
    let (show_update_modal, set_show_update_modal) = signal(false);

    // Get the current user from context (provided by AuthProvider)
    let current_user = use_context::<ReadSignal<Option<SessionUser>>>()
        .expect("AuthProvider should provide current_user");

    // Create a derived signal for user_id to avoid unnecessary refetching
    let user_id = Memo::new(move |_| current_user.get().map(|user| user.id));

    // Fetch full user data when authenticated
    let user_resource = Resource::new(
        move || user_id.get(),
        move |id| async move {
            match id {
                Some(user_id) => get_user(user_id).await.ok(),
                None => None,
            }
        },
    );

    // Handle opening the update profile modal
    let open_update_modal = move |_| {
        set_show_update_modal.set(true);
    };

    // Handle closing the update profile modal
    let close_update_modal = move |_| {
        set_show_update_modal.set(false);
    };

    // Handle successful profile update
    let on_profile_updated = move |_| {
        // Refetch user data to update the UI
        user_resource.refetch();
    };

    let loading = use_context::<ReadSignal<bool>>().expect("AuthProvider should provide loading");

    view! {
        <div class="bg-[#F9F9F8]">
            <Header/>
            <div class="bg-[#2E3A59] text-white w-full max-w-[64rem] mx-auto p-6 rounded-md my-4">
                <h1 class="text-2xl font-bold mb-6">"My Account"</h1>

                {move || {
                    if loading.get() {
                        view! { <div class="text-center p-8">"Loading..."</div> }
                    } else if let Some(user) = current_user.get() {
                        // Define reusable function to display user data safely
                        let display_user_field = |field_value: Option<String>| {
                            field_value.unwrap_or_else(|| "Not provided".to_string())
                        };

                        // Create a derived signal for the full user data
                        let user_data = move || user_resource.get().flatten();

                        view! {
                            <div>
                                <div class="bg-white text-[#2E3A59] p-4 rounded-md shadow-md">
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div class="mb-4">
                                            <h2 class="text-xl font-semibold text-[#2E3A59] mb-2">"Account Information"</h2>

                                            <div class="mb-2">
                                                <label class="block text-[#2E3A59] text-sm font-medium">"Username:"</label>
                                                <p class="font-medium text-[#2E3A59]">{user.username.clone()}</p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-[#2E3A59] text-sm font-medium">"Firstname:"</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {move || user_data().map(|u| u.first_name.clone()).unwrap_or(Some("Not provided".to_string()))}
                                                </p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-[#2E3A59] text-sm font-medium">"Lastname:"</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {move || user_data().map(|u| u.last_name.clone()).unwrap_or(Some("Not provided".to_string()))}
                                                </p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-[#2E3A59] text-sm font-medium">"Email:"</label>
                                                <p class="font-medium text-[#2E3A59]">{user.email.clone()}</p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-[#2E3A59] text-sm font-medium">"User ID:"</label>
                                                <p class="font-medium text-[#2E3A59]">{user.id.to_string()}</p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-gray-600 text-sm font-medium">"Role:"</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {user.role.to_string().clone()}
                                                    <span class="ml-2 text-xs bg-blue-100 text-blue-800 py-1 px-2 rounded-full">
                                                        {
                                                            if user.is_admin() {
                                                                "Administrator"
                                                            } else if user.is_teacher() {
                                                                "Teacher"
                                                            } else {
                                                                "Standard User"
                                                            }
                                                        }
                                                    </span>
                                                </p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-gray-600 text-sm font-medium">"Email Verification:"</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {move || user_data().map(|u| if u.email_verified { "âœ“" } else { "âŒ" }).unwrap_or("âŒ")}
                                                </p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-gray-600 text-sm font-medium">"Phone Verification:"</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {move || user_data().map(|u| if u.phone_verified { "âœ“" } else { "âŒ" }).unwrap_or("âŒ")}
                                                </p>
                                            </div>

                                            <div class="mb-2">
                                                <label class="block text-gray-600 text-sm font-medium">"Phone Number: "</label>
                                                <p class="font-medium text-[#2E3A59]">
                                                    {move || user_data()
                                                        .and_then(|u| u.phone_number)
                                                        .unwrap_or_else(|| "Not provided".to_string())}
                                                </p>
                                            </div>
                                        </div>

                                        <div class="flex-1 flex-row">
                                            <h2 class="text-xl font-semibold text-[#2E3A59] mb-2">"Account Actions"</h2>

                                            <button
                                                on:click=open_update_modal
                                                class="block text-center w-[20rem] bg-[#2E3A59] text-white py-2 px-4 rounded-md mb-2 hover:bg-[#DADADA] transition"
                                            >
                                                "Update Profile"
                                            </button>

                                            <div class="w-[20rem]">
                                                <LogoutButton/>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                // Render the update profile modal, hidden by default
                                <UpdateProfileModal
                                    show=Signal::derive(move || show_update_modal.get())
                                    on_close=Callback::new(close_update_modal)
                                    on_success=Callback::new(on_profile_updated)
                                />
                            </div>
                        }
                    } else {
                        view! {
                            <div class="bg-[#F9F9F8] text-[#2E3A59] p-8 rounded-md shadow-md text-center">
                                <p class="mb-4">"You are not logged in."</p>
                                <a href="/login" class="bg-[#2E3A59] text-white py-2 px-4 rounded-md hover:bg-[#DADADA] transition">
                                    "Log In"
                                </a>
                            </div>
                        }
                    }
                }}
            </div>
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::dashboard::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::header::Header;
use crate::app::components::teacher_page::{
    AddEmployeeForm, DeleteConfirmation, EmployeeDetails, EmployeeTable, SearchFilter,
    TeacherTable, UserTable,
};
use crate::app::models::employee::{AddNewEmployeeRequest, Employee, EmployeeRole};
use crate::app::models::student::GradeEnum;
use crate::app::models::user::{SessionUser, UserRole};
use crate::app::models::StatusEnum;
use crate::app::server_functions::employees::{add_employee, get_employees};
use crate::app::server_functions::teachers::get_teachers;
use crate::app::server_functions::users::get_users;
use leptos::ev::SubmitEvent;
use leptos::prelude::*;
use leptos_router::path;
use std::rc::Rc;
use std::str::FromStr;
use strum::IntoEnumIterator;
use validator::Validate;

#[component]
pub fn Teachers() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/teachers">
            <TeachersContent />
        </ServerAuthGuard>
    }
}

// Side panel styles - Updated for responsiveness and toggle behavior
const SIDE_PANEL_STYLE: &str = "lg:w-[30%] w-full h-[calc(100vh-2rem)] fixed lg:right-0 right-0 top-0 mt-10 p-5 lg:p-10 z-20 lg:z-10 transform transition-transform duration-300 ease-in-out";
const SIDE_PANEL_STYLE_HIDDEN: &str = "w-0 h-[calc(100vh-2rem)] fixed lg:right-0 right-0 top-0 mt-10 overflow-hidden z-20 lg:z-10 transform transition-all duration-300 ease-in-out";

// Toggle button styles
const TOGGLE_BUTTON_STYLE: &str = "absolute left-0 top-1/2 -ml-8 bg-[#2E3A59] text-white p-2 rounded-l-md shadow-md hidden lg:flex items-center justify-center transition-all duration-300 transform";

// Table styles - Updated to be responsive to panel toggle
const TABLE_CONTAINER_STYLE_DEFAULT: &str = "w-full lg:w-[68%] fixed p-3 lg:p-5 h-[calc(100vh-2rem)] flex flex-col lg:ml-20 transition-all duration-300 ease-in-out";
const TABLE_CONTAINER_STYLE_EXPANDED: &str = "w-full lg:w-[92%] fixed p-3 lg:p-5 h-[calc(100vh-2rem)] flex flex-col lg:ml-20 transition-all duration-300 ease-in-out";

const TAB_BUTTON_ACTIVE: &str =
    "px-4 py-2 font-medium rounded-t-lg bg-[#2E3A59] text-white border-none";
const TAB_BUTTON_INACTIVE: &str =
    "px-4 py-2 font-medium rounded-t-lg bg-[#DADADA] text-[#2E3A59] hover:bg-gray-200";
const ADD_BUTTON_STYLE: &str = "inline-flex items-center justify-center px-4 py-2 bg-[#4CAF50] text-white rounded-md font-semibold hover:bg-[#388E3C] focus:outline-none focus:ring-2 focus:ring-[#388E3C]/50 transition-colors duration-200 shadow-sm hover:shadow-md";
const DELETE_BUTTON_STYLE: &str = "inline-flex items-center justify-center px-4 py-2 bg-[#F44336] text-white rounded-md font-semibold hover:bg-[#D32F2F] focus:outline-none focus:ring-2 focus:ring-[#D32F2F]/50 transition-colors duration-200 shadow-sm hover:shadow-md";

// Side panel styles for details
const INFO_CONTAINER_STYLE: &str =
    "h-full p-6 border-t-8 border-[#2E3A59] shadow-lg rounded-lg flex flex-col";
const INFO_CONTENT_STYLE: &str = "flex-grow overflow-y-auto";
const INFO_TITLE_STYLE: &str = "text-stone-400 text-xs";
const INFO_VALUE_STYLE: &str = "mt-1";
const INFO_GROUP_STYLE: &str = "mb-2";
const BUTTON_CONTAINER_STYLE: &str =
    "mt-4 pt-4 flex border-t gap-2 justify-end sticky bottom-0 bg-white w-full";

#[component]
pub fn TeachersContent() -> impl IntoView {
    let user = use_context::<ReadSignal<Option<SessionUser>>>().expect("AuthProvider not found");
    // Create resource for refreshing data
    let (refresh_trigger, set_refresh_trigger) = signal(0);
    let (selected_view, set_selected_view) = signal(SidebarSelected::TeacherView);

    // Create resources for employees and teachers
    let employees = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            match get_employees().await {
                Ok(employees) => Some(employees),
                Err(e) => {
                    log::error!("Failed to fetch employees: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    let teachers = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            match get_teachers().await {
                Ok(teachers) => Some(teachers),
                Err(e) => {
                    log::error!("Failed to fetch teachers: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    let users = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            match get_users().await {
                Ok(users) => Some(users),
                Err(e) => {
                    log::error!("Failed to fetch users: {}", e);
                    Some(vec![])
                }
            }
        },
    );

    // Main UI state signals
    let (active_view, set_active_view) = signal(String::from("employees"));
    let (selected_employee, set_selected_employee) = signal(None::<Rc<Employee>>);
    let (search_term, set_search_term) = signal(String::new());
    let (role_filter, set_role_filter) = signal(String::new());
    let (adding_employee, set_adding_employee) = signal(false);
    let (confirm_delete, set_confirm_delete) = signal(false);

    // Panel visibility control
    let (show_side_panel, set_show_side_panel) = signal(false);

    // Panel toggle for desktop view
    let (panel_expanded, set_panel_expanded) = signal(false);

    // Watch for selected employee changes to show panel on mobile
    Effect::new(move |_| {
        if selected_employee().is_some() || adding_employee() {
            set_show_side_panel(true);
            set_panel_expanded(true);
        }
    });

    // Tab view selection handlers
    let select_teachers_view = move |_| set_active_view(String::from("teachers"));
    let select_employees_view = move |_| set_active_view(String::from("employees"));
    let select_users_view = move |_| set_active_view(String::from("users"));

    // Clear filters function
    let clear_filters = move |_| {
        set_search_term(String::new());
        set_role_filter(String::new());
    };

    view! {
        <div class="min-h-screen flex flex-col bg-[#F9F9F8]">
            <Header/>
            <DashboardSidebar
                selected_item=selected_view
                set_selected_item=set_selected_view
            />
            // Delete confirmation modal
            <Show when=move || confirm_delete() && selected_employee().is_some()>
                <DeleteConfirmation
                    selected_employee=selected_employee
                    on_cancel=Callback::new(move |_| set_confirm_delete(false))
                    on_delete=Callback::new(move |_| {
                        set_selected_employee(None::<Rc::<Employee>>);
                        set_refresh_trigger.update(|count| *count += 1);
                        set_confirm_delete(false);
                    })
                />
            </Show>

            // Main content area with dynamic width based on panel state
            <div class=move || {
                if panel_expanded() {
                    TABLE_CONTAINER_STYLE_DEFAULT.to_string()
                } else {
                    TABLE_CONTAINER_STYLE_EXPANDED.to_string()
                }
            }>
                // Search and Filters
                <SearchFilter
                    search_term=search_term
                    set_search_term=set_search_term
                    role_filter=role_filter
                    set_role_filter=set_role_filter
                    on_clear_filters=clear_filters
                />

                // View selection tabs
                <div class="flex border-b mb-4">
                    <button
                        class=move || if active_view() == "employees" { TAB_BUTTON_ACTIVE } else { TAB_BUTTON_INACTIVE }
                        on:click=select_employees_view
                    >
                        "All Employees"
                    </button>
                    <button
                        class=move || if active_view() == "teachers" { TAB_BUTTON_ACTIVE } else { TAB_BUTTON_INACTIVE }
                        on:click=select_teachers_view
                    >
                        "Teachers"
                    </button>
                    <Show when=move || user.get().map_or(false, |u| u.is_admin())>
                        <button
                            class=move || if active_view() == "users" { TAB_BUTTON_ACTIVE } else { TAB_BUTTON_INACTIVE }
                            on:click=select_users_view
                        >
                            "Users"
                        </button>
                    </Show>
                </div>

                // Teachers Table
                <Show when=move || active_view() == "teachers">
                    <TeacherTable
                        teachers=teachers
                        search_term=search_term
                        role_filter=role_filter
                        selected_employee=selected_employee
                        set_selected_employee=set_selected_employee
                        is_panel_expanded=Signal::derive(move || panel_expanded())
                    />
                </Show>

                // All Employees Table
                <Show when=move || active_view() == "employees">
                    <EmployeeTable
                        employees=employees
                        search_term=search_term
                        role_filter=role_filter
                        selected_employee=selected_employee
                        set_selected_employee=set_selected_employee
                        is_panel_expanded=Signal::derive(move || panel_expanded())
                    />
                </Show>

                //Users Table
                <Show when=move || active_view() =="users">
                    <UserTable
                        users=users
                        search_term=search_term
                        is_panel_expanded=Signal::derive(move || panel_expanded())
                        current_user_role=Signal::derive(move || {
                            user.get().map_or(UserRole::User, |u| u.role)
                        })
                        current_user_id=Signal::derive(move || {
                            user.get().map(|u| u.id).unwrap_or(0)
                        })
                        set_refresh_trigger=set_refresh_trigger
                    />
                </Show>

                // Action Buttons
                <div class="mt-4 pt-2 flex flex-wrap gap-2 justify-end sticky bottom-0 bg-[#F9F9F8]">
                    {
                        let delete_button_class = move || {
                            let base = DELETE_BUTTON_STYLE;
                            if selected_employee().is_none() {
                                format!("{} opacity-50 cursor-not-allowed", base)
                            } else {
                                base.to_string()
                            }
                        };

                        view! {
                            <button
                                class=delete_button_class
                                on:click=move |_| {
                                    if selected_employee().is_some() {
                                        set_confirm_delete(true)
                                    }
                                }
                            >
                                "Delete"
                            </button>
                        }
                    }
                    <button
                        class=ADD_BUTTON_STYLE
                        on:click=move |_| {
                            set_adding_employee(true);
                            set_selected_employee(None);
                            set_show_side_panel(true); // Show panel on mobile when adding
                            set_panel_expanded(true); // Ensure panel is expanded
                        }
                    >
                        "Add Employee"
                    </button>
                </div>
            </div>

            // Employee Detail Side Panel - modified for responsive behavior with toggle capability
            <div class=move || {
                if show_side_panel() && panel_expanded() {
                    format!("{} {}", SIDE_PANEL_STYLE, "translate-x-0")
                } else if !panel_expanded() {
                    SIDE_PANEL_STYLE_HIDDEN.to_string()
                } else {
                    format!("{} {}", SIDE_PANEL_STYLE, "translate-x-full lg:translate-x-0")
                }
            }>
                // Panel header with close button
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-[#2E3A59]">
                        {move || {
                            if adding_employee() {
                                "Add New Employee"
                            } else if selected_employee().is_some() {
                                "Employee Details"
                            } else {
                                "Details"
                            }
                        }}
                    </h2>
                    <div class="flex gap-2">
                        // Desktop toggle button
                        <button
                            class="hidden lg:block text-[#2E3A59] p-1 rounded hover:bg-[#DADADA] transition-colors"
                            on:click=move |_| {
                                set_panel_expanded(false);
                            }
                            title="Collapse panel"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7" />
                            </svg>
                        </button>

                        // Mobile close button
                        <button
                            class="lg:hidden rounded p-1 hover:bg-[#DADADA] text-[#2E3A59]"
                            on:click=move |_| set_show_side_panel(false)
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                </div>

                <Show
                    when=move || selected_employee().is_some() || adding_employee()
                    fallback=|| view! {
                        <div class="hidden lg:flex items-center justify-center border-t-8 border-[#2E3A59] h-[95%] text-gray-500 rounded-lg shadow-lg bg-[#F9F9F8]">
                            "Select an employee to view details"
                        </div>
                    }
                >
                    {move || {
                        if adding_employee() {
                            view! {
                                <div class="h-full">
                                    <AddEmployeeForm
                                        on_cancel=move |_| {
                                            set_adding_employee(false);
                                            set_show_side_panel(false); // Close panel on mobile
                                        }
                                        on_save=move |_| {
                                            set_adding_employee(false);
                                            set_refresh_trigger.update(|count| *count += 1);
                                            set_show_side_panel(false); // Close panel on mobile
                                        }
                                    />
                                </div>
                            }
                        } else if let Some(employee) = selected_employee() {
                            view! {
                                <div class="h-full">
                                    <EmployeeDetails
                                        employee=employee
                                        on_close=move |_| {
                                            set_selected_employee(None);
                                            set_show_side_panel(false); // Close panel on mobile
                                        }
                                        call_refresh=move |_| {
                                            set_selected_employee(None);
                                            set_refresh_trigger.update(|count| *count +=1);
                                            set_show_side_panel(false); // Close panel on mobile
                                        }
                                    />
                                </div>
                            }
                        } else {
                            view! {
                                <div>"An error has occurred"</div>
                            }
                        }
                    }}
                </Show>
            </div>

            // Global Panel toggle button for when panel is fully collapsed
            <Show when=move || !panel_expanded()>
                <button
                    class="fixed right-4 top-16 lg:right-8 lg:top-20 bg-[#2E3A59] text-white p-2 rounded-full shadow-lg z-20"
                    on:click=move |_| {
                        set_panel_expanded(true);
                        if selected_employee().is_some() || adding_employee() {
                            set_show_side_panel(true);
                        }
                    }
                    title="Expand panel"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7" />
                    </svg>
                </button>
            </Show>
        </div>
    }
}
use crate::app::components::auth::server_auth_components::ServerAuthGuard;
use crate::app::components::dashboard_sidebar::{DashboardSidebar, SidebarSelected};
use crate::app::components::data_processing::{
    AssessmentSummary, Progress, StudentResultsSummary, TestDetail,
};
use crate::app::components::enhanced_login_form::{
    use_student_mapping_service, DeAnonymizedStudent, StudentMappingService,
};
use crate::app::components::gradebook_side_panel::{ScorePanelType, StudentScorePanel};
use crate::app::components::header::Header;
use crate::app::middleware::global_settings::use_settings;
use crate::app::models::assessment::Assessment;
use crate::app::models::student::Student;
use crate::app::server_functions::assessments::get_assessments;
use crate::app::server_functions::data_wrappers::get_student_results_batch;
use crate::app::server_functions::scores::get_scores_by_test;
use crate::app::server_functions::students::get_students;
use crate::app::server_functions::tests::get_tests_batch;
use chrono::Utc;
use icondata::{BiCheckboxCheckedRegular, BiCheckboxRegular, HiUserCircleOutlineLg};
use leptos::prelude::*;
use leptos::prelude::*;
use leptos_icons::Icon;
use leptos_router::components::*;
use leptos_router::hooks::*;
use leptos_router::path;
use std::collections::HashMap;

#[component]
pub fn Gradebook() -> impl IntoView {
    view! {
        <ServerAuthGuard page_path="/gradebook">
            <GradebookContent />
        </ServerAuthGuard>
    }
}

#[component]
pub fn GradebookContent() -> impl IntoView {
    let (refresh_trigger, set_refresh_trigger) = signal(0);
    let (selected_view, set_selected_view) = signal(SidebarSelected::Dashboard);
    let (search_term, set_search_term) = signal(String::new());

    // Store assessment ID instead of the whole assessment
    let (selected_assessment_id, set_selected_assessment_id) = signal(Option::<String>::None);

    // Side panel state
    let (show_side_panel, set_show_side_panel) = signal(false);
    let (panel_type, set_panel_type) = signal(ScorePanelType::None);
    let (selected_student, set_selected_student) = signal(Option::<Student>::None);

    // Current assessment/test data for the side panel
    let (current_assessment_data, set_current_assessment_data) =
        signal(Option::<AssessmentSummary>::None);
    let (current_test_data, set_current_test_data) = signal(Option::<TestDetail>::None);
    let (next_test_id, set_next_test_id) = signal(Option::<String>::None);

    // Get global settings for anonymization
    let (settings, _) = use_settings();
    let anonymization_enabled = move || settings.get().student_protections;

    // Get the student mapping service
    let (student_mapping_service, _) = use_student_mapping_service();

    // OPTIMIZATION 1: Combine all initial data fetching into a single resource with better error handling
    let initial_data = LocalResource::new(
        move || refresh_trigger(),
        |_| async move {
            log::info!("Starting gradebook data fetch...");

            // Fetch students and assessments concurrently
            let (students_result, assessments_result) =
                futures::join!(get_students(), get_assessments());

            match (students_result, assessments_result) {
                (Ok(students), Ok(assessments)) => {
                    log::info!(
                        "Fetched {} students and {} assessments",
                        students.len(),
                        assessments.len()
                    );

                    if !students.is_empty() {
                        let student_ids: Vec<i32> =
                            students.iter().map(|student| student.student_id).collect();

                        log::info!("Starting batch fetch for {} students", student_ids.len());

                        // Use the optimized batch function
                        match get_student_results_batch(student_ids).await {
                            Ok(student_results) => {
                                log::info!(
                                    "Successfully fetched batch results for {} students",
                                    student_results.len()
                                );
                                Some((students, assessments, student_results))
                            }
                            Err(e) => {
                                log::error!("Failed to fetch batch results: {}", e);
                                // Return with empty results rather than failing completely
                                Some((students, assessments, HashMap::new()))
                            }
                        }
                    } else {
                        log::info!("No students found");
                        Some((students, assessments, HashMap::new()))
                    }
                }
                (Err(e), _) => {
                    log::error!("Failed to fetch students: {}", e);
                    None
                }
                (_, Err(e)) => {
                    log::error!("Failed to fetch assessments: {}", e);
                    None
                }
            }
        },
    );

    // OPTIMIZATION 2: Create derived signals from the combined data
    let students = Memo::new(move |_| {
        initial_data
            .get()
            .and_then(|data| data.as_ref().map(|(students, _, _)| students.clone()))
            .unwrap_or_default()
    });

    let assessment_list = Memo::new(move |_| {
        initial_data
            .get()
            .and_then(|data| data.as_ref().map(|(_, assessments, _)| assessments.clone()))
            .unwrap_or_default()
    });

    let all_student_results = Memo::new(move |_| {
        initial_data
            .get()
            .and_then(|data| data.as_ref().map(|(_, _, results)| results.clone()))
            .unwrap_or_default()
    });

    // OPTIMIZATION 3: Lazy load tests and scores only when assessment is selected
    let selected_assessment = Memo::new(move |_| {
        if let Some(assessment_id) = selected_assessment_id.get() {
            if assessment_id.is_empty() {
                return None;
            }

            let assessments = assessment_list.get();
            assessments
                .iter()
                .find(|a| a.id.to_string() == assessment_id)
                .cloned()
        } else {
            None
        }
    });

    // Only load tests when an assessment is selected
    let tests = LocalResource::new(
        move || (selected_assessment.get(), refresh_trigger()),
        |(selected_assessment_opt, _)| async move {
            if let Some(assessment) = selected_assessment_opt {
                match get_tests_batch(assessment.tests).await {
                    Ok(tests) => Some(tests),
                    Err(e) => {
                        log::error!("Failed to fetch tests: {}", e);
                        Some(vec![])
                    }
                }
            } else {
                None
            }
        },
    );

    // Only load scores when an assessment is selected
    let scores = LocalResource::new(
        move || (selected_assessment.get(), refresh_trigger()),
        |(selected_assessment_opt, _)| async move {
            if let Some(assessment) = selected_assessment_opt {
                match get_scores_by_test(assessment.tests).await {
                    Ok(scores) => Some(scores),
                    Err(e) => {
                        log::error!("Failed to fetch scores: {}", e);
                        Some(vec![])
                    }
                }
            } else {
                None
            }
        },
    );

    // Helper function to get display name and ID
    let get_student_display = move |student: &Student| -> (String, String) {
        if anonymization_enabled() {
            if let Some(service) = student_mapping_service.get() {
                if let Some(mapping) = service.get_original_student_info(student.student_id) {
                    return (
                        format!("{} {}", mapping.firstname, mapping.lastname),
                        mapping.original_student_id.to_string(),
                    );
                }
            }
        }

        // Fallback to anonymized or regular display
        (
            format!(
                "{} {}",
                student.firstname.as_deref().unwrap_or("Student"),
                student
                    .lastname
                    .as_deref()
                    .unwrap_or(&format!("#{}", student.student_id))
            ),
            student.student_id.to_string(),
        )
    };

    // OPTIMIZATION 4: Memoized filtered students with debouncing
    let filtered_students = Memo::new(move |_| {
        let search = search_term().trim().to_lowercase();
        let students_list = students.get();

        if search.is_empty() {
            return students_list;
        }

        students_list
            .into_iter()
            .filter(|student| {
                let (display_name, display_id) = get_student_display(student);
                display_name.to_lowercase().contains(&search)
                    || display_id.to_lowercase().contains(&search)
            })
            .collect::<Vec<_>>()
    });

    // Helper function to find the next test ID
    fn find_next_test_id(assessment: &AssessmentSummary) -> Option<String> {
        if assessment.progress == Progress::Completed {
            return None;
        }

        assessment
            .test_details
            .iter()
            .find(|test| test.score < test.total_possible)
            .map(|test| test.test_id.clone())
    }

    // Handler for opening assessment side panel
    let open_assessment_panel = move |assessment_id: String, student_id: i32| {
        let students_list = students.get();
        if let Some(student) = students_list.iter().find(|s| s.student_id == student_id) {
            set_selected_student(Some(student.clone()));

            let results_map = all_student_results.get();
            if let Some(student_results) = results_map.get(&student_id) {
                if let Some(summary) = student_results
                    .assessment_summaries
                    .iter()
                    .find(|s| s.assessment_id == assessment_id)
                {
                    set_current_assessment_data(Some(summary.clone()));
                    set_next_test_id(find_next_test_id(summary));
                    set_panel_type(ScorePanelType::AssessmentScore(assessment_id));
                    set_show_side_panel(true);
                    return;
                }
            }
        }
        log::error!("Failed to load assessment data for side panel");
    };

    // Handler for opening test side panel
    let open_test_panel = move |test_id: String, student_id: i32, attempt: i32| {
        let students_list = students.get();
        if let Some(student) = students_list.iter().find(|s| s.student_id == student_id) {
            set_selected_student(Some(student.clone()));

            if let Some(Some(test_list)) = tests.get() {
                if let Some(test) = test_list.iter().find(|t| t.test_id == test_id) {
                    let mut test_detail = TestDetail {
                        test_id: test.test_id.clone(),
                        test_name: test.name.clone(),
                        test_area: test.testarea.clone().to_string(),
                        score: 0,
                        total_possible: test.score,
                        performance_class: "Not available".to_string(),
                        date_administered: Utc::now(),
                        attempt: 0,
                        test_variant: 0,
                    };

                    if let Some(Some(score_data)) = scores.get() {
                        if let Some(score) = score_data.iter().find(|s| {
                            s.student_id == student_id
                                && s.test_id == test_id
                                && s.attempt == attempt
                        }) {
                            test_detail.score = score.get_total();
                            test_detail.performance_class = if score.get_total() >= (test.score / 2)
                            {
                                "Satisfactory".to_string()
                            } else {
                                "Needs Improvement".to_string()
                            };
                            test_detail.attempt = score.attempt;
                            test_detail.test_variant = score.test_variant;
                        }
                    }

                    set_current_test_data(Some(test_detail));
                    set_panel_type(ScorePanelType::TestScore(test_id, student_id, attempt));
                    set_show_side_panel(true);
                }
            }
        }
    };

    view! {
        <div class="h-screen flex flex-col bg-[#F9F9F8]">
            <Header />
            <div class="flex flex-1 overflow-hidden">
                <DashboardSidebar
                    selected_item=selected_view
                    set_selected_item=set_selected_view
                />
                <main class="flex-1 flex flex-col mt-16 ml-20 px-10 pb-6">
                    <h1 class="text-2xl font-bold mb-2 text-[#2E3A59]">
                        "Gradebook"
                        {move || {
                            if anonymization_enabled() {
                                if student_mapping_service.get().is_some() {
                                    view! {
                                        <span class="ml-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full">
                                            "De-anonymized"
                                        </span>
                                    }.into_any()
                                } else {
                                    view! {
                                        <span class="ml-2 px-2 py-1 bg-yellow-100 text-yellow-800 text-xs rounded-full">
                                            "Anonymized"
                                        </span>
                                    }.into_any()
                                }
                            } else {
                                view! { <span></span> }.into_any()
                            }
                        }}
                    </h1>

                    <div class="flex justify-between items-center mb-2">
                        <div class="w-[40rem] mr-4">
                            <input
                                type="text"
                                placeholder={move || {
                                    if anonymization_enabled() && student_mapping_service.get().is_some() {
                                        "Search students by real name or ID..."
                                    } else {
                                        "Search students..."
                                    }
                                }}
                                prop:value={move || search_term.get()}
                                class="border border-gray-300 rounded px-3 py-1 w-full text-sm"
                                on:input=move |ev| set_search_term(event_target_value(&ev))
                            />
                        </div>
                        <div class="w-[20rem]">
                            <select
                                id="assessment-select"
                                class="block w-full px-2 py-1 bg-white border-gray-200 rounded-md border text-sm"
                                on:change=move |ev| {
                                    let value = event_target_value(&ev);
                                    if value.is_empty() || value == "none" {
                                        set_selected_assessment_id(None);
                                    } else {
                                        set_selected_assessment_id(Some(value));
                                    }
                                }
                                prop:value=move || selected_assessment_id.get().unwrap_or_default()
                            >
                               <option value="">"All Assessments"</option>
                               {move || {
                                   let assessments = assessment_list.get();
                                   assessments.into_iter().map(|assessment| {
                                       view! {
                                           <option value={assessment.id.to_string()}>{assessment.name}</option>
                                       }
                                   }).collect_view()
                               }}
                            </select>
                        </div>
                    </div>

                    // OPTIMIZATION 5: Show loading state
                    {move || {
                        match initial_data.get() {
                            None => view! {
                                <div class="flex-1 flex items-center justify-center">
                                    <div class="text-center">
                                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-[#2E3A59] mx-auto mb-4"></div>
                                        <p class="text-gray-600">"Loading gradebook data..."</p>
                                    </div>
                                </div>
                            }.into_any(),
                            Some(None) => view! {
                                <div class="flex-1 flex items-center justify-center">
                                    <p class="text-red-600">"Failed to load gradebook data"</p>
                                </div>
                            }.into_any(),
                            Some(Some(_)) => view! {
                                <div class="flex-1 flex flex-col overflow-hidden rounded-md">
                                    <div class="h-full overflow-auto">
                                        <table class="min-w-full bg-[#F9F9F8] border border-gray-200 table-fixed divide-y divide-[#DADADA]">
                                            <thead class="sticky top-0 bg-[#DADADA]">
                                                <tr>
                                                    <th class="px-2 py-4 border text-center font-medium text-[#2E3A59] text-md uppercase tracking-wider">"Student Name"</th>
                                                    <th class="px-2 py-4 border text-center font-medium text-[#2E3A59] text-md uppercase tracking-wider">
                                                        {move || {
                                                            if anonymization_enabled() && student_mapping_service.get().is_some() {
                                                                "Original ID"
                                                            } else {
                                                                "ID"
                                                            }
                                                        }}
                                                    </th>
                                                    {
                                                        move || {
                                                            if selected_assessment_id.get().is_none() {
                                                                // Show all assessments as columns
                                                                let assessments = assessment_list.get();
                                                                assessments.into_iter().map(|assessment| {
                                                                    view! {
                                                                        <th class="px-2 py-4 border text-center font-medium text-[#2E3A59] text-md whitespace-normal uppercase tracking-wider">{&assessment.name}</th>
                                                                    }
                                                                }).collect_view()
                                                            } else {
                                                                // Show selected assessment's tests as columns
                                                                match tests.get() {
                                                                    Some(Some(test_list)) => {
                                                                        test_list.iter().map(|test| {
                                                                            view! {
                                                                                <th class="px-2 py-4 border text-center font-medium text-[#2E3A59] text-md whitespace-normal uppercase tracking-wider">
                                                                                    {format!("{}",&test.name)}
                                                                                    <br/>
                                                                                    {format!("(Out of {})", &test.score)}
                                                                                </th>
                                                                            }
                                                                        }).collect_view()
                                                                    },
                                                                    _ => view! {}.into_any()
                                                                }
                                                            }
                                                        }
                                                    }
                                                </tr>
                                            </thead>
                                            <                                            tbody class="text-md">
                                                {move || {
                                                    let students_list = filtered_students();
                                                    if students_list.is_empty() {
                                                        view! {
                                                            <tr>
                                                                <td colspan="2" class="px-2 py-1 border-b">
                                                                    "No students match your search criteria."
                                                                </td>
                                                            </tr>
                                                        }.into_any()
                                                    } else {
                                                        // Clone the results map to avoid move issues
                                                        let results_map = all_student_results.get();
                                                        students_list.into_iter().map(|student| {
                                                            let student_id = student.student_id;
                                                            let (display_name, display_id) = get_student_display(&student);

                                                            // Get student results once for this row
                                                            let student_results = results_map.get(&student_id);

                                                            view! {
                                                                <tr>
                                                                    <td class="px-2 py-2 border whitespace-nowrap text-indigo-500 bg-white">
                                                                        <a href=format!("/studentview/{}/results", &student.student_id)>
                                                                            <Icon
                                                                                icon=HiUserCircleOutlineLg
                                                                                class="w-4 h-4 text-[#2E3A59] inline-block mr-2"
                                                                            />
                                                                            {display_name}
                                                                        </a>
                                                                    </td>
                                                                    <td class="px-2 py-2 border whitespace-nowrap text-center bg-white">{display_id}</td>
                                                                    {
                                                                        if selected_assessment_id.get().is_none() {
                                                                            // Show all assessments for this student
                                                                            let assessments = assessment_list.get();
                                                                            assessments.into_iter().map(|assessment| {
                                                                                if let Some(results) = student_results {
                                                                                    if let Some(summary) = results.assessment_summaries.iter()
                                                                                        .find(|summary| summary.assessment_id == assessment.id.to_string()) {
                                                                                        let score = summary.current_score;
                                                                                        let total = summary.total_possible.unwrap_or(0);
                                                                                        let progression_color = if summary.progress == Progress::Completed {
                                                                                            "bg-green-100"
                                                                                        } else {
                                                                                            "bg-yellow-100"
                                                                                        };

                                                                                        let assessment_id = assessment.id.to_string();
                                                                                        let student_id = student.student_id;
                                                                                        let open_assessment = open_assessment_panel.clone();

                                                                                        view! {
                                                                                            <td
                                                                                                class=format!("{} px-2 py-2 border whitespace-nowrap text-center cursor-pointer hover:bg-gray-100", progression_color)
                                                                                                on:click=move |_| open_assessment(assessment_id.clone(), student_id)
                                                                                            >
                                                                                                {format!("{} / {}", score, total)}
                                                                                            </td>
                                                                                        }.into_any()
                                                                                    } else {
                                                                                        view! {
                                                                                            <td class="px-2 py-2 border whitespace-nowrap bg-blue-100 text-center">
                                                                                                "Not started"
                                                                                            </td>
                                                                                        }.into_any()
                                                                                    }
                                                                                } else {
                                                                                    view! {
                                                                                        <td class="px-2 py-2 border whitespace-nowrap text-center">
                                                                                            "-"
                                                                                        </td>
                                                                                    }.into_any()
                                                                                }
                                                                            }).collect_view()
                                                                        } else {
                                                                            // Show selected assessment's test scores
                                                                            match tests.get() {
                                                                                Some(Some(test_list)) => {
                                                                                    let score_data = scores.get().unwrap_or(None).unwrap_or_default();

                                                                                    test_list.iter().map(|test| {
                                                                                        let score = score_data
                                                                                            .iter()
                                                                                            .find(|s| s.student_id == student.student_id && s.test_id == test.test_id);

                                                                                        let test_id = test.test_id.clone();
                                                                                        let student_id = student.student_id;
                                                                                        let open_test = open_test_panel.clone();
                                                                                        let attempt_clone = match score {
                                                                                            Some(s) => s.attempt.clone(),
                                                                                            None => 0,
                                                                                        };

                                                                                        view! {
                                                                                            <td class="px-2 py-2 border whitespace-nowrap text-center">
                                                                                                {
                                                                                                    match score {
                                                                                                        Some(s) => view! {
                                                                                                            <span class="cursor-pointer hover:text-indigo-600" on:click=move |_| open_test(test_id.clone(), student_id, attempt_clone)>
                                                                                                                {s.get_total().to_string()}
                                                                                                            </span>
                                                                                                        }.into_any(),
                                                                                                        None => view!{"-"}.into_any(),
                                                                                                    }
                                                                                                }
                                                                                            </td>
                                                                                        }
                                                                                    }).collect_view()
                                                                                },
                                                                                _ => view! {}.into_any()
                                                                            }
                                                                        }
                                                                    }
                                                                </tr>
                                                            }
                                                        }).collect_view()
                                                    }
                                                }}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            }.into_any()
                        }
                    }}
                </main>

                <StudentScorePanel
                    show=show_side_panel
                    panel_type=panel_type
                    set_show=set_show_side_panel
                    student=selected_student
                    assessment_data=current_assessment_data
                    test_data=current_test_data
                    next_test=next_test_id
                />
            </div>
        </div>
    }
}
